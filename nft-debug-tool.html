<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFT Debug Tool - Otterful Wallet</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            margin: 0;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        
        .debug-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .debug-section h3 {
            margin-top: 0;
            color: #ffd700;
        }
        
        .status {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .status.success { background: rgba(76, 175, 80, 0.3); }
        .status.error { background: rgba(244, 67, 54, 0.3); }
        .status.warning { background: rgba(255, 193, 7, 0.3); }
        .status.info { background: rgba(33, 150, 243, 0.3); }
        
        .connect-btn {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }
        
        .connect-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .debug-log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .nft-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .nft-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .test-btn {
            background: linear-gradient(45deg, #42a5f5, #478ed1);
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            margin: 5px;
        }
        
        .test-btn:hover {
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü¶¶ Otterful NFT Debug Tool</h1>
        <p>This tool will help diagnose why NFTs aren't showing up from your wallet.</p>
        
        <div class="debug-section">
            <h3>üîó Connection Status</h3>
            <div id="connectionStatus" class="status info">Not connected</div>
            <button id="connectBtn" class="connect-btn">Connect Wallet</button>
        </div>
        
        <div class="debug-section">
            <h3>üîç Debug Tests</h3>
            <button class="test-btn" onclick="testWalletProvider()">Test Wallet Provider</button>
            <button class="test-btn" onclick="testChainId()">Test Chain ID</button>
            <button class="test-btn" onclick="testContractCall()">Test Contract Call</button>
            <button class="test-btn" onclick="testTokenBalance()">Test Token Balance</button>
            <button class="test-btn" onclick="scanForTokens()">Scan for Tokens</button>
            <button class="test-btn" onclick="testMetadata()">Test Metadata</button>
        </div>
        
        <div class="debug-section">
            <h3>üìã Debug Log</h3>
            <div id="debugLog" class="debug-log">Waiting for tests...</div>
        </div>
        
        <div class="debug-section">
            <h3>ü¶¶ Found NFTs</h3>
            <div id="nftResults" class="nft-grid">No NFTs loaded yet</div>
        </div>
    </div>

    <script>
        let wallet = null;
        let debugLog = [];
        
        const CONTRACT_ADDRESS = '0x4e5913922b7ddf916c8d27d1016827f799687e66';
        const APE_CHAIN_ID = '0x8173'; // 33139 in hex
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            debugLog.push(`[${timestamp}] ${message}`);
            updateDebugLog();
            console.log(message);
        }
        
        function updateDebugLog() {
            const logEl = document.getElementById('debugLog');
            logEl.textContent = debugLog.slice(-50).join('\n'); // Show last 50 lines
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        function updateStatus(message, type) {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
        
        // Connect wallet function
        document.getElementById('connectBtn').addEventListener('click', async () => {
            if (!window.ethereum) {
                updateStatus('No Web3 wallet found! Please install MetaMask.', 'error');
                log('‚ùå No ethereum provider found');
                return;
            }
            
            try {
                log('üîó Requesting wallet connection...');
                updateStatus('Connecting...', 'warning');
                
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });
                
                if (accounts.length > 0) {
                    wallet = {
                        account: accounts[0],
                        provider: window.ethereum
                    };
                    
                    updateStatus(`Connected: ${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`, 'success');
                    log(`‚úÖ Connected to wallet: ${accounts[0]}`);
                    
                    // Check chain
                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    log(`üîó Current chain: ${chainId} (${parseInt(chainId, 16)})`);
                    
                    if (chainId !== APE_CHAIN_ID) {
                        log('‚ö†Ô∏è Not on ApeChain, attempting to switch...');
                        await switchToApeChain();
                    }
                } else {
                    updateStatus('No accounts found', 'error');
                    log('‚ùå No accounts returned');
                }
            } catch (error) {
                updateStatus(`Connection failed: ${error.message}`, 'error');
                log(`‚ùå Connection error: ${error.message}`);
            }
        });
        
        async function switchToApeChain() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: APE_CHAIN_ID }],
                });
                log('‚úÖ Switched to ApeChain');
            } catch (switchError) {
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: APE_CHAIN_ID,
                                chainName: 'ApeChain',
                                nativeCurrency: {
                                    name: 'ApeCoin',
                                    symbol: 'APE',
                                    decimals: 18
                                },
                                rpcUrls: ['https://apechain.calderachain.xyz/http'],
                                blockExplorerUrls: ['https://apechain.calderachain.xyz']
                            }]
                        });
                        log('‚úÖ Added ApeChain network');
                    } catch (addError) {
                        log(`‚ùå Failed to add ApeChain: ${addError.message}`);
                    }
                } else {
                    log(`‚ùå Failed to switch to ApeChain: ${switchError.message}`);
                }
            }
        }
        
        function testWalletProvider() {
            log('üß™ Testing wallet provider...');
            
            if (!window.ethereum) {
                log('‚ùå No ethereum provider found');
                return;
            }
            
            log(`‚úÖ Ethereum provider found: ${window.ethereum.constructor.name}`);
            log(`üì± Is MetaMask: ${window.ethereum.isMetaMask ? 'Yes' : 'No'}`);
            
            if (wallet) {
                log(`üë§ Connected account: ${wallet.account}`);
            } else {
                log('‚ö†Ô∏è No wallet connected yet');
            }
        }
        
        async function testChainId() {
            log('üß™ Testing chain ID...');
            
            if (!window.ethereum) {
                log('‚ùå No ethereum provider');
                return;
            }
            
            try {
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                log(`üîó Current chain ID: ${chainId}`);
                log(`üîó Chain ID in decimal: ${parseInt(chainId, 16)}`);
                log(`üéØ Expected ApeChain ID: ${APE_CHAIN_ID} (${parseInt(APE_CHAIN_ID, 16)})`);
                
                if (chainId === APE_CHAIN_ID) {
                    log('‚úÖ On correct chain (ApeChain)');
                } else {
                    log('‚ö†Ô∏è Wrong chain - need to switch to ApeChain');
                }
            } catch (error) {
                log(`‚ùå Error getting chain ID: ${error.message}`);
            }
        }
        
        async function testContractCall() {
            log('üß™ Testing basic contract call...');
            
            if (!wallet) {
                log('‚ùå Wallet not connected');
                return;
            }
            
            try {
                // Test contract exists by calling totalSupply
                const data = '0x18160ddd'; // totalSupply() function selector
                log(`üìã Calling totalSupply() on contract: ${CONTRACT_ADDRESS}`);
                
                const result = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{
                        to: CONTRACT_ADDRESS,
                        data: data
                    }, 'latest']
                });
                
                if (result && result !== '0x') {
                    const totalSupply = parseInt(result, 16);
                    log(`‚úÖ Contract responded! Total supply: ${totalSupply}`);
                } else {
                    log('‚ùå Contract call returned empty result');
                }
            } catch (error) {
                log(`‚ùå Contract call failed: ${error.message}`);
                log('üí° This might mean the contract doesn\'t exist on this chain or the address is wrong');
            }
        }
        
        async function testTokenBalance() {
            log('üß™ Testing token balance...');
            
            if (!wallet) {
                log('‚ùå Wallet not connected');
                return;
            }
            
            try {
                const data = '0x70a08231' + wallet.account.slice(2).padStart(64, '0');
                log(`üìã Calling balanceOf(${wallet.account})`);
                log(`üìã Call data: ${data}`);
                
                const result = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{
                        to: CONTRACT_ADDRESS,
                        data: data
                    }, 'latest']
                });
                
                log(`üìÑ Raw result: ${result}`);
                
                if (result && result !== '0x') {
                    const balance = parseInt(result, 16);
                    log(`üí∞ Token balance: ${balance}`);
                    
                    if (balance === 0) {
                        log('‚ö†Ô∏è No tokens found in this wallet');
                        log('üí° Make sure you\'re on the right chain and have Otterful Otter NFTs');
                    } else {
                        log(`‚úÖ Found ${balance} tokens!`);
                    }
                } else {
                    log('‚ùå Balance call returned empty result');
                }
            } catch (error) {
                log(`‚ùå Balance check failed: ${error.message}`);
            }
        }
        
        async function scanForTokens() {
            log('üß™ Scanning for owned tokens...');
            
            if (!wallet) {
                log('‚ùå Wallet not connected');
                return;
            }
            
            try {
                log('üîç Checking ownership of first 20 token IDs...');
                const ownedTokens = [];
                
                for (let i = 0; i < 20; i++) {
                    try {
                        // Call ownerOf(tokenId)
                        const data = '0x6352211e' + i.toString(16).padStart(64, '0');
                        
                        const result = await window.ethereum.request({
                            method: 'eth_call',
                            params: [{
                                to: CONTRACT_ADDRESS,
                                data: data
                            }, 'latest']
                        });
                        
                        if (result && result !== '0x' && result.length >= 26) {
                            const owner = '0x' + result.slice(26).toLowerCase();
                            
                            if (owner === wallet.account.toLowerCase()) {
                                log(`‚úÖ You own token #${i}!`);
                                ownedTokens.push(i);
                            } else {
                                log(`‚ÑπÔ∏è Token #${i} owned by: ${owner.slice(0, 6)}...${owner.slice(-4)}`);
                            }
                        } else {
                            log(`‚ö†Ô∏è Token #${i}: Invalid result or doesn't exist`);
                        }
                    } catch (error) {
                        log(`‚ùå Error checking token #${i}: ${error.message}`);
                        
                        // If we get too many errors, the tokens might not exist
                        if (i > 5 && ownedTokens.length === 0) {
                            log('‚ö†Ô∏è Many errors encountered - tokens might not exist in this range');
                            break;
                        }
                    }
                }
                
                if (ownedTokens.length > 0) {
                    log(`üéâ Found ${ownedTokens.length} owned tokens: ${ownedTokens.join(', ')}`);
                    
                    // Try to load metadata for the first owned token
                    await testTokenMetadata(ownedTokens[0]);
                } else {
                    log('üòû No owned tokens found in the first 20 token IDs');
                    log('üí° Your tokens might have higher IDs, or you might not own any on this chain');
                }
                
            } catch (error) {
                log(`‚ùå Token scan failed: ${error.message}`);
            }
        }
        
        async function testMetadata(tokenId = 1) {
            log(`üß™ Testing metadata for token #${tokenId}...`);
            
            if (!wallet) {
                log('‚ùå Wallet not connected');
                return;
            }
            
            try {
                await testTokenMetadata(tokenId);
            } catch (error) {
                log(`‚ùå Metadata test failed: ${error.message}`);
            }
        }
        
        async function testTokenMetadata(tokenId) {
            try {
                log(`üîó Getting tokenURI for token #${tokenId}...`);
                
                // Call tokenURI(tokenId)
                const data = '0xc87b56dd' + tokenId.toString(16).padStart(64, '0');
                
                const result = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{
                        to: CONTRACT_ADDRESS,
                        data: data
                    }, 'latest']
                });
                
                log(`üìÑ TokenURI result: ${result}`);
                
                if (result && result !== '0x') {
                    // Try to decode the URI
                    let uri = '';
                    try {
                        // Simple hex to string conversion
                        const hex = result.slice(2);
                        for (let i = 0; i < hex.length; i += 2) {
                            const charCode = parseInt(hex.substr(i, 2), 16);
                            if (charCode === 0) break;
                            if (charCode >= 32 && charCode <= 126) { // Printable ASCII
                                uri += String.fromCharCode(charCode);
                            }
                        }
                        
                        uri = uri.trim();
                        log(`üîó Decoded URI: "${uri}"`);
                        
                        if (uri) {
                            // Try to fetch the metadata
                            log(`üåê Fetching metadata from: ${uri}`);
                            
                            let metadataUrl = uri;
                            if (uri.startsWith('ipfs://')) {
                                metadataUrl = `https://ipfs.io/ipfs/${uri.slice(7)}`;
                                log(`üîÑ Converted to IPFS gateway: ${metadataUrl}`);
                            }
                            
                            try {
                                const response = await fetch(metadataUrl);
                                log(`üì° Fetch response status: ${response.status}`);
                                
                                if (response.ok) {
                                    const metadata = await response.json();
                                    log(`üìÑ Metadata loaded successfully!`);
                                    log(`üìÑ Name: ${metadata.name || 'Unknown'}`);
                                    log(`üìÑ Description: ${metadata.description || 'No description'}`);
                                    
                                    if (metadata.attributes && metadata.attributes.length > 0) {
                                        log(`üé® Attributes found: ${metadata.attributes.length}`);
                                        metadata.attributes.forEach(attr => {
                                            log(`  - ${attr.trait_type}: ${attr.value}`);
                                        });
                                        
                                        // Display the NFT
                                        displayNFT(tokenId, metadata);
                                    } else {
                                        log('‚ö†Ô∏è No attributes found in metadata');
                                    }
                                    
                                    if (metadata.image) {
                                        log(`üñºÔ∏è Image URL: ${metadata.image}`);
                                    }
                                } else {
                                    log(`‚ùå Failed to fetch metadata: HTTP ${response.status}`);
                                }
                            } catch (fetchError) {
                                log(`‚ùå Fetch error: ${fetchError.message}`);
                                log('üí° This might be a CORS issue or the server is unreachable');
                            }
                        } else {
                            log('‚ùå Could not decode URI from contract response');
                        }
                    } catch (decodeError) {
                        log(`‚ùå Error decoding URI: ${decodeError.message}`);
                    }
                } else {
                    log('‚ùå TokenURI returned empty result - token might not exist');
                }
            } catch (error) {
                log(`‚ùå Error getting token metadata: ${error.message}`);
            }
        }
        
        function displayNFT(tokenId, metadata) {
            const resultsEl = document.getElementById('nftResults');
            
            const nftCard = document.createElement('div');
            nftCard.className = 'nft-card';
            nftCard.innerHTML = `
                <h4>ü¶¶ ${metadata.name || `Otter #${tokenId}`}</h4>
                <p><strong>Token ID:</strong> ${tokenId}</p>
                ${metadata.description ? `<p><strong>Description:</strong> ${metadata.description}</p>` : ''}
                ${metadata.attributes ? `
                    <div><strong>Traits:</strong></div>
                    <ul>
                        ${metadata.attributes.map(attr => 
                            `<li>${attr.trait_type}: ${attr.value}</li>`
                        ).join('')}
                    </ul>
                ` : ''}
                ${metadata.image ? `<img src="${metadata.image}" alt="${metadata.name}" style="max-width: 100%; border-radius: 8px; margin-top: 10px;">` : ''}
            `;
            
            if (resultsEl.textContent === 'No NFTs loaded yet') {
                resultsEl.innerHTML = '';
            }
            resultsEl.appendChild(nftCard);
        }
    </script>
</body>
</html>
