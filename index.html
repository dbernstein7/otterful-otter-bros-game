<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Otterful Otter Bros</title>
    <!-- Cache bust: Updated title to Otterful Otter Bros - v3 -->
    <script>
        // Force set the title to ensure it's correct
        document.title = "Otterful Otter Bros";
    </script>
    <style>
            @keyframes levelUpPulse {
                0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }
            
            @keyframes laserUpgradePulse {
                0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }
            
        body {
            margin: 0;
            padding: 0;
            background: #87CEEB; /* Match game sky color to fill white space */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            position: relative;
            overflow: hidden;
        }
        
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
            animation: backgroundShift 10s ease-in-out infinite;
        }
        
        @keyframes backgroundShift {
            0%, 100% { transform: translateX(0) translateY(0); }
            25% { transform: translateX(-10px) translateY(-10px); }
            50% { transform: translateX(10px) translateY(-5px); }
            75% { transform: translateX(-5px) translateY(10px); }
        }
        
        @font-face {
            font-family: 'SuperMario';
            src: url('public/SuperMario256.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        #gameContainer {
            position: relative;
            width: 1920px;
            height: 1080px;
            max-width: 100vw;
            max-height: 100vh;
            border: 6px solid #FFD700;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 0 30px rgba(255,215,0,0.3);
            background: #87CEEB; /* Match game sky color */
            padding: 10px;
            animation: glow 3s ease-in-out infinite alternate;
            overflow: hidden;
            margin: 0 auto;
        }
        
        /* Mobile responsive container */
        @media (max-width: 768px) {
            body {
                background: #87CEEB; /* Match game sky color on mobile */
            }
            
            #gameContainer {
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
                border-radius: 0;
                padding: 0;
                border: none;
                background: #87CEEB; /* Match game sky color */
            }
            
            /* Scale down UI elements significantly on mobile */
            .corner-display {
                font-size: 10px !important;
                padding: 4px 8px !important;
                border-width: 1px !important;
            }
            
            .game-title {
                font-size: 10px !important;
                padding: 3px 6px !important;
            }
            
            .score-item {
                font-size: 10px !important;
                padding: 4px 8px !important;
            }
            
            #ui {
                font-size: 10px !important;
            }
            
            /* Reduce visual effects on mobile */
            .corner-display {
                backdrop-filter: none !important;
                box-shadow: 0 2px 5px rgba(0,0,0,0.5) !important;
                animation: none !important;
            }
        }
        
        #gameCanvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            object-fit: fill; /* Fill entire container instead of contain */
            background: #87CEEB; /* Match game sky color */
        }
        
        @keyframes glow {
            from { box-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 0 30px rgba(255,215,0,0.3); }
            to { box-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 0 50px rgba(255,215,0,0.6); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        /* Mobile Controls Styling */
        .mobile-btn {
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.1s ease;
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
        }
        
        .mobile-btn:active {
            transform: scale(0.9);
            opacity: 0.7;
        }
        
        #mobileControls {
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            /* Show UI elements on mobile but make them smaller */
            #ui {
                display: block !important;
                font-size: 8px !important;
            }
            
            #ui .game-title {
                display: none !important; /* Hide title on mobile to save space */
            }
            
            #ui .score-row {
                position: fixed !important;
                top: 5px !important;
                left: 5px !important;
                right: auto !important;
                flex-wrap: wrap !important;
                gap: 4px !important;
                z-index: 10 !important;
            }
            
            #ui .score-item {
                font-size: 8px !important;
                padding: 2px 4px !important;
            }
            
            .corner-display {
                font-size: 8px !important;
                padding: 2px 4px !important;
                border-width: 1px !important;
                backdrop-filter: none !important;
                box-shadow: 0 1px 3px rgba(0,0,0,0.5) !important;
                animation: none !important;
            }
            
            #levelDisplay {
                top: 5px !important;
                left: 5px !important;
                font-size: 8px !important;
                padding: 2px 4px !important;
                display: block !important; /* Ensure it's visible */
            }
            
            #collectiblesCounter {
                top: 30px !important; /* Position below level display */
                left: 5px !important;
                font-size: 8px !important;
                gap: 4px !important;
                min-width: auto !important;
                display: flex !important; /* Ensure it's visible */
            }
            
            /* Adjust for landscape/horizontal mode */
            @media (orientation: landscape) and (max-width: 768px) {
                #levelDisplay {
                    top: 5px !important;
                    left: 5px !important;
                }
                
                #collectiblesCounter {
                    top: 25px !important;
                    left: 5px !important;
                }
                
                #ui .score-row {
                    top: 5px !important;
                    left: 200px !important; /* Move to the right to avoid overlap */
                }
            }
            
            .counter-item {
                padding: 2px 4px !important;
                font-size: 8px !important;
            }
            
            .counter-icon {
                font-size: 10px !important;
            }
            
            .counter-label, .counter-value {
                font-size: 8px !important;
            }
            
            /* Show mobile controls on mobile */
            #mobileControls {
                display: block !important;
            }
            
            /* Make settings button smaller - swap with D-pad */
            #settingsBtn {
                bottom: 10px !important;
                left: 10px !important;
                padding: 8px 12px !important;
                font-size: 10px !important;
            }
            
            /* Health/Armor bars - make much smaller on mobile */
            #health-bar-container,
            .health-bar-container {
                bottom: 10px !important;
                right: 10px !important;
                gap: 4px !important;
                flex-direction: row !important; /* Horizontal layout */
                flex-wrap: nowrap !important; /* No wrapping - all in one row */
                align-items: center !important;
                justify-content: flex-end !important;
            }
            
            /* Lives display - same size as health/armor bars, in same row */
            #livesDisplay,
            .health-bar-container .lives-display,
            .health-bar-container #livesDisplay {
                order: 0 !important; /* Lives first */
                margin-top: 0 !important;
                padding: 2px 4px !important;
                gap: 2px !important;
                border-width: 1px !important;
                border-radius: 6px !important;
                height: 12px !important; /* Same height as bars */
                display: flex !important;
                flex-direction: row !important;
                align-items: center !important;
                min-width: 60px !important;
            }
            
            /* Health bar group - second, appears on same row */
            .health-bar-container .bar-group:first-of-type {
                order: 1 !important;
            }
            
            /* Armor bar - third, appears on same row */
            .health-bar-container .bar-group:last-of-type {
                order: 2 !important;
                flex-basis: auto !important; /* Don't force to new line */
                width: auto !important;
            }
            
            .health-bar-container .bar-group {
                flex-direction: column !important;
                gap: 2px !important;
            }
            
            .health-bar, .armor-bar {
                width: 100px !important;
                height: 12px !important;
                border-width: 1px !important;
                border-radius: 6px !important;
            }
            
            .health-text, .armor-text {
                font-size: 8px !important;
                padding: 2px 4px !important;
                border-width: 1px !important;
                border-radius: 4px !important;
            }
            
            .bar-group {
                gap: 2px !important;
            }
            
            .lives-icon {
                font-size: 10px !important;
            }
            
            .lives-text {
                font-size: 8px !important;
            }
            
            /* Abilities display - position directly above armor bar */
            /* IMPORTANT: Hard refresh browser (Ctrl+Shift+R or Cmd+Shift+R) to see changes */
            #abilities-display,
            div.abilities-display,
            .abilities-display {
                position: fixed !important;
                bottom: 70px !important; /* Position above health-bar-container (which is at bottom: 10px) */
                top: auto !important;
                right: 10px !important;
                left: auto !important;
                gap: 4px !important;
                transform: none !important; /* Remove any transforms that might interfere */
                margin: 0 !important;
                width: auto !important;
                height: auto !important;
            }
            
            /* Adjust abilities position when in landscape/horizontal mode */
            @media (orientation: landscape) and (max-width: 768px) {
                #abilities-display,
                div.abilities-display,
                .abilities-display {
                    bottom: 70px !important; /* Keep same position in landscape */
                    top: auto !important;
                    right: 10px !important;
                }
            }
            
            .abilities-title {
                font-size: 8px !important;
                padding: 2px 4px !important;
                border-width: 1px !important;
            }
            
            .abilities-grid {
                gap: 4px !important;
            }
            
            .ability-item {
                min-width: 30px !important;
                width: 30px !important;
                height: 30px !important;
                padding: 2px !important;
                gap: 1px !important;
                border-width: 1px !important;
                border-radius: 4px !important;
            }
            
            .ability-icon {
                font-size: 12px !important;
            }
            
            .ability-label {
                font-size: 6px !important;
            }
            
            /* Remove animations and effects on mobile for performance */
            .health-bar-container,
            .health-bar,
            .health-text,
            .armor-bar,
            .armor-text,
            .lives-display,
            .abilities-display {
                animation: none !important;
                backdrop-filter: none !important;
                box-shadow: 0 1px 3px rgba(0,0,0,0.5) !important;
            }
            
            #leaderboardPanel {
                max-width: 95vw;
                max-height: 90vh;
                padding: 15px;
            }
        }
        
        @media (min-width: 769px) {
            #mobileControls {
                display: none !important;
            }
        }
        
        /* Ultra-wide screen adjustments */
        @media (min-width: 2560px) {
            .corner-display {
                font-size: 18px;
                padding: 15px 25px;
            }
            
            .game-title {
                font-size: 28px;
                padding: 15px 30px;
            }
            
            .score-item {
                font-size: 16px;
                padding: 10px 16px;
            }
        }
        
        canvas {
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 0.5vh;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: clamp(10px, 1.2vw, 14px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8);
            z-index: 10;
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: clamp(6px, 1vw, 12px);
            border-radius: 10px;
            border: 2px solid #FFD700;
            box-shadow: 0 6px 15px rgba(0,0,0,0.6), inset 0 0 15px rgba(255,215,0,0.15), 0 0 20px rgba(255,215,0,0.5), 0 0 30px rgba(255,215,0,0.3);
            backdrop-filter: blur(15px);
            overflow: visible;
            animation: scoreGlow 2s ease-in-out infinite alternate;
            max-width: 75vw;
        }
        
        @keyframes scoreGlow {
            from { 
                box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 25px rgba(255,215,0,0.15), 0 0 30px rgba(255,215,0,0.5), 0 0 50px rgba(255,215,0,0.3);
                border-color: #FFD700;
            }
            to { 
                box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 25px rgba(255,215,0,0.25), 0 0 40px rgba(255,215,0,0.8), 0 0 70px rgba(255,215,0,0.5);
                border-color: #FFA500;
            }
        }
        
        .game-title {
            font-size: clamp(12px, 2.5vw, 20px);
            font-weight: 900;
            text-align: center;
            margin-bottom: clamp(4px, 0.5vh, 8px);
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9), 0 0 20px rgba(255,215,0,0.8);
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: clamp(4px, 1vw, 8px) clamp(10px, 2vw, 16px);
            border-radius: 12px;
            border: 2px solid #FFD700;
            box-shadow: 0 6px 15px rgba(0,0,0,0.6), inset 0 0 15px rgba(255,215,0,0.15), 0 0 20px rgba(255,215,0,0.5), 0 0 30px rgba(255,215,0,0.3);
            backdrop-filter: blur(15px);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { 
                box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 25px rgba(255,215,0,0.15), 0 0 30px rgba(255,215,0,0.5), 0 0 50px rgba(255,215,0,0.3);
                border-color: #FFD700;
            }
            to { 
                box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 25px rgba(255,215,0,0.25), 0 0 40px rgba(255,215,0,0.8), 0 0 70px rgba(255,215,0,0.5);
                border-color: #FFA500;
            }
        }
        
        .corner-display {
            position: fixed;
            top: 1vh;
            color: #FFD700;
            font-size: clamp(12px, 1.5vw, 18px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8);
            z-index: 10;
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(26,26,46,0.95));
            padding: clamp(8px, 1.2vw, 16px) clamp(12px, 2vw, 20px);
            border-radius: 15px;
            border: 2px solid #FFD700;
            box-shadow: 0 8px 20px rgba(0,0,0,0.7), inset 0 0 20px rgba(255,215,0,0.2), 0 0 25px rgba(255,215,0,0.6), 0 0 40px rgba(255,215,0,0.4);
            backdrop-filter: blur(15px);
            animation: cornerGlow 2s ease-in-out infinite alternate, cornerFloat 4s ease-in-out infinite;
            transition: all 0.3s ease;
        }
        
        .corner-display:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 40px rgba(0,0,0,0.8), inset 0 0 30px rgba(255,215,0,0.3), 0 0 40px rgba(255,215,0,0.8), 0 0 60px rgba(255,215,0,0.6);
            animation: cornerGlow 2s ease-in-out infinite alternate, cornerHover 0.3s ease-in-out;
        }
        
        @keyframes cornerFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }
        
        @keyframes cornerHover {
            0% { transform: translateY(-3px) scale(1.05); }
            50% { transform: translateY(-5px) scale(1.08); }
            100% { transform: translateY(-3px) scale(1.05); }
        }
        
        .top-left {
            left: 8vw;
        }
        
        .top-right {
            right: 8vw;
        }
        
        /* Collectibles Counter Styles */
        #collectiblesCounter {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 120px;
        }
        
        .counter-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,165,0,0.1));
            border-radius: 8px;
            border-left: 3px solid #FFD700;
            /* Removed transition and animation for performance */
        }
        
        .counter-icon {
            font-size: 18px;
            filter: drop-shadow(0 0 8px rgba(255,215,0,0.7));
            /* Removed animation for performance */
        }
        
        .counter-label {
            font-size: 11px;
            color: #FFD700;
            font-weight: bold;
            min-width: 45px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .counter-value {
            font-size: 13px;
            color: #00FFFF;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0,255,255,0.7), 1px 1px 2px rgba(0,0,0,0.8);
            min-width: 30px;
            text-align: right;
            /* Removed animation for performance */
        }
        
        /* Removed counter animation for performance */
        
        @keyframes cornerGlow {
            from { 
                box-shadow: 0 8px 25px rgba(0,0,0,0.6), inset 0 0 20px rgba(255,215,0,0.15), 0 0 25px rgba(255,215,0,0.5), 0 0 40px rgba(255,215,0,0.3);
                border-color: #FFD700;
            }
            to { 
                box-shadow: 0 8px 25px rgba(0,0,0,0.6), inset 0 0 20px rgba(255,215,0,0.25), 0 0 35px rgba(255,215,0,0.8), 0 0 60px rgba(255,215,0,0.5);
                border-color: #FFA500;
            }
        }
        
        .score-row {
            display: flex;
            gap: clamp(3px, 0.5vw, 6px);
            justify-content: center;
            align-items: center;
            margin-bottom: clamp(3px, 0.5vh, 6px);
            flex-wrap: wrap;
        }
        
        .score-item {
            margin: 0;
            padding: clamp(2px, 0.5vw, 4px) clamp(6px, 1vw, 10px);
            border-radius: 6px;
            background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05));
            border-left: 2px solid #FFD700;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            white-space: nowrap;
            font-size: clamp(8px, 1.2vw, 12px);
        }
        
        .score-item {
            color: #FFD700 !important;
            font-weight: bold !important;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8) !important;
        }
        
        /* Ensure the labels (text before spans) are yellow */
        .score-item:not(:has(span)) {
            color: #FFD700 !important;
        }
        
        /* Target the text content directly */
        .score-item {
            color: #FFD700 !important;
        }
        
        /* Style for the labels */
        .score-item .label {
            color: #FFD700 !important;
            font-weight: bold !important;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8) !important;
        }
        
        .score-item span {
            color: #00FFFF;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0,255,255,0.7), 1px 1px 2px rgba(0,0,0,0.8);
            animation: valueShine 3s ease-in-out infinite;
        }
        
        #ui div {
            margin: 2px 0;
            padding: 4px 8px;
            border-radius: 6px;
            background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05));
            border-left: 2px solid #FFD700;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .score-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,215,0,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .score-item:hover {
            background: linear-gradient(135deg, rgba(255,215,0,0.25), rgba(255,215,0,0.1));
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 5px 15px rgba(255,215,0,0.3);
        }
        
        /* Prevent score-item hover effects from affecting XP bar */
        .score-item:hover .xp-bar-container {
            transform: none !important;
            background: none !important;
            box-shadow: none !important;
        }
        
        .score-item:hover::before {
            left: 100%;
        }
        
        #ui div::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,215,0,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        #ui div:hover {
            background: linear-gradient(135deg, rgba(255,215,0,0.25), rgba(255,215,0,0.1));
            transform: translateX(8px) scale(1.02);
            box-shadow: 0 5px 15px rgba(255,215,0,0.3);
        }
        
        #ui div:hover::before {
            left: 100%;
        }
        
        #controls {
            position: absolute;
            bottom: -130px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(26,26,46,0.95));
            color: #00FFFF;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            border: 3px solid #00FFFF;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5), 0 0 20px rgba(0,255,255,0.4);
            backdrop-filter: blur(10px);
            text-shadow: 0 0 10px #00FFFF;
            animation: glow 3s ease-in-out infinite alternate;
        }
        

        
        @keyframes controlsGlow {
            from { box-shadow: 0 8px 25px rgba(0,0,0,0.3), 0 0 20px rgba(255,215,0,0.5); }
            to { box-shadow: 0 8px 25px rgba(0,0,0,0.3), 0 0 30px rgba(255,215,0,0.8); }
        }
        
        #controls::before {
            content: 'ðŸŽ®';
            display: block;
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.95));
            color: #FFD700;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            font-size: 28px;
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            display: none;
            z-index: 20;
            border: 4px solid #FFD700;
            box-shadow: 0 0 40px rgba(255,215,0,0.7), inset 0 0 30px rgba(255,215,0,0.1);
            backdrop-filter: blur(15px);
            animation: levelCompleteGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes levelCompleteGlow {
            from { box-shadow: 0 0 40px rgba(255,215,0,0.7), inset 0 0 30px rgba(255,215,0,0.1); }
            to { box-shadow: 0 0 60px rgba(255,215,0,0.9), inset 0 0 40px rgba(255,215,0,0.2); }
        }
        
        #levelComplete .level-name {
            font-size: 20px;
            color: #FFD700;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255,215,0,0.8);
            font-weight: 900;
        }
        
        /* Asset Import Panel Styles */
        /* Enhanced Top UI Styles */
        .game-title {
            text-align: center;
            margin-bottom: 15px;
            animation: titleGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 10px #FFD700) drop-shadow(0 0 20px #FFA500); }
            to { filter: drop-shadow(0 0 15px #FFD700) drop-shadow(0 0 30px #FFA500) drop-shadow(0 0 40px #FF6B35); }
        }
        
        .score-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .score-item {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 165, 0, 0.8));
            color: #000;
            padding: 10px 15px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 14px;
            border: 2px solid #FFD700;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            /* Removed transition and animation for performance */
        }
        
        /* Enhanced XP Bar Styles - COOL VERSION */
        .xp-bar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            /* Removed animation and transition for performance */
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(26,26,46,0.95));
            padding: 12px 16px;
            border-radius: 15px;
            border: 3px solid #00FFFF;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8), inset 0 0 25px rgba(0,255,255,0.2), 0 0 35px rgba(0,255,255,0.6), 0 0 60px rgba(0,255,255,0.4);
            backdrop-filter: blur(15px);
        }
        
        .xp-bar {
            width: 200px;
            height: 24px;
            background: linear-gradient(180deg, #1a1a2e, #16213e);
            border: 3px solid #00FFFF;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 8px 25px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,255,255,0.2), 0 0 30px rgba(0,255,255,0.6), 0 0 50px rgba(0,255,255,0.4);
            /* Removed animation for performance */
        }
        
        .xp-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3), transparent);
            border-radius: 12px 12px 0 0;
            z-index: 1;
        }
        
        .xp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00FFFF, #0080FF, #0040FF, #0000FF, #8000FF, #FF00FF);
            background-size: 200% 100%;
            width: 0%;
            /* Removed transition and animation for performance */
            border-radius: 12px;
            position: relative;
            z-index: 2;
        }
        
        .xp-text {
            font-size: clamp(12px, 1.4vw, 16px);
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8);
            /* Removed animation for performance */
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: 8px 12px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            box-shadow: 0 4px 15px rgba(0,0,0,0.7), inset 0 0 12px rgba(255,215,0,0.15), 0 0 20px rgba(255,215,0,0.5);
            backdrop-filter: blur(10px);
        }
        
        .xp-text span {
            color: #00FFFF;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0,255,255,0.8), 1px 1px 2px rgba(0,0,0,0.9);
            /* Removed animation for performance */
        }
        
        @keyframes profileXpShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* Override score-item styling for XP bar */
        .score-item .xp-bar-container {
            background: none !important;
            padding: 0 !important;
            border: none !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            margin: 0 !important;
        }
        
        .score-item .xp-bar {
            background: linear-gradient(180deg, #1a1a2e, #16213e) !important;
            border: 3px solid #00FFFF !important;
            border-radius: 15px !important;
            box-shadow: 0 8px 25px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,255,255,0.2), 0 0 30px rgba(0,255,255,0.6), 0 0 50px rgba(0,255,255,0.4) !important;
            width: 200px !important;
            height: 24px !important;
            overflow: hidden !important;
            position: relative !important;
        }
        
        .score-item .xp-bar-fill {
            background: linear-gradient(90deg, #00FFFF, #0080FF, #0040FF, #0000FF, #8000FF, #FF00FF) !important;
            background-size: 200% 100% !important;
            border-radius: 12px !important;
            height: 100% !important;
            position: relative !important;
            z-index: 2 !important;
            animation: xpFillGlow 2s ease-in-out infinite alternate, xpFillMove 3s ease-in-out infinite !important;
        }
        
        .score-item .xp-text {
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95)) !important;
            border: 2px solid #FFD700 !important;
            border-radius: 10px !important;
            box-shadow: 0 4px 15px rgba(0,0,0,0.7), inset 0 0 12px rgba(255,215,0,0.15), 0 0 20px rgba(255,215,0,0.5) !important;
            backdrop-filter: blur(10px) !important;
            padding: 8px 12px !important;
            margin-top: 6px !important;
            font-size: clamp(12px, 1.4vw, 16px) !important;
            color: #FFD700 !important;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8) !important;
        }
        
        .score-item .xp-text span {
            color: #00FFFF !important;
            text-shadow: 0 0 10px rgba(0,255,255,0.8), 1px 1px 2px rgba(0,0,0,0.9) !important;
        }
        

        
        #assetPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-height: 80vh;
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.95));
            border: 4px solid #FFD700;
            border-radius: 20px;
            z-index: 1001;
            overflow-y: auto;
            backdrop-filter: blur(15px);
        }
        
        .asset-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 2px solid #FFD700;
            background: rgba(255,215,0,0.1);
        }
        
        .asset-header h3 {
            color: #FFD700;
            margin: 0;
            font-size: 24px;
        }
        
        .close-btn {
            background: #FF4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .close-btn:hover {
            background: #FF6666;
            transform: scale(1.1);
        }
        
        .asset-content {
            padding: 20px;
        }
        
        .asset-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255,215,0,0.05);
            border-radius: 10px;
            border-left: 3px solid #FFD700;
            transition: all 0.3s ease;
        }
        
        .asset-section:hover {
            background: rgba(255,215,0,0.1);
            transform: translateX(5px);
        }
        
        .asset-section h4 {
            color: #FFD700;
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        
        .asset-section input[type="file"] {
            display: block;
            margin: 5px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #FFD700;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }
        
        .asset-section input[type="file"]:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .preview {
            margin-top: 10px;
            min-height: 60px;
            background: rgba(0,0,0,0.3);
            border: 2px dashed #FFD700;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #FFD700;
            font-style: italic;
        }
        
        .preview img {
            max-width: 100%;
            max-height: 60px;
            border-radius: 3px;
        }
        
        .asset-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #FFD700;
        }
        
        .asset-controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-family: 'SuperMario', 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .reset-btn {
            background: #FF4444;
            color: white;
        }
        
        .export-btn {
            background: #4CAF50;
            color: white;
        }
        
        .import-btn {
            background: #2196F3;
            color: white;
        }
        
        .asset-controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        /* Health Bar Styles - Enhanced */
        .health-bar-container {
            position: fixed;
            bottom: 24px;
            right: 2vw;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 12px;
            /* Removed animation and transition for performance */
        }
        
        /* Removed @keyframes healthContainerFloat for performance */
        
        .bar-group {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
            /* Removed transition for performance */
        }
        
        .health-bar {
            width: 600px;
            height: 28px;
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(26,26,46,0.95));
            border: 3px solid #00FF00;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.8), inset 0 0 25px rgba(0,255,0,0.2), 0 0 30px rgba(0,255,0,0.6), 0 0 50px rgba(0,255,0,0.4);
            backdrop-filter: blur(15px);
            /* Removed animation and transition for performance */
            overflow: hidden;
            position: relative;
        }
        
        /* Removed hover and animation for performance */
        
        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00FF00, #66FF66, #99FF99, #CCFFCC);
            border-radius: 12px;
            /* Removed transition and animation for performance */
            position: relative;
            overflow: hidden;
        }
        
        .health-bar-fill.medium {
            background: linear-gradient(90deg, #FFFF00, #FFFF66, #FFFF99);
        }
        
        .health-bar-fill.low {
            background: linear-gradient(90deg, #FF4444, #FF6666, #FF8888);
        }
        
        .health-bar-fill::before {
            display: none; /* Removed shine animation for performance */
        }
        
        .health-text {
            color: #00FF00;
            font-size: clamp(16px, 2vw, 24px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(0,255,0,0.8);
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: clamp(10px, 1.4vw, 14px) clamp(16px, 2.2vw, 24px);
            border-radius: 12px;
            border: 2px solid #00FF00;
            box-shadow: 0 6px 18px rgba(0,0,0,0.7), inset 0 0 15px rgba(0,255,0,0.15), 0 0 20px rgba(0,255,0,0.6);
            backdrop-filter: blur(15px);
            /* Removed transition and animation for performance */
        }
        
        .armor-bar {
            width: 600px;
            height: 28px;
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            border: 3px solid #4169E1;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.8), inset 0 0 25px rgba(65,105,225,0.2), 0 0 30px rgba(65,105,225,0.6), 0 0 50px rgba(65,105,225,0.4);
            backdrop-filter: blur(15px);
            /* Removed animation and transition for performance */
            overflow: hidden;
            position: relative;
        }
        
        .armor-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4169E1, #6495ED, #87CEEB);
            border-radius: 12px;
            /* Removed transition for performance */
            position: relative;
            overflow: hidden;
        }
        
        .armor-bar-fill::before {
            display: none; /* Removed shine animation for performance */
        }
        
        .armor-text {
            color: #4169E1;
            font-size: clamp(16px, 2vw, 24px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(65,105,225,0.8);
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: clamp(10px, 1.4vw, 14px) clamp(16px, 2.2vw, 24px);
            border-radius: 12px;
            border: 2px solid #4169E1;
            box-shadow: 0 6px 18px rgba(0,0,0,0.7), inset 0 0 15px rgba(65,105,225,0.15), 0 0 20px rgba(65,105,225,0.6);
            backdrop-filter: blur(15px);
            /* Removed transition and animation for performance */
        }
        
        .lives-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(255,20,147,0.2), rgba(255,105,180,0.1));
            border-radius: 15px;
            border: 2px solid #FF1493;
            box-shadow: 0 8px 25px rgba(255,20,147,0.4), inset 0 0 20px rgba(255,20,147,0.1), 0 0 30px rgba(255,20,147,0.6);
            backdrop-filter: blur(15px);
            /* Removed transition and animation for performance */
            align-self: flex-end;
        }
        
        .lives-icon {
            font-size: 32px;
            /* Removed animation for performance */
            filter: drop-shadow(0 0 10px rgba(255,20,147,0.8));
        }
        
        /* Removed @keyframes heartBeat for performance */
        
        .lives-text {
            color: #FFD700;
            font-size: clamp(16px, 2vw, 24px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8);
            text-align: center;
        }
        
        /* Abilities Display Styles */
        .abilities-display {
            position: fixed;
            top: 18px;
            right: 2vw;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            animation: abilitiesContainerFloat 4s ease-in-out infinite;
            transform-origin: top right;
        }
        
        @keyframes abilitiesContainerFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-2px); }
        }
        
        .abilities-title {
            color: #FF6B35;
            font-size: clamp(12px, 1.6vw, 18px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,107,53,0.8);
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: clamp(6px, 1vw, 10px) clamp(10px, 1.6vw, 16px);
            border-radius: 8px;
            border: 2px solid #FF6B35;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6), inset 0 0 12px rgba(255,107,53,0.15), 0 0 16px rgba(255,107,53,0.5);
            backdrop-filter: blur(10px);
        }
        
        .abilities-grid {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .ability-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 8px 10px;
            background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05));
            border-radius: 8px;
            border: 2px solid rgba(255,107,53,0.3);
            transition: all 0.3s ease;
            min-width: 52px;
        }
        
        .ability-item.active {
            background: linear-gradient(135deg, rgba(255,107,53,0.3), rgba(255,107,53,0.2));
            border-color: #FF6B35;
            box-shadow: 0 0 10px rgba(255,107,53,0.5);
            animation: abilityGlow 2s ease-in-out infinite alternate;
        }
        
        .ability-item.inactive {
            opacity: 0.4;
            filter: grayscale(0.8);
        }
        
        @keyframes abilityGlow {
            from { box-shadow: 0 0 10px rgba(255,107,53,0.5); }
            to { box-shadow: 0 0 20px rgba(255,107,53,0.8); }
        }
        
        .ability-icon {
            font-size: 26px;
            filter: drop-shadow(0 0 5px rgba(255,107,53,0.7));
        }
        
        .ability-label {
            font-size: 10px;
            color: #FF6B35;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .tab-btn.active {
            background: linear-gradient(135deg, #4CAF50, #45a049) !important;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        
        /* Marketplace Tab Button Styles */
        .marketplace-tab-btn {
            position: relative;
            overflow: hidden;
        }
        
        .marketplace-tab-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .marketplace-tab-btn:hover::before {
            left: 100%;
        }
        
        .marketplace-tab-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        .marketplace-tab-btn.active {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }
        
        /* Pause Menu Tab Button Styles */
        .pause-tab-btn {
            position: relative;
            overflow: hidden;
        }
        
        .pause-tab-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .pause-tab-btn:hover::before {
            left: 100%;
        }
        
        .pause-tab-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        .pause-tab-btn.active {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }
        
        /* Toggle Switch Styles */
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        input:checked + .toggle-slider {
            background-color: #4CAF50;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .marketplace-grid {
            max-height: 600px;
            overflow-y: auto;
            padding: 20px;
            scrollbar-width: thin;
            scrollbar-color: rgba(0,255,255,0.5) rgba(0,255,255,0.1);
        }
        
        .marketplace-grid::-webkit-scrollbar {
            width: 10px;
        }
        
        .marketplace-grid::-webkit-scrollbar-track {
            background: rgba(0,255,255,0.1);
            border-radius: 8px;
            margin: 5px;
        }
        
        .marketplace-grid::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, rgba(0,255,255,0.6), rgba(0,255,255,0.4));
            border-radius: 8px;
            border: 2px solid rgba(0,255,255,0.1);
        }
        
        .marketplace-grid::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, rgba(0,255,255,0.8), rgba(0,255,255,0.6));
        }
        
        /* Home Screen Animations */
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }
        
        @keyframes titleGlow {
            0%, 100% { filter: drop-shadow(0 0 40px #FFD700); }
            50% { filter: drop-shadow(0 0 60px #FFD700) drop-shadow(0 0 80px #FFA500); }
        }
        
        @keyframes logoGlow {
            0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.1); }
        }
        
        @keyframes subtitleGlow {
            0% { text-shadow: 2px 2px 8px rgba(0,0,0,0.9), 0 0 20px #00FFFF, 0 0 30px #00FFFF; }
            100% { text-shadow: 2px 2px 8px rgba(0,0,0,0.9), 0 0 30px #00FFFF, 0 0 40px #00FFFF, 0 0 50px #00FFFF; }
        }
        
        @keyframes subtitlePulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }
        
        @keyframes buttonGlow {
            0%, 100% { box-shadow: 0 0 40px rgba(255,215,0,0.6), 0 8px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); }
            50% { box-shadow: 0 0 60px rgba(255,215,0,0.8), 0 12px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.5); }
        }
        
        @keyframes buttonShine {
            0% { transform: rotate(45deg) translateX(-100%); }
            50% { transform: rotate(45deg) translateX(100%); }
            100% { transform: rotate(45deg) translateX(100%); }
        }
        
        @keyframes borderGlow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        /* Button Hover Effects */
        .home-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 0 60px rgba(255,215,0,0.8), 0 15px 35px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.5);
        }
        
        .start-btn:hover {
            box-shadow: 0 0 60px rgba(255,215,0,0.8), 0 15px 35px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.5);
        }
        
        .profile-btn:hover {
            box-shadow: 0 0 60px rgba(156,39,176,0.8), 0 15px 35px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.5);
        }
        
        .marketplace-btn:hover {
            box-shadow: 0 0 60px rgba(76,175,80,0.8), 0 15px 35px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.5);
        }
        
        /* Floating Elements */
        .floating-otter, .floating-coin {
            pointer-events: none;
            user-select: none;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .home-button {
                padding: 15px 25px !important;
                font-size: clamp(16px, 4vw, 20px) !important;
            }
            
            /* Mobile Marketplace Panel */
            #marketplacePanel {
                padding: 10px !important;
                overflow-y: auto !important;
            }
            
            #marketplacePanel > div {
                max-width: 100% !important;
                padding: 10px !important;
            }
            
            .marketplace-grid {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
                padding: 10px !important;
            }
            
            .marketplace-item {
                min-height: auto !important;
                padding: 15px !important;
            }
            
            .marketplace-tab-btn {
                padding: 8px 12px !important;
                font-size: 12px !important;
                min-width: 80px !important;
            }
            
            /* Mobile Profile Panel */
            #profilePanel {
                top: 0 !important;
                left: 0 !important;
                transform: none !important;
                width: 100vw !important;
                height: 100vh !important;
                max-width: 100vw !important;
                max-height: 100vh !important;
                border-radius: 0 !important;
                padding: 10px !important;
                overflow-y: auto !important;
            }
            
            #profilePanel > div {
                max-width: 100% !important;
                padding: 10px !important;
            }
            
            .profile-tab-btn {
                padding: 8px 12px !important;
                font-size: 12px !important;
                min-width: 80px !important;
            }
            
            /* Mobile Grid Layouts */
            .profile-grid, .stats-grid {
                grid-template-columns: 1fr !important;
                gap: 10px !important;
            }
            
            /* Mobile Text Sizes */
            h1, h2, h3 {
                font-size: clamp(18px, 5vw, 24px) !important;
            }
            
            .profile-stats-card {
                padding: 15px !important;
                margin-bottom: 10px !important;
            }
            
            /* Mobile Achievement Cards */
            #profileAchievementsList {
                grid-template-columns: 1fr !important;
                gap: 10px !important;
            }
            
            /* Mobile Inventory Grids */
            #profileSkinsInventory, #profileHatsInventory, #profileAbilitiesInventory {
                grid-template-columns: 1fr !important;
                gap: 10px !important;
            }
            
            /* Mobile Leaderboard */
            #leaderboardPanel {
                top: 0 !important;
                left: 0 !important;
                transform: none !important;
                width: 100vw !important;
                height: 100vh !important;
                max-width: 100vw !important;
                max-height: 100vh !important;
                border-radius: 0 !important;
                padding: 10px !important;
            }
            
            /* Mobile Pause Menu */
            #pauseMenu {
                top: 0 !important;
                left: 0 !important;
                transform: none !important;
                width: 100vw !important;
                height: 100vh !important;
                max-width: 100vw !important;
                max-height: 100vh !important;
                border-radius: 0 !important;
                padding: 10px !important;
            }
            
            /* Mobile Buttons */
            button {
                min-height: 44px !important;
                min-width: 44px !important;
                font-size: 14px !important;
            }
            
            /* Mobile Close Buttons */
            .close-btn {
                position: fixed !important;
                top: 10px !important;
                right: 10px !important;
                z-index: 1001 !important;
                background: #FF4444 !important;
                color: white !important;
                border: none !important;
                padding: 10px 15px !important;
                border-radius: 50% !important;
                font-size: 18px !important;
                font-weight: bold !important;
            }
            
            /* Mobile Scrollbars */
            ::-webkit-scrollbar {
                width: 8px !important;
            }
            
            ::-webkit-scrollbar-track {
                background: rgba(0,0,0,0.1) !important;
            }
            
            ::-webkit-scrollbar-thumb {
                background: rgba(0,255,255,0.5) !important;
                border-radius: 4px !important;
            }
            
            /* Mobile Touch Targets */
            .marketplace-item, .profile-stats-card, .achievement-card {
                min-height: 60px !important;
                touch-action: manipulation !important;
            }
            
            /* Mobile Spacing */
            .mobile-spacing {
                margin: 10px 0 !important;
                padding: 10px !important;
            }
        }
        
        /* Marketplace Item Darkening Effects */
        .marketplace-item {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .marketplace-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.6s ease;
            z-index: 1;
        }
        
        .marketplace-item:hover::before {
            left: 100%;
        }
        
        .marketplace-item:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 35px rgba(0,0,0,0.4), 0 0 20px rgba(255,215,0,0.3);
        }
        
        .marketplace-item:not(.owned) {
            opacity: 0.8;
        }
        
        .marketplace-item:not(.owned):hover {
            opacity: 0.95;
        }
        
        .marketplace-item.owned {
            animation: ownedItemGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes ownedItemGlow {
            0% { box-shadow: 0 4px 15px rgba(0,0,0,0.2), 0 0 10px rgba(76,175,80,0.3); }
            100% { box-shadow: 0 4px 15px rgba(0,0,0,0.2), 0 0 20px rgba(76,175,80,0.6); }
        }
        
        /* Profile Page Enhancements */
        #profileOtterImage {
            object-fit: cover;
            object-position: center;
            max-width: 100%;
            max-height: 100%;
            transition: all 0.3s ease;
        }
        
        #profileOtterImage:hover {
            transform: scale(1.1);
        }
        
        #profilePlayerName:hover {
            color: #00FFFF;
            text-shadow: 0 0 10px #00FFFF;
        }
        
        .profile-edit-btn {
            transition: all 0.3s ease;
        }
        
        .profile-edit-btn:hover {
            transform: scale(1.1);
            background: #00FFFF !important;
            color: #000 !important;
        }

        /* Wallet Integration Styles - REMOVED */

        .fish-earnings {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.3);
            animation: fishEarningsPulse 2s ease-in-out infinite;
        }

        .fish-earnings.show {
            display: block;
        }

        @keyframes fishEarningsPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .trait-bonus {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            z-index: 10000;
            display: none;
            text-align: center;
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            animation: traitBonusSlideIn 0.5s ease-out;
        }

        .trait-bonus.show {
            display: block;
        }

        @keyframes traitBonusSlideIn {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
        <div id="ui">
        <div class="game-title">
            <img src="public/otterfulotterbros.png" alt="Otter Bros" style="width: clamp(120px, 20vw, 200px); height: auto; filter: drop-shadow(0 0 10px #FFD700);" onload="console.log('Game title image loaded successfully')" onerror="console.log('Failed to load game title image')">
        </div>
        <div class="score-row">
            <div class="score-item"><span class="label">Score:</span> <span id="score">0</span></div>
            <div class="score-item"><span class="label">Coins:</span> <span id="coins">0</span></div>
            <div class="score-item"><span class="label">XP:</span> <span id="xp">0</span></div>
            <div class="score-item">
                <div class="xp-bar-container">
                    <div class="xp-bar">
                        <div class="xp-bar-fill" id="xpBarFill"></div>
                    </div>
                    <div class="xp-text" id="xpText">Level 1 <span id="xpProgress">(0/1000 XP)</span></div>
                </div>
            </div>
        </div>
            <div id="giantIndicator" style="display: none; color: #FF00FF; font-weight: bold; text-shadow: 0 0 10px #FF00FF;">ðŸ„ GIANT MODE: 10s</div>
    </div>
    
    
    
            <div id="levelDisplay" class="corner-display top-left" style="top: 22px; left: 4vw;">Level: <span id="level">1</span></div>
    
    <!-- Real-time Collectibles Counter - Horizontal -->
            <div id="collectiblesCounter" class="corner-display top-left" style="top: 2vh; left: 11vw; display: flex; flex-direction: row; gap: 15px;">
        <div class="counter-item">
            <span class="counter-icon">ðŸª™</span>
            <span class="counter-label">Coins:</span>
            <span id="coinsCounter" class="counter-value">0</span>
        </div>
        <div class="counter-item">
            <span class="counter-icon">ðŸ’Ž</span>
            <span class="counter-label">Chests:</span>
            <span id="chestsCounter" class="counter-value">0</span>
        </div>
        <div class="counter-item">
            <span class="counter-icon">ðŸ”‘</span>
            <span class="counter-label">Keys:</span>
            <span id="keysCounter" class="counter-value">0</span>
        </div>
    </div>
    
    <!-- Health Bar and Lives Display - Reorganized -->
    <div class="health-bar-container">
        <!-- Lives Display at Top -->
        <div class="lives-display" id="livesDisplay">
            <div class="lives-icon">â¤ï¸</div>
            <div class="lives-text">Lives: <span id="lives">3</span></div>
        </div>
        
        <!-- Health Bar in Middle -->
        <div class="bar-group">
            <div class="health-bar">
                <div class="health-bar-fill" id="healthBarFill" style="width: 100%;"></div>
            </div>
            <div class="health-text" id="healthText">Health: 100%</div>
        </div>
        
        <!-- Armor Bar at Bottom -->
        <div class="bar-group">
            <div class="armor-bar">
                <div class="armor-bar-fill" id="armorBarFill" style="width: 0%;"></div>
            </div>
            <div class="armor-text" id="armorText">Armor: 0%</div>
        </div>
    </div>

    <!-- Abilities Display -->
    <div class="abilities-display">
        <div class="abilities-title">âš¡ ABILITIES</div>
        <div class="abilities-grid">
                          <div id="laserAbility" class="ability-item inactive">
                  <div class="ability-icon">ðŸ”«</div>
                  <div class="ability-label" style="display: none;"></div>
              </div>
            <div id="fireballAbility" class="ability-item inactive">
                <div class="ability-icon">ðŸ”¥</div>
                <div class="ability-label">FIREBALL</div>
            </div>
            <div id="jetpackAbility" class="ability-item inactive">
                <div class="ability-icon">ðŸš</div>
                <div class="ability-label">JETPACK</div>
            </div>
        </div>
    </div>

    <!-- Wallet Info Display - REMOVED FOR PERFORMANCE -->

    <!-- Fish Earnings Display -->
    <div id="fishEarnings" class="fish-earnings">
        <div style="display: flex; align-items: center; gap: 8px;">
            <span>ðŸŸ</span>
            <span>+<span id="fishEarningsAmount">0</span> $FISH</span>
        </div>
        <div style="font-size: 12px; margin-top: 4px; opacity: 0.9;">From staked otters!</div>
    </div>

        <div id="titleScreen" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: url('public/fishhh.png') center center / cover, linear-gradient(135deg, rgba(26,26,46,0.9), rgba(22,33,62,0.9), rgba(15,52,96,0.9)); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 3000; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif; overflow: hidden;">
        
        <!-- Animated Background Elements -->
        <div class="floating-sparkle" style="position: absolute; top: 10%; left: 5%; font-size: 60px; animation: float 6s ease-in-out infinite; opacity: 0.3;">âœ¨</div>
        <div class="floating-sparkle" style="position: absolute; top: 20%; right: 10%; font-size: 40px; animation: float 8s ease-in-out infinite reverse; opacity: 0.2;">âœ¨</div>
        <div class="floating-sparkle" style="position: absolute; bottom: 30%; left: 15%; font-size: 50px; animation: float 7s ease-in-out infinite; opacity: 0.25;">âœ¨</div>
        <div class="floating-sparkle" style="position: absolute; bottom: 20%; right: 5%; font-size: 45px; animation: float 9s ease-in-out infinite reverse; opacity: 0.3;">âœ¨</div>
        
        <!-- Floating Coins -->
        <div class="floating-coin" style="position: absolute; top: 15%; left: 20%; font-size: 30px; animation: float 5s ease-in-out infinite; opacity: 0.4;">ðŸª™</div>
        <div class="floating-coin" style="position: absolute; top: 25%; right: 20%; font-size: 25px; animation: float 6.5s ease-in-out infinite reverse; opacity: 0.3;">ðŸª™</div>
        <div class="floating-coin" style="position: absolute; bottom: 25%; left: 25%; font-size: 35px; animation: float 7.5s ease-in-out infinite; opacity: 0.35;">ðŸª™</div>
        <div class="floating-coin" style="position: absolute; bottom: 15%; right: 15%; font-size: 28px; animation: float 8.5s ease-in-out infinite reverse; opacity: 0.4;">ðŸª™</div>
        
        <!-- Main Content Container -->
        <div style="text-align: center; color: #FFD700; background: url('public/FLOLW.png') center center / cover, linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.9)); padding: 40px; border-radius: 30px; border: 4px solid #FFD700; box-shadow: 0 0 60px rgba(255,215,0,0.6), inset 0 0 30px rgba(255,215,0,0.1), 0 20px 40px rgba(0,0,0,0.8); backdrop-filter: blur(10px); position: relative; z-index: 10;">
            <!-- FLOLW Overlay at 10% opacity -->
            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: url('public/FLOLW.png') center center / cover; opacity: 0.1; border-radius: 30px; pointer-events: none; z-index: -1;"></div>
            
            <!-- Glowing Border Effect -->
            <div style="position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700, #FFA500); border-radius: 32px; z-index: -1; animation: borderGlow 3s ease-in-out infinite;"></div>
            
            <!-- Title Logo with Enhanced Effects -->
            <div style="position: relative; margin-bottom: 30px;">
                <img src="public/otterfulotterbros.png" alt="Otter Bros" style="width: clamp(300px, 60vw, 600px); height: auto; filter: drop-shadow(0 0 40px #FFD700); animation: titleGlow 3s ease-in-out infinite; position: relative; z-index: 2;" onload="console.log('Title screen image loaded successfully')" onerror="console.log('Failed to load title screen image')">
                
                <!-- Logo Glow Effect -->
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; height: 100%; background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%); animation: logoGlow 4s ease-in-out infinite; z-index: 1;"></div>
                </div>
            
            <!-- Subtitle with Enhanced Styling -->
            <div style="margin-bottom: 40px; position: relative;">
                <p style="font-size: clamp(18px, 3.5vw, 28px); margin: 0; color: #00FFFF; text-shadow: 2px 2px 8px rgba(0,0,0,0.9), 0 0 20px #00FFFF, 0 0 30px #00FFFF; font-weight: bold; animation: subtitleGlow 2s ease-in-out infinite alternate;">A Platforming Adventure</p>
                <p style="font-size: clamp(14px, 2.5vw, 20px); margin: 25px 0 0 0; color: #000000; text-shadow: 1px 1px 4px rgba(255,255,255,0.8); opacity: 0.9; animation: subtitlePulse 3s ease-in-out infinite;">Embark on an epic journey with your otter companion!</p>
                </div>
            
            <!-- Enhanced Button Container -->
            <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 30px; align-items: center; position: relative;">
                
                <!-- Continue Game Button (hidden by default) -->
                <button id="continueGameBtn" class="home-button continue-btn" style="display: none; background: linear-gradient(135deg, #FF9800, #F57C00, #FF9800); background-size: 200% 200%; color: #FFFFFF; border: 3px solid #FF9800; padding: 18px 35px; border-radius: 30px; font-size: clamp(18px, 3vw, 24px); font-weight: bold; cursor: pointer; box-shadow: 0 0 40px rgba(255,152,0,0.6), 0 8px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); transition: all 0.3s ease; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: relative; overflow: hidden; animation: buttonGlow 2s ease-in-out infinite; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <span style="position: relative; z-index: 2;">ðŸŽ® Continue Game</span>
                    <div class="button-shine" style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent); transform: rotate(45deg); animation: buttonShine 3s ease-in-out infinite;"></div>
                </button>
                
                <!-- Start Adventure Button -->
                <button id="startGameBtn" class="home-button start-btn" style="background: linear-gradient(135deg, #4CAF50, #45a049, #4CAF50); background-size: 200% 200%; color: #FFFFFF; border: 3px solid #4CAF50; padding: 18px 35px; border-radius: 30px; font-size: clamp(18px, 3vw, 24px); font-weight: bold; cursor: pointer; box-shadow: 0 0 40px rgba(76,175,80,0.6), 0 8px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); transition: all 0.3s ease; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: relative; overflow: hidden; animation: buttonGlow 2s ease-in-out infinite; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <span style="position: relative; z-index: 2;">ðŸš€ Start Adventure</span>
                    <div class="button-shine" style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent); transform: rotate(45deg); animation: buttonShine 3s ease-in-out infinite;"></div>
                </button>
                
                <!-- Connect Wallet Button - REMOVED FOR PERFORMANCE -->
                
                <!-- Marketplace Button -->
                <button id="marketplaceBtn" class="home-button marketplace-btn" style="background: linear-gradient(135deg, #2196F3, #1976D2, #2196F3); background-size: 200% 200%; color: #FFFFFF; border: 3px solid #2196F3; padding: 18px 35px; border-radius: 30px; font-size: clamp(18px, 3vw, 24px); font-weight: bold; cursor: pointer; box-shadow: 0 0 40px rgba(33,150,243,0.6), 0 8px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); transition: all 0.3s ease; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: relative; overflow: hidden; animation: buttonGlow 2s ease-in-out infinite 0.5s; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <span style="position: relative; z-index: 2;">ðŸ›’ Marketplace</span>
                    <div class="button-shine" style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent); transform: rotate(45deg); animation: buttonShine 3s ease-in-out infinite 0.5s;"></div>
                </button>
                
                <!-- Profile Button -->
                <button id="profileBtn" class="home-button profile-btn" style="background: linear-gradient(135deg, #9C27B0, #7B1FA2, #9C27B0); background-size: 200% 200%; color: #FFFFFF; border: 3px solid #9C27B0; padding: 18px 35px; border-radius: 30px; font-size: clamp(18px, 3vw, 24px); font-weight: bold; cursor: pointer; box-shadow: 0 0 40px rgba(156,39,176,0.6), 0 8px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); transition: all 0.3s ease; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: relative; overflow: hidden; animation: buttonGlow 2s ease-in-out infinite 1s; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <span style="position: relative; z-index: 2;">ðŸ‘¤ Profile</span>
                    <div class="button-shine" style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent); transform: rotate(45deg); animation: buttonShine 3s ease-in-out infinite 1s;"></div>
                </button>
                </div>
            
            <!-- Footer Info -->
            <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid rgba(255,215,0,0.3);">
                <p style="font-size: clamp(12px, 2vw, 16px); color: #000000; text-shadow: 1px 1px 4px rgba(255,255,255,0.8); opacity: 0.9; margin: 0;">Use Arrow Keys or WASD to move â€¢ SPACE to jump â€¢ Collect coins and defeat enemies!</p>
                </div>
            </div>
            
        <!-- Particle Effects Container -->
        <div id="particleContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;"></div>
    </div>
    
    <div id="cutscenePanel" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.9); background-image: url('public/fishhh.png'); background-size: cover; background-position: center; background-repeat: no-repeat; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 4000; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
        <div id="cutsceneText" style="color: #FFD700; font-size: clamp(16px, 3vw, 24px); text-align: center; max-width: 80vw; line-height: 1.6; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); background: rgba(0,0,0,0.7); padding: 20px; border-radius: 15px; backdrop-filter: blur(5px);"></div>
        <button id="skipCutsceneBtn" style="background: #FF4444; color: white; border: none; padding: 10px 20px; border-radius: 15px; cursor: pointer; font-size: 16px;">
            Skip Cutscene
        </button>
    </div>
    
    <!-- Sign In Modal (thirdweb style) -->
    <div id="signInModal" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); z-index: 5000; font-family: 'Arial', sans-serif; align-items: center; justify-content: center;">
        <div style="background: #1a1a1a; border-radius: 16px; padding: 32px; max-width: 420px; width: 90%; max-height: 90vh; overflow-y: auto; position: relative; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
            <!-- Header -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                <h2 style="margin: 0; color: #ffffff; font-size: 24px; font-weight: bold; letter-spacing: -0.5px;">SIGN IN</h2>
                <button id="closeSignInModal" style="background: none; border: none; color: #ffffff; font-size: 24px; cursor: pointer; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='none'">Ã—</button>
            </div>
            
            <!-- Quick Sign-In Buttons -->
            <div style="display: flex; gap: 8px; margin-bottom: 24px;">
                <button class="quick-signin-btn" style="flex: 1; background: #ffffff; border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='#ffffff'">
                    <span style="font-size: 20px;">G</span>
                </button>
                <button class="quick-signin-btn" style="flex: 1; background: #5865F2; border: 1px solid #5865F2; border-radius: 8px; padding: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#4752C4'" onmouseout="this.style.background='#5865F2'">
                    <span style="color: white; font-size: 20px;">ðŸ’¬</span>
                </button>
                <button class="quick-signin-btn" style="flex: 1; background: #0088cc; border: 1px solid #0088cc; border-radius: 8px; padding: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#0077b5'" onmouseout="this.style.background='#0088cc'">
                    <span style="color: white; font-size: 20px;">âœˆï¸</span>
                </button>
                <button class="quick-signin-btn" style="flex: 1; background: #6366f1; border: 1px solid #6366f1; border-radius: 8px; padding: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#4f46e5'" onmouseout="this.style.background='#6366f1'">
                    <span style="color: white; font-size: 20px;">ðŸ”·</span>
                </button>
            </div>
            
            <!-- Input Fields -->
            <div style="margin-bottom: 16px;">
                <div style="position: relative; margin-bottom: 12px;">
                    <input type="email" id="emailInput" placeholder="EMAIL ADDRESS" style="width: 100%; padding: 14px 16px; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 8px; color: #ffffff; font-size: 14px; box-sizing: border-box; padding-right: 40px;" />
                    <span style="position: absolute; right: 16px; top: 50%; transform: translateY(-50%); color: #888; cursor: pointer;">â†’</span>
                </div>
                <div style="position: relative; margin-bottom: 12px;">
                    <span style="position: absolute; left: 16px; top: 50%; transform: translateY(-50%); color: #4a9eff; font-size: 18px;">ðŸ“±</span>
                    <input type="tel" id="phoneInput" placeholder="PHONE NUMBER" style="width: 100%; padding: 14px 16px 14px 48px; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 8px; color: #ffffff; font-size: 14px; box-sizing: border-box;" />
                </div>
                <div style="position: relative;">
                    <span style="position: absolute; left: 16px; top: 50%; transform: translateY(-50%); color: #4a9eff; font-size: 18px;">ðŸ”</span>
                    <input type="text" id="passkeyInput" placeholder="PASSKEY" style="width: 100%; padding: 14px 16px 14px 48px; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 8px; color: #ffffff; font-size: 14px; box-sizing: border-box;" />
                </div>
            </div>
            
            <!-- OR Separator -->
            <div style="display: flex; align-items: center; margin: 24px 0;">
                <div style="flex: 1; height: 1px; background: #3a3a3a;"></div>
                <span style="padding: 0 16px; color: #ffffff; font-size: 14px;">OR</span>
                <div style="flex: 1; height: 1px; background: #3a3a3a;"></div>
            </div>
            
            <!-- Connect Wallet Button - REMOVED FOR PERFORMANCE -->
            
            <!-- Powered By -->
            <div style="text-align: center; margin-top: 24px; padding-top: 24px; border-top: 1px solid #3a3a3a;">
                <div style="color: #888; font-size: 12px; margin-bottom: 8px;">POWERED BY</div>
                <div style="color: #ffffff; font-size: 16px; font-weight: 600; letter-spacing: 0.5px;">thirdweb</div>
            </div>
        </div>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Mobile Touch Controls -->
        <div id="mobileControls" style="display: none; position: absolute; bottom: 0; left: 0; right: 0; z-index: 2000; pointer-events: none; touch-action: none;">
            <!-- Circular Touchpad Joystick -->
            <div id="mobileJoystick" style="position: absolute; bottom: 80px; left: 10px; width: 120px; height: 120px; pointer-events: auto; touch-action: none;">
                <div id="joystickBase" style="position: absolute; width: 100%; height: 100%; border-radius: 50%; background: rgba(255,255,255,0.2); border: 3px solid rgba(255,255,255,0.5); pointer-events: none;"></div>
                <div id="joystickHandle" style="position: absolute; width: 50px; height: 50px; border-radius: 50%; background: rgba(255,255,255,0.6); border: 2px solid rgba(255,255,255,0.9); left: 50%; top: 50%; transform: translate(-50%, -50%); pointer-events: none; transition: none;"></div>
            </div>
            
            <!-- Jump Button -->
            <button id="mobileJump" class="mobile-btn" style="position: absolute; bottom: 100px; right: 5px; width: 60px; height: 60px; border-radius: 50%; background: rgba(0,255,0,0.5); border: 2px solid rgba(0,255,0,0.8); font-size: 14px; color: white; font-weight: bold; pointer-events: auto; touch-action: manipulation;">JUMP</button>
            
            <!-- Jetpack Button -->
            <button id="mobileJetpack" class="mobile-btn" style="display: none; position: absolute; bottom: 170px; right: 5px; width: 60px; height: 60px; border-radius: 50%; background: rgba(255,165,0,0.5); border: 2px solid rgba(255,165,0,0.8); font-size: 12px; color: white; font-weight: bold; pointer-events: auto; touch-action: manipulation;">JET</button>
            
            <!-- Action Buttons (Laser/Fireball) -->
            <div id="mobileActions" style="position: absolute; bottom: 240px; right: 10px; pointer-events: auto;">
                <button id="mobileLaser" class="mobile-btn" style="display: none; width: 50px; height: 50px; border-radius: 50%; background: rgba(0,150,255,0.5); border: 2px solid rgba(0,150,255,0.8); font-size: 12px; color: white; font-weight: bold; margin-bottom: 8px; touch-action: manipulation;">L</button>
                <button id="mobileFireball" class="mobile-btn" style="display: none; width: 50px; height: 50px; border-radius: 50%; background: rgba(255,100,0,0.5); border: 2px solid rgba(255,100,0,0.8); font-size: 12px; color: white; font-weight: bold; touch-action: manipulation;">F</button>
            </div>
        </div>
        
        <div id="levelComplete">
            <div class="level-name" id="levelCompleteName">Level Complete!</div>
            <div id="levelCompleteText">Level Complete!</div>
            <div style="font-size: 16px; margin-top: 10px;">Press SPACE to continue</div>
        </div>
        <div id="controls" style="text-align: center; padding: 10px;">
            <button id="pauseBtn" onclick="togglePauseMenu()" style="display: none; background: linear-gradient(135deg, rgba(255,107,53,0.9), rgba(255,68,68,0.8)); color: #000; padding: clamp(10px, 2vw, 15px) clamp(15px, 3vw, 25px); border-radius: 25px; font-size: clamp(14px, 2vw, 18px); font-weight: bold; border: 3px solid #FF6B35; box-shadow: 0 0 20px #FF6B35, 0 5px 15px rgba(0,0,0,0.3); backdrop-filter: blur(5px); cursor: pointer;">
                â¸ï¸ Pause
            </button>
            </div>
        
        <!-- Settings Button (Bottom Left) -->
        <button id="settingsBtn" onclick="togglePauseMenu()" style="position: fixed; bottom: 20px; left: 20px; background: linear-gradient(135deg, rgba(0,255,255,0.9), rgba(0,255,255,0.8)); color: #000; padding: clamp(12px, 2.5vw, 18px) clamp(18px, 3.5vw, 28px); border-radius: 25px; font-size: clamp(14px, 2.2vw, 18px); font-weight: bold; border: 3px solid #00FFFF; box-shadow: 0 0 20px #00FFFF, 0 5px 15px rgba(0,0,0,0.3); backdrop-filter: blur(5px); cursor: pointer; z-index: 1000; display: none; transition: all 0.3s ease; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
            âš™ï¸ Settings
        </button>
    </div>
    
    <!-- Leaderboard Panel -->
    <div id="leaderboardPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.98)); color: #FFD700; padding: clamp(20px, 3vw, 35px); border-radius: 25px; border: 3px solid #FFD700; box-shadow: 0 20px 60px rgba(0,0,0,0.8), 0 0 40px rgba(255,215,0,0.5); backdrop-filter: blur(20px); z-index: 2000; max-width: 90vw; max-height: 85vh; overflow-y: auto; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid #FFD700; padding-bottom: 15px;">
            <h2 style="margin: 0; font-size: clamp(20px, 4vw, 32px); text-shadow: 0 0 15px #FFD700;">ðŸ† Global Leaderboard</h2>
            <div style="display: flex; gap: 10px;">
                <button id="refreshLeaderboardBtn" onclick="refreshGlobalLeaderboard()" style="background: #00FF88; color: white; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; font-size: 12px; font-weight: bold;">ðŸ”„ Refresh</button>
                <button onclick="resetStats()" style="background: #FF8800; color: white; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; font-size: 12px; font-weight: bold;">Reset</button>
                <button onclick="toggleLeaderboard()" style="background: #FF4444; color: white; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold;">Ã—</button>
            </div>
        </div>
        <div id="leaderboardContent">
            <!-- Global Leaderboard Section -->
            <div style="margin-bottom: 30px;">
                <h3 style="color: #FFD700; margin-bottom: 15px; text-align: center;">ðŸŒ Global Rankings</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 15px; justify-content: center;">
                    <button id="scoreTabBtn" class="tab-btn active" onclick="switchLeaderboardTab('score')" style="background: #FFD700; color: black; border: none; padding: 8px 15px; border-radius: 10px; cursor: pointer; font-weight: bold;">High Scores</button>
                    <button id="coinsTabBtn" class="tab-btn" onclick="switchLeaderboardTab('coins')" style="background: rgba(255,215,0,0.3); color: #FFD700; border: none; padding: 8px 15px; border-radius: 10px; cursor: pointer; font-weight: bold;">Coin Collectors</button>
                    <button id="levelsTabBtn" class="tab-btn" onclick="switchLeaderboardTab('levels')" style="background: rgba(255,215,0,0.3); color: #FFD700; border: none; padding: 8px 15px; border-radius: 10px; cursor: pointer; font-weight: bold;">Level Masters</button>
                    <button id="bossesTabBtn" class="tab-btn" onclick="switchLeaderboardTab('bosses')" style="background: rgba(255,215,0,0.3); color: #FFD700; border: none; padding: 8px 15px; border-radius: 10px; cursor: pointer; font-weight: bold;">ðŸ‘‘ Boss Slayers</button>
                </div>
                <div id="globalLeaderboardContent">
                    <div style="text-align: center; color: #FFD700; font-size: 18px; margin: 20px 0;">
                        Loading global leaderboard...
                    </div>
                </div>
                <div id="leaderboardStatus" style="text-align: center; color: #00FFFF; font-size: 12px; margin-top: 10px;">
                    Last updated: Never
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="submitToGlobalLeaderboard()" style="background: #FFD700; color: black; border: none; padding: 10px 20px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 14px;">
                        ðŸ† Submit My Score
                    </button>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00FFFF; margin-bottom: 10px;">ðŸ“Š All-Time Stats</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #FFD700;">
                        <div style="font-size: 14px; color: #FFD700;">Total Score</div>
                        <div id="totalScore" style="font-size: 24px; font-weight: bold;">0</div>
                        <div style="font-size: 12px; color: #00FFFF;">Best: <span id="highestScore">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #FFD700;">
                        <div style="font-size: 14px; color: #FFD700;">Levels Completed</div>
                        <div id="totalLevels" style="font-size: 24px; font-weight: bold;">0</div>
                        <div style="font-size: 12px; color: #00FFFF;">Best: <span id="highestLevels">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #FFD700;">
                        <div style="font-size: 14px; color: #FFD700;">Coins Collected</div>
                        <div id="totalCoins" style="font-size: 24px; font-weight: bold;">0</div>
                        <div style="font-size: 12px; color: #00FFFF;">Best: <span id="highestCoins">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #FFD700;">
                        <div style="font-size: 14px; color: #FFD700;">Crabs Defeated</div>
                        <div id="totalCrabs" style="font-size: 24px; font-weight: bold;">0</div>
                        <div style="font-size: 12px; color: #00FFFF;">Best: <span id="highestCrabs">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #FFD700;">
                        <div style="font-size: 14px; color: #FFD700;">ðŸ‘‘ Bosses Defeated</div>
                        <div id="totalBosses" style="font-size: 24px; font-weight: bold;">0</div>
                        <div style="font-size: 12px; color: #00FFFF;">Best: <span id="highestBosses">0</span></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00FFFF; margin-bottom: 10px;">ðŸŽ¯ Current Session</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #00FFFF;">
                        <div style="font-size: 14px; color: #00FFFF;">Session Score</div>
                        <div id="sessionScore" style="font-size: 24px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #00FFFF;">
                        <div style="font-size: 14px; color: #00FFFF;">Session Levels</div>
                        <div id="sessionLevels" style="font-size: 24px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #00FFFF;">
                        <div style="font-size: 14px; color: #00FFFF;">Session Coins</div>
                        <div id="sessionCoins" style="font-size: 24px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #00FFFF;">
                        <div style="font-size: 14px; color: #00FFFF;">Session Crabs</div>
                        <div id="sessionCrabs" style="font-size: 24px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #00FFFF;">
                        <div style="font-size: 14px; color: #00FFFF;">ðŸ‘‘ Session Bosses</div>
                        <div id="sessionBosses" style="font-size: 24px; font-weight: bold;">0</div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00FFFF; margin-bottom: 10px;">ðŸŽ¯ All-Time Collectibles</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div style="background: rgba(255,215,0,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #FFD700;">Fish</div>
                        <div id="totalFish" style="font-size: 18px; font-weight: bold;">0</div>
                        <div style="font-size: 10px; color: #00FFFF;">Best: <span id="highestFish">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #FFD700;">Health</div>
                        <div id="totalHealth" style="font-size: 18px; font-weight: bold;">0</div>
                        <div style="font-size: 10px; color: #00FFFF;">Best: <span id="highestHealth">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #FFD700;">Treasures</div>
                        <div id="totalTreasures" style="font-size: 18px; font-weight: bold;">0</div>
                        <div style="font-size: 10px; color: #00FFFF;">Best: <span id="highestTreasures">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #FFD700;">Mushrooms</div>
                        <div id="totalMushrooms" style="font-size: 18px; font-weight: bold;">0</div>
                        <div style="font-size: 10px; color: #00FFFF;">Best: <span id="highestMushrooms">0</span></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00FFFF; margin-bottom: 10px;">ðŸŽ¯ Session Collectibles</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div style="background: rgba(0,255,255,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #00FFFF;">Fish</div>
                        <div id="sessionFish" style="font-size: 18px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #00FFFF;">Health</div>
                        <div id="sessionHealth" style="font-size: 18px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #00FFFF;">Treasures</div>
                        <div id="sessionTreasures" style="font-size: 18px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #00FFFF;">Mushrooms</div>
                        <div id="sessionMushrooms" style="font-size: 18px; font-weight: bold;">0</div>
                    </div>
                </div>
            </div>
            
            <!-- Achievements/Badges Section -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00FFFF; margin-bottom: 10px;">ðŸ† Recent Achievements</h3>
                <div id="recentAchievements" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <!-- Achievements will be populated here -->
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="toggleProfile()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 8px 16px; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease;">View All Achievements</button>
                </div>
            </div>
            <div>
                <h3 style="color: #00FFFF; margin-bottom: 10px;">â±ï¸ Level Times</h3>
                <div id="levelTimes" style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 10px; padding: 10px;">
                    <div style="text-align: center; color: #888; font-style: italic;">No levels completed yet</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Instructions Panel -->
    <div id="instructionsPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.98)); color: #00FFFF; padding: clamp(20px, 3vw, 35px); border-radius: 25px; border: 3px solid #00FFFF; box-shadow: 0 20px 60px rgba(0,0,0,0.8), 0 0 40px rgba(0,255,255,0.5); backdrop-filter: blur(20px); z-index: 2000; max-width: 90vw; max-height: 85vh; overflow-y: auto; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid #00FFFF; padding-bottom: 15px;">
            <h2 style="margin: 0; font-size: clamp(20px, 4vw, 32px); text-shadow: 0 0 15px #00FFFF;">ðŸ“– How to Play</h2>
            <button onclick="toggleInstructions()" style="background: #FF4444; color: white; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold;">Ã—</button>
        </div>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
            <!-- Basic Controls -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">ðŸŽ® Basic Controls</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>Move:</strong> Arrow Keys or WASD</li>
                    <li><strong>Jump:</strong> Spacebar (double jump available!)</li>
                    <li><strong>Swim:</strong> Use arrow keys in water (1.5x faster than walking)</li>
                    <li><strong>Jetpack:</strong> Hold Shift while in air (if collected)</li>
                    <li><strong>Laser Charge:</strong> Hold left mouse button to charge (unlocks at level 10, 20, 30, etc.)</li>
                    <li><strong>Golden Chest:</strong> Press F key near chest with key</li>
                </ul>
            </div>
            
            <!-- Game Mechanics -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">ðŸŽ¯ Game Mechanics</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>Goal:</strong> Reach the flag at the end of each level</li>
                    <li><strong>Platforms:</strong> Jump on static, moving, and disappearing platforms</li>
                    <li><strong>Checkpoints:</strong> Touch to activate - respawn here if you fall</li>
                    <li><strong>Water Physics:</strong> Swim underwater, different movement mechanics</li>
                    <li><strong>Breakable Tiles:</strong> Stomp or shoot to reveal secrets</li>
                    <li><strong>Secret Rooms:</strong> Hidden areas with rare treasures</li>
                    <li><strong>Boss Battles:</strong> Every 5 levels - defeat Captain Claws!</li>
                </ul>
            </div>
            
            <!-- Collectibles & Points -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">ðŸ’Ž Collectibles & Points</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>ðŸŸ Fish:</strong> +100 points each</li>
                    <li><strong>ðŸ’° Coins:</strong> +1 coin, +25 points each (used in marketplace)</li>
                    <li><strong>â¤ï¸ Health:</strong> +25 points, 60% chance for +1 life</li>
                    <li><strong>ðŸ›¡ï¸ Armor:</strong> +50 points, +50 armor protection</li>
                    <li><strong>ðŸ›¡ï¸ Hidden Armor:</strong> +100 points, +75 armor protection</li>
                    <li><strong>ðŸ›¡ï¸ Boss Armor:</strong> +150 points, +100 armor protection</li>
                    <li><strong>ðŸ’Ž Treasures:</strong> +500-1000 points each</li>
                    <li><strong>ðŸ’Ž Rare Treasures:</strong> +1500-2500 points each, +25 coins, +1 life</li>
                    <li><strong>ðŸ„ Mushrooms:</strong> +1000 points, giant mode + invincibility</li>
                    <li><strong>ðŸ”‘ Keys:</strong> +200 points, opens golden chests</li>
                    <li><strong>ðŸš Jetpack:</strong> +200 points, enables flight</li>
                    <li><strong>ðŸ”« Laser:</strong> +200 points, shoot enemies from distance</li>
                    <li><strong>Level Complete:</strong> +500 points + fish bonus</li>
                    <li><strong>Every 10,000 points:</strong> +1 life</li>
                </ul>
            </div>
            
            <!-- Enemies -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">ðŸ¦€ Enemies & Combat</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>ðŸ¦€ Regular Crab:</strong> +200 points - patrols platforms, jump on head</li>
                    <li><strong>ðŸ¦… Eagle:</strong> +200 points - intelligent targeting, swoops and attacks</li>
                    <li><strong>ðŸ”´ ChargerCrab:</strong> +200 points - large red cube, charges after windup</li>
                    <li><strong>ðŸŠ Gator:</strong> +200 points - sits on water surface, chases player</li>
                    <li><strong>ðŸ”® Wizgator:</strong> +200 points - magical gator, shoots fireballs</li>
                    <li><strong>ðŸ¦ˆ Shark:</strong> +200 points - underwater hunter, swoops and attacks</li>
                    <li><strong>ðŸŸ Goldfish:</strong> +200 points - swims underwater, shoots lasers (level 5+)</li>
                    <li><strong>ðŸ‘‘ Captain Claws (Boss):</strong> +1000 points - every 5 levels</li>
                    <li><strong>Combat Methods:</strong> Jump on head, shoot with laser, or giant mode</li>
                    <li><strong>Invincibility:</strong> 2 seconds after taking damage</li>
                </ul>
            </div>
            
            <!-- Abilities & Power-ups -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">âš¡ Abilities & Power-ups</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>Double Jump:</strong> Jump again while in the air</li>
                    <li><strong>Armor System:</strong> Armor absorbs damage before health</li>
                    <li><strong>Giant Mode:</strong> Larger size, invincibility, enemy knockback</li>
                    <li><strong>Jetpack Flight:</strong> Hold Shift to fly through the air</li>
                    <li><strong>Laser Weapon:</strong> Shoot enemies from a distance</li>
                    <li><strong>Laser Charge System:</strong> Hold to charge for more powerful shots (unlocks every 10 levels)</li>
                    <li><strong>Water Swimming:</strong> 1.5x faster movement in water</li>
                    <li><strong>Screen Shake:</strong> Visual feedback for impacts</li>
                    <li><strong>Particle Effects:</strong> Visual effects for actions</li>
                </ul>
            </div>
            
            <!-- XP & Progression System -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">ðŸ“ˆ XP & Progression System</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>XP Progression:</strong> Level 1-10: 500 XP increase per level, Level 10+: 1000 XP per level</li>
                    <li><strong>Laser Charge Unlocks:</strong> Every 10 levels (10, 20, 30, 40, 50, 60)</li>
                    <li><strong>Laser Charge Upgrades:</strong> Each unlock increases max charge level</li>
                    <li><strong>Level Rewards:</strong> Unlock new abilities and cosmetics as you progress</li>
                    <li><strong>Persistent Progress:</strong> All unlocks and levels are saved automatically</li>
                </ul>
            </div>
            
            <!-- New Features -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">ðŸ†• New Features</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>ðŸ¦‰ AI Owl Guide:</strong> Provides tips and follows you</li>
                    <li><strong>ðŸª Marketplace:</strong> Spend coins on owl hats and otter skins</li>
                    <li><strong>ðŸ‘¤ Profile System:</strong> Track stats, achievements, and customization</li>
                    <li><strong>ðŸ† Global Leaderboard:</strong> Compete with players worldwide</li>
                    <li><strong>ðŸ“Š Detailed Statistics:</strong> Track all your progress</li>
                    <li><strong>ðŸ… Achievements:</strong> Unlock achievements for milestones</li>
                    <li><strong>ðŸŽ¨ Customization:</strong> Change profile picture and player name</li>
                    <li><strong>ðŸ’¾ Save Progress:</strong> All data persists across sessions</li>
                </ul>
            </div>
            
            <!-- UI Controls -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">ðŸŽ›ï¸ UI Controls</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>ðŸ  Home Screen:</strong> Main menu with all options</li>
                    <li><strong>ðŸ† Leaderboard:</strong> View global rankings and stats</li>
                    
                    <li><strong>ðŸª Marketplace:</strong> Buy hats and skins with coins</li>
                    <li><strong>ðŸ‘¤ Profile:</strong> View achievements and stats</li>
                    <li><strong>ðŸ“– Instructions:</strong> This help panel</li>
                    <li><strong>ðŸŽ¨ Asset Import:</strong> Import custom sprites</li>
                    <li><strong>ðŸ”„ Refresh:</strong> Update leaderboard data</li>
                </ul>
            </div>
            
            <!-- Tips & Strategies -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">ðŸ’¡ Tips & Strategies</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>Explore:</strong> Check high areas and underwater for secrets</li>
                    <li><strong>Break Tiles:</strong> Stomp or shoot breakable tiles for rewards</li>
                    <li><strong>Use Power-ups:</strong> Save mushrooms for difficult sections</li>
                    <li><strong>Collect Coins:</strong> Spend them in the marketplace for customization</li>
                    <li><strong>Check Leaderboard:</strong> See how you rank globally</li>
                    <li><strong>Complete Achievements:</strong> Unlock rewards and track progress</li>
                    <li><strong>Customize:</strong> Make your otter and owl unique</li>
                    
                </ul>
            </div>
        </div>
        </div>
    


    <!-- Marketplace Panel -->
    <div id="marketplacePanel" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.98)); backdrop-filter: blur(20px); z-index: 3500; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif; overflow: hidden;">
        
        <!-- Header Section -->
        <div style="position: relative; background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(26,26,46,0.9)); padding: 20px 30px; border-bottom: 2px solid rgba(0,255,255,0.3); box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
            <div style="display: flex; justify-content: space-between; align-items: center; max-width: 1400px; margin: 0 auto;">
                <div style="display: flex; align-items: center; gap: 20px;">
                    <h1 style="margin: 0; font-size: clamp(24px, 4vw, 36px); color: #00FFFF; text-shadow: 0 0 20px rgba(0,255,255,0.6); font-weight: 900;">ðŸ›’ Marketplace</h1>
                    <div style="display: flex; align-items: center; gap: 8px; background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 12px 20px; border-radius: 25px; border: 2px solid rgba(255,215,0,0.3); backdrop-filter: blur(10px);">
                        <span style="font-size: 20px;">ðŸª™</span>
                        <span id="marketplaceCoins" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 10px rgba(255,215,0,0.5);">0</span>
                        <span style="color: #FFD700; font-size: 14px; font-weight: 600;">Coins</span>
        </div>
        </div>
                <button onclick="toggleMarketplace()" style="background: linear-gradient(135deg, #FF4444, #CC0000); color: white; border: none; padding: 12px 20px; border-radius: 50%; cursor: pointer; font-size: 20px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(255,68,68,0.3); width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;">Ã—</button>
    </div>
        </div>
        
        <!-- Navigation Tabs -->
        <div style="background: rgba(0,0,0,0.6); padding: 15px 30px; border-bottom: 1px solid rgba(0,255,255,0.2);">
            <div style="display: flex; gap: 15px; max-width: 1400px; margin: 0 auto; justify-content: center;">
                <button id="hatsTabBtn" class="marketplace-tab-btn active" onclick="switchMarketplaceTab('hats')" style="background: linear-gradient(135deg, rgba(76,175,80,0.2), rgba(76,175,80,0.1)); color: #4CAF50; border: 2px solid rgba(76,175,80,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">ðŸ¦‰</div>
                    <div>Owl Hats</div>
                </button>
                <button id="skinsTabBtn" class="marketplace-tab-btn" onclick="switchMarketplaceTab('skins')" style="background: linear-gradient(135deg, rgba(33,150,243,0.2), rgba(33,150,243,0.1)); color: #2196F3; border: 2px solid rgba(33,150,243,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">ðŸ¦¦</div>
                    <div>Otter Skins</div>
                </button>
                <button id="abilitiesTabBtn" class="marketplace-tab-btn" onclick="switchMarketplaceTab('abilities')" style="background: linear-gradient(135deg, rgba(255,107,53,0.2), rgba(255,107,53,0.1)); color: #FF6B35; border: 2px solid rgba(255,107,53,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">âš¡</div>
                    <div>Abilities</div>
                </button>
        </div>
        </div>
        
        <!-- Content Area -->
        <div style="flex: 1; overflow-y: auto; padding: 30px; max-width: 1400px; margin: 0 auto;">
        <div id="hatsTab" class="marketplace-content">
                <div class="marketplace-grid" id="hatsGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 25px;">
                <!-- Owl hats will be populated here -->
            </div>
        </div>
        
        <div id="skinsTab" class="marketplace-content" style="display: none;">
                <div class="marketplace-grid" id="skinsGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 25px;">
                <!-- Otter skins will be populated here -->
            </div>
        </div>
        
        <div id="abilitiesTab" class="marketplace-content" style="display: none;">
                <div class="marketplace-grid" id="abilitiesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 25px;">
                <!-- Abilities will be populated here -->
                </div>
            </div>
        </div>
        
        <!-- Footer -->
        <div style="background: rgba(0,0,0,0.6); padding: 20px 30px; border-top: 1px solid rgba(0,255,255,0.2); text-align: center;">
            <button onclick="toggleMarketplace()" style="background: linear-gradient(135deg, #666666, #444444); color: white; border: none; padding: 15px 30px; border-radius: 25px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); border: 2px solid rgba(255,255,255,0.1);">â† Back to Menu</button>
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.98)); backdrop-filter: blur(20px); z-index: 4000; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif; overflow: hidden;">
        
        <!-- Header -->
        <div style="position: relative; background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(26,26,46,0.9)); padding: 20px 30px; border-bottom: 2px solid rgba(0,255,255,0.3); box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
            <div style="display: flex; justify-content: space-between; align-items: center; max-width: 1400px; margin: 0 auto;">
                <h1 style="margin: 0; font-size: clamp(24px, 4vw, 36px); color: #00FFFF; text-shadow: 0 0 20px rgba(0,255,255,0.6); font-weight: 900;">â¸ï¸ PAUSED</h1>
                <button onclick="togglePauseMenu()" style="background: linear-gradient(135deg, #FF4444, #CC0000); color: white; border: none; padding: 12px 20px; border-radius: 50%; cursor: pointer; font-size: 20px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(255,68,68,0.3); width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;">Ã—</button>
            </div>
        </div>
        
        <!-- Navigation Tabs -->
        <div style="background: rgba(0,0,0,0.6); padding: 15px 30px; border-bottom: 1px solid rgba(0,255,255,0.2);">
            <div style="display: flex; gap: 15px; max-width: 1400px; margin: 0 auto; justify-content: center; flex-wrap: wrap;">
                <button id="pauseInstructionsTabBtn" class="pause-tab-btn active" onclick="switchPauseTab('instructions')" style="background: linear-gradient(135deg, rgba(76,175,80,0.2), rgba(76,175,80,0.1)); color: #4CAF50; border: 2px solid rgba(76,175,80,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">ðŸ“–</div>
                    <div>Instructions</div>
                </button>
                <button id="pauseSettingsTabBtn" class="pause-tab-btn" onclick="switchPauseTab('settings')" style="background: linear-gradient(135deg, rgba(33,150,243,0.2), rgba(33,150,243,0.1)); color: #2196F3; border: 2px solid rgba(33,150,243,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">âš™ï¸</div>
                    <div>Settings</div>
                </button>
                <button id="pauseCustomizationTabBtn" class="pause-tab-btn" onclick="switchPauseTab('customization')" style="background: linear-gradient(135deg, rgba(255,107,53,0.2), rgba(255,107,53,0.1)); color: #FF6B35; border: 2px solid rgba(255,107,53,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">ðŸŽ¨</div>
                    <div>Customization</div>
                </button>
                <button id="pauseActionsTabBtn" class="pause-tab-btn" onclick="switchPauseTab('actions')" style="background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,215,0,0.1)); color: #FFD700; border: 2px solid rgba(255,215,0,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">ðŸ </div>
                    <div>Actions</div>
                </button>
            </div>
        </div>
        
        <!-- Content Area -->
        <div style="flex: 1; overflow-y: auto; padding: 30px; max-width: 1400px; margin: 0 auto;">
            
            <!-- Instructions Tab -->
            <div id="pauseInstructionsTab" class="pause-content">
                <div style="background: rgba(76,175,80,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(76,175,80,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #4CAF50; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(76,175,80,0.5);">ðŸŽ® Basic Controls</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #4CAF50; font-size: 18px;">Movement</h4>
                            <ul style="color: #FFD700; line-height: 1.6; margin: 0; padding-left: 20px;">
                                <li><strong>Move:</strong> Arrow keys or WASD</li>
                                <li><strong>Jump:</strong> Spacebar (double jump available!)</li>
                                <li><strong>Swim:</strong> Use arrow keys in water (1.5x faster than walking)</li>
                                <li><strong>Jetpack:</strong> Hold Shift while in air (if collected)</li>
                            </ul>
                        </div>
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #4CAF50; font-size: 18px;">Combat & Abilities</h4>
                            <ul style="color: #FFD700; line-height: 1.6; margin: 0; padding-left: 20px;">
                                <li><strong>Laser Charge:</strong> Hold left mouse button to charge (unlocks at level 10, 20, 30, etc.)</li>
                                <li><strong>Fireball:</strong> Right-click to shoot (if collected)</li>
                                <li><strong>Golden Chest:</strong> Press F key near chest with key</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(33,150,243,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(33,150,243,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #2196F3; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(33,150,243,0.5);">âš¡ Abilities & Power-ups</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div style="background: rgba(33,150,243,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(33,150,243,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #2196F3; font-size: 18px;">Power-ups</h4>
                            <ul style="color: #FFD700; line-height: 1.6; margin: 0; padding-left: 20px;">
                                <li><strong>Mushroom:</strong> Temporary invincibility and size boost</li>
                                <li><strong>Giant Mode:</strong> Larger size, invincibility, enemy knockback</li>
                                <li><strong>Jetpack Flight:</strong> Hold Shift to fly through the air</li>
                                <li><strong>Laser Weapon:</strong> Shoot enemies from a distance</li>
                                <li><strong>Laser Charge System:</strong> Hold to charge for more powerful shots (unlocks every 10 levels)</li>
                                <li><strong>Water Swimming:</strong> 1.5x faster movement in water</li>
                                <li><strong>Screen Shake:</strong> Visual feedback for impacts</li>
                                <li><strong>Particle Effects:</strong> Visual effects for actions</li>
                            </ul>
                        </div>
                        <div style="background: rgba(33,150,243,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(33,150,243,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #2196F3; font-size: 18px;">Collectibles</h4>
                            <ul style="color: #FFD700; line-height: 1.6; margin: 0; padding-left: 20px;">
                                <li><strong>ðŸª™ Coins:</strong> Collect for marketplace purchases</li>
                                <li><strong>ðŸ—ï¸ Keys:</strong> Open golden chests for rewards</li>
                                <li><strong>ðŸ“¦ Chests:</strong> Regular chests with coins and items</li>
                                <li><strong>ðŸ’Ž Golden Chests:</strong> Special chests requiring keys</li>
                                <li><strong>â¤ï¸ Hearts:</strong> Restore health</li>
                                <li><strong>ðŸ›¡ï¸ Armor:</strong> Provide damage protection</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(0,255,255,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(0,255,255,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #00FFFF; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(0,255,255,0.5);">ðŸ“ˆ XP & Progression System</h3>
                    <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(0,255,255,0.2);">
                        <ul style="color: #FFD700; line-height: 1.6; margin: 0; padding-left: 20px;">
                            <li><strong>XP Progression:</strong> Level 1-10: 500 XP increase per level, Level 10+: 1000 XP per level</li>
                            <li><strong>Laser Charge Unlocks:</strong> Every 10 levels (10, 20, 30, 40, 50, 60)</li>
                            <li><strong>Laser Charge Upgrades:</strong> Each unlock increases max charge level</li>
                            <li><strong>Level Rewards:</strong> Unlock new abilities and cosmetics as you progress</li>
                            <li><strong>Persistent Progress:</strong> All unlocks and levels are saved automatically</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- Settings Tab -->
            <div id="pauseSettingsTab" class="pause-content" style="display: none;">
                <div style="background: rgba(33,150,243,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(33,150,243,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #2196F3; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(33,150,243,0.5);">ðŸ¤– AI Owl Bot Settings</h3>
                    <div style="display: flex; align-items: center; justify-content: center; gap: 20px; padding: 20px; background: rgba(33,150,243,0.1); border-radius: 15px; border: 1px solid rgba(33,150,243,0.2);">
                        <span style="color: #FFD700; font-size: 18px; font-weight: bold;">AI Owl Bot:</span>
                        <label class="toggle-switch" style="position: relative; display: inline-block; width: 60px; height: 34px;">
                            <input type="checkbox" id="aiOwlToggle" style="opacity: 0; width: 0; height: 0;">
                            <span class="toggle-slider" style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);"></span>
                        </label>
                        <span id="aiOwlStatus" style="color: #4CAF50; font-size: 16px; font-weight: bold;">ON</span>
                    </div>
                </div>
                
                <div style="background: rgba(255,107,53,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(255,107,53,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #FF6B35; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(255,107,53,0.5);">ðŸŽ® Game Settings</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div style="background: rgba(255,107,53,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,107,53,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FF6B35; font-size: 18px;">Visual Settings</h4>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Screen Shake:</label>
                                <input type="range" id="screenShakeSlider" min="0" max="100" value="50" style="width: 100%; height: 8px; border-radius: 5px; background: rgba(255,107,53,0.3); outline: none;">
                                <div style="text-align: center; color: #FFD700; font-size: 14px; margin-top: 5px;">50%</div>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Particle Effects:</label>
                                <input type="range" id="particleEffectsSlider" min="0" max="100" value="75" style="width: 100%; height: 8px; border-radius: 5px; background: rgba(255,107,53,0.3); outline: none;">
                                <div style="text-align: center; color: #FFD700; font-size: 14px; margin-top: 5px;">75%</div>
                            </div>
                        </div>
                        <div style="background: rgba(255,107,53,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,107,53,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FF6B35; font-size: 18px;">Audio Settings</h4>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Master Volume:</label>
                                <input type="range" id="masterVolumeSlider" min="0" max="100" value="80" style="width: 100%; height: 8px; border-radius: 5px; background: rgba(255,107,53,0.3); outline: none;">
                                <div style="text-align: center; color: #FFD700; font-size: 14px; margin-top: 5px;">80%</div>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">SFX Volume:</label>
                                <input type="range" id="sfxVolumeSlider" min="0" max="100" value="90" style="width: 100%; height: 8px; border-radius: 5px; background: rgba(255,107,53,0.3); outline: none;">
                                <div style="text-align: center; color: #FFD700; font-size: 14px; margin-top: 5px;">90%</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Customization Tab -->
            <div id="pauseCustomizationTab" class="pause-content" style="display: none;">
                <div style="background: rgba(255,107,53,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(255,107,53,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #FF6B35; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(255,107,53,0.5);">ðŸŽ¨ Character Customization</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div style="background: rgba(255,107,53,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,107,53,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FF6B35; font-size: 18px;">Otter Skins</h4>
                            <div id="pauseOtterSkins" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 10px;">
                                <!-- Otter skins will be populated here -->
                            </div>
                        </div>
                        <div style="background: rgba(255,107,53,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,107,53,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FF6B35; font-size: 18px;">Owl Hats</h4>
                            <div id="pauseOwlHats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 10px;">
                                <!-- Owl hats will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(255,215,0,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(255,215,0,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(255,215,0,0.5);">ðŸŽ¨ Asset Importer</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div style="background: rgba(255,215,0,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,215,0,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FFD700; font-size: 18px;">Character Assets</h4>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Otter Character:</label>
                                <input type="file" id="otterCharacterInput" accept="image/*" style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importOtterCharacter()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Otter</button>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Owl Companion:</label>
                                <input type="file" id="owlCompanionInput" accept="image/*" style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importOwlCompanion()" style="background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Owl</button>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Enemy Sprites:</label>
                                <input type="file" id="enemySpritesInput" accept="image/*" multiple style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importEnemySprites()" style="background: linear-gradient(135deg, #FF6B35, #F7931E); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Enemies</button>
                            </div>
                        </div>
                        <div style="background: rgba(255,215,0,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,215,0,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FFD700; font-size: 18px;">Environment Assets</h4>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Background Images:</label>
                                <input type="file" id="backgroundInput" accept="image/*" multiple style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importBackgrounds()" style="background: linear-gradient(135deg, #9C27B0, #7B1FA2); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Backgrounds</button>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Platform Textures:</label>
                                <input type="file" id="platformInput" accept="image/*" multiple style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importPlatforms()" style="background: linear-gradient(135deg, #795548, #5D4037); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Platforms</button>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Collectibles:</label>
                                <input type="file" id="collectiblesInput" accept="image/*" multiple style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importCollectibles()" style="background: linear-gradient(135deg, #FFD700, #FFA000); color: #000; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Collectibles</button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(0,255,255,0.3); margin-top: 20px;">
                        <h4 style="margin: 0 0 15px 0; color: #00FFFF; font-size: 18px; text-align: center;">Asset Management</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <button onclick="previewImportedAssets()" style="background: linear-gradient(135deg, #00BCD4, #0097A7); color: white; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease;">
                                ðŸ‘ï¸ Preview Assets
                            </button>
                            <button onclick="exportAssetPack()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease;">
                                ðŸ“¦ Export Pack
                            </button>
                            <button onclick="resetToDefaults()" style="background: linear-gradient(135deg, #FF4444, #CC0000); color: white; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease;">
                                ðŸ”„ Reset Defaults
                            </button>
                            <button onclick="clearAllAssets()" style="background: linear-gradient(135deg, #9E9E9E, #757575); color: white; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease;">
                                ðŸ—‘ï¸ Clear All
                            </button>
                        </div>
                    </div>
                    
                    <div id="assetPreviewArea" style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px; border: 2px solid rgba(255,215,0,0.2); margin-top: 20px; display: none;">
                        <h4 style="margin: 0 0 15px 0; color: #FFD700; font-size: 18px; text-align: center;">Asset Preview</h4>
                        <div id="assetPreviewGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; max-height: 300px; overflow-y: auto;">
                            <!-- Asset previews will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Actions Tab -->
            <div id="pauseActionsTab" class="pause-content" style="display: none;">
                <div style="background: rgba(255,215,0,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(255,215,0,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(255,215,0,0.5); font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">ðŸ  Game Actions</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                        <button onclick="resumeGame()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 20px; border-radius: 15px; cursor: pointer; font-size: 18px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; align-items: center; gap: 10px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                            <div style="font-size: 32px;">â–¶ï¸</div>
                            <div>Resume Game</div>
                        </button>
                        <button onclick="restartLevel()" style="background: linear-gradient(135deg, #FF6B35, #F7931E); color: white; border: none; padding: 20px; border-radius: 15px; cursor: pointer; font-size: 18px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; align-items: center; gap: 10px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                            <div style="font-size: 32px;">ðŸ”„</div>
                            <div>Restart Level</div>
                        </button>
                        <button onclick="returnToHome()" style="background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; padding: 20px; border-radius: 15px; cursor: pointer; font-size: 18px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; align-items: center; gap: 10px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                            <div style="font-size: 32px;">ðŸ </div>
                            <div>Return Home</div>
                        </button>
                        <button onclick="saveAndQuit()" style="background: linear-gradient(135deg, #FF4444, #CC0000); color: white; border: none; padding: 20px; border-radius: 15px; cursor: pointer; font-size: 18px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; align-items: center; gap: 10px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                            <div style="font-size: 32px;">ðŸ’¾</div>
                            <div>Save & Quit</div>
                        </button>
                        <button onclick="resetAllGameData(); alert('All game data has been reset! The game will now start fresh.'); location.reload();" style="background: linear-gradient(135deg, #FF8800, #FF6600); color: white; border: none; padding: 20px; border-radius: 15px; cursor: pointer; font-size: 18px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; align-items: center; gap: 10px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                            <div style="font-size: 32px;">ðŸ”„</div>
                            <div>Reset All Data</div>
                        </button>
                    </div>
                </div>
                
                <div style="background: rgba(76,175,80,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(76,175,80,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #4CAF50; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(76,175,80,0.5);">ðŸ“Š Current Session</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2); text-align: center;">
                            <div style="font-size: 24px; margin-bottom: 10px;">ðŸŽ¯</div>
                            <div style="color: #FFD700; font-size: 18px; font-weight: bold;">Score</div>
                            <div id="pauseScore" style="color: #4CAF50; font-size: 24px; font-weight: bold;">0</div>
                        </div>
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2); text-align: center;">
                            <div style="font-size: 24px; margin-bottom: 10px;">ðŸª™</div>
                            <div style="color: #FFD700; font-size: 18px; font-weight: bold;">Coins</div>
                            <div id="pauseCoins" style="color: #4CAF50; font-size: 24px; font-weight: bold;">0</div>
                        </div>
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2); text-align: center;">
                            <div style="font-size: 24px; margin-bottom: 10px;">â¤ï¸</div>
                            <div style="color: #FFD700; font-size: 18px; font-weight: bold;">Health</div>
                            <div id="pauseHealth" style="color: #4CAF50; font-size: 24px; font-weight: bold;">100</div>
                        </div>
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2); text-align: center;">
                            <div style="font-size: 24px; margin-bottom: 10px;">ðŸ“ˆ</div>
                            <div style="color: #FFD700; font-size: 18px; font-weight: bold;">Level</div>
                            <div id="pauseLevel" style="color: #4CAF50; font-size: 24px; font-weight: bold;">1</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Panel -->
    <div id="profilePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.98)); color: #00FFFF; padding: clamp(20px, 3vw, 35px); border-radius: 25px; border: 3px solid #00FFFF; box-shadow: 0 20px 60px rgba(0,0,0,0.8), 0 0 40px rgba(0,255,255,0.5); backdrop-filter: blur(20px); z-index: 3500; max-width: 90vw; max-height: 85vh; overflow-y: auto; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid #00FFFF; padding-bottom: 15px;">
            <h2 style="margin: 0; font-size: clamp(20px, 4vw, 32px); text-shadow: 0 0 15px #00FFFF;">ðŸ‘¤ Player Profile</h2>
            <button onclick="toggleProfile()" style="background: #FF4444; color: white; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold;">Ã—</button>
        </div>
        
        <!-- Profile Header -->
        <div style="display: flex; align-items: center; margin-bottom: 25px; padding: 20px; background: rgba(255,215,0,0.1); border-radius: 15px; border: 2px solid #FFD700;">
            <div style="margin-right: 20px; position: relative;">
                <div style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid #FFD700; box-shadow: 0 0 20px rgba(255,215,0,0.5); background: rgba(0,0,0,0.1); cursor: pointer; display: flex; align-items: center; justify-content: center; overflow: hidden;" onclick="editProfilePicture()">
                    <img id="profileOtterImage" src="public/oggg.png" alt="Player Otter" style="width: 100%; height: 100%; object-fit: cover; object-position: center;">
                </div>
                <div class="profile-edit-btn" style="position: absolute; bottom: -5px; right: -5px; background: #4CAF50; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; border: 2px solid #FFD700;" onclick="editProfilePicture()" title="Edit Profile Picture">âœï¸</div>
            </div>
            <div style="flex: 1;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <h3 id="profilePlayerName" style="margin: 0; color: #FFD700; font-size: 24px; cursor: pointer;" onclick="editPlayerName()">Otter Player</h3>
                    <button class="profile-edit-btn" onclick="editPlayerName()" style="background: none; border: none; color: #00FFFF; font-size: 16px; cursor: pointer; padding: 2px 6px; border-radius: 5px; transition: all 0.3s ease;" title="Edit Name">âœï¸</button>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 20px;">ðŸª™</span>
                    <span id="profileCoins" style="font-size: 18px; font-weight: bold; color: #FFD700;">0</span>
                    <span style="margin-left: 5px;">Coins</span>
                </div>
            </div>
        </div>
        
        <!-- Profile Tabs -->
        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
            <button id="statsTabBtn" class="tab-btn active" onclick="switchProfileTab('stats')" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #FF6B35, #F7931E); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">ðŸ“Š Stats</button>
            <button id="achievementsTabBtn" class="tab-btn" onclick="switchProfileTab('achievements')" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #FFD700, #FFA500); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">ðŸ† Achievements</button>
            <button id="customizationTabBtn" class="tab-btn" onclick="switchProfileTab('customization')" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">ðŸŽ¨ Customization</button>
            <!-- Wallet Tab Button - REMOVED FOR PERFORMANCE -->
            <!-- Button removed - wallet system disabled -->
        </div>
        
        <!-- Stats Tab -->
        <div id="statsTab" class="profile-content">
            <!-- Main Stats Grid -->
            <!-- Main Stats Section -->
            <div style="background: rgba(255,107,53,0.05); padding: 20px; border-radius: 20px; border: 2px solid #FF6B35; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #FF6B35; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(255,107,53,0.5);">ðŸ† Main Statistics</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 24px; margin-bottom: 8px;">ðŸŽ¯</div>
                        <div style="font-size: 12px; color: #FF6B35; margin-bottom: 5px; font-weight: bold;">TOTAL SCORE</div>
                        <div id="profileTotalScore" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 24px; margin-bottom: 8px;">ðŸ†</div>
                        <div style="font-size: 12px; color: #FF6B35; margin-bottom: 5px; font-weight: bold;">LEVELS COMPLETED</div>
                        <div id="profileLevelsCompleted" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 24px; margin-bottom: 8px;">ðŸª™</div>
                        <div style="font-size: 12px; color: #FF6B35; margin-bottom: 5px; font-weight: bold;">TOTAL COINS</div>
                        <div id="profileTotalCoins" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 24px; margin-bottom: 8px;">âš”ï¸</div>
                        <div style="font-size: 12px; color: #FF6B35; margin-bottom: 5px; font-weight: bold;">ENEMIES DEFEATED</div>
                        <div id="profileEnemiesDefeated" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 24px; margin-bottom: 8px;">ðŸ‘‘</div>
                        <div style="font-size: 12px; color: #FF6B35; margin-bottom: 5px; font-weight: bold;">BOSSES DEFEATED</div>
                        <div id="profileBossesDefeated" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                </div>
            </div>
            
            <!-- XP Progress Section -->
            <div style="background: rgba(0,255,255,0.05); padding: 20px; border-radius: 20px; border: 2px solid #00FFFF; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #00FFFF; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(0,255,255,0.5);">ðŸ“ˆ Experience Progress</h3>
                <div style="background: linear-gradient(135deg, rgba(0,255,255,0.15), rgba(0,255,255,0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(0,255,255,0.3); text-align: center;">
                    <div style="font-size: 24px; margin-bottom: 8px;">â­</div>
                    <div style="font-size: 14px; color: #00FFFF; margin-bottom: 10px; font-weight: bold;">CURRENT LEVEL</div>
                    <div id="profilePlayerLevel" style="font-size: 28px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5); margin-bottom: 15px;">1</div>
                    
                    <!-- XP Bar Container -->
                    <div style="margin-bottom: 15px;">
                        <div style="font-size: 12px; color: #00FFFF; margin-bottom: 8px; font-weight: bold;">EXPERIENCE PROGRESS</div>
                        <div class="profile-xp-bar-container" style="width: 100%; height: 25px; background: rgba(0,0,0,0.3); border-radius: 15px; border: 2px solid rgba(0,255,255,0.5); overflow: hidden; position: relative; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);">
                            <div class="profile-xp-bar-fill" id="profileXpBarFill" style="height: 100%; background: linear-gradient(90deg, #00FFFF, #0080FF, #00FFFF); border-radius: 13px; transition: width 0.5s ease-in-out; position: relative; min-width: 0%;">
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent); animation: profileXpShine 2s ease-in-out infinite;"></div>
                            </div>
                        </div>
                        <div id="profileXpText" style="font-size: 14px; color: #00FFFF; margin-top: 8px; font-weight: bold;">0 / 1,000 XP</div>
                    </div>
                    
                    <!-- XP Stats -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-top: 20px;">
                        <div style="background: rgba(0,255,255,0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(0,255,255,0.2);">
                            <div style="font-size: 12px; color: #00FFFF; margin-bottom: 5px; font-weight: bold;">TOTAL XP</div>
                            <div id="profileTotalXP" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                        </div>
                        <div style="background: rgba(0,255,255,0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(0,255,255,0.2);">
                            <div style="font-size: 12px; color: #00FFFF; margin-bottom: 5px; font-weight: bold;">XP TO NEXT</div>
                            <div id="profileXpToNext" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">1,000</div>
                        </div>
                        <div style="background: rgba(0,255,255,0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(0,255,255,0.2);">
                            <div style="font-size: 12px; color: #00FFFF; margin-bottom: 5px; font-weight: bold;">PROGRESS %</div>
                            <div id="profileXpProgress" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0%</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Detailed Stats Section -->
            <div style="background: rgba(255,215,0,0.05); padding: 20px; border-radius: 20px; border: 2px solid #FFD700; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(255,215,0,0.5);">ðŸ“Š Detailed Statistics</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">ðŸŽ®</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">GAMES PLAYED</div>
                        <div id="profileGamesPlayed" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">â±ï¸</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">TOTAL PLAY TIME</div>
                        <div id="profilePlayTime" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0 min</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">ðŸ…</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">BEST SCORE</div>
                        <div id="profileBestScore" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">â­</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">CURRENT LEVEL</div>
                        <div id="profileCurrentLevel" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">1</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">ðŸ’Ž</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">TREASURES FOUND</div>
                        <div id="profileTreasuresFound" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">ðŸ”‘</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">KEYS COLLECTED</div>
                        <div id="profileKeysCollected" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">â¤ï¸</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">HEALTH PICKUPS</div>
                        <div id="profileHealthPickups" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">ðŸ„</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">MUSHROOMS EATEN</div>
                        <div id="profileMushroomsEaten" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                </div>
            </div>
            
            <!-- Enemy Defeat Breakdown -->
            <div style="background: rgba(255,0,0,0.05); padding: 20px; border-radius: 20px; border: 2px solid #FF4444; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #FF4444; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(255,68,68,0.5);">âš”ï¸ Enemy Defeat Breakdown</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, rgba(255,68,68,0.15), rgba(255,68,68,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,68,68,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">ðŸ¦€</div>
                        <div style="font-size: 11px; color: #FF4444; margin-bottom: 5px; font-weight: bold;">CRABS DEFEATED</div>
                        <div id="profileCrabsDefeated" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,68,68,0.15), rgba(255,68,68,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,68,68,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">ðŸ¦…</div>
                        <div style="font-size: 11px; color: #FF4444; margin-bottom: 5px; font-weight: bold;">EAGLES DEFEATED</div>
                        <div id="profileEaglesDefeated" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,68,68,0.15), rgba(255,68,68,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,68,68,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">ðŸŠ</div>
                        <div style="font-size: 11px; color: #FF4444; margin-bottom: 5px; font-weight: bold;">GATORS DEFEATED</div>
                        <div id="profileGatorsDefeated" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,68,68,0.15), rgba(255,68,68,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,68,68,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">ðŸ¦ˆ</div>
                        <div style="font-size: 11px; color: #FF4444; margin-bottom: 5px; font-weight: bold;">SHARKS DEFEATED</div>
                        <div id="profileSharksDefeated" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                </div>
            </div>
            
            <!-- Recent Achievements Section -->
            <div style="background: rgba(0,255,255,0.05); padding: 20px; border-radius: 20px; border: 2px solid #00FFFF; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #00FFFF; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(0,255,255,0.5);">ðŸŽ¯ Recent Achievements</h3>
                <div id="profileRecentAchievements" style="font-size: 14px; color: #FFD700; background: rgba(0,255,255,0.1); padding: 15px; border-radius: 12px; border: 1px solid rgba(0,255,255,0.3);">
                    <div style="text-align: center; font-style: italic;">ðŸŽ‰ Welcome to Otter Bros! Complete achievements to see them here!</div>
                </div>
            </div>
        </div>
        
        <!-- Achievements Tab -->
        <div id="achievementsTab" class="profile-content" style="display: none;">
            <div style="background: rgba(76,175,80,0.05); padding: 20px; border-radius: 20px; border: 2px solid #4CAF50; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #4CAF50; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(76,175,80,0.5);">ðŸ† Achievement Collection</h3>
                <div style="text-align: center; margin-bottom: 20px; color: #00FFFF; font-size: 14px;">
                    Complete challenges to unlock achievements and earn XP rewards!
                </div>
                <div id="profileAchievementsList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">
                    <!-- Achievements will be populated here -->
                </div>
            </div>
        </div>
        
        <!-- Customization Tab -->
        <div id="customizationTab" class="profile-content" style="display: none;">
            <!-- Currently Equipped Section -->
            <div style="margin-bottom: 30px;">
                <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 20px;">ðŸŽ¯ Currently Equipped</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div style="background: rgba(76,175,80,0.1); padding: 15px; border-radius: 15px; border: 2px solid #4CAF50;">
                        <h4 style="margin: 0 0 10px 0; color: #00FFFF; text-align: center;">ðŸ¦¦ Current Skin</h4>
                        <div id="profileCurrentSkin" style="display: flex; align-items: center; gap: 15px;">
                            <img id="profileSkinImage" src="public/oggg.png" alt="Current Skin" style="width: 60px; height: 60px; border-radius: 10px; object-fit: contain; background: rgba(0,0,0,0.1);">
                            <div>
                                <div id="profileSkinName" style="font-size: 16px; font-weight: bold; color: #4CAF50;">Classic Otter</div>
                                <div id="profileSkinDescription" style="font-size: 12px; color: #00FFFF;">The original look</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(76,175,80,0.1); padding: 15px; border-radius: 15px; border: 2px solid #4CAF50;">
                        <h4 style="margin: 0 0 10px 0; color: #00FFFF; text-align: center;">ðŸ¦‰ Current Hat</h4>
                        <div id="profileCurrentHat" style="display: flex; align-items: center; gap: 15px;">
                            <img id="profileHatImage" src="public/owl.png" alt="Current Hat" style="width: 60px; height: 60px; border-radius: 10px; object-fit: contain; background: rgba(0,0,0,0.1);">
                            <div>
                                <div id="profileHatName" style="font-size: 16px; font-weight: bold; color: #4CAF50;">No Hat</div>
                                <div id="profileHatDescription" style="font-size: 12px; color: #00FFFF;">Classic owl look</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Current Abilities Section -->
                <div style="margin-top: 20px;">
                    <h4 style="margin: 0 0 10px 0; color: #FF6B35; text-align: center;">âš¡ Current Abilities</h4>
                    <div id="profileCurrentAbilities" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Currently equipped abilities will be populated here -->
                    </div>
                </div>
            </div>
            
            <!-- Inventory Section -->
            <div style="margin-bottom: 30px;">
                <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 20px;">ðŸŽ’ Your Inventory</h3>
                
                <!-- Otter Skins Inventory -->
                <div style="margin-bottom: 25px;">
                    <h4 style="margin: 0 0 15px 0; color: #00FFFF; border-bottom: 2px solid #00FFFF; padding-bottom: 5px;">ðŸ¦¦ Otter Skins</h4>
                    <div id="profileSkinsInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Skins will be populated here -->
                    </div>
                </div>
                
                <!-- Owl Hats Inventory -->
                <div>
                    <h4 style="margin: 0 0 15px 0; color: #00FFFF; border-bottom: 2px solid #00FFFF; padding-bottom: 5px;">ðŸ¦‰ Owl Hats</h4>
                    <div id="profileHatsInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Hats will be populated here -->
                    </div>
                </div>
                
                            <!-- Abilities Inventory -->
            <div>
                <h4 style="margin: 0 0 15px 0; color: #00FFFF; border-bottom: 2px solid #00FFFF; padding-bottom: 5px;">âš¡ Abilities</h4>
                <div id="profileAbilitiesInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                    <!-- Abilities will be populated here -->
                </div>
            </div>
            
            <!-- Laser Charging Level -->
            <div style="margin-top: 20px;">
                <h4 style="margin: 0 0 15px 0; color: #FF0000; border-bottom: 2px solid #FF0000; padding-bottom: 5px;">ðŸ”« Laser Charging</h4>
                <div style="background: rgba(255,0,0,0.1); border: 2px solid #FF0000; border-radius: 15px; padding: 15px; text-align: center;">
                    <div style="font-size: 24px; margin-bottom: 10px;">âš¡</div>
                    <div style="font-size: 18px; font-weight: bold; color: #FF0000; margin-bottom: 5px;">Level <span id="profileLaserLevel">1</span></div>
                    <div style="font-size: 14px; color: #00FFFF; margin-bottom: 10px;">Max Charge: <span id="profileMaxCharge">5</span></div>
                    <div style="font-size: 12px; color: #888;">Upgrade every 10 levels</div>
                    </div>
                </div>
            </div>
            
            <!-- Quick Equip Section -->
            <div style="background: rgba(255,215,0,0.1); padding: 20px; border-radius: 15px; border: 2px solid #FFD700;">
                <h4 style="margin: 0 0 15px 0; color: #FFD700; text-align: center;">âš¡ Quick Equip</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <label style="color: #FFD700; font-size: 14px; margin-bottom: 5px; display: block;">Equip Skin:</label>
                        <select id="quickEquipSkin" onchange="quickEquipSkin(this.value)" style="width: 100%; padding: 8px; border-radius: 8px; border: 2px solid #FFD700; background: rgba(0,0,0,0.8); color: #FFD700;">
                            <option value="">Select a skin...</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #FFD700; font-size: 14px; margin-bottom: 5px; display: block;">Equip Hat:</label>
                        <select id="quickEquipHat" onchange="quickEquipHat(this.value)" style="width: 100%; padding: 8px; border-radius: 8px; border: 2px solid #FFD700; background: rgba(0,0,0,0.8); color: #FFD700;">
                            <option value="">Select a hat...</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Wallet Tab completely removed -->
        
        <div style="text-align: center; margin-top: 20px;">
            <button onclick="toggleProfile()" style="background: linear-gradient(135deg, #FF4444, #CC0000); color: white; border: none; padding: 12px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">Back to Menu</button>
        </div>
    </div>
    
    <!-- Asset Import Panel -->
    <div id="assetPanel" style="display: none;">
        <div class="asset-header">
            <h3>ðŸŽ¨ Asset Importer</h3>
            <button onclick="toggleAssetPanel()" class="close-btn">Ã—</button>
        </div>
        <div class="asset-content">
            <div class="asset-section" style="background: rgba(0,255,0,0.1); border-left-color: #00FF00;">
                <h4 style="color: #00FF00;">ðŸ’¡ Tips for Best Results</h4>
                <ul style="color: #FFD700; font-size: 12px; margin: 5px 0; padding-left: 20px;">
                    <li>Use PNG images with transparent backgrounds for best results</li>
                    <li>Keep sprites around 100x100 pixels for characters and collectibles</li>
                    <li>Background images will tile/repeat automatically</li>
                    <li>Platform tiles should be seamless for smooth appearance</li>
                    <li>Use the Export/Import buttons to save your custom asset configurations</li>
                </ul>
            </div>
            <div class="asset-section">
                <h4>ðŸ¦¦ Player Character (Otterful Otter Bros)</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the otter character sprite (recommended: 100x100px PNG with transparent background)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="playerSprite" accept="image/*" onchange="loadAsset('player', this)">
                    <button onclick="clearAsset('player')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="playerPreview"></div>
            </div>
            <div class="asset-section">
                <h4>ðŸ¦€ Enemy Sprites (Crabs)</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the crab enemy sprites (recommended: 96x80px PNG with transparent background)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="enemySprite" accept="image/*" onchange="loadAsset('enemy', this)">
                    <button onclick="clearAsset('enemy')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="enemyPreview"></div>
            </div>
            <div class="asset-section">
                <h4>ðŸ”® Wizgator Sprite</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the wizgator sprite (recommended: 120x80px PNG with transparent background)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="wizgatorSprite" accept="image/*" onchange="loadAsset('wizgator', this)">
                    <button onclick="clearAsset('wizgator')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="wizgatorPreview"></div>
            </div>
            <div class="asset-section">
                <h4>ðŸ’° Collectibles</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace collectible item sprites (recommended: 38x38px PNG with transparent background)</p>
                <div style="margin: 10px 0;">
                    <label style="color: #FFD700; display: block; margin: 5px 0;">ðŸª™ Coins (38x38px):</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="coinSprite" accept="image/*" onchange="loadAsset('coin', this)">
                        <button onclick="clearAsset('coin')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                    </div>
                </div>
                <div style="margin: 10px 0;">
                    <label style="color: #FFD700; display: block; margin: 5px 0;">â¤ï¸ Health Hearts (38x38px):</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="healthSprite" accept="image/*" onchange="loadAsset('health', this)">
                        <button onclick="clearAsset('health')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                    </div>
                </div>
                <div style="margin: 10px 0;">
                    <label style="color: #FFD700; display: block; margin: 5px 0;">ðŸ’Ž Treasures (38x38px):</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="treasureSprite" accept="image/*" onchange="loadAsset('treasure', this)">
                        <button onclick="clearAsset('treasure')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                    </div>
                </div>
                <div style="margin: 10px 0;">
                    <label style="color: #FFD700; display: block; margin: 5px 0;">ðŸŸ Fish (38x38px):</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="fishSprite" accept="image/*" onchange="loadAsset('fish', this)">
                        <button onclick="clearAsset('fish')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                    </div>
                </div>
                <div class="preview" id="collectiblesPreview"></div>
            </div>
            <div class="asset-section">
                <h4>ðŸŒ… Background Image</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the sky background (will tile/repeat automatically, recommended: 512x512px PNG)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="backgroundSprite" accept="image/*" onchange="loadAsset('background', this)">
                    <button onclick="clearAsset('background')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="backgroundPreview"></div>
            </div>
            <div class="asset-section">
                <h4>ðŸ”ï¸ Platform Tiles</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the platform/ground tiles (recommended: 77x48px PNG, will tile seamlessly)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="platformSprite" accept="image/*" onchange="loadAsset('platform', this)">
                    <button onclick="clearAsset('platform')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="platformPreview"></div>
            </div>
            <div class="asset-section">
                <h4>ðŸ„ Power-up Mushroom</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the mushroom power-up sprite (recommended: 38x38px PNG with transparent background)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="mushroomSprite" accept="image/*" onchange="loadAsset('mushroom', this)">
                    <button onclick="clearAsset('mushroom')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="mushroomPreview"></div>
            </div>
            <div class="asset-controls">
                <button onclick="resetToDefault()" class="reset-btn">Reset to Default</button>
                <button onclick="exportAssetConfig()" class="export-btn">Export Config</button>
                <button onclick="importAssetConfig()" class="import-btn">Import Config</button>
            </div>
        </div>
    </div>
    


    <script>
        // PERFORMANCE: Disable verbose console logging in production to reduce memory usage
        const originalLog = console.log;
        const originalWarn = console.warn;
        console.log = function(...args) {
            // Only log important messages, skip verbose game loop logs
            if (args[0] && typeof args[0] === 'string' && (
                args[0].includes('ERROR') || 
                args[0].includes('WARNING') ||
                args[0].includes('Initializing') ||
                args[0].includes('DOM loaded')
            )) {
                originalLog.apply(console, args);
            }
        };
        console.warn = function(...args) {
            // Keep warnings but reduce frequency
            originalWarn.apply(console, args);
        };
        
        // WALLET/STAKING SYSTEM REMOVED FOR PERFORMANCE
        // OtterfulWallet class removed - entire wallet/staking system disabled
        /*
        class OtterfulWallet {
            constructor() {
                // In-memory storage object (replaces localStorage)
                this.memoryStorage = {
                    nftData: null
                };
                
                // Initialize other properties
                this.provider = null;
                this.account = null;
                this.isConnected = false;
                this.isLoadingNFTs = false; // Track loading state to prevent duplicate calls
                this.contractAddress = '0x4e5913922b7ddf916c8d27d1016827f799687e66';
                this.stakingContractAddress = '0x0000000000000000000000000000000000000000'; // TODO: Deploy staking contract
                this.apeChainId = '0x8173'; // 33139 in hex
                this.userNFTs = [];
                this.stakedNFTs = [];
                this.fishCoins = 0;
                this.stakingStartTimes = {};
                
                // Updated trait multipliers based on your actual NFT attributes
                this.traitMultipliers = {
                    // Hat traits (most valuable)
                    'Hat-Stealth-v2': 2.5,
                    'Hat-Plumber-v5': 3.0,
                    'Hat-Plumber-v3': 2.5,
                    'Hat-Plumber-v4': 2.2,
                    'Hat-Plumber-v2': 2.0,
                    'Hat-Plumber': 1.8,
                    'Hat-Pirate': 2.0,
                    'Hat-Crown': 1.8,
                    'Hat-Wizard': 1.5,
                    'Hat-Baseball': 1.2,
                    'Hat-Beanie': 1.1,
                    
                    // Shirt/Overalls traits
                    'Shirt-Overalls-Orange': 1.6,
                    'Shirt-Overalls-Blue': 1.5,
                    'Shirt-Overalls-V2': 2.2,
                    'Shirt-Overalls-V3': 2.8,
                    
                    // Fur color traits
                    'Fur-Golden': 1.5,
                    'Fur-Rainbow': 1.3,
                    'Fur-Green': 1.2,
                    'Fur-Blue': 1.1,
                    
                    // Eye traits
                    'Eyes-Laser': 1.4,
                    'Eyes-Yellow-Scanner': 1.3,
                    'Eyes-Diamond': 1.3,
                    'Eyes-Sunglasses': 1.2,
                    
                    // Base traits
                    'Base-Stealth': 1.4,
                    'Base-Normal': 1.0
                };

                this.gamePerks = {
                    // Hat perks
                    'Hat-Stealth-v2': { type: 'stealth', value: 1.0, description: 'Invisible to enemies for 3 seconds' },
                    'Hat-Plumber-v5': { type: 'master', value: 1.0, description: 'Ultra Rare! All plumber abilities + 3x build speed' },
                    'Hat-Plumber-v3': { type: 'damage', value: 2.0, description: 'Pipe burst! Double damage output' },
                    'Hat-Plumber-v4': { type: 'speed', value: 1.8, description: 'Pipe rush! +80% movement speed' },
                    'Hat-Plumber-v2': { type: 'luck', value: 1.6, description: 'Pipe finder! +60% rare item discovery' },
                    'Hat-Plumber': { type: 'points', value: 1.5, description: 'Coin collector! +50% score multiplier' },
                    'Hat-Pirate': { type: 'speed', value: 1.5, description: '50% faster movement' },
                    'Hat-Crown': { type: 'points', value: 2.0, description: 'Double points scoring' },
                    'Hat-Wizard': { type: 'magic', value: 1.0, description: 'Unlock magic abilities' },
                    
                    // Shirt perks
                    'Shirt-Overalls-Orange': { type: 'construction', value: 1.0, description: 'Build temporary platforms' },
                    'Shirt-Overalls-V2': { type: 'construction', value: 1.0, description: 'Build platforms! Create temporary bridges' },
                    'Shirt-Overalls-V3': { type: 'master', value: 1.0, description: 'Master builder! All construction abilities + double build speed' },
                    
                    // Eye perks
                    'Eyes-Laser': { type: 'damage', value: 1.4, description: '40% more damage' },
                    'Eyes-Yellow-Scanner': { type: 'detection', value: 1.0, description: 'See hidden items and enemies' },
                    'Eyes-Diamond': { type: 'defense', value: 0.8, description: '20% damage reduction' },
                    'Eyes-Sunglasses': { type: 'cool', value: 1.0, description: 'Immunity to flash effects' },
                    
                    // Fur perks
                    'Fur-Golden': { type: 'luck', value: 1.3, description: '30% better item drops' },
                    'Fur-Rainbow': { type: 'rainbow', value: 1.0, description: 'Random ability every 30 seconds' },
                    
                    // Base perks
                    'Base-Stealth': { type: 'stealth', value: 0.7, description: 'Slightly harder for enemies to detect' }
                };
                
                this.init();
            }

            init() {
                // Don't auto-connect - let user manually connect
                // this.checkConnection();
                this.startStakingRewardsTimer();
                
                // Periodic save every 30 seconds
                setInterval(() => {
                    if (this.isConnected && (this.userNFTs.length > 0 || this.stakedNFTs.length > 0 || this.fishCoins > 0)) {
                        this.saveNFTsToStorage();
                    }
                }, 30000);
            }

            setupEventListeners() {
                // Connect wallet button from title screen
                const connectWalletBtn = document.getElementById('connectWalletBtn');
                if (connectWalletBtn) {
                    connectWalletBtn.addEventListener('click', () => {
                        if (this.isConnected) {
                            this.disconnect();
                        } else {
                            // Show sign-in modal instead of directly connecting
                            showSignInModal();
                        }
                    });
                }
                
                // Close sign-in modal button
                const closeSignInModal = document.getElementById('closeSignInModal');
                if (closeSignInModal) {
                    closeSignInModal.addEventListener('click', () => {
                        hideSignInModal();
                    });
                }
                
                // Connect wallet from modal button
                const connectWalletFromModal = document.getElementById('connectWalletFromModal');
                if (connectWalletFromModal) {
                    connectWalletFromModal.addEventListener('click', () => {
                        hideSignInModal();
                        this.connect();
                    });
                }
                
                // Close modal when clicking outside
                const signInModal = document.getElementById('signInModal');
                if (signInModal) {
                    signInModal.addEventListener('click', (e) => {
                        if (e.target === signInModal) {
                            hideSignInModal();
                        }
                    });
                }
                
                // Save data when page is about to unload
                window.addEventListener('beforeunload', () => {
                    if (this.isConnected && (this.userNFTs.length > 0 || this.stakedNFTs.length > 0 || this.fishCoins > 0)) {
                        this.saveNFTsToStorage();
                    }
                });

                // Wallet event listeners
                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', async (accounts) => {
                        if (accounts.length === 0) {
                            this.disconnect(true); // Clear NFTs when fully disconnecting
                        } else {
                            // Save current data before switching accounts
                            if (this.isConnected && (this.userNFTs.length > 0 || this.stakedNFTs.length > 0 || this.fishCoins > 0)) {
                                this.saveNFTsToStorage();
                            }
                            
                            // Switch to new account
                            this.account = accounts[0];
                            
                            // **AUTO-LOAD NFTs for the new account**
                            console.log('ðŸ”„ Account changed, attempting to auto-load saved NFTs from localStorage...');
                            const loaded = this.loadNFTsFromStorage();
                            
                            // Check if we actually have NFTs after loading
                            if (loaded && (this.userNFTs.length > 0 || this.stakedNFTs.length > 0)) {
                                console.log('âœ… Auto-loaded saved NFTs for new account!');
                                this.updateNFTDisplay(); // Update the UI with loaded NFTs
                            } else {
                                console.log('âš ï¸ No saved NFTs found for new account - auto-scanning wallet...');
                                // Clear NFTs for new account
                                this.userNFTs = [];
                                this.stakedNFTs = [];
                                this.fishCoins = 0;
                                this.stakingStartTimes = {};
                                this.updateNFTDisplay();
                                
                                // Automatically scan for NFTs in the new account
                                try {
                                    const balance = await this.getTokenBalance();
                                    if (balance > 0) {
                                        console.log(`ðŸ’° Found ${balance} Otterful Otters in new wallet, loading...`);
                                        await this.loadUserNFTsWithMetadata(balance);
                                    }
                                } catch (error) {
                                    console.error('âŒ Error auto-scanning for NFTs:', error);
                                }
                            }
                            
                            this.updateUI();
                            console.log('âœ… Account switched and NFTs auto-loaded');
                        }
                    });

                    window.ethereum.on('chainChanged', (chainId) => {
                        // Save current data before chain change
                        if (this.isConnected && (this.userNFTs.length > 0 || this.stakedNFTs.length > 0 || this.fishCoins > 0)) {
                            this.saveNFTsToStorage();
                        }
                        
                        this.updateUI();
                        if (chainId === this.apeChainId) {
                            // Removed automatic NFT loading - user must load manually
                        }
                    });
                }
            }

            async checkConnection() {
                if (window.ethereum) {
                    try {
                        const accounts = await window.ethereum.request({
                            method: 'eth_accounts'
                        });
                        
                        if (accounts.length > 0) {
                            this.account = accounts[0];
                            this.provider = window.ethereum;
                            this.isConnected = true;
                            this.updateUI();
                            
                            const chainId = await window.ethereum.request({
                                method: 'eth_chainId'
                            });
                            
                            if (chainId === this.apeChainId) {
                                // Auto-load NFTs from localStorage first
                                const loadedFromStorage = this.loadNFTsFromStorage();
                                if (!loadedFromStorage || (this.userNFTs.length === 0 && this.stakedNFTs.length === 0)) {
                                    // If no saved NFTs, automatically scan wallet
                                    console.log('ðŸ”„ Auto-scanning wallet for Otterful Otters NFTs...');
                                    try {
                                        const balance = await this.getTokenBalance();
                                        if (balance > 0) {
                                            console.log(`ðŸ’° Found ${balance} Otterful Otters in wallet, loading...`);
                                            await this.loadUserNFTsWithMetadata(balance);
                                        }
                                    } catch (error) {
                                        console.error('âŒ Error auto-scanning for NFTs:', error);
                                    }
                                } else {
                                    this.updateNFTDisplay();
                                }
                            }
                        }
                    } catch (error) {
                        console.error('Error checking connection:', error);
                    }
                }
            }

            async connect() {
                console.log('ðŸš€ connect() called');
                const connectWalletBtn = document.getElementById('connectWalletBtn');
                
                if (!window.ethereum) {
                    console.log('âŒ No ethereum provider found');
                    this.showMessage('Please install MetaMask or another Web3 wallet!', 'error');
                    throw new Error('No ethereum provider found');
                }

                try {
                    console.log('ðŸ”— Requesting accounts...');
                    if (connectWalletBtn) {
                        connectWalletBtn.innerHTML = '<span style="position: relative; z-index: 2;">ðŸ”„ Connecting...</span>';
                        connectWalletBtn.disabled = true;
                    }

                    const accounts = await window.ethereum.request({
                        method: 'eth_requestAccounts'
                    });

                    console.log('ðŸ‘¤ Accounts received:', accounts);
                    this.account = accounts[0];
                    this.provider = window.ethereum;
                    this.isConnected = true;
                    
                    console.log('âœ… Wallet connected successfully');
                    console.log('ðŸ‘¤ Account:', this.account);
                    console.log('ðŸ”— Provider:', this.provider);
                    console.log('ðŸ”— isConnected:', this.isConnected);

                    console.log('ðŸ”„ Switching to ApeChain...');
                    await this.switchToApeChain();

                    console.log('ðŸ”„ Updating UI...');
                    this.updateUI();
                    
                    // **AUTO-LOAD NFTs from localStorage after connecting**
                    console.log('ðŸ”„ Attempting to auto-load saved NFTs from localStorage...');
                    const loadedFromStorage = this.loadNFTsFromStorage();
                    
                    // Check if we actually have NFTs after loading (not just if data was found)
                    if (loadedFromStorage && (this.userNFTs.length > 0 || this.stakedNFTs.length > 0)) {
                        console.log('âœ… Auto-loaded saved NFTs successfully!');
                        this.updateNFTDisplay(); // Update the UI with loaded NFTs
                        this.saveNFTsToStorage(); // Save after loading to ensure data is current
                        this.showMessage(`âœ… Auto-loaded ${this.userNFTs.length} NFTs and ${this.stakedNFTs.length} staked NFTs from previous session!`, 'success');
                    } else {
                        console.log('âš ï¸ No saved NFTs found - automatically scanning wallet for Otterful Otters...');
                        // Automatically scan for NFTs when wallet is connected
                        this.showMessage('Scanning wallet for Otterful Otters NFTs...', 'info');
                        try {
                            const balance = await this.getTokenBalance();
                            if (balance > 0) {
                                console.log(`ðŸ’° Found ${balance} Otterful Otters in wallet, loading...`);
                                await this.loadUserNFTsWithMetadata(balance);
                            } else {
                                this.showMessage('No Otterful Otters NFTs found in this wallet.', 'info');
                            }
                        } catch (error) {
                            console.error('âŒ Error auto-scanning for NFTs:', error);
                            this.showMessage('Auto-scan failed. Use "Check Token" or "Load Multiple" to load your NFTs.', 'warning');
                        }
                    }

                } catch (error) {
                    console.error('âŒ Connection failed:', error);
                    this.showMessage(`Connection failed: ${error.message}`, 'error');
                    throw error; // Re-throw the error so callers can catch it
                } finally {
                    if (connectWalletBtn) {
                        connectWalletBtn.disabled = false;
                    }
                }
            }

            async switchToApeChain() {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: this.apeChainId }],
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: this.apeChainId,
                                    chainName: 'ApeChain',
                                    nativeCurrency: {
                                        name: 'ApeCoin',
                                        symbol: 'APE',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://apechain.calderachain.xyz/http'],
                                    blockExplorerUrls: ['https://apechain.calderachain.xyz']
                                }]
                            });
                        } catch (addError) {
                            throw new Error('Failed to add ApeChain network');
                        }
                    } else {
                        throw switchError;
                    }
                }
            }

            async loadNFTsManuallyOnly() {
                console.log('ðŸš€ loadNFTsManuallyOnly() called - manual loading without clearing existing NFTs');
                
                if (!this.isConnected || !this.provider) {
                    console.log('âŒ Not connected or no provider, returning');
                    return;
                }

                try {
                    console.log('ðŸ”— Requesting chain ID...');
                    const chainId = await window.ethereum.request({
                        method: 'eth_chainId'
                    });

                    console.log('ðŸ”— Current chain ID:', chainId);
                    console.log('ðŸŽ¯ Expected chain ID:', this.apeChainId);

                    if (chainId !== this.apeChainId) {
                        console.log('âš ï¸ Wrong chain, switching to ApeChain...');
                        await this.switchToApeChain();
                        return;
                    }

                    console.log('âœ… On correct chain, checking balance...');
                    const balance = await this.getTokenBalance();
                    console.log('ðŸ’° Token balance:', balance);
                    
                    if (balance > 0) {
                        console.log('ðŸ¦¦ Loading NFT metadata (manual mode)...');
                        await this.loadUserNFTsWithMetadata(balance, false); // Don't clear existing NFTs
                    } else {
                        console.log('âš ï¸ No tokens found in manual mode');
                    }

                    this.updateUI();

                } catch (error) {
                    console.error('âŒ Error in manual NFT loading:', error);
                    this.showMessage(`Error loading NFTs: ${error.message}`, 'error');
                }
            }

            async loadNFTs() {
                // Prevent multiple simultaneous calls
                if (this.isLoadingNFTs) {
                    console.log('â³ NFTs already loading, skipping duplicate call');
                    return;
                }
                
                this.isLoadingNFTs = true;
                console.log('ðŸš€ loadNFTs() called');
                console.log('ðŸ”— isConnected:', this.isConnected);
                console.log('ðŸ”— provider:', this.provider);
                console.log('ðŸ‘¤ account:', this.account);
                
                if (!this.isConnected || !this.provider) {
                    console.log('âŒ Not connected or no provider, returning');
                    this.isLoadingNFTs = false;
                    return;
                }

                // Check if we already have NFTs loaded for this account
                if (this.userNFTs && this.userNFTs.length > 0) {
                    console.log('âœ… NFTs already loaded, skipping reload');
                    this.isLoadingNFTs = false;
                    return;
                }

                try {
                    console.log('ðŸ”— Requesting chain ID...');
                    const chainId = await window.ethereum.request({
                        method: 'eth_chainId'
                    });

                    console.log('ðŸ”— Current chain ID:', chainId);
                    console.log('ðŸŽ¯ Expected chain ID:', this.apeChainId);

                    if (chainId !== this.apeChainId) {
                        console.log('âš ï¸ Wrong chain, switching to ApeChain...');
                        await this.switchToApeChain();
                        this.isLoadingNFTs = false;
                        return;
                    }

                    console.log('âœ… On correct chain, checking balance...');
                    const balance = await this.getTokenBalance();
                    console.log('ðŸ’° Token balance:', balance);
                    
                    if (balance > 0) {
                        console.log('ðŸ¦¦ Loading NFT metadata...');
                        await this.loadUserNFTsWithMetadata(balance); // Clear existing NFTs for automatic loading
                    } else {
                        console.log('âš ï¸ No tokens found, loading sample data for testing...');
                        // Load sample data for testing
                        this.loadSampleNFTs(4); // Show 4 sample NFTs
                    }

                    this.updateUI();

                } catch (error) {
                    console.error('âŒ Error loading NFTs:', error);
                    console.log('ðŸ”„ Loading sample data as fallback...');
                    this.loadSampleNFTs(4); // Load sample data on error
                    this.showMessage(`Error loading NFTs: ${error.message}`, 'error');
                } finally {
                    this.isLoadingNFTs = false;
                }
            }

            async getTokenBalance() {
                try {
                    console.log('ðŸ’° Getting token balance for address:', this.account);
                    const data = '0x70a08231' + this.account.slice(2).padStart(64, '0');
                    console.log('ðŸ“‹ BalanceOf call data:', data);
                    
                    const result = await window.ethereum.request({
                        method: 'eth_call',
                        params: [{
                            to: this.contractAddress,
                            data: data
                        }, 'latest']
                    });

                    console.log('ðŸ“„ BalanceOf result:', result);
                    const balance = parseInt(result, 16);
                    console.log('ðŸ’° Parsed balance:', balance);
                    return balance;
                } catch (error) {
                    console.error('âŒ Error getting token balance:', error);
                    throw error;
                }
            }

            // PRODUCTION-READY NFT LOADING SYSTEM
            // This will work for any user on any computer
            async loadUserNFTsWithMetadata(balance, clearExisting = true) {
                if (clearExisting) {
                    this.userNFTs = [];
                    console.log('ðŸ§¹ Cleared existing NFTs for fresh load');
                } else {
                    console.log('ðŸ“‹ Keeping existing NFTs, adding to them');
                }
                console.log('ðŸš€ PRODUCTION NFT LOADING - Finding real NFTs for any user...');
                
                try {
                    // Step 1: Find owned tokens (this works for everyone)
                    console.log('ðŸ” Step 1: Scanning blockchain for your owned NFTs...');
                    const ownedTokens = await this.findOwnedTokens();
                    
                    if (ownedTokens.length === 0) {
                        console.log('ðŸ“‹ No NFTs found for this wallet');
                        this.showMessage('No Otterful Otters NFTs found in this wallet', 'info');
                        return;
                    }
                    
                    console.log(`ðŸŽ¯ Found ${ownedTokens.length} owned NFTs: ${ownedTokens.join(', ')}`);
                    
                    // Step 2: Load metadata for each owned NFT
                    console.log('ðŸ“„ Step 2: Loading metadata for each NFT...');
                    
                    for (let i = 0; i < ownedTokens.length; i++) {
                        const tokenId = ownedTokens[i];
                        console.log(`ðŸ“‹ Processing NFT ${i + 1}/${ownedTokens.length}: Token #${tokenId}`);
                        
                        try {
                            // Get the real metadata from blockchain/IPFS
                            const metadata = await this.getRealNFTMetadata(tokenId);
                            
                            let nft;
                            if (metadata) {
                                console.log(`âœ… Loaded metadata for token ${tokenId}:`, metadata);
                                
                                // Extract traits from the actual metadata
                                const traits = this.extractTraitsFromMetadata(metadata);
                                
                                nft = {
                                    tokenId: tokenId,
                                    name: metadata.name || `Otterful Otter #${tokenId}`,
                                    traits: traits,
                                    multiplier: this.calculateMultiplier(traits),
                                    perks: this.calculatePerks(traits),
                                    rarity: this.calculateRarity(traits),
                                    image: this.processImageUrl(metadata.image, tokenId),
                                    description: metadata.description || `Otterful Otter #${tokenId}`,
                                    rawMetadata: metadata // Store for debugging
                                };
                            } else {
                                // Create basic NFT entry even if metadata fails - user owns it!
                                console.log(`âš ï¸ No metadata found for token ${tokenId}, creating basic NFT entry`);
                                const basicTraits = this.generateTraitsFromTokenId ? this.generateTraitsFromTokenId(tokenId) : ['Base-Normal'];
                                nft = {
                                    tokenId: tokenId,
                                    name: `Otterful Otter #${tokenId}`,
                                    traits: basicTraits,
                                    multiplier: this.calculateMultiplier(basicTraits),
                                    perks: this.calculatePerks(basicTraits),
                                    rarity: this.calculateRarity(basicTraits),
                                    image: this.processImageUrl(null, tokenId), // Will use compressed PNG if available
                                    description: `Otterful Otter #${tokenId}`,
                                    rawMetadata: null
                                };
                            }
                            
                            // Always add the NFT if we found it in the wallet
                            this.userNFTs.push(nft);
                            console.log(`ðŸ¦¦ Added NFT: ${nft.name} (Token #${tokenId})`);
                            
                            // Small delay between requests to be nice to servers
                            if (i < ownedTokens.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 500));
                            }
                            
                        } catch (error) {
                            console.warn(`âš ï¸ Error loading metadata for token ${tokenId}:`, error.message);
                            // Still create a basic NFT entry even on error - user owns it!
                            const basicTraits = this.generateTraitsFromTokenId ? this.generateTraitsFromTokenId(tokenId) : ['Base-Normal'];
                            const nft = {
                                tokenId: tokenId,
                                name: `Otterful Otter #${tokenId}`,
                                traits: basicTraits,
                                multiplier: this.calculateMultiplier(basicTraits),
                                perks: this.calculatePerks(basicTraits),
                                rarity: this.calculateRarity(basicTraits),
                                image: this.processImageUrl(null, tokenId),
                                description: `Otterful Otter #${tokenId}`,
                                rawMetadata: null
                            };
                            this.userNFTs.push(nft);
                            console.log(`ðŸ¦¦ Added NFT (fallback): ${nft.name} (Token #${tokenId})`);
                        }
                    }
                    
                    console.log(`ðŸŽ‰ SUCCESS! Loaded ${this.userNFTs.length} NFTs for this wallet`);
                    this.saveNFTsToStorage(); // Save loaded NFTs to localStorage
                    this.updateNFTDisplay();
                    this.showMessage(`Successfully loaded ${this.userNFTs.length} Otterful Otters!`, 'success');
                    
                } catch (error) {
                    console.error('âŒ Error in production NFT loading:', error);
                    this.showMessage(`Error loading NFTs: ${error.message}`, 'error');
                }
            }

            // Find tokens owned by the current user (works for everyone)
            async findOwnedTokens() {
                console.log('ðŸ” Scanning blockchain for owned tokens...');
                const ownedTokens = [];
                
                try {
                    // Strategy 1: Use events to find transfers TO this user
                    console.log('ðŸ“¡ Method 1: Checking recent Transfer events...');
                    const recentTokens = await this.findTokensFromEvents();
                    ownedTokens.push(...recentTokens);
                    
                    // Strategy 2: If events don't work or found fewer than balance, scan the full range
                    const balance = await this.getTokenBalance();
                    console.log(`ðŸ’° Wallet balance: ${balance} NFTs`);
                    
                    if (ownedTokens.length < balance) {
                        console.log(`ðŸ” Method 2: Events found ${ownedTokens.length} but balance is ${balance}, scanning full range...`);
                        // Scan all 2222 tokens to find all owned NFTs
                        const scannedTokens = await this.scanTokenRange(1, 2222);
                        ownedTokens.push(...scannedTokens);
                    } else if (ownedTokens.length === 0) {
                        // If events found nothing, try scanning full range
                        console.log('ðŸ” Method 2: No tokens from events, scanning full range...');
                        const scannedTokens = await this.scanTokenRange(1, 2222);
                        ownedTokens.push(...scannedTokens);
                    }
                    
                    // Strategy 3: If all else fails, return empty array (user will use manual loading)
                    if (ownedTokens.length === 0) {
                        console.log('ðŸ“‹ No tokens found via scanning, use manual token loading');
                        this.showMessage('No NFTs found via scanning. Use "Check Token" to load specific NFTs.', 'info');
                    }
                    
                    // Remove duplicates
                    const uniqueTokens = [...new Set(ownedTokens)];
                    console.log(`ðŸ“Š Found ${uniqueTokens.length} owned tokens total (expected ${balance})`);
                    
                    // If we found fewer than the balance, warn the user
                    if (balance > 0 && uniqueTokens.length < balance) {
                        console.warn(`âš ï¸ Found ${uniqueTokens.length} tokens but balance shows ${balance}. Some NFTs may not be displayed.`);
                        this.showMessage(`Found ${uniqueTokens.length} of ${balance} NFTs. Some may be missing. Try manual scan.`, 'warning');
                    }
                    
                    return uniqueTokens;
                    
                } catch (error) {
                    console.error('âŒ Error finding owned tokens:', error);
                    this.showMessage('Blockchain scanning failed. Use "Check Token" to load specific NFTs.', 'warning');
                    return [];
                }
            }

            // IMPROVED NFT LOADING FUNCTION - PREVENTS TOKEN #102 ISSUE
            async loadUserNFTsWithMetadataImproved(balance) {
                this.userNFTs = [];
                console.log('ðŸš€ IMPROVED NFT LOADING - Finding real NFTs with better validation...');
                
                try {
                    // Step 1: Find owned tokens with improved validation
                    console.log('ðŸ” Step 1: Scanning blockchain for your owned NFTs...');
                    const ownedTokens = await this.findOwnedTokensImproved();
                    
                    if (ownedTokens.length === 0) {
                        console.log('ðŸ“‹ No NFTs found for this wallet');
                        this.showMessage('No Otterful Otters NFTs found in this wallet', 'info');
                        return;
                    }
                    
                    console.log(`ðŸŽ¯ Found ${ownedTokens.length} owned NFTs: ${ownedTokens.join(', ')}`);
                    
                    // Step 2: Load metadata for each owned NFT
                    console.log('ðŸ“„ Step 2: Loading metadata for each NFT...');
                    
                    for (let i = 0; i < ownedTokens.length; i++) {
                        const tokenId = ownedTokens[i];
                        console.log(`ðŸ“‹ Processing NFT ${i + 1}/${ownedTokens.length}: Token #${tokenId}`);
                        
                        try {
                            // Get the real metadata from blockchain/IPFS
                            const metadata = await this.getRealNFTMetadata(tokenId);
                            
                            let nft;
                            if (metadata) {
                                console.log(`âœ… Loaded metadata for token ${tokenId}:`, metadata);
                                
                                // Extract traits from the actual metadata
                                const traits = this.extractTraitsFromMetadata(metadata);
                                
                                nft = {
                                    tokenId: tokenId,
                                    name: metadata.name || `Otterful Otter #${tokenId}`,
                                    traits: traits,
                                    multiplier: this.calculateMultiplier(traits),
                                    perks: this.calculatePerks(traits),
                                    rarity: this.calculateRarity(traits),
                                    image: this.processImageUrl(metadata.image, tokenId),
                                    description: metadata.description || `Otterful Otter #${tokenId}`,
                                    rawMetadata: metadata // Store for debugging
                                };
                            } else {
                                // Create basic NFT entry even if metadata fails - user owns it!
                                console.log(`âš ï¸ No metadata found for token ${tokenId}, creating basic NFT entry`);
                                const basicTraits = this.generateTraitsFromTokenId ? this.generateTraitsFromTokenId(tokenId) : ['Base-Normal'];
                                nft = {
                                    tokenId: tokenId,
                                    name: `Otterful Otter #${tokenId}`,
                                    traits: basicTraits,
                                    multiplier: this.calculateMultiplier(basicTraits),
                                    perks: this.calculatePerks(basicTraits),
                                    rarity: this.calculateRarity(basicTraits),
                                    image: this.processImageUrl(null, tokenId), // Will use compressed PNG if available
                                    description: `Otterful Otter #${tokenId}`,
                                    rawMetadata: null
                                };
                            }
                            
                            // Always add the NFT if we found it in the wallet
                            this.userNFTs.push(nft);
                            console.log(`ðŸ¦¦ Added NFT: ${nft.name} (Token #${tokenId})`);
                            
                            // Small delay between requests to be nice to servers
                            if (i < ownedTokens.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 500));
                            }
                            
                        } catch (error) {
                            console.warn(`âš ï¸ Error loading metadata for token ${tokenId}:`, error.message);
                            // Still create a basic NFT entry even on error - user owns it!
                            const basicTraits = this.generateTraitsFromTokenId ? this.generateTraitsFromTokenId(tokenId) : ['Base-Normal'];
                            const nft = {
                                tokenId: tokenId,
                                name: `Otterful Otter #${tokenId}`,
                                traits: basicTraits,
                                multiplier: this.calculateMultiplier(basicTraits),
                                perks: this.calculatePerks(basicTraits),
                                rarity: this.calculateRarity(basicTraits),
                                image: this.processImageUrl(null, tokenId),
                                description: `Otterful Otter #${tokenId}`,
                                rawMetadata: null
                            };
                            this.userNFTs.push(nft);
                            console.log(`ðŸ¦¦ Added NFT (fallback): ${nft.name} (Token #${tokenId})`);
                        }
                    }
                    
                    console.log(`ðŸŽ‰ SUCCESS! Loaded ${this.userNFTs.length} NFTs for this wallet`);
                    this.saveNFTsToStorage(); // Save loaded NFTs to localStorage
                    this.updateNFTDisplay();
                    this.showMessage(`Successfully loaded ${this.userNFTs.length} Otterful Otters!`, 'success');
                    
                } catch (error) {
                    console.error('âŒ Error in improved NFT loading:', error);
                    this.showMessage(`Error loading NFTs: ${error.message}`, 'error');
                }
            }

            // ULTRA-FAST TOKEN FINDING WITH PRE-LOADED WALLET LIST
            async findOwnedTokensImproved() {
                console.log('ðŸš€ ULTRA-FAST SCANNING - Using pre-loaded wallet addresses...');
                const ownedTokens = [];
                
                try {
                    // Strategy 1: Use pre-loaded wallet addresses for instant results
                    console.log('ðŸ“‹ Method 1: Checking pre-loaded wallet addresses...');
                    const preloadedTokens = await this.findTokensFromPreloadedWallets();
                    ownedTokens.push(...preloadedTokens);
                    
                    // Strategy 2: If pre-loaded doesn't work, use events as backup
                    if (ownedTokens.length === 0) {
                        console.log('ðŸ“¡ Method 2: Checking recent Transfer events with validation...');
                        const recentTokens = await this.findTokensFromEventsImproved();
                        ownedTokens.push(...recentTokens);
                    }
                    
                    // Strategy 3: If events don't work or found fewer than balance, scan the full range
                    const balance = await this.getTokenBalance();
                    console.log(`ðŸ’° Wallet balance: ${balance} NFTs`);
                    
                    if (ownedTokens.length < balance) {
                        console.log(`ðŸ” Method 3: Found ${ownedTokens.length} but balance is ${balance}, scanning full range...`);
                        // Scan all 2222 tokens to find all owned NFTs
                        const scannedTokens = await this.scanTokenRangeImproved(1, 2222);
                        ownedTokens.push(...scannedTokens);
                    } else if (ownedTokens.length === 0) {
                        console.log('ðŸ” Method 3: No tokens found, scanning full range...');
                        const scannedTokens = await this.scanTokenRangeImproved(1, 2222);
                        ownedTokens.push(...scannedTokens);
                    }
                    
                    // Strategy 4: If all else fails, return empty array
                    if (ownedTokens.length === 0) {
                        console.log('ðŸ“‹ No tokens found via any method');
                        this.showMessage('No NFTs found via scanning. Use "Check Token" to load specific NFTs.', 'info');
                    }
                    
                    // Remove duplicates and validate each token
                    const uniqueTokens = [...new Set(ownedTokens)];
                    console.log(`ðŸ“Š Found ${uniqueTokens.length} owned tokens before validation (expected ${balance || 'unknown'})`);
                    
                    // If we found fewer than the balance, warn the user
                    if (balance > 0 && uniqueTokens.length < balance) {
                        console.warn(`âš ï¸ Found ${uniqueTokens.length} tokens but balance shows ${balance}. Some NFTs may not be displayed.`);
                    }
                    
                    // DOUBLE-CHECK OWNERSHIP TO PREVENT FALSE POSITIVES
                    const validatedTokens = [];
                    for (const tokenId of uniqueTokens) {
                        try {
                            console.log(`ðŸ” Double-checking ownership of token #${tokenId}...`);
                            const owner = await this.getTokenOwner(tokenId);
                            
                            if (owner && owner.toLowerCase() === this.account.toLowerCase()) {
                                console.log(`âœ… Confirmed ownership of token #${tokenId}`);
                                validatedTokens.push(tokenId);
                            } else {
                                console.log(`âŒ Token #${tokenId} ownership check failed - removing from list`);
                            }
                            
                            // Small delay to prevent RPC overload
                            await new Promise(resolve => setTimeout(resolve, 200));
                            
                        } catch (error) {
                            console.log(`âš ï¸ Error validating token #${tokenId}: ${error.message} - removing from list`);
                        }
                    }
                    
                    console.log(`ðŸ“Š Final validated tokens: ${validatedTokens.length} (${validatedTokens.join(', ')})`);
                    return validatedTokens;
                    
                } catch (error) {
                    console.error('âŒ Error in improved token finding:', error);
                    this.showMessage('Blockchain scanning failed. Use "Check Token" to load specific NFTs.', 'warning');
                    return [];
                }
            }

            // ULTRA-FAST: Find tokens using pre-loaded wallet addresses
            async findTokensFromPreloadedWallets() {
                try {
                    console.log('ðŸ“‹ ULTRA-FAST: Checking pre-loaded wallet addresses...');
                    
                    // Load wallet data from JSON file
                    const walletData = await this.loadWalletData();
                    
                    if (!walletData || walletData.length === 0) {
                        console.log('ðŸ“‹ No pre-loaded wallet data available');
                        return [];
                    }
                    
                    // Find this user's address in the pre-loaded list
                    const userEntry = walletData.find(owner => 
                        owner.address.toLowerCase() === this.account.toLowerCase()
                    );
                    
                    if (userEntry) {
                        console.log(`âœ… Found user in pre-loaded data with ${userEntry.tokens.length} tokens:`, userEntry.tokens);
                        return userEntry.tokens;
                    } else {
                        console.log('ðŸ“‹ User not found in pre-loaded wallet data');
                        return [];
                    }
                    
                } catch (error) {
                    console.log('âš ï¸ Error in pre-loaded wallet check:', error);
                    return [];
                }
            }

            // Load wallet data from JSON file
            async loadWalletData() {
                try {
                    console.log('ðŸ“ Loading wallet data from JSON file...');
                    
                    // Try to load from local JSON file
                    const response = await fetch('./public/wallet-data.json');
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`âœ… Loaded wallet data for ${data.length} addresses`);
                        return data;
                    } else {
                        console.log('âŒ Could not load wallet data file');
                        return [];
                    }
                } catch (error) {
                    console.log('âŒ Error loading wallet data:', error);
                    return [];
                }
            }

            // IMPROVED EVENT SCANNING WITH BETTER VALIDATION
            async findTokensFromEventsImproved() {
                try {
                    console.log('ðŸ“¡ IMPROVED: Searching Transfer events for your address...');
                    
                    // Create event topic for Transfer(address,address,uint256)
                    const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                    const userAddressPadded = '0x000000000000000000000000' + this.account.slice(2).toLowerCase();
                    
                    // Get logs for transfers TO this address (limit to recent blocks to avoid RPC overload)
                    const logs = await window.ethereum.request({
                        method: 'eth_getLogs',
                        params: [{
                            fromBlock: '0x' + (parseInt(await window.ethereum.request({method: 'eth_blockNumber'})) - 10000).toString(16), // Last 10k blocks
                            toBlock: 'latest',
                            address: this.contractAddress,
                            topics: [
                                transferTopic,
                                null, // from address (any)
                                userAddressPadded // to address (this user)
                            ]
                        }]
                    });
                    
                    console.log(`ðŸ“¡ Found ${logs.length} transfer events to your address`);
                    
                    const tokenIds = logs.map(log => {
                        // Token ID is in the data field or third topic
                        if (log.topics.length > 3) {
                            return parseInt(log.topics[3], 16);
                        } else if (log.data && log.data !== '0x') {
                            return parseInt(log.data, 16);
                        }
                        return null;
                    }).filter(id => id !== null && id >= 1 && id <= 2222); // Filter valid token IDs
                    
                    console.log('ðŸ“¡ Valid token IDs from events:', tokenIds);
                    
                    // Verify current ownership with better error handling
                    const currentlyOwned = [];
                    for (const tokenId of tokenIds) {
                        try {
                            console.log(`ðŸ” Verifying ownership of token #${tokenId}...`);
                            const owner = await this.getTokenOwner(tokenId);
                            
                            if (owner && owner.toLowerCase() === this.account.toLowerCase()) {
                                console.log(`âœ… Confirmed ownership of token #${tokenId}`);
                                currentlyOwned.push(tokenId);
                            } else {
                                console.log(`âŒ Token #${tokenId} not owned by you (owner: ${owner})`);
                            }
                            
                            // Add small delay to prevent RPC overload
                            await new Promise(resolve => setTimeout(resolve, 200));
                            
                        } catch (error) {
                            console.log(`âš ï¸ Could not verify ownership of token ${tokenId}: ${error.message}`);
                        }
                    }
                    
                    console.log(`ðŸ“Š Currently owned from events: ${currentlyOwned.length} tokens`);
                    return currentlyOwned;
                    
                } catch (error) {
                    console.log('âš ï¸ Improved event method failed:', error.message);
                    return [];
                }
            }

            // IMPROVED DIRECT SCANNING WITH BETTER VALIDATION
            async scanTokenRangeImproved(start, end) {
                console.log(`ðŸ” IMPROVED: Scanning tokens ${start} to ${end} for ownership...`);
                const ownedTokens = [];
                const BATCH_SIZE = 10; // Increased batch size for faster scanning
                const totalTokens = end - start + 1;
                let scannedCount = 0;
                
                for (let i = start; i <= end; i += BATCH_SIZE) {
                    const batchEnd = Math.min(i + BATCH_SIZE - 1, end);
                    scannedCount += (batchEnd - i + 1);
                    const progress = Math.round((scannedCount / totalTokens) * 100);
                    
                    console.log(`ðŸ” Scanning batch ${i}-${batchEnd}... (${progress}% complete)`);
                    
                    // Show progress message for large scans
                    if (totalTokens > 200 && scannedCount % 100 === 0) {
                        this.showMessage(`Scanning progress: ${progress}% (${scannedCount}/${totalTokens} tokens)`, 'info');
                    }
                    
                    // Check batch of tokens with better error handling
                    for (let tokenId = i; tokenId <= batchEnd; tokenId++) {
                        try {
                            const owner = await this.getTokenOwner(tokenId);
                            
                            if (owner && owner.toLowerCase() === this.account.toLowerCase()) {
                                console.log(`âœ… Found owned token: ${tokenId}`);
                                ownedTokens.push(tokenId);
                            }
                            
                            // Small delay between checks
                            await new Promise(resolve => setTimeout(resolve, 50)); // Reduced delay for faster scanning
                            
                        } catch (error) {
                            console.log(`âš ï¸ Error checking token ${tokenId}: ${error.message}`);
                        }
                    }
                    
                    // Delay between batches to avoid overwhelming RPC
                    if (batchEnd < end) {
                        await new Promise(resolve => setTimeout(resolve, 500)); // Reduced delay
                    }
                }
                
                console.log(`ðŸ” Improved scan complete. Found ${ownedTokens.length} owned tokens`);
                return ownedTokens;
            }

            // Method 1: Use Transfer events to find NFTs (more efficient)
            async findTokensFromEvents() {
                try {
                    console.log('ðŸ“¡ Searching Transfer events for your address...');
                    
                    // Create event topic for Transfer(address,address,uint256)
                    const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                    const userAddressPadded = '0x000000000000000000000000' + this.account.slice(2).toLowerCase();
                    
                    // Get logs for transfers TO this address (limit to recent blocks to avoid RPC overload)
                    const logs = await window.ethereum.request({
                        method: 'eth_getLogs',
                        params: [{
                            fromBlock: '0x' + (parseInt(await window.ethereum.request({method: 'eth_blockNumber'})) - 10000).toString(16), // Last 10k blocks
                            toBlock: 'latest',
                            address: this.contractAddress,
                            topics: [
                                transferTopic,
                                null, // from address (any)
                                userAddressPadded // to address (this user)
                            ]
                        }]
                    });
                    
                    console.log(`ðŸ“¡ Found ${logs.length} transfer events to your address`);
                    
                    const tokenIds = logs.map(log => {
                        // Token ID is in the data field or third topic
                        if (log.topics.length > 3) {
                            return parseInt(log.topics[3], 16);
                        } else if (log.data && log.data !== '0x') {
                            return parseInt(log.data, 16);
                        }
                        return null;
                    }).filter(id => id !== null);
                    
                    console.log('ðŸ“¡ Token IDs from events:', tokenIds);
                    
                    // Verify current ownership (they might have transferred these NFTs away)
                    const currentlyOwned = [];
                    for (const tokenId of tokenIds) {
                        try {
                            const owner = await this.getTokenOwner(tokenId);
                            if (owner && owner.toLowerCase() === this.account.toLowerCase()) {
                                currentlyOwned.push(tokenId);
                            }
                            // Add small delay to prevent RPC overload
                            await new Promise(resolve => setTimeout(resolve, 100));
                        } catch (error) {
                            console.log(`âš ï¸ Could not verify ownership of token ${tokenId}: ${error.message}`);
                        }
                    }
                    
                    console.log(`ðŸ“Š Currently owned from events: ${currentlyOwned.length} tokens`);
                    return currentlyOwned;
                    
                } catch (error) {
                    console.log('âš ï¸ Event method failed:', error.message);
                    return [];
                }
            }

            // Method 2: Direct scanning (fallback)
            async scanTokenRange(start, end) {
                console.log(`ðŸ” Scanning tokens ${start} to ${end} for ownership...`);
                const ownedTokens = [];
                const BATCH_SIZE = 10;
                
                for (let i = start; i <= end; i += BATCH_SIZE) {
                    const batchEnd = Math.min(i + BATCH_SIZE - 1, end);
                    console.log(`ðŸ” Scanning batch ${i}-${batchEnd}...`);
                    
                    // Check batch of tokens
                    const batchPromises = [];
                    for (let tokenId = i; tokenId <= batchEnd; tokenId++) {
                        batchPromises.push(
                            this.getTokenOwner(tokenId)
                                .then(owner => ({ tokenId, owner }))
                                .catch(() => ({ tokenId, owner: null }))
                        );
                    }
                    
                    const batchResults = await Promise.all(batchPromises);
                    
                    batchResults.forEach(({ tokenId, owner }) => {
                        if (owner && owner.toLowerCase() === this.account.toLowerCase()) {
                            console.log(`âœ… Found owned token: ${tokenId}`);
                            ownedTokens.push(tokenId);
                        }
                    });
                    
                    // Delay between batches to avoid overwhelming RPC
                    if (batchEnd < end) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                console.log(`ðŸ” Scan complete. Found ${ownedTokens.length} owned tokens`);
                return ownedTokens;
            }

            // LOCAL-ONLY NFT metadata loading - NO IPFS/REMOTE REQUESTS
            async getRealNFTMetadata(tokenId) {
                // Validate token ID range first
                if (!tokenId || tokenId < 1 || tokenId > 2222) {
                    console.log(`âŒ Invalid token ID: ${tokenId} - must be between 1-2222`);
                    return null;
                }
                
                try {
                    console.log(`ðŸ“ Loading LOCAL metadata for token ${tokenId}...`);
                    
                    // ONLY use local metadata - skip blockchain/IPFS entirely
                    const localMetadata = await this.loadLocalMetadata(tokenId);
                    if (localMetadata) {
                        console.log(`âœ… LOCAL SUCCESS: Loaded metadata for token #${tokenId}`);
                        return localMetadata;
                    }
                    
                    console.log(`âŒ LOCAL FAILED: No metadata found for token #${tokenId}`);
                    return null;
                    
                } catch (error) {
                    console.warn(`âš ï¸ Error loading local metadata for token ${tokenId}:`, error);
                    return null;
                }
            }

            // Load local metadata file - LOCAL PATHS ONLY
            async loadLocalMetadata(tokenId) {
                try {
                    console.log(`ðŸ“ Loading local metadata for token #${tokenId}...`);
                    
                    // ONLY use relative local paths - no absolute paths that resolve to remote URLs
                    const possiblePaths = [
                        `./public/metadata/${tokenId}.json`,
                        `./metadata/${tokenId}.json`
                    ];
                    
                    for (const path of possiblePaths) {
                        try {
                            console.log(`ðŸ” Trying LOCAL path: ${path}`);
                            const response = await fetch(path);
                            if (response.ok) {
                                const metadata = await response.json();
                                console.log(`âœ… Local metadata loaded for token #${tokenId} from ${path}:`, metadata);
                                return metadata;
                            } else {
                                console.log(`âŒ Local path ${path} returned ${response.status}`);
                            }
                        } catch (error) {
                            console.log(`âŒ Local path ${path} failed: ${error.message}`);
                        }
                    }
                    
                    console.log(`âŒ All local paths failed for token #${tokenId}`);
                    return null;
                } catch (error) {
                    console.log(`âŒ Error loading local metadata for token #${tokenId}:`, error);
                    return null;
                }
            }

            // REMOVED: No longer using remote metadata - LOCAL ONLY

            // Extract token ID from metadata (from name or other fields)
            extractTokenIdFromMetadata(metadata) {
                try {
                    // Method 1: Extract from name field (e.g., "Otterful Otters #102")
                    if (metadata.name) {
                        const nameMatch = metadata.name.match(/#(\d+)/);
                        if (nameMatch) {
                            return parseInt(nameMatch[1]);
                        }
                    }
                    
                    // Method 2: Extract from description field
                    if (metadata.description) {
                        const descMatch = metadata.description.match(/#(\d+)/);
                        if (descMatch) {
                            return parseInt(descMatch[1]);
                        }
                    }
                    
                    // Method 3: Check if there's a token_id field
                    if (metadata.token_id !== undefined) {
                        return parseInt(metadata.token_id);
                    }
                    
                    // Method 4: Check if there's an id field
                    if (metadata.id !== undefined) {
                        return parseInt(metadata.id);
                    }
                    
                    console.log(`âš ï¸ Could not extract token ID from metadata:`, metadata);
                    return null;
                } catch (error) {
                    console.log(`âš ï¸ Error extracting token ID from metadata:`, error);
                    return null;
                }
            }

            // Improved tokenURI getter with proper ABI decoding
            async getTokenURI(tokenId) {
                try {
                    const data = '0xc87b56dd' + tokenId.toString(16).padStart(64, '0');
                    
                    const result = await window.ethereum.request({
                        method: 'eth_call',
                        params: [{
                            to: this.contractAddress,
                            data: data
                        }, 'latest']
                    });
                    
                    if (result && result !== '0x' && result.length > 2) {
                        // Proper ABI string decoding
                        const uri = this.decodeStringFromHex(result);
                        console.log(`ðŸ”— Decoded URI for token ${tokenId}: ${uri}`);
                        return uri;
                    }
                    
                    return null;
                } catch (error) {
                    console.error(`âŒ Error getting tokenURI for ${tokenId}:`, error);
                    return null;
                }
            }

            // Improved hex string decoder
            decodeStringFromHex(hexString) {
                try {
                    const hex = hexString.slice(2); // Remove 0x
                    
                    if (hex.length >= 128) {
                        // ABI encoded string format
                        // Skip first 32 bytes (offset), next 32 bytes is length
                        const lengthHex = hex.slice(64, 128);
                        const length = parseInt(lengthHex, 16);
                        
                        if (length > 0 && length < 1000) { // Reasonable length
                            const dataHex = hex.slice(128, 128 + (length * 2));
                            let result = '';
                            
                            for (let i = 0; i < dataHex.length; i += 2) {
                                const byte = parseInt(dataHex.substr(i, 2), 16);
                                if (byte !== 0) {
                                    result += String.fromCharCode(byte);
                                }
                            }
                            
                            return result.trim();
                        }
                    }
                    
                    // Fallback: try direct conversion
                    let result = '';
                    for (let i = 0; i < hex.length; i += 2) {
                        const byte = parseInt(hex.substr(i, 2), 16);
                        if (byte === 0) break;
                        if (byte >= 32 && byte <= 126) { // Printable ASCII
                            result += String.fromCharCode(byte);
                        }
                    }
                    
                    return result.trim();
                    
                } catch (error) {
                    console.warn('Error decoding hex string:', error);
                    return null;
                }
            }

            // Fetch metadata from URI (handles HTTP and IPFS)
            async fetchMetadataFromURI(uri) {
                try {
                    let fetchUrl = uri;
                    
                    // Convert IPFS URLs to HTTP
                    if (uri.startsWith('ipfs://')) {
                        const ipfsHash = uri.replace('ipfs://', '');
                        // Try multiple IPFS gateways
                        const gateways = [
                            'https://ipfs.io/ipfs/',
                            'https://gateway.pinata.cloud/ipfs/',
                            'https://cloudflare-ipfs.com/ipfs/'
                        ];
                        
                        for (const gateway of gateways) {
                            try {
                                fetchUrl = gateway + ipfsHash;
                                console.log(`ðŸŒ Trying IPFS gateway: ${fetchUrl}`);
                                
                                const response = await fetch(fetchUrl, {
                                    method: 'GET',
                                    headers: {
                                        'Accept': 'application/json'
                                    },
                                    // Add timeout
                                    signal: AbortSignal.timeout(10000) // 10 second timeout
                                });
                                
                                if (response.ok) {
                                    const metadata = await response.json();
                                    console.log(`âœ… Successfully fetched metadata from ${gateway}`);
                                    return metadata;
                                }
                            } catch (error) {
                                console.log(`âš ï¸ Gateway ${gateway} failed: ${error.message}`);
                                continue;
                            }
                        }
                        
                        throw new Error('All IPFS gateways failed');
                        
                    } else if (uri.startsWith('http')) {
                        // Direct HTTP fetch
                        console.log(`ðŸŒ Fetching from HTTP: ${fetchUrl}`);
                        
                        const response = await fetch(fetchUrl, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json'
                            },
                            signal: AbortSignal.timeout(10000)
                        });
                        
                        if (response.ok) {
                            return await response.json();
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                    } else {
                        throw new Error(`Unsupported URI format: ${uri}`);
                    }
                    
                } catch (error) {
                    console.warn(`âš ï¸ Error fetching metadata from ${uri}:`, error.message);
                    return null;
                }
            }

            // Extract traits from the actual NFT metadata
            extractTraitsFromMetadata(metadata) {
                const traits = [];
                
                if (metadata.attributes && Array.isArray(metadata.attributes)) {
                    metadata.attributes.forEach(attr => {
                        if (attr.trait_type && attr.value) {
                            // Create consistent trait format
                            const trait = `${attr.trait_type}-${attr.value}`;
                            traits.push(trait);
                        }
                    });
                }
                
                // If no traits found, add a default
                if (traits.length === 0) {
                    traits.push('Base-Normal');
                }
                
                console.log(`ðŸŽ¨ Extracted traits:`, traits);
                return traits;
            }

            // Process image URL to use compressed PNG images from public folder
            processImageUrl(imageUrl, tokenId) {
                // Only use compressed PNG image if token ID is valid
                if (tokenId && tokenId >= 1 && tokenId <= 2222) {
                    console.log(`ðŸ–¼ï¸ Using compressed PNG for token #${tokenId}: public/images_compressed/${tokenId}.png`);
                    return `public/images_compressed/${tokenId}.png`;
                }
                
                // NO FALLBACK - return null if invalid token ID
                console.log(`âŒ Invalid token ID: ${tokenId} - NO FALLBACK`);
                return null;
            }

            // âŒ REMOVED: No more basic NFTs - only show real metadata
            // createBasicNFT(tokenId) {
            //     return {
            //         tokenId: tokenId,
            //         name: `Otterful Otter #${tokenId}`,
            //         traits: ['Base-Normal'],
            //         multiplier: 1.0,
            //         perks: [],
            //         rarity: 'common',
            //         image: null,
            //         description: `Otterful Otter #${tokenId} (metadata unavailable)`
            //     };
            // }

            // Add this new function to generate traits based on token ID
            generateTraitsFromTokenId(tokenId) {
                console.log(`ðŸŽ¨ Generating traits for token ${tokenId}...`);
                
                // Use token ID to deterministically generate traits
                const traits = [];
                
                // Hat trait based on token ID
                if (tokenId <= 10) {
                    traits.push('Hat-Stealth-v2'); // Ultra rare for first 10
                } else if (tokenId <= 50) {
                    traits.push('Hat-Plumber-v5'); // Very rare for next 40
                } else if (tokenId <= 150) {
                    traits.push('Hat-Plumber-v3'); // Rare for next 100
                } else if (tokenId <= 500) {
                    traits.push('Hat-Pirate'); // Uncommon
                } else {
                    traits.push('Hat-Baseball'); // Common for rest
                }
                
                // Fur trait based on token ID modulo
                const furMod = tokenId % 5;
                switch (furMod) {
                    case 0: traits.push('Fur-Golden'); break;
                    case 1: traits.push('Fur-Rainbow'); break;
                    case 2: traits.push('Fur-Green'); break;
                    case 3: traits.push('Fur-Blue'); break;
                    default: traits.push('Fur-Brown'); break;
                }
                
                // Eyes trait
                const eyesMod = tokenId % 4;
                switch (eyesMod) {
                    case 0: traits.push('Eyes-Laser'); break;
                    case 1: traits.push('Eyes-Diamond'); break;
                    case 2: traits.push('Eyes-Yellow-Scanner'); break;
                    default: traits.push('Eyes-Sunglasses'); break;
                }
                
                // Shirt trait for some tokens
                if (tokenId % 3 === 0) {
                    traits.push('Shirt-Overalls-Orange');
                }
                
                // Base trait for special tokens
                if (tokenId <= 20) {
                    traits.push('Base-Stealth');
                } else {
                    traits.push('Base-Normal');
                }
                
                console.log(`ðŸŽ¨ Generated traits for token ${tokenId}:`, traits);
                return traits;
            }

            // Add this function to update the UI after loading NFTs
            updateNFTDisplay() {
                console.log('ðŸ–¥ï¸ Updating NFT display in UI...');
                console.log(`ðŸ“Š userNFTs array length: ${this.userNFTs.length}`);
                console.log(`ðŸ“‹ userNFTs array:`, this.userNFTs);
                
                // Update NFT count displays
                const totalNftsEl = document.getElementById('totalNfts');
                const stakedNftsEl = document.getElementById('stakedNfts');
                
                if (totalNftsEl) {
                    totalNftsEl.textContent = this.userNFTs.length;
                    console.log(`ðŸ“Š Updated total NFTs display: ${this.userNFTs.length}`);
                }
                
                if (stakedNftsEl) {
                    stakedNftsEl.textContent = this.stakedNFTs.length;
                    console.log(`ðŸ“Š Updated staked NFTs display: ${this.stakedNFTs.length}`);
                }
                
                // Update any NFT grid displays
                this.updateNFTGrid();
                
                // Force update profile gallery if it exists
                const profileGallery = document.getElementById('profileNFTGallery');
                if (profileGallery) {
                    console.log('ðŸ”„ Force updating profile gallery...');
                    profileGallery.innerHTML = '';
                    if (this.userNFTs.length > 0) {
                        this.userNFTs.forEach((nft, index) => {
                            try {
                                const nftElement = this.createNFTElement(nft);
                                profileGallery.appendChild(nftElement);
                                console.log(`âœ… Force-added NFT ${index + 1}: Token #${nft.tokenId}`);
                            } catch (error) {
                                console.error(`âŒ Error force-adding NFT ${nft.tokenId}:`, error);
                            }
                        });
                    }
                }
                
                // Save data to localStorage whenever display is updated (only if we have data)
                if (this.userNFTs.length > 0 || this.stakedNFTs.length > 0 || this.fishCoins > 0) {
                    this.saveNFTsToStorage();
                }
                
                console.log('âœ… UI update completed');
            }

            // Add this function to update NFT grid display
            updateNFTGrid() {
                console.log('ðŸ–¼ï¸ Updating NFT grid display...');
                console.log(`ðŸ“Š Current userNFTs count: ${this.userNFTs.length}`);
                if (this.userNFTs.length > 0) {
                    console.log(`ðŸ“‹ NFT token IDs:`, this.userNFTs.map(n => n.tokenId).join(', '));
                }
                
                // Look for NFT container elements - ADD THE CORRECT CONTAINER ID
                const nftContainers = [
                    document.getElementById('profileNFTGallery'), // âœ… MAIN NFT GALLERY CONTAINER
                    document.getElementById('nftCollection'),
                    document.getElementById('userNfts'),
                    document.querySelector('.nft-grid'),
                    document.querySelector('.nft-container')
                ];
                
                let containerUpdated = false;
                
                nftContainers.forEach(container => {
                    if (container) {
                        console.log(`ðŸ–¼ï¸ Found NFT container: ${container.id || container.className}`);
                        
                        // Clear existing content
                        container.innerHTML = '';
                        
                        // Check if we have NFTs to display
                        if (this.userNFTs.length === 0) {
                            console.log('ðŸ“­ No NFTs to display');
                            container.innerHTML = '<div style="text-align: center; color: #FFD700; padding: 20px;">NO NFTS FOUND IN WALLET</div>';
                        } else {
                            console.log(`ðŸ–¼ï¸ Adding ${this.userNFTs.length} NFTs to container ${container.id || container.className}`);
                            
                            // Add NFTs to container
                            this.userNFTs.forEach((nft, index) => {
                                try {
                                    const nftElement = this.createNFTElement(nft);
                                    container.appendChild(nftElement);
                                    console.log(`âœ… Added NFT ${index + 1}/${this.userNFTs.length}: Token #${nft.tokenId} to gallery`);
                                } catch (error) {
                                    console.error(`âŒ Error creating NFT element for token ${nft.tokenId}:`, error);
                                }
                            });
                            
                            console.log(`âœ… Successfully added ${this.userNFTs.length} NFTs to ${container.id || container.className}`);
                        }
                        
                        containerUpdated = true;
                    }
                });
                
                if (!containerUpdated) {
                    console.error('âŒ No NFT containers found! Available containers:', nftContainers.map(c => c ? (c.id || c.className) : 'null'));
                } else {
                    console.log('âœ… NFT grid update completed');
                }
            }

            // Add duplicate check function
            checkForDuplicateNFT(tokenId) {
                const existingIndex = this.userNFTs.findIndex(nft => nft.tokenId === tokenId);
                if (existingIndex !== -1) {
                    console.log(`âš ï¸ Token #${tokenId} already loaded, skipping duplicate`);
                    return true;
                }
                return false;
            }

            // Save NFTs to localStorage - SIMPLIFIED AND BULLETPROOF
            saveNFTsToStorage() {
                try {
                    console.log('ðŸ’¾ SAVING DATA TO LOCALSTORAGE...');
                    console.log('ðŸ’¾ Account:', this.account);
                    console.log('ðŸ’¾ User NFTs:', this.userNFTs.length);
                    console.log('ðŸ’¾ Staked NFTs:', this.stakedNFTs.length);
                    console.log('ðŸŸ Fish coins:', this.fishCoins);
                    
                    // Create the data object
                    const nftData = {
                        userNFTs: this.userNFTs || [],
                        stakedNFTs: this.stakedNFTs || [],
                        fishCoins: this.fishCoins || 0,
                        stakingStartTimes: this.stakingStartTimes || {},
                        account: this.account || '',
                        timestamp: Date.now()
                    };
                    
                    // Save to localStorage
                    const jsonString = JSON.stringify(nftData);
                    localStorage.setItem('otterWalletNFTs', jsonString);
                    
                    // Double-check it saved
                    const saved = localStorage.getItem('otterWalletNFTs');
                    if (saved) {
                        console.log('âœ… DATA SAVED TO LOCALSTORAGE SUCCESSFULLY!');
                        console.log('âœ… Saved data size:', saved.length, 'characters');
                        console.log('âœ… Full saved data:', JSON.parse(saved));
                    } else {
                        console.log('âŒ FAILED TO SAVE DATA TO LOCALSTORAGE!');
                    }
                    
                } catch (error) {
                    console.error('âŒ CRITICAL ERROR SAVING DATA:', error);
                }
            }

            // Load NFTs from localStorage - SIMPLIFIED AND BULLETPROOF
            loadNFTsFromStorage() {
                try {
                    console.log('ðŸ” LOADING DATA FROM LOCALSTORAGE...');
                    console.log('ðŸ” Current account:', this.account);
                    
                    const stored = localStorage.getItem('otterWalletNFTs');
                    console.log('ðŸ” Data exists in localStorage:', !!stored);
                    
                    if (stored) {
                        console.log('ðŸ” Found stored data, parsing...');
                        const nftData = JSON.parse(stored);
                        console.log('ðŸ” Parsed data:', nftData);
                        
                        // Check if accounts match
                        const storedAccount = nftData.account || '';
                        const currentAccount = this.account || '';
                        const accountsMatch = storedAccount.toLowerCase() === currentAccount.toLowerCase();
                        
                        console.log('ðŸ” Stored account:', storedAccount);
                        console.log('ðŸ” Current account:', currentAccount);
                        console.log('ðŸ” Accounts match:', accountsMatch);
                        
                        if (accountsMatch) {
                            // Load the data
                            this.userNFTs = nftData.userNFTs || [];
                            this.stakedNFTs = nftData.stakedNFTs || [];
                            this.fishCoins = nftData.fishCoins || 0;
                            this.stakingStartTimes = nftData.stakingStartTimes || {};
                            
                            console.log('âœ… DATA LOADED FROM LOCALSTORAGE SUCCESSFULLY!');
                            console.log('âœ… User NFTs loaded:', this.userNFTs.length);
                            console.log('âœ… Staked NFTs loaded:', this.stakedNFTs.length);
                            console.log('âœ… Fish coins loaded:', this.fishCoins);
                            console.log('âœ… Staking times loaded:', Object.keys(this.stakingStartTimes).length);
                            
                            return true;
                        } else {
                            console.log('âŒ ACCOUNT MISMATCH - Cannot load data');
                            console.log('âŒ Stored account:', storedAccount);
                            console.log('âŒ Current account:', currentAccount);
                        }
                    } else {
                        console.log('âŒ NO DATA FOUND IN LOCALSTORAGE');
                    }
                } catch (error) {
                    console.error('âŒ CRITICAL ERROR LOADING DATA:', error);
                }
                return false;
            }

            // Add this function to create individual NFT elements for display
            createNFTElement(nft) {
                console.log(`ðŸŽ¨ Creating NFT element for ${nft.name} (Token #${nft.tokenId})`);
                
                const nftDiv = document.createElement('div');
                nftDiv.className = 'nft-card';
                nftDiv.style.cssText = `
                    background: rgba(255, 215, 0, 0.1);
                    border: 2px solid #FFD700;
                    border-radius: 15px;
                    padding: 15px;
                    text-align: center;
                    color: #FFD700;
                    transition: all 0.3s ease;
                    cursor: pointer;
                `;
                
                nftDiv.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <h4 style="margin: 0; color: #FFD700; font-size: 16px;">${nft.name}</h4>
                        <div style="margin-top: 5px; margin-bottom: 5px;">
                            <span style="background: #00FFFF; color: #000; padding: 3px 10px; border-radius: 10px; font-size: 11px; font-weight: bold;">Token #${nft.tokenId}</span>
                            <span style="background: #FFD700; color: #000; padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: bold; margin-left: 5px;">${nft.rarity.toUpperCase()}</span>
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        ${nft.image ? `<img src="${nft.image}" alt="${nft.name}" style="width: 80px; height: 80px; object-fit: cover; border-radius: 10px;">` : '<div style="width: 80px; height: 80px; background: #f0f0f0; border-radius: 10px; display: flex; align-items: center; justify-content: center; color: #999; font-size: 12px;">NO IMAGE</div>'}
                    </div>
                    <div style="margin-bottom: 10px; font-size: 12px;">
                        <div style="margin-bottom: 5px;"><strong>Multiplier:</strong> ${nft.multiplier}x</div>
                        <div style="font-size: 10px; color: #FFA500;">${nft.traits.slice(0, 3).join(', ')}${nft.traits.length > 3 ? '...' : ''}</div>
                    </div>
                    <div>
                        <!-- Wallet staking button removed -->
                    </div>
                `;
                
                console.log(`âœ… NFT element created for ${nft.name}`);
                return nftDiv;
            }

            // Add message display function
            showMessage(message, type = 'info') {
                console.log(`ðŸ“¢ ${type.toUpperCase()}: ${message}`);
                
                // Create or find message container
                let messageContainer = document.getElementById('messageContainer');
                if (!messageContainer) {
                    messageContainer = document.createElement('div');
                    messageContainer.id = 'messageContainer';
                    messageContainer.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        z-index: 10000;
                        max-width: 300px;
                        padding: 15px;
                        border-radius: 8px;
                        color: white;
                        font-weight: bold;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                        transition: all 0.3s ease;
                    `;
                    document.body.appendChild(messageContainer);
                }
                
                // Set background color based on message type
                let bgColor = '#2196F3'; // default blue
                if (type === 'success') bgColor = '#4CAF50';
                if (type === 'error') bgColor = '#F44336';
                if (type === 'warning') bgColor = '#FF9800';
                
                messageContainer.style.backgroundColor = bgColor;
                messageContainer.textContent = message;
                messageContainer.style.display = 'block';
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    messageContainer.style.display = 'none';
                }, 5000);
            }
            
            // Debug function to check localStorage
            debugLocalStorage() {
                console.log('ðŸ” CHECKING LOCALSTORAGE CONTENTS...');
                const stored = localStorage.getItem('otterWalletNFTs');
                if (stored) {
                    const data = JSON.parse(stored);
                    console.log('âœ… FOUND STORED DATA IN LOCALSTORAGE:');
                    console.log('âœ… Account:', data.account);
                    console.log('âœ… User NFTs:', data.userNFTs?.length || 0);
                    console.log('âœ… Staked NFTs:', data.stakedNFTs?.length || 0);
                    console.log('âœ… Fish coins:', data.fishCoins || 0);
                    console.log('âœ… Staking start times:', Object.keys(data.stakingStartTimes || {}).length);
                    console.log('âœ… Full data:', data);
                } else {
                    console.log('âŒ NO DATA FOUND IN LOCALSTORAGE');
                }
            }
            
            // Test localStorage persistence
            testLocalStoragePersistence() {
                console.log('ðŸ§ª TESTING LOCALSTORAGE PERSISTENCE...');
                
                // 1. Check current state
                console.log('1ï¸âƒ£ Current state:');
                console.log('   - userNFTs:', this.userNFTs.length);
                console.log('   - stakedNFTs:', this.stakedNFTs.length);
                console.log('   - fishCoins:', this.fishCoins);
                console.log('   - account:', this.account);
                
                // 2. Add some test data
                console.log('2ï¸âƒ£ Adding test data...');
                this.userNFTs = [
                    {
                        tokenId: '9999',
                        name: 'Test NFT #9999',
                        rarity: 'test',
                        multiplier: 1.0,
                        image: 'https://via.placeholder.com/150/FF0000/000000?text=TEST',
                        traits: ['Test Trait']
                    }
                ];
                this.stakedNFTs = [
                    {
                        tokenId: '8888',
                        name: 'Staked NFT #8888',
                        rarity: 'test',
                        multiplier: 2.0,
                        image: 'https://via.placeholder.com/150/00FF00/000000?text=STAKED',
                        traits: ['Staked Trait']
                    }
                ];
                this.fishCoins = 100;
                this.stakingStartTimes = { '8888': Date.now() };
                
                // 3. Save to localStorage
                console.log('3ï¸âƒ£ Saving to localStorage...');
                this.saveNFTsToStorage();
                
                // 4. Clear memory
                console.log('4ï¸âƒ£ Clearing memory...');
                this.userNFTs = [];
                this.stakedNFTs = [];
                this.fishCoins = 0;
                this.stakingStartTimes = {};
                
                // 5. Load from localStorage
                console.log('5ï¸âƒ£ Loading from localStorage...');
                const loaded = this.loadNFTsFromStorage();
                
                // 6. Check result
                console.log('6ï¸âƒ£ Result:');
                console.log('   - Loaded successfully:', loaded);
                console.log('   - userNFTs after load:', this.userNFTs.length);
                console.log('   - stakedNFTs after load:', this.stakedNFTs.length);
                console.log('   - fishCoins after load:', this.fishCoins);
                
                if (loaded && (this.userNFTs.length > 0 || this.stakedNFTs.length > 0)) {
                    console.log('âœ… LOCALSTORAGE PERSISTENCE TEST PASSED!');
                } else {
                    console.log('âŒ LOCALSTORAGE PERSISTENCE TEST FAILED!');
                }
            }
            
            // Force save test data
            forceSaveTestData() {
                console.log('ðŸ’¾ FORCE SAVING TEST DATA...');
                
                // Set account if not set
                if (!this.account) {
                    this.account = '0x16E315e37cDEda413D22a6899FFF67A4B001D91B';
                    console.log('   - Set test account:', this.account);
                }
                
                // Add test data
                this.userNFTs = [
                    {
                        tokenId: '1111',
                        name: 'Test NFT #1111',
                        rarity: 'common',
                        multiplier: 1.2,
                        image: 'https://via.placeholder.com/150/FFD700/000000?text=1111',
                        traits: ['Blue Eyes', 'Red Hat']
                    },
                    {
                        tokenId: '2222',
                        name: 'Test NFT #2222',
                        rarity: 'rare',
                        multiplier: 1.8,
                        image: 'https://via.placeholder.com/150/00FFFF/000000?text=2222',
                        traits: ['Green Eyes', 'Crown']
                    }
                ];
                
                this.stakedNFTs = [
                    {
                        tokenId: '3333',
                        name: 'Staked NFT #3333',
                        rarity: 'epic',
                        multiplier: 2.5,
                        image: 'https://via.placeholder.com/150/FF00FF/000000?text=3333',
                        traits: ['Rainbow Eyes', 'Diamond Crown']
                    }
                ];
                
                this.fishCoins = 250;
                this.stakingStartTimes = { '3333': Date.now() - 3600000 }; // 1 hour ago
                
                // Save to localStorage
                this.saveNFTsToStorage();
                
                console.log('âœ… Test data saved! Now refresh the page and check if it loads.');
            }
            
            // Clear localStorage completely
            clearLocalStorage() {
                console.log('ðŸ—‘ï¸ CLEARING LOCALSTORAGE COMPLETELY...');
                localStorage.removeItem('otterWalletNFTs');
                localStorage.clear(); // Clear ALL localStorage
                console.log('âœ… localStorage completely cleared!');
                console.log('ðŸ”„ Now refresh the page and connect your wallet - no demo NFTs will load!');
            }
            
            // Force clear and reset everything
            forceReset() {
                console.log('ðŸ”„ FORCE RESETTING EVERYTHING...');
                
                // Clear localStorage
                localStorage.clear();
                
                // Clear memory
                this.userNFTs = [];
                this.stakedNFTs = [];
                this.fishCoins = 0;
                this.stakingStartTimes = {};
                
                // Clear UI
                const gallery = document.getElementById('profileNFTGallery');
                if (gallery) {
                    gallery.innerHTML = '<div style="text-align: center; color: #FFD700; padding: 20px;">NO NFTS FOUND IN WALLET</div>';
                }
                
                console.log('âœ… FORCE RESET COMPLETE!');
                console.log('ðŸ”„ Refresh the page now - everything is cleared!');
            }
            
            // Nuclear option - clear everything and reload page
            nuclearClear() {
                console.log('ðŸ’¥ NUCLEAR CLEAR - CLEARING EVERYTHING AND RELOADING...');
                
                // Clear all localStorage
                localStorage.clear();
                
                // Clear sessionStorage too
                sessionStorage.clear();
                
                // Clear memory
                this.userNFTs = [];
                this.stakedNFTs = [];
                this.fishCoins = 0;
                this.stakingStartTimes = {};
                
                console.log('âœ… NUCLEAR CLEAR COMPLETE!');
                console.log('ðŸ”„ RELOADING PAGE...');
                
                // Force reload the page
                window.location.reload(true);
            }
            
            // Test function to manually save current data
            testSaveData() {
                console.log('ðŸ§ª TESTING DATA SAVE...');
                this.saveNFTsToStorage();
                console.log('ðŸ§ª SAVE TEST COMPLETE');
            }
            
            // Test function to manually load data
            testLoadData() {
                console.log('ðŸ§ª TESTING DATA LOAD...');
                const result = this.loadNFTsFromStorage();
                console.log('ðŸ§ª LOAD TEST RESULT:', result);
                return result;
            }
            
            // Manual load function for debugging
            manualLoadNFTs() {
                console.log('ðŸ”§ MANUAL NFT LOAD TRIGGERED...');
                const loaded = this.loadNFTsFromStorage();
                
                // Check if we actually have NFTs after loading
                if (loaded && (this.userNFTs.length > 0 || this.stakedNFTs.length > 0)) {
                    this.updateNFTDisplay();
                    this.updateUI();
                    console.log('âœ… MANUAL NFT LOAD COMPLETE!');
                    return true;
                } else {
                    console.log('âŒ MANUAL NFT LOAD FAILED - NO DATA FOUND OR NO NFTS');
                    this.showMessage('No saved NFTs found. Use "Check Token" or "Load Multiple" to load your NFTs.', 'info');
                    return false;
                }
            }
            
            // Test function to debug NFT display issues
            testNFTDisplay() {
                console.log('ðŸ§ª TESTING NFT DISPLAY SYSTEM...');
                console.log('ðŸ§ª Current userNFTs:', this.userNFTs.length);
                console.log('ðŸ§ª Current stakedNFTs:', this.stakedNFTs.length);
                
                // Load from localStorage instead of demo NFTs
                const loaded = this.loadNFTsFromStorage();
                if (loaded && (this.userNFTs.length > 0 || this.stakedNFTs.length > 0)) {
                    console.log('ðŸ§ª Loaded saved NFTs, now updating display...');
                } else {
                    console.log('ðŸ§ª No saved NFTs found');
                    this.showMessage('No saved NFTs found. Use "Check Token" or "Load Multiple" to load your NFTs.', 'info');
                    return;
                }
                
                // Force update display
                this.updateNFTDisplay();
                this.updateUI();
                
                console.log('ðŸ§ª Display update complete. Check the UI now!');
                console.log('ðŸ§ª You should see your saved NFTs in the gallery.');
            }
            
            // Comprehensive debug function to find the issue
            debugNFTDisplayIssue() {
                console.log('ðŸ” COMPREHENSIVE NFT DISPLAY DEBUG...');
                
                // 1. Check if we have NFTs
                console.log('1ï¸âƒ£ NFT Data Check:');
                console.log('   - userNFTs length:', this.userNFTs.length);
                console.log('   - userNFTs:', this.userNFTs);
                
                // 2. Check if containers exist
                console.log('2ï¸âƒ£ Container Check:');
                const containers = [
                    'profileNFTGallery',
                    'nftCollection', 
                    'userNfts',
                    '.nft-grid',
                    '.nft-container'
                ];
                
                containers.forEach(containerId => {
                    let element;
                    if (containerId.startsWith('.')) {
                        element = document.querySelector(containerId);
                    } else {
                        element = document.getElementById(containerId);
                    }
                    console.log(`   - ${containerId}:`, element ? 'FOUND' : 'NOT FOUND');
                    if (element) {
                        console.log(`     - Visible:`, element.offsetParent !== null);
                        console.log(`     - Display:`, element.style.display);
                        console.log(`     - InnerHTML length:`, element.innerHTML.length);
                    }
                });
                
                // 3. Check localStorage for saved NFTs
                console.log('3ï¸âƒ£ Checking localStorage for saved NFTs...');
                const loaded = this.loadNFTsFromStorage();
                console.log('   - Loaded from localStorage:', loaded);
                console.log('   - userNFTs after load:', this.userNFTs.length);
                
                // 4. Test container update
                console.log('4ï¸âƒ£ Testing Container Update...');
                const mainContainer = document.getElementById('profileNFTGallery');
                if (mainContainer) {
                    console.log('   - Found main container, clearing and adding NFTs...');
                    mainContainer.innerHTML = '';
                    
                    this.userNFTs.forEach((nft, index) => {
                        const nftElement = this.createNFTElement(nft);
                        mainContainer.appendChild(nftElement);
                        console.log(`   - Added NFT ${index + 1}: ${nft.name}`);
                    });
                    
                    console.log('   - Container innerHTML length after update:', mainContainer.innerHTML.length);
                } else {
                    console.log('   - Main container not found!');
                }
                
                // 5. Check if profile panel is visible
                console.log('5ï¸âƒ£ Profile Panel Check:');
                const profilePanel = document.getElementById('profilePanel');
                console.log('   - Profile panel element:', profilePanel ? 'FOUND' : 'NOT FOUND');
                if (profilePanel) {
                    console.log('   - Profile panel display:', profilePanel.style.display);
                    console.log('   - Profile panel visible:', profilePanel.offsetParent !== null);
                }
                
                console.log('ðŸ” DEBUG COMPLETE - Check console for details!');
            }
            
            // Force show NFTs in profile tab
            forceShowNFTs() {
                console.log('ðŸš€ FORCE SHOWING NFTS...');
                
                // 1. Load from localStorage
                const loaded = this.loadNFTsFromStorage();
                if (loaded && (this.userNFTs.length > 0 || this.stakedNFTs.length > 0)) {
                    console.log('âœ… Loaded saved NFTs');
                } else {
                    console.log('âš ï¸ No saved NFTs found');
                    this.showMessage('No saved NFTs found. Use "Check Token" or "Load Multiple" to load your NFTs.', 'info');
                    return;
                }
                
                // 2. Show profile panel
                const profilePanel = document.getElementById('profilePanel');
                if (profilePanel) {
                    profilePanel.style.display = 'block';
                    console.log('âœ… Profile panel shown');
                }
                
                // 3. Update NFT display
                this.updateNFTDisplay();
                this.updateUI();
                
                // 4. Force update the gallery
                const gallery = document.getElementById('profileNFTGallery');
                if (gallery) {
                    gallery.innerHTML = '';
                    this.userNFTs.forEach(nft => {
                        const element = this.createNFTElement(nft);
                        gallery.appendChild(element);
                    });
                    console.log('âœ… Gallery updated with', this.userNFTs.length, 'NFTs');
                } else {
                    console.log('âŒ Gallery container not found!');
                }
                
                console.log('ðŸš€ FORCE SHOW COMPLETE - Check the Profile panel now!');
            }
            

            
            async getOwnedTokenIds() {
                console.log('ðŸ” ENABLING BLOCKCHAIN SCANNING - Looking for your real owned NFTs');
                console.log('ðŸ“‹ Contract address:', this.contractAddress);
                console.log('ðŸ‘¤ User address:', this.account);
                
                const tokenIds = [];
                const TOTAL_OTTERS = 2222;
                const BATCH_SIZE = 100; // Smaller batches to reduce RPC errors
                
                console.log(`ðŸ” Scanning ${TOTAL_OTTERS} Otterful Otters for your wallet...`);
                
                for (let i = 0; i < TOTAL_OTTERS; i += BATCH_SIZE) {
                    const endToken = Math.min(i + BATCH_SIZE, TOTAL_OTTERS);
                    console.log(`ðŸ“¦ Scanning tokens ${i}-${endToken - 1}...`);
                    
                    for (let j = i; j < endToken; j++) {
                        try {
                            const owner = await this.getTokenOwner(j);
                            if (owner && owner.toLowerCase() === this.account.toLowerCase()) {
                                console.log(`âœ… Found owned token: ${j}`);
                                tokenIds.push(j);
                            }
                            
                            // Add delay every 10 calls to prevent RPC overload
                            if ((j - i) % 10 === 0 && (j - i) > 0) {
                                console.log('â³ Pausing to prevent RPC overload...');
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            }
                        } catch (error) {
                            console.log(`âŒ Error checking token ${j}:`, error.message);
                            // Continue scanning even if some tokens fail
                        }
                    }
                    
                    // Pause between batches
                    if (endToken < TOTAL_OTTERS) {
                        console.log('â³ Pausing between batches...');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }
                
                console.log('ðŸ“Š Blockchain scan completed. Found tokens:', tokenIds);
                
                // If no tokens found, use sample tokens for testing
                if (tokenIds.length === 0) {
                    console.log('âš ï¸ No owned tokens found, using sample tokens for testing');
                    return [1499, 1000, 500, 1];
                }
                
                return tokenIds;
            }
            
            // SIMPLIFIED getTokenOwner that actually works
            async getTokenOwner(tokenId) {
                try {
                    // Simple ownerOf call
                    const data = '0x6352211e' + tokenId.toString(16).padStart(64, '0');
                    
                    const result = await window.ethereum.request({
                        method: 'eth_call',
                        params: [{
                            to: this.contractAddress,
                            data: data
                        }, 'latest']
                    });
                    
                    if (result && result !== '0x' && result.length >= 26) {
                        const owner = '0x' + result.slice(-40); // Get last 40 chars for address
                        return owner;
                    }
                    
                    return null;
                } catch (error) {
                    // Check if it's an RPC error and handle gracefully
                    if (error.code === -32603 || error.message.includes('Internal JSON-RPC error')) {
                        console.log(`âš ï¸ RPC error for token ${tokenId}, will retry later`);
                        // Don't log the full error to avoid spam
                        return null;
                    } else {
                        console.log(`âš ï¸ Error getting owner for token ${tokenId}: ${error.message}`);
                        return null;
                    }
                }
            }
            
            async getLocalTokenMetadata(tokenId) {
                try {
                    console.log(`ðŸ“ Loading metadata for token ${tokenId}...`);
                    
                    // First try to load from local files
                    const metadataUrls = [
                        `./metadata/${tokenId}.json`,
                        `/metadata/${tokenId}.json`,
                        `metadata/${tokenId}.json`
                    ];
                    
                    for (const metadataUrl of metadataUrls) {
                        try {
                            console.log(`ðŸ“„ Trying to fetch from: ${metadataUrl}`);
                            const response = await fetch(metadataUrl);
                            
                            if (response.ok) {
                                const metadata = await response.json();
                                console.log(`âœ… Local metadata loaded for token ${tokenId}:`, metadata);
                                return metadata;
                            }
                        } catch (error) {
                            console.log(`âš ï¸ Error fetching from ${metadataUrl}:`, error.message);
                        }
                    }
                    
                    // If local files fail, return null (NO EMBEDDED FALLBACK)
                    console.log(`âŒ No metadata found for token ${tokenId} - returning null`);
                    return null;
                    
                } catch (error) {
                    console.warn(`âš ï¸ Error loading metadata for token ${tokenId}:`, error);
                    return null; // NO EMBEDDED FALLBACK
                }
            }

            // REMOVED: getEmbeddedMetadata function - was causing fake NFTs to appear
            // REMOVED: calculateAttributeRarity function - was part of embedded metadata system

            async getTokenMetadata(tokenId) {
                try {
                    // First get the token URI
                    const tokenURI = await this.getTokenURI(tokenId);
                    console.log(`ðŸ”— Token ${tokenId} URI:`, tokenURI);
                    
                    if (!tokenURI) {
                        console.log(`âš ï¸ No URI found for token ${tokenId}, creating basic NFT`);
                        return {
                            name: `Otter #${tokenId}`,
                            description: 'Base Otterful Otter',
                            attributes: [
                                { trait_type: 'Type', value: 'Base Otter' }
                            ]
                        };
                    }
                    
                    if (tokenURI && tokenURI.startsWith('http')) {
                        console.log(`ðŸŒ Fetching metadata from: ${tokenURI}`);
                        
                        // Try multiple approaches to handle CORS issues
                        let metadata = null;
                        
                        // Approach 1: Direct fetch
                        try {
                            const response = await fetch(tokenURI);
                            console.log(`ðŸ“„ Response status:`, response.status);
                            
                            if (response.ok) {
                                metadata = await response.json();
                                console.log(`ðŸ“„ Parsed metadata for token ${tokenId}:`, metadata);
                                return metadata;
                            } else {
                                console.warn(`âš ï¸ HTTP error ${response.status} for token ${tokenId}`);
                            }
                        } catch (error) {
                            console.warn(`âš ï¸ Direct fetch failed for token ${tokenId}:`, error);
                        }
                        
                        // Approach 2: Try CORS proxy
                        if (!metadata) {
                            try {
                                console.log(`ðŸ”„ Trying CORS proxy for token ${tokenId}...`);
                                const proxyURL = `https://cors-anywhere.herokuapp.com/${tokenURI}`;
                                const response = await fetch(proxyURL);
                                
                                if (response.ok) {
                                    metadata = await response.json();
                                    console.log(`ðŸ“„ Proxy metadata for token ${tokenId}:`, metadata);
                                    return metadata;
                                }
                            } catch (error) {
                                console.warn(`âš ï¸ CORS proxy failed for token ${tokenId}:`, error);
                            }
                        }
                        
                        // Approach 3: Try alternative proxy
                        if (!metadata) {
                            try {
                                console.log(`ðŸ”„ Trying alternative proxy for token ${tokenId}...`);
                                const proxyURL = `https://api.allorigins.win/raw?url=${encodeURIComponent(tokenURI)}`;
                                const response = await fetch(proxyURL);
                                
                                if (response.ok) {
                                    metadata = await response.json();
                                    console.log(`ðŸ“„ Alternative proxy metadata for token ${tokenId}:`, metadata);
                                    return metadata;
                                }
                            } catch (error) {
                                console.warn(`âš ï¸ Alternative proxy failed for token ${tokenId}:`, error);
                            }
                        }
                        
                    } else if (tokenURI && tokenURI.startsWith('ipfs://')) {
                        console.log(`ðŸŒ Converting IPFS URI: ${tokenURI}`);
                        const ipfsGateway = 'https://ipfs.io/ipfs/';
                        const ipfsHash = tokenURI.replace('ipfs://', '');
                        const httpURI = ipfsGateway + ipfsHash;
                        console.log(`ðŸŒ Converting IPFS to HTTP: ${httpURI}`);
                        
                        const response = await fetch(httpURI);
                        if (response.ok) {
                            const metadata = await response.json();
                            console.log(`ðŸ“„ IPFS metadata for token ${tokenId}:`, metadata);
                            return metadata;
                        }
                    } else {
                        console.warn(`âš ï¸ Invalid URI format for token ${tokenId}:`, tokenURI);
                    }
                    
                    // If all else fails, create a basic NFT
                    console.log(`ðŸ“„ Creating basic NFT for token ${tokenId}`);
                    return {
                        name: `Otter #${tokenId}`,
                        description: 'Base Otterful Otter',
                        attributes: [
                            { trait_type: 'Type', value: 'Base Otter' }
                        ]
                    };
                } catch (error) {
                    console.warn(`âš ï¸ Error getting metadata for token ${tokenId}:`, error);
                    // Return basic NFT on error
                    return {
                        name: `Otter #${tokenId}`,
                        description: 'Base Otterful Otter',
                        attributes: [
                            { trait_type: 'Type', value: 'Base Otter' }
                        ]
                    };
                }
            }
            
            async getTokenURI(tokenId) {
                try {
                    console.log(`ðŸ”— Getting token URI for token ${tokenId}...`);
                    const data = '0xc87b56dd' + tokenId.toString().padStart(64, '0');
                    console.log(`ðŸ“‹ TokenURI call data:`, data);
                    
                    const result = await window.ethereum.request({
                        method: 'eth_call',
                        params: [{
                            to: this.contractAddress,
                            data: data
                        }, 'latest']
                    });
                    
                    console.log(`ðŸ“„ TokenURI result for token ${tokenId}:`, result);
                    
                    // Decode the URI from the result
                    if (result && result !== '0x') {
                        // This is a simplified decoder - you might need a proper ABI decoder
                        const uri = this.decodeString(result);
                        console.log(`ðŸ”— Decoded URI for token ${tokenId}:`, uri);
                        return uri;
                    } else {
                        console.log(`âš ï¸ No URI found for token ${tokenId}`);
                        return null;
                    }
                } catch (error) {
                    console.error(`âŒ Error getting token URI for token ${tokenId}:`, error);
                    return null;
                }
            }
            
            decodeString(hexString) {
                try {
                    const hex = hexString.slice(2);
                    
                    // Try ABI string decoding first
                    if (hex.length >= 128) {
                        const lengthHex = hex.slice(64, 128);
                        const length = parseInt(lengthHex, 16);
                        
                        if (length > 0 && length < 1000) {
                            const dataHex = hex.slice(128, 128 + (length * 2));
                            let str = '';
                            for (let i = 0; i < dataHex.length; i += 2) {
                                const byte = parseInt(dataHex.substr(i, 2), 16);
                                if (byte !== 0) str += String.fromCharCode(byte);
                            }
                            console.log('ðŸ” ABI decoded string:', str);
                            return str.trim();
                        }
                    }
                    
                    // Fallback to simple conversion
                    let str = '';
                    for (let i = 0; i < hex.length; i += 2) {
                        const charCode = parseInt(hex.substr(i, 2), 16);
                        if (charCode === 0) break;
                        if (charCode >= 32 && charCode <= 126) {
                            str += String.fromCharCode(charCode);
                        }
                    }
                    console.log('ðŸ” Simple decoded string:', str);
                    return str.trim();
                } catch (error) {
                    console.warn('Error decoding string:', error);
                    return null;
                }
            }
            
            loadSampleNFTs(balance) {
                console.log('ðŸ”„ Loading sample NFTs as fallback...');
                
                // Sample traits based on your actual NFT format
                const sampleTraitCombos = [
                    ['Hat-Stealth-v2', 'Fur-Green', 'Shirt-Overalls-Orange', 'Eyes-Yellow-Scanner', 'Base-Stealth'],
                    ['Hat-Plumber-v5', 'Fur-Golden', 'Shirt-Overalls-V3'],
                    ['Hat-Plumber-v3', 'Fur-Rainbow', 'Eyes-Laser'],
                    ['Hat-Pirate', 'Fur-Golden', 'Eyes-Diamond'],
                    ['Hat-Crown', 'Fur-Rainbow', 'Shirt-Overalls-V2'],
                    ['Hat-Wizard', 'Eyes-Yellow-Scanner', 'Base-Stealth'],
                    ['Fur-Green', 'Eyes-Sunglasses', 'Shirt-Overalls-Orange'],
                    ['Base-Normal']
                ];

                for (let i = 0; i < Math.min(balance, 16); i++) {
                    const traits = sampleTraitCombos[i % sampleTraitCombos.length];
                    this.userNFTs.push({
                        tokenId: i + 1,
                        name: `Otter #${i + 1}`,
                        traits: traits,
                        multiplier: this.calculateMultiplier(traits),
                        perks: this.calculatePerks(traits),
                        rarity: this.calculateRarity(traits)
                    });
                }
            }

            calculateRarity(traits) {
                // Check for legendary traits
                if (traits.some(trait => 
                    trait.includes('Hat-Plumber-v5') || 
                    trait.includes('Hat-Stealth-v2') ||
                    trait.includes('Shirt-Overalls-V3')
                )) return 'legendary';
                
                // Check for epic traits
                if (traits.some(trait => 
                    trait.includes('Hat-Plumber-v3') || 
                    trait.includes('Fur-Golden')
                )) return 'epic';
                
                // Check for rare traits
                if (traits.some(trait => 
                    trait.includes('Hat-') || 
                    trait.includes('Eyes-Laser') ||
                    trait.includes('Base-Stealth')
                )) return 'rare';
                
                return 'common';
            }

            calculateMultiplier(traits) {
                let multiplier = 1.0;
                traits.forEach(trait => {
                    if (this.traitMultipliers[trait]) {
                        multiplier *= this.traitMultipliers[trait];
                    }
                });
                return Math.round(multiplier * 100) / 100;
            }

            calculatePerks(traits) {
                const perks = [];
                traits.forEach(trait => {
                    if (this.gamePerks[trait]) {
                        perks.push(this.gamePerks[trait]);
                    }
                });
                return perks;
            }

            startStakingRewardsTimer() {
                setInterval(() => {
                    if (this.stakedNFTs.length > 0) {
                        this.updateStakingStats();
                        
                        // Calculate and show fish earnings
                        let totalEarned = 0;
                        this.stakedNFTs.forEach(nft => {
                            const stakingTime = Date.now() - this.stakingStartTimes[nft.tokenId];
                            const hoursStaked = stakingTime / (1000 * 60 * 60);
                            totalEarned += Math.floor(hoursStaked * nft.multiplier * 10 / 24);
                        });
                        
                        if (totalEarned > 0) {
                            this.showFishEarnings(totalEarned);
                        }
                    }
                }, 30000); // Update every 30 seconds
            }

            updateStakingStats() {
                let totalEarned = this.fishCoins;
                let avgMultiplier = 1.0;

                if (this.stakedNFTs.length > 0) {
                    const totalMultiplier = this.stakedNFTs.reduce((sum, nft) => sum + nft.multiplier, 0);
                    avgMultiplier = totalMultiplier / this.stakedNFTs.length;
                    
                    // Add pending rewards
                    this.stakedNFTs.forEach(nft => {
                        const stakingTime = Date.now() - this.stakingStartTimes[nft.tokenId];
                        const hoursStaked = stakingTime / (1000 * 60 * 60);
                        totalEarned += Math.floor(hoursStaked * nft.multiplier * 10 / 24);
                    });
                }

                // Update UI elements
                const stakedCountEl = document.getElementById('stakedCount');
                const fishEarnedEl = document.getElementById('fishEarned');
                const stakingRateEl = document.getElementById('stakingRate');
                
                if (stakedCountEl) stakedCountEl.textContent = this.stakedNFTs.length;
                if (fishEarnedEl) fishEarnedEl.textContent = Math.floor(totalEarned);
                if (stakingRateEl) stakingRateEl.textContent = `${Math.round(avgMultiplier * 10)}/day`;
            }

            showFishEarnings(amount) {
                const fishEarningsEl = document.getElementById('fishEarnings');
                const fishEarningsAmountEl = document.getElementById('fishEarningsAmount');
                
                if (fishEarningsEl && fishEarningsAmountEl) {
                    fishEarningsAmountEl.textContent = amount;
                    fishEarningsEl.classList.add('show');
                    
                    setTimeout(() => {
                        fishEarningsEl.classList.remove('show');
                    }, 3000);
                }
            }

            disconnect(clearNFTs = true) {
                // Save current data before disconnecting
                if (this.isConnected) {
                    this.saveNFTsToStorage();
                }
                
                this.provider = null;
                this.account = null;
                this.isConnected = false;
                this.isLoadingNFTs = false; // Reset loading state
                
                // Only clear NFTs if explicitly requested (for full disconnect)
                if (clearNFTs) {
                    this.userNFTs = [];
                    this.stakedNFTs = [];
                    this.fishCoins = 0;
                    this.stakingStartTimes = {};
                }
                
                this.updateUI();
                this.showMessage('Wallet disconnected', 'success');
            }

            updateUI() {
                const connectWalletBtn = document.getElementById('connectWalletBtn');
                const walletInfo = document.getElementById('walletInfo');
                const walletAddress = document.getElementById('walletAddress');

                if (this.isConnected) {
                    if (connectWalletBtn) {
                        connectWalletBtn.innerHTML = '<span style="position: relative; z-index: 2;">âœ… Connected</span>';
                        connectWalletBtn.classList.add('connected');
                    }
                    
                    if (walletInfo) {
                        walletInfo.classList.add('show');
                    }
                    
                    if (walletAddress) {
                        walletAddress.textContent = `${this.account.slice(0, 6)}...${this.account.slice(-4)}`;
                    }
                    
                    this.updateStakingStats();
                    
                    // Save data to localStorage whenever UI is updated (only if we have data)
                    if (this.userNFTs.length > 0 || this.stakedNFTs.length > 0 || this.fishCoins > 0) {
                        this.saveNFTsToStorage();
                    }
                } else {
                    if (connectWalletBtn) {
                        connectWalletBtn.innerHTML = '<span style="position: relative; z-index: 2;">ðŸ”— Connect Wallet</span>';
                        connectWalletBtn.classList.remove('connected');
                    }
                    
                    if (walletInfo) {
                        walletInfo.classList.remove('show');
                    }
                }
            }

            showMessage(text, type = 'info') {
                console.log(`${type.toUpperCase()}: ${text}`);
                
                // Create or find message container
                let messageContainer = document.getElementById('messageContainer');
                if (!messageContainer) {
                    messageContainer = document.createElement('div');
                    messageContainer.id = 'messageContainer';
                    messageContainer.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        z-index: 10000;
                        max-width: 300px;
                        padding: 15px;
                        border-radius: 8px;
                        color: white;
                        font-weight: bold;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                        transition: all 0.3s ease;
                        opacity: 0;
                        transform: translateX(100%);
                    `;
                    document.body.appendChild(messageContainer);
                }
                
                // Set message content and style
                messageContainer.textContent = text;
                messageContainer.style.backgroundColor = {
                    'success': '#4CAF50',
                    'error': '#f44336',
                    'warning': '#ff9800',
                    'info': '#2196F3'
                }[type] || '#2196F3';
                
                // Show message
                messageContainer.style.opacity = '1';
                messageContainer.style.transform = 'translateX(0)';
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    messageContainer.style.opacity = '0';
                    messageContainer.style.transform = 'translateX(100%)';
                }, 5000);
            }

            // Game integration methods
            getActiveTraits() {
                const activeTraits = new Set();
                [...this.userNFTs, ...this.stakedNFTs].forEach(nft => {
                    nft.traits.forEach(trait => {
                        if (trait && trait !== 'Base-Normal') {
                            activeTraits.add(trait);
                        }
                    });
                });
                return Array.from(activeTraits);
            }

            getGameMultipliers() {
                const multipliers = {
                    speed: 1.0,
                    points: 1.0,
                    damage: 1.0,
                    defense: 1.0,
                    luck: 1.0
                };

                this.getActiveTraits().forEach(trait => {
                    const perk = this.gamePerks[trait];
                    if (perk) {
                        if (perk.type === 'defense') {
                            multipliers[perk.type] *= perk.value; // Defense is damage reduction
                        } else {
                            multipliers[perk.type] *= perk.value;
                        }
                    }
                });

                return multipliers;
            }

            hasSpecialAbilities() {
                return this.getActiveTraits().some(trait => 
                    ['Hat-Wizard', 'Eyes-Laser', 'Hat-Pirate'].includes(trait)
                );
            }

            getStakingBonus() {
                return {
                    fishPerSecond: this.stakedNFTs.reduce((total, nft) => 
                        total + (nft.multiplier * 10 / (24 * 60 * 60)), 0),
                    totalStaked: this.stakedNFTs.length,
                    totalFish: this.fishCoins
                };
            }

            // Auto-stake all NFTs for demo purposes (simulated)
            autoStakeAll() {
                this.userNFTs.forEach(nft => {
                    if (!this.stakedNFTs.some(staked => staked.tokenId === nft.tokenId)) {
                        this.stakedNFTs.push(nft);
                        this.stakingStartTimes[nft.tokenId] = Date.now();
                    }
                });
                this.saveNFTsToStorage(); // Save to localStorage immediately
                this.updateUI();
                this.showMessage('All otters auto-staked for demo! (Simulated)', 'success');
            }

            // Simulated staking functions for testing without contract
            simulateStakeNFT(tokenId) {
                const nft = this.userNFTs.find(n => n.tokenId === tokenId);
                if (nft && !this.stakedNFTs.some(staked => staked.tokenId === tokenId)) {
                    this.stakedNFTs.push(nft);
                    this.stakingStartTimes[tokenId] = Date.now();
                    this.userNFTs = this.userNFTs.filter(n => n.tokenId !== tokenId);
                    this.saveNFTsToStorage(); // Save to localStorage immediately
                    this.updateUI();
                    this.showMessage(`NFT ${tokenId} staked (simulated)!`, 'success');
                    return true;
                }
                return false;
            }

            simulateUnstakeNFT(tokenId) {
                const nft = this.stakedNFTs.find(n => n.tokenId === tokenId);
                if (nft) {
                    this.userNFTs.push(nft);
                    this.stakedNFTs = this.stakedNFTs.filter(n => n.tokenId !== tokenId);
                    delete this.stakingStartTimes[tokenId];
                    this.saveNFTsToStorage(); // Save to localStorage immediately
                    this.updateUI();
                    this.showMessage(`NFT ${tokenId} unstaked (simulated)!`, 'success');
                    return true;
                }
                return false;
            }

            simulateStakeMultiple(tokenIds) {
                let stakedCount = 0;
                tokenIds.forEach(tokenId => {
                    if (this.simulateStakeNFT(tokenId)) {
                        stakedCount++;
                    }
                });
                this.showMessage(`${stakedCount} NFTs staked (simulated)!`, 'success');
                return stakedCount;
            }

            simulateUnstakeAll() {
                const stakedCount = this.stakedNFTs.length;
                this.stakedNFTs.forEach(nft => {
                    this.userNFTs.push(nft);
                });
                this.stakedNFTs = [];
                this.stakingStartTimes = {};
                this.saveNFTsToStorage(); // Save to localStorage immediately
                this.updateUI();
                this.showMessage(`All ${stakedCount} NFTs unstaked (simulated)!`, 'success');
                return stakedCount;
            }

            // Real blockchain staking functions
            async stakeNFT(tokenId) {
                console.log(`ðŸ”’ Staking NFT ${tokenId} on blockchain...`);
                
                try {
                    // Check if user owns the NFT
                    const owner = await this.getTokenOwner(tokenId);
                    if (owner.toLowerCase() !== this.account.toLowerCase()) {
                        throw new Error('You do not own this NFT');
                    }

                    // Approve staking contract to transfer NFT
                    const approveData = '0x095ea7b3' + 
                        '000000000000000000000000' + this.stakingContractAddress.slice(2) + // staking contract address
                        '0000000000000000000000000000000000000000000000000000000000000001'; // tokenId
                    
                    console.log('ðŸ” Approving staking contract...');
                    const approveTx = await window.ethereum.request({
                        method: 'eth_sendTransaction',
                        params: [{
                            from: this.account,
                            to: this.contractAddress,
                            data: approveData
                        }]
                    });
                    
                    console.log('âœ… Approval transaction:', approveTx);
                    
                    // Wait for approval confirmation
                    await this.waitForTransaction(approveTx);
                    
                    // Stake the NFT
                    const stakeData = '0x23b872dd' + // transferFrom function
                        '000000000000000000000000' + this.account.slice(2) + // from
                        '000000000000000000000000' + this.stakingContractAddress.slice(2) + // to (staking contract)
                        '0000000000000000000000000000000000000000000000000000000000000001'; // tokenId
                    
                    console.log('ðŸ”’ Staking NFT...');
                    const stakeTx = await window.ethereum.request({
                        method: 'eth_sendTransaction',
                        params: [{
                            from: this.account,
                            to: this.contractAddress,
                            data: stakeData
                        }]
                    });
                    
                    console.log('âœ… Stake transaction:', stakeTx);
                    await this.waitForTransaction(stakeTx);
                    
                    // Update local state
                    const nft = this.userNFTs.find(n => n.tokenId === tokenId);
                    if (nft) {
                        this.stakedNFTs.push(nft);
                        this.stakingStartTimes[tokenId] = Date.now();
                        this.userNFTs = this.userNFTs.filter(n => n.tokenId !== tokenId);
                    }
                    
                    this.updateUI();
                    this.showMessage(`NFT ${tokenId} staked successfully!`, 'success');
                    
                } catch (error) {
                    console.error('âŒ Error staking NFT:', error);
                    this.showMessage(`Staking failed: ${error.message}`, 'error');
                }
            }

            async unstakeNFT(tokenId) {
                console.log(`ðŸ”“ Unstaking NFT ${tokenId} from blockchain...`);
                
                try {
                    // Call unstake function on staking contract
                    const unstakeData = '0x' + // unstake function selector
                        '0000000000000000000000000000000000000000000000000000000000000001'; // tokenId
                    
                    const unstakeTx = await window.ethereum.request({
                        method: 'eth_sendTransaction',
                        params: [{
                            from: this.account,
                            to: this.stakingContractAddress,
                            data: unstakeData
                        }]
                    });
                    
                    console.log('âœ… Unstake transaction:', unstakeTx);
                    await this.waitForTransaction(unstakeTx);
                    
                    // Update local state
                    const nft = this.stakedNFTs.find(n => n.tokenId === tokenId);
                    if (nft) {
                        this.userNFTs.push(nft);
                        this.stakedNFTs = this.stakedNFTs.filter(n => n.tokenId !== tokenId);
                        delete this.stakingStartTimes[tokenId];
                    }
                    
                    this.updateUI();
                    this.showMessage(`NFT ${tokenId} unstaked successfully!`, 'success');
                    
                } catch (error) {
                    console.error('âŒ Error unstaking NFT:', error);
                    this.showMessage(`Unstaking failed: ${error.message}`, 'error');
                }
            }

            async claimRewards() {
                console.log('ðŸ’° Claiming staking rewards...');
                
                try {
                    // Call claim function on staking contract
                    const claimData = '0x'; // claim function selector
                    
                    const claimTx = await window.ethereum.request({
                        method: 'eth_sendTransaction',
                        params: [{
                            from: this.account,
                            to: this.stakingContractAddress,
                            data: claimData
                        }]
                    });
                    
                    console.log('âœ… Claim transaction:', claimTx);
                    await this.waitForTransaction(claimTx);
                    
                    // Reset local fish coins (claimed on blockchain)
                    this.fishCoins = 0;
                    this.saveNFTsToStorage(); // Save the updated fish coins balance
                    this.updateUI();
                    this.showMessage('Rewards claimed successfully!', 'success');
                    
                } catch (error) {
                    console.error('âŒ Error claiming rewards:', error);
                    this.showMessage(`Claim failed: ${error.message}`, 'error');
                }
            }

            async waitForTransaction(txHash) {
                console.log('â³ Waiting for transaction confirmation...');
                
                return new Promise((resolve, reject) => {
                    const checkInterval = setInterval(async () => {
                        try {
                            const receipt = await window.ethereum.request({
                                method: 'eth_getTransactionReceipt',
                                params: [txHash]
                            });
                            
                            if (receipt) {
                                clearInterval(checkInterval);
                                if (receipt.status === '0x1') {
                                    console.log('âœ… Transaction confirmed!');
                                    resolve(receipt);
                                } else {
                                    reject(new Error('Transaction failed'));
                                }
                            }
                        } catch (error) {
                            clearInterval(checkInterval);
                            reject(error);
                        }
                    }, 2000); // Check every 2 seconds
                    
                    // Timeout after 5 minutes
                    setTimeout(() => {
                        clearInterval(checkInterval);
                        reject(new Error('Transaction timeout'));
                    }, 300000);
                });
            }
        }
        */
        
        // Wallet system completely removed - no code remaining
        
        // Global variables
        let aiOwlBotEnabled = true;
        
        // Global canvas variable
        let canvas;
        let ctx;
        
        // Global safety check for canvas context
        function isCanvasReady() {
            return canvas && ctx && canvas.width > 0 && canvas.height > 0;
        }
        
        // Game state - Define this BEFORE any functions that use it
        const game = {
            score: 0,
            lives: 3,
            level: 1,
            gameState: 'menu', // 'menu', 'playing', 'paused'
            camera: { x: 0, y: 0 },
            keys: {},
            gameOver: false,
            levelComplete: false,
            levelTransition: false,
            coins: 0,
            keyCount: 0,
            maxLives: 99, // Increased max lives to 99
            lastLifeScore: 0,
            jumpPressed: false,
            selectedOtter: 'otter1', // Default selected otter
            secretChestsSpawned: false, // Track if secret chests have been spawned
            secretChestConditions: {
                coinsCollected: 0,
                treasuresCollected: 0,
                keysCollected: 0
            },
            // AI Bot system
            aiBot: {
                x: 0,
                y: 0,
                width: 60,
                height: 60,
                offsetX: -80, // Position behind the player
                offsetY: 0,
                currentTip: '',
                tipTimer: 0,
                tipDuration: 5000, // 5 seconds per tip
                lastTipTime: 0,
                tipCooldown: 12000, // 12 seconds between tips (increased for better performance)
                isVisible: true,
                bobOffset: 0,
                bobSpeed: 0.02,
                glowIntensity: 0,
                lookDirection: 1, // Track owl's looking direction
                scale: 1,
                canvasWidth: 1920, // Default values until canvas is initialized
                canvasHeight: 1080
            },
            // Marketplace system
            marketplace: {},
            // Profile system
            profile: {},
            // Mouse tracking for laser aiming
            mouseX: 0,
            mouseY: 0,
            // Laser cycling system
            laserCycleIndex: 0,
            laserCycleTimer: 0,
            laserCycleSpeed: 200, // Change every 200ms
            // Responsive scaling
            scale: 1,
            canvasWidth: 1920,
            canvasHeight: 1080,
            // Leaderboard tracking
            sessionStats: {},
            // Checkpoint system
            checkpoints: [],
            activeCheckpoint: null,
            checkpointProgress: {},
            // Boss system
            currentBoss: null,
            bossActive: false,
            // Secret system
            secrets: [],
            secretRooms: [],
            // Environmental effects
            particles: [],
            screenShake: 0,
            freezeFrame: 0,
            // Water system
            waterLevel: 1400,
            waterDepth: 2000,
            deathBarrier: 2400,
            // Lava system for boss levels
            lavaLevel: 1400,
            lavaDepth: 2000,
            inLava: false,
            lavaSinkTime: 0,
            lavaSinkDuration: 1500,
            lavaBouncePower: 8,
            lavaDamageInvulnerability: 2000,
            // Extra abilities
            // Story system
            storyMode: false,
            cutsceneActive: false,
            cutsceneText: '',
            cutsceneIndex: 0,
            typewriterInterval: null,
            // Real-time collectibles tracking
            collectiblesCount: {
                coinsCollected: 0,
                chestsCollected: 0,
                goldenChestsCollected: 0
            }
        };
        
        // Single initialization function to prevent multiple executions
        function initializeGame() {
            console.log('ðŸŽ® Initializing game...');
            
            // Wallet integration removed for performance
            // Wallet system disabled

            // Initialize canvas
            canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error('âŒ Canvas element not found!');
                return false;
            }
            
            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('âŒ Canvas context not available!');
                return false;
            }
            
            console.log('âœ… Canvas initialized successfully');
            
            // Update game object with canvas dimensions
            game.canvasWidth = canvas.width;
            game.canvasHeight = canvas.height;
            
            return true;
        }
        
        // Wait for DOM to be fully loaded before initializing
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ðŸŽ® DOM loaded, initializing game...');
            
            // Initialize game components
            if (!initializeGame()) {
                console.error('âŒ Game initialization failed!');
                return;
            }
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerRect = container.getBoundingClientRect();
            
            // For mobile, use full viewport; for desktop, use fixed 1920x1080
            const isMobile = window.innerWidth < 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            let newWidth, newHeight;
            if (isMobile) {
                // Mobile: fill entire viewport to eliminate white space
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Use full viewport dimensions
                newWidth = viewportWidth;
                newHeight = viewportHeight;
            } else {
                // Desktop: use fixed 1920x1080 or container size
                newWidth = Math.min(1920, containerRect.width - 20);
                newHeight = Math.min(1080, containerRect.height - 20);
            }
            
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // Calculate scale factors
            const baseWidth = 1920;
            const baseHeight = 1080;
            const scaleX = canvas.width / baseWidth;
            const scaleY = canvas.height / baseHeight;
            const scale = Math.min(scaleX, scaleY);
            
            // Mobile: zoom out 20% to show more of the game world, desktop: zoom in 10%
            const zoomedScale = isMobile ? scale * 0.8 : scale * 1.1;
            
            // Store scale for use in game logic
            game.scale = zoomedScale;
            game.isMobile = isMobile;
            game.canvasWidth = canvas.width;
            game.canvasHeight = canvas.height;
            game.isMobile = isMobile;
        }
        
        // Initial resize with delay to ensure DOM is ready
        setTimeout(() => {
            resizeCanvas();
            // Setup canvas event listeners after canvas is ready
            setupCanvasEventListeners();
            // Setup mobile controls
            setupMobileControls();
            // Initialize the first level after canvas is fully set up
            loadLevel(1);
            
            // Wallet event listeners removed - wallet system disabled
        }, 100);
        
        // Resize on window resize
        window.addEventListener('resize', resizeCanvas);
        }); // Close DOMContentLoaded event listener
        
        // ðŸ”« FORCE LASER ARRAY INITIALIZATION
        let laserPowerups = [];
        console.log('ðŸ”« Global laserPowerups array initialized');
        
        // ðŸ”¥ FIREBALL ARRAY INITIALIZATION
        let fireballPowerups = [];
        let playerFireballs = [];
        console.log('ðŸ”¥ Global fireball arrays initialized');
        
        // Achievements System
        const achievements = [
            // Basic Achievements (Easy) - 50 XP each
            { id: 'first_game', name: 'First Steps', description: 'Play your first game', icon: 'ðŸŽ®', unlocked: false, xpReward: 50 },
            { id: 'first_coin', name: 'Coin Collector', description: 'Collect your first coin', icon: 'ðŸª™', unlocked: false, xpReward: 50 },
            { id: 'first_level', name: 'Level Up!', description: 'Complete your first level', icon: 'â­', unlocked: false, xpReward: 50 },
            { id: 'first_enemy', name: 'Combat Ready', description: 'Defeat your first enemy', icon: 'âš”ï¸', unlocked: false, xpReward: 50 },
            { id: 'ten_coins', name: 'Rich Otter', description: 'Collect 10 coins in one game', icon: 'ðŸ’°', unlocked: false, xpReward: 50 },
            { id: 'five_levels', name: 'Adventure Seeker', description: 'Complete 5 levels', icon: 'ðŸ—ºï¸', unlocked: false, xpReward: 50 },
            { id: 'hundred_score', name: 'Score Master', description: 'Score 100 points in one game', icon: 'ðŸ†', unlocked: false, xpReward: 50 },
            { id: 'jetpack_user', name: 'Jetpack Jockey', description: 'Use a jetpack for the first time', icon: 'ðŸš', unlocked: false, xpReward: 50 },
            { id: 'laser_user', name: 'Laser Expert', description: 'Use a laser for the first time', icon: 'ðŸ”«', unlocked: false, xpReward: 50 },
            { id: 'mushroom_user', name: 'Giant Mode', description: 'Use a mushroom for the first time', icon: 'ðŸ„', unlocked: false, xpReward: 50 },
            { id: 'underwater_explorer', name: 'Deep Diver', description: 'Explore underwater areas', icon: 'ðŸŒŠ', unlocked: false, xpReward: 50 },
            { id: 'boss_defeater', name: 'Boss Slayer', description: 'Defeat your first boss', icon: 'ðŸ‘‘', unlocked: false, xpReward: 50 },
            { id: 'marketplace_shopper', name: 'Fashion Forward', description: 'Buy your first item from the marketplace', icon: 'ðŸ›’', unlocked: false, xpReward: 50 },
            { id: 'hat_collector', name: 'Hat Enthusiast', description: 'Own 3 different owl hats', icon: 'ðŸ¦‰', unlocked: false, xpReward: 50 },
            { id: 'skin_collector', name: 'Style Master', description: 'Own 3 different otter skins', icon: 'ðŸ¦¦', unlocked: false, xpReward: 50 },
            
            // Intermediate Achievements (Medium) - 100 XP each
            { id: 'fifty_coins', name: 'Coin Hoarder', description: 'Collect 50 coins in one game', icon: 'ðŸ’Ž', unlocked: false, xpReward: 100 },
            { id: 'ten_levels', name: 'Level Master', description: 'Complete 10 levels', icon: 'ðŸ”ï¸', unlocked: false, xpReward: 100 },
            { id: 'complete_10_levels', name: 'Level Master', description: 'Complete 10 levels', icon: 'ðŸ”ï¸', unlocked: false, xpReward: 100 },
            { id: 'thousand_score', name: 'High Scorer', description: 'Score 1,000 points in one game', icon: 'ðŸŽ¯', unlocked: false, xpReward: 100 },
            { id: 'twenty_enemies', name: 'Enemy Hunter', description: 'Defeat 20 enemies in one game', icon: 'ðŸ—¡ï¸', unlocked: false, xpReward: 100 },
            { id: 'five_bosses', name: 'Boss Hunter', description: 'Defeat 5 bosses', icon: 'ðŸ‘‘', unlocked: false, xpReward: 100 },
            { id: 'defeat_5_bosses', name: 'Boss Hunter', description: 'Defeat 5 bosses', icon: 'ðŸ‘‘', unlocked: false, xpReward: 100 },
            { id: 'all_hats', name: 'Hat Master', description: 'Own all owl hats', icon: 'ðŸŽ©', unlocked: false, xpReward: 100 },
            { id: 'all_skins', name: 'Skin Master', description: 'Own all otter skins', icon: 'ðŸŽ¨', unlocked: false, xpReward: 100 },
            { id: 'speed_runner', name: 'Speed Runner', description: 'Complete a level in under 30 seconds', icon: 'âš¡', unlocked: false, xpReward: 100 },
            { id: 'no_damage', name: 'Untouchable', description: 'Complete a level without taking damage', icon: 'ðŸ›¡ï¸', unlocked: false, xpReward: 100 },
            { id: 'collector', name: 'Collector', description: 'Collect 100 items in one game', icon: 'ðŸ“¦', unlocked: false, xpReward: 100 },
            
            // Advanced Achievements (Hard) - 200 XP each
            { id: 'hundred_coins', name: 'Coin Millionaire', description: 'Collect 100 coins in one game', icon: 'ðŸ’Ž', unlocked: false, xpReward: 200 },
            { id: 'collect_100_coins', name: 'Coin Collector Master', description: 'Collect 100 coins total', icon: 'ðŸ’Ž', unlocked: false, xpReward: 200 },
            { id: 'twenty_levels', name: 'Level Legend', description: 'Complete 20 levels', icon: 'ðŸ†', unlocked: false, xpReward: 200 },
            { id: 'reach_level_20', name: 'Level 20 Master', description: 'Reach player level 20', icon: 'ðŸ†', unlocked: false, xpReward: 200 },
            { id: 'ten_thousand_score', name: 'Score Legend', description: 'Score 10,000 points in one game', icon: 'ðŸŒŸ', unlocked: false, xpReward: 200 },
            { id: 'fifty_enemies', name: 'Enemy Slayer', description: 'Defeat 50 enemies in one game', icon: 'âš”ï¸', unlocked: false, xpReward: 200 },
            { id: 'defeat_50_enemies', name: 'Enemy Slayer', description: 'Defeat 50 enemies total', icon: 'âš”ï¸', unlocked: false, xpReward: 200 },
            { id: 'ten_bosses', name: 'Boss Legend', description: 'Defeat 10 bosses', icon: 'ðŸ‘‘', unlocked: false, xpReward: 200 },
            { id: 'perfect_run', name: 'Perfect Run', description: 'Complete a level with 100% items collected', icon: 'ðŸ’¯', unlocked: false, xpReward: 200 },
            { id: 'no_jump', name: 'Ground Walker', description: 'Complete a level without jumping', icon: 'ðŸš¶', unlocked: false, xpReward: 200 },
            { id: 'underwater_master', name: 'Underwater Master', description: 'Spend 5 minutes underwater in one game', icon: 'ðŸ ', unlocked: false, xpReward: 200 },
            { id: 'jetpack_master', name: 'Jetpack Master', description: 'Use jetpack for 3 minutes in one game', icon: 'ðŸš', unlocked: false, xpReward: 200 },
            { id: 'laser_master', name: 'Laser Master', description: 'Defeat 10 enemies with laser in one game', icon: 'ðŸ”«', unlocked: false, xpReward: 200 },
            
            // Expert Achievements (Very Hard) - 500 XP each
            { id: 'two_hundred_coins', name: 'Coin Billionaire', description: 'Collect 200 coins in one game', icon: 'ðŸ’Ž', unlocked: false, xpReward: 500 },
            { id: 'fifty_levels', name: 'Level God', description: 'Complete 50 levels', icon: 'ðŸ†', unlocked: false, xpReward: 500 },
            { id: 'hundred_thousand_score', name: 'Score God', description: 'Score 100,000 points in one game', icon: 'ðŸŒŸ', unlocked: false, xpReward: 500 },
            { id: 'hundred_enemies', name: 'Enemy God', description: 'Defeat 100 enemies in one game', icon: 'âš”ï¸', unlocked: false, xpReward: 500 },
            { id: 'twenty_bosses', name: 'Boss God', description: 'Defeat 20 bosses', icon: 'ðŸ‘‘', unlocked: false, xpReward: 500 },
            { id: 'no_powerups', name: 'Pure Skill', description: 'Complete 5 levels without using any powerups', icon: 'ðŸŽ¯', unlocked: false, xpReward: 500 },
            { id: 'speed_god', name: 'Speed God', description: 'Complete a level in under 15 seconds', icon: 'âš¡', unlocked: false, xpReward: 500 },
            { id: 'invincible', name: 'Invincible', description: 'Complete 3 levels without taking damage', icon: 'ðŸ›¡ï¸', unlocked: false, xpReward: 500 },
            { id: 'master_collector', name: 'Master Collector', description: 'Collect 500 items in one game', icon: 'ðŸ“¦', unlocked: false, xpReward: 500 },
            
            // New Gameplay Achievements - 150 XP each
            { id: 'fireball_master', name: 'Fireball Master', description: 'Hit 10 enemies with fireballs in one game', icon: 'ðŸ”¥', unlocked: false, xpReward: 150 },
            { id: 'underwater_explorer_master', name: 'Deep Sea Explorer', description: 'Spend 10 minutes underwater total', icon: 'ðŸŒŠ', unlocked: false, xpReward: 150 },
            { id: 'jetpack_explorer', name: 'Sky Explorer', description: 'Use jetpack for 5 minutes total', icon: 'ðŸš', unlocked: false, xpReward: 150 },
            { id: 'laser_expert', name: 'Laser Expert', description: 'Defeat 25 enemies with laser total', icon: 'ðŸ”«', unlocked: false, xpReward: 150 },
            { id: 'treasure_hunter', name: 'Treasure Hunter', description: 'Collect 50 treasures total', icon: 'ðŸ’Ž', unlocked: false, xpReward: 150 },
            { id: 'health_master', name: 'Health Master', description: 'Collect 100 health pickups total', icon: 'â¤ï¸', unlocked: false, xpReward: 150 },
            { id: 'mushroom_master', name: 'Mushroom Master', description: 'Eat 50 mushrooms total', icon: 'ðŸ„', unlocked: false, xpReward: 150 },
            { id: 'key_collector', name: 'Key Master', description: 'Collect 25 keys total', icon: 'ðŸ—ï¸', unlocked: false, xpReward: 150 },
            { id: 'fish_collector', name: 'Fish Collector', description: 'Collect 100 fish total', icon: 'ðŸŸ', unlocked: false, xpReward: 150 },
            { id: 'jump_master', name: 'Jump Master', description: 'Make 500 jumps total', icon: 'ðŸ¦˜', unlocked: false, xpReward: 150 },
            
            // Hidden Achievements (Random/Secret) - 75 XP each
            { id: 'lucky_777', name: 'Lucky 777', description: 'Score exactly 777 points', icon: 'ðŸ€', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'collector_13', name: 'Unlucky Collector', description: 'Collect exactly 13 items', icon: 'ðŸ˜±', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'enemy_666', name: 'Devil Hunter', description: 'Defeat exactly 666 enemies', icon: 'ðŸ˜ˆ', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'coin_42', name: 'Answer to Everything', description: 'Collect exactly 42 coins', icon: 'ðŸ¤–', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'level_69', name: 'Nice Level', description: 'Complete level 69', icon: 'ðŸ˜', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'random_master', name: 'Random Master', description: 'Unlock 5 hidden achievements', icon: 'ðŸŽ²', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'midnight_gamer', name: 'Midnight Gamer', description: 'Play at exactly midnight', icon: 'ðŸŒ™', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'early_bird', name: 'Early Bird', description: 'Play at exactly 6 AM', icon: 'ðŸŒ…', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'night_owl', name: 'Night Owl', description: 'Play for 2 hours straight', icon: 'ðŸ¦‰', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'weekend_warrior', name: 'Weekend Warrior', description: 'Play on a weekend', icon: 'ðŸ“…', unlocked: false, hidden: true, xpReward: 75 },
            
            // Special Event Achievements - 100 XP each
            { id: 'christmas_player', name: 'Christmas Player', description: 'Play during December', icon: 'ðŸŽ„', unlocked: false, hidden: true, xpReward: 100 },
            { id: 'halloween_player', name: 'Halloween Player', description: 'Play during October', icon: 'ðŸŽƒ', unlocked: false, hidden: true, xpReward: 100 },
            { id: 'summer_player', name: 'Summer Player', description: 'Play during June-August', icon: 'â˜€ï¸', unlocked: false, hidden: true, xpReward: 100 },
            { id: 'spring_player', name: 'Spring Player', description: 'Play during March-May', icon: 'ðŸŒ¸', unlocked: false, hidden: true, xpReward: 100 },
            
            // Ultra Rare Achievements (Extremely Hard) - 1000 XP each
            { id: 'million_score', name: 'Millionaire', description: 'Score 1,000,000 points in one game', icon: 'ðŸ’Ž', unlocked: false, xpReward: 1000 },
            { id: 'hundred_levels', name: 'Century Master', description: 'Complete 100 levels', icon: 'ðŸ†', unlocked: false, xpReward: 1000 },
            { id: 'thousand_enemies', name: 'Enemy Annihilator', description: 'Defeat 1,000 enemies', icon: 'âš”ï¸', unlocked: false, xpReward: 1000 },
            { id: 'fifty_bosses', name: 'Boss Annihilator', description: 'Defeat 50 bosses', icon: 'ðŸ‘‘', unlocked: false, xpReward: 1000 },
            { id: 'perfect_game', name: 'Perfect Game', description: 'Complete a game with 100% completion', icon: 'ðŸ’¯', unlocked: false, xpReward: 1000 },
            { id: 'no_death_master', name: 'No Death Master', description: 'Complete 10 levels without dying', icon: 'ðŸ›¡ï¸', unlocked: false, xpReward: 1000 },
            { id: 'speed_demon', name: 'Speed Demon', description: 'Complete a level in under 10 seconds', icon: 'âš¡', unlocked: false, xpReward: 1000 },
            { id: 'collector_god', name: 'Collector God', description: 'Collect 1,000 items in one game', icon: 'ðŸ“¦', unlocked: false, xpReward: 1000 },
            { id: 'underwater_god', name: 'Underwater God', description: 'Spend 10 minutes underwater in one game', icon: 'ðŸ ', unlocked: false, xpReward: 1000 },
            { id: 'jetpack_god', name: 'Jetpack God', description: 'Use jetpack for 10 minutes in one game', icon: 'ðŸš', unlocked: false, xpReward: 1000 }
        ];

        // Marketplace Items
        const marketplaceItems = {
                            hats: [
                    { id: 'none', name: 'No Hat', price: 0, description: 'Classic owl look', owned: true, equipped: true, image: 'public/owl.png' },
                    { id: 'party', name: 'Party Hat', price: 75, description: 'Celebration time!', owned: false, equipped: false, image: 'public/owl-hats/Party.png' },
                    { id: 'snow_plumber', name: 'Snow Plumber', price: 150, description: 'Winter warrior', owned: false, equipped: false, image: 'public/owl-hats/Snow-Plumber.png' },
                    { id: 'yellow_plumber', name: 'Yellow Plumber', price: 200, description: 'Sunny disposition', owned: false, equipped: false, image: 'public/owl-hats/Yellow-Plumber.png' },
                    { id: 'purple_plumber', name: 'Purple Plumber', price: 175, description: 'Royal plumber', owned: false, equipped: false, image: 'public/owl-hats/Purple-Plumber.png' },
                    { id: 'green_plumber', name: 'Green Plumber', price: 125, description: 'Nature lover', owned: false, equipped: false, image: 'public/owl-hats/Green-Plumber.png' },
                    { id: 'red_plumber', name: 'Red Plumber', price: 100, description: 'Fire and passion', owned: false, equipped: false, image: 'public/owl-hats/Red-Plumber.png' }
                ],
            skins: [
                { id: 'default', name: 'Classic Otter', price: 0, description: 'The original look', owned: true, equipped: true, image: 'public/oggg.png', unlockType: 'default' },
                { id: 'king_otter', name: 'King Otter', price: 50000, description: 'Royal majesty - Premium skin', owned: false, equipped: false, image: 'public/otter-skins/King Otter.png', unlockType: 'purchase' },
                { id: 'purple_plumber', name: 'Purple Plumber', price: 0, description: 'Royal plumber otter - Unlock by defeating 50 enemies', owned: false, equipped: false, image: 'public/otter-skins/Purple Plumber.png', unlockType: 'achievement', achievementId: 'defeat_50_enemies' },
                { id: 'yellow_plumber', name: 'Yellow Plumber', price: 0, description: 'Sunny plumber otter - Unlock by collecting 100 coins', owned: false, equipped: false, image: 'public/otter-skins/Yellow Plumber.png', unlockType: 'achievement', achievementId: 'collect_100_coins' },
                { id: 'green_plumber', name: 'Green Plumber', price: 0, description: 'Nature plumber otter - Unlock by completing 10 levels', owned: false, equipped: false, image: 'public/otter-skins/Green Plumber.png', unlockType: 'achievement', achievementId: 'complete_10_levels' },
                { id: 'red_plumber', name: 'Red Plumber', price: 0, description: 'Fire plumber otter - Unlock by defeating 5 bosses', owned: false, equipped: false, image: 'public/otter-skins/Red Plumber.png', unlockType: 'achievement', achievementId: 'defeat_5_bosses' },
                { id: 'snow_plumber', name: 'Snow Plumber', price: 0, description: 'Winter plumber otter - Unlock by reaching level 20', owned: false, equipped: false, image: 'public/otter-skins/Snow Plumber.png', unlockType: 'achievement', achievementId: 'reach_level_20' }
            ],
            abilities: [
                { id: 'jetpack', name: 'Jetpack', price: 25000, description: 'Start with jetpack ability', owned: false, equipped: false, image: 'public/jet.png' },
                { id: 'laser', name: 'Laser', price: 50000, description: 'Start with laser ability', owned: false, equipped: false, image: 'public/laser.png' },
                { id: 'fireball', name: 'Fireball', price: 10000, description: 'Shoot bouncing fireballs with right-click', owned: false, equipped: false, image: 'public/fireball.png' },
                { id: 'armor', name: 'Armor Boost', price: 15000, description: 'Start with enhanced armor (Level 1: +25% armor)', owned: false, equipped: false, image: 'public/armor.png' }
            ]
        };

        // ðŸ¤– AI Bot Tips System
        const aiBotTips = {
            // General gameplay tips
            general: [
                "ðŸ’¡ Pro tip: Double jump can save you from falls!",
                "ðŸŽ¯ Remember: Jump on enemies to defeat them!",
                "ðŸ’Ž Collect coins for extra points and lives!",
                "â¤ï¸ Health pickups restore your health!",
                "ðŸ›¡ï¸ Armor protects you from damage!",
                "ðŸ„ Mushrooms make you giant and invincible!",
                "ðŸ”‘ Keys unlock special treasures!",
                "ðŸŸ Fish give you bonus points!",
                "ðŸ’Ž Treasures are worth big points!",
                "ðŸš Jetpacks let you fly around!",
                "ðŸ”« Lasers can shoot enemies from afar!",
                "â˜ï¸ Cloud platforms disappear when you touch them!",
                "ðŸŒŠ Underwater platforms are hidden treasures!",
                "âš¡ Moving platforms require timing!",
                "ðŸŽ® Use checkpoints to avoid starting over!",
                "ðŸŽ® Press F to interact with golden chests!",
                "ðŸŽ® Use Shift for jetpack boost!",
                "ðŸŽ® Space shoots lasers when you have them!",
                "ðŸŽ® Break crates to find secrets!",
                "ðŸŽ® High places often have better rewards!",
                "ðŸŽ® Water areas hide special items!",
                "ðŸŽ® Boss levels have unique challenges!",
                "ðŸŽ® Every 10,000 points gives you a life!",
                "ðŸŽ® Armor absorbs damage before health!",
                "ðŸŽ® Giant mode makes you unstoppable!",
                "ðŸŽ® Keys are rare but valuable!",
                "ðŸŽ® Explore every corner for secrets!"
            ],
            
            // Level-specific tips
            level1: [
                "ðŸŽ‰ Welcome to your first adventure!",
                "ðŸš¶â€â™‚ï¸ Use arrow keys or WASD to move!",
                "ðŸ¦˜ Press SPACE to jump!",
                "ðŸ¦˜ Press SPACE twice for double jump!",
                "ðŸŽ¯ Try jumping on that crab!",
                "ðŸ’Ž See that coin? Collect it for points!",
                "ðŸŽ® This is your first level - take it slow!",
                "ðŸŽ¯ Crabs are your first enemies - jump on them!",
                "ðŸ’Ž Coins give you points and extra lives!",
                "â¤ï¸ Health pickups restore your health!",
                "ðŸŽ® Use checkpoints to save your progress!",
                "ðŸŽ¯ Don't rush - explore and collect everything!"
            ],
            
            level2: [
                "ðŸ¦… Eagles are smart - they'll dive at you!",
                "ðŸŒŠ Watch out for water - you can swim!",
                "ðŸ›¡ï¸ Look for armor in high places!",
                "ðŸ” Break tiles to find secrets!",
                "ðŸŽ¯ Eagles are more dangerous than crabs!",
                "ðŸŒŠ Swimming is slower but safer!",
                "ðŸ’Ž Underwater areas hide treasures!",
                "ðŸŽ® You're getting better at this!",
                "ðŸ›¡ï¸ Armor is your best friend!",
                "ðŸŽ¯ Watch for eagle dive patterns!",
                "ðŸŒŠ Water areas are great for exploration!",
                "ðŸ’Ž Don't forget to collect everything!"
            ],
            
            level3: [
                "ðŸŠ Gators wait on water surfaces!",
                "âš¡ Moving platforms need good timing!",
                "ðŸ’Ž Rare treasures need keys to unlock!",
                "ðŸŽ¯ Eagles are more aggressive now!",
                "ðŸŠ Gators are slow but deadly!",
                "âš¡ Time your jumps on moving platforms!",
                "ðŸ”‘ Keys unlock the best treasures!",
                "ðŸŽ¯ This level introduces new challenges!",
                "ðŸ’Ž Golden chests need keys to open!",
                "ðŸŽ® Moving platforms require patience!",
                "ðŸŠ Stay away from gator mouths!",
                "ðŸ’Ž Keys are worth the effort to find!"
            ],
            
            level4: [
                "ðŸ”® Wizgators shoot fireballs!",
                "ðŸ¦ˆ Sharks hunt underwater!",
                "ðŸ„ Mushrooms make you unstoppable!",
                "ðŸš Jetpacks are game changers!",
                "ðŸ”® Wizgators are magical enemies!",
                "ðŸ¦ˆ Sharks are fast underwater hunters!",
                "ðŸ„ Mushrooms give you super powers!",
                "ðŸš Jetpacks let you fly freely!",
                "ðŸ”® Dodge wizgator fireballs!",
                "ðŸ¦ˆ Sharks can't reach you on land!",
                "ðŸ„ Giant mode makes you invincible!",
                "ðŸš Use jetpacks to reach high places!",
                "ðŸ”® Wizgators are vulnerable when not shooting!",
                "ðŸ¦ˆ Underwater combat is dangerous!",
                "ðŸ„ Mushroom power lasts 10 seconds!",
                "ðŸš Jetpacks work great underwater too!"
            ],
            
            level5: [
                "ðŸ‘‘ Boss level! Captain Claws awaits!",
                "ðŸ”¥ Lava is deadly - don't touch it!",
                "ðŸ›¡ï¸ Boss armor gives extra protection!",
                "ðŸŽ¯ Dodge his attacks and counter!",
                "ðŸ‘‘ Captain Claws is your first boss!",
                "ðŸ”¥ Lava deals massive damage!",
                "ðŸ›¡ï¸ Boss armor is the strongest!",
                "ðŸŽ¯ Watch for boss attack patterns!",
                "ðŸ‘‘ Boss battles are epic challenges!",
                "ðŸ”¥ Stay away from lava pools!",
                "ðŸ›¡ï¸ Boss armor can save your life!",
                "ðŸŽ¯ Attack when the boss is vulnerable!",
                "ðŸ‘‘ This is a test of your skills!",
                "ðŸ”¥ Lava bounces you up but hurts!",
                "ðŸ›¡ï¸ Armor absorbs boss damage!",
                "ðŸŽ¯ Patience is key in boss fights!"
            ],
            
            // Situation-specific tips
            lowHealth: [
                "â¤ï¸ Your health is low! Find health pickups!",
                "ðŸ›¡ï¸ Look for armor to protect yourself!",
                "ðŸ’Ž Treasures often contain health!",
                "ðŸŒŠ Check underwater for hidden health!",
                "â¤ï¸ Be extra careful with low health!",
                "ðŸ›¡ï¸ Armor will protect you from damage!",
                "ðŸ’Ž Golden chests might have health!",
                "ðŸŒŠ Underwater areas hide health pickups!",
                "â¤ï¸ Avoid dangerous enemies when low on health!",
                "ðŸ›¡ï¸ Boss armor gives maximum protection!",
                "ðŸ’Ž Break crates to find health!",
                "ðŸŒŠ Swim carefully when health is low!"
            ],
            
            noArmor: [
                "ðŸ›¡ï¸ You're vulnerable! Find some armor!",
                "ðŸ’Ž Armor is often in high places!",
                "ðŸ” Break tiles to find hidden armor!",
                "ðŸŒŠ Underwater areas hide good armor!",
                "ðŸ›¡ï¸ Without armor, you're fragile!",
                "ðŸ’Ž High platforms often have armor!",
                "ðŸ” Hidden armor is the best kind!",
                "ðŸŒŠ Underwater armor is special!",
                "ðŸ›¡ï¸ Armor absorbs damage before health!",
                "ðŸ’Ž Cloud platforms hide armor!",
                "ðŸ” Boss armor is the strongest!",
                "ðŸŒŠ Water areas are armor hotspots!"
            ],
            
            manyEnemies: [
                "âš”ï¸ Lots of enemies! Use your abilities!",
                "ðŸ„ Mushroom power makes you invincible!",
                "ðŸ”« Lasers can take them out safely!",
                "ðŸ¦˜ Jump on them from above!"
            ],
            
            bossLevel: [
                "ðŸ‘‘ Boss battle! Stay focused!",
                "ðŸ”¥ Watch out for lava attacks!",
                "ðŸ›¡ï¸ Boss armor gives major protection!",
                "ðŸŽ¯ Attack when he's vulnerable!"
            ],
            
            underwater: [
                "ðŸŒŠ You're underwater! Swim carefully!",
                "ðŸ¦ˆ Sharks are more dangerous here!",
                "ðŸ’Ž Underwater treasures are valuable!",
                "ðŸš Jetpacks work great underwater!"
            ],
            
            highPlatforms: [
                "â˜ï¸ High platforms need precise jumping!",
                "ðŸ¦˜ Double jump helps reach them!",
                "ðŸ’Ž High places often have treasures!",
                "ðŸ›¡ï¸ Armor is usually up high!",
                "â˜ï¸ Cloud platforms are tricky but rewarding!",
                "ðŸ¦˜ Use double jump for extra height!",
                "ðŸ’Ž The best treasures are up high!",
                "ðŸ›¡ï¸ Hidden armor loves high places!",
                "â˜ï¸ Take your time on high platforms!",
                "ðŸ¦˜ Double jump is your best friend!",
                "ðŸ’Ž High risk, high reward!",
                "ðŸ›¡ï¸ Boss armor is often up high!"
            ],
            
            // Fun and encouraging tips
            encouragement: [
                "ðŸŽ‰ You're doing great! Keep it up!",
                "ðŸŒŸ You're getting better at this!",
                "ðŸŽ¯ Nice moves! You're a natural!",
                "ðŸ’ª You've got this! Keep going!",
                "ðŸŽ® You're mastering the controls!",
                "â­ You're becoming an otter pro!",
                "ðŸŽŠ Excellent gameplay!",
                "ðŸ† You're on fire today!",
                "ðŸŽ¯ Perfect timing on that jump!",
                "ðŸŒŸ You're making this look easy!",
                "ðŸ’ª Your skills are improving!",
                "ðŸŽ® You're a platforming master!",
                "ðŸ¦‰ Wise choice on that jump!",
                "ðŸ¦‰ Your platforming wisdom grows!",
                "ðŸ¦‰ Excellent navigation, young otter!",
                "ðŸ¦‰ You're learning the ways of the platform!",
                "ðŸ¦‰ Your otter instincts are sharp!",
                "ðŸ¦‰ Magnificent display of otter agility!",
                "ðŸ¦‰ You're becoming a true otter master!"
            ]
        };
        
        // ðŸ¤– AI Bot Toggle Function (removed - button no longer exists)
        // Note: AI Bot can still be controlled through the pause menu
        
        // ðŸ¤– AI Bot Functions
        function updateAiBot() {
            // Skip updates if AI Owl Bot is disabled
            if (!aiOwlBotEnabled) return;
            
            // Update bot position to follow player (simplified)
            game.aiBot.x = player.x + game.aiBot.offsetX;
            game.aiBot.y = player.y + game.aiBot.offsetY;
            
            // Simplified bobbing motion (less frequent updates)
            if (Math.random() < 0.1) { // Only 10% chance to update bobbing
                game.aiBot.bobOffset = Math.sin(Date.now() * game.aiBot.bobSpeed) * 1;
            }
            
            // Simplified glow effect (less frequent updates)
            if (Math.random() < 0.05) { // Only 5% chance to update glow
                game.aiBot.glowIntensity = Math.sin(Date.now() * 0.002) * 0.2 + 0.8;
            }
            
            // Update owl's looking direction with delay
            if (game.aiBot.lookDelay > 0) {
                game.aiBot.lookDelay--;
            } else if (game.aiBot.lookDirection !== player.direction) {
                // Change direction with a small delay for natural movement
                game.aiBot.lookDirection = player.direction;
                game.aiBot.lookDelay = 10; // 10 frames delay
            }
            

        }
        

        
        function drawAiBot() {
            if (!game.aiBot.isVisible || !aiOwlBotEnabled) return;
            
            const botScreenX = game.aiBot.x - game.camera.x;
            const botScreenY = game.aiBot.y - game.camera.y + game.aiBot.bobOffset;
            
            // Only draw if on screen (simplified check)
            if (botScreenX < -150 || botScreenX > game.canvasWidth + 150 || 
                botScreenY < -150 || botScreenY > game.canvasHeight + 150) {
                return;
            }
            
            ctx.save();
            
            // Owl glow effect removed
            
            // Draw owl image with hat if equipped, otherwise default owl
            if (game.marketplace.currentHat && game.marketplace.currentHat !== 'none') {
                // Draw hat-equipped owl
                drawOwlHat(botScreenX, botScreenY);
            } else {
                // Draw default owl image
                if (gameAssets.owl) {
                    ctx.save();
                    // Flip owl based on owl's looking direction
                    if (game.aiBot.lookDirection === -1) {
                        ctx.scale(-1, 1);
                        ctx.drawImage(gameAssets.owl, -botScreenX - game.aiBot.width, botScreenY, game.aiBot.width, game.aiBot.height);
                    } else {
                        ctx.drawImage(gameAssets.owl, botScreenX, botScreenY, game.aiBot.width, game.aiBot.height);
                    }
                    ctx.restore();
                } else {
                    // Fallback to simple owl shape if image not loaded
                    ctx.fillStyle = '#8B4513'; // Brown color for owl
                    ctx.fillRect(botScreenX, botScreenY, game.aiBot.width, game.aiBot.height);
                    
                    // Draw owl eyes based on direction
                    ctx.fillStyle = '#FFD700'; // Golden eyes
                    if (game.aiBot.lookDirection === -1) {
                        // Looking left - adjust eye positions
                        ctx.beginPath();
                        ctx.arc(botScreenX + 15, botScreenY + 20, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(botScreenX + 45, botScreenY + 20, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw owl beak pointing left
                        ctx.fillStyle = '#FFA500'; // Orange beak
                        ctx.beginPath();
                        ctx.moveTo(botScreenX + 30, botScreenY + 35);
                        ctx.lineTo(botScreenX + 35, botScreenY + 45);
                        ctx.lineTo(botScreenX + 25, botScreenY + 45);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Looking right - normal eye positions
                        ctx.beginPath();
                        ctx.arc(botScreenX + 15, botScreenY + 20, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(botScreenX + 45, botScreenY + 20, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw owl beak pointing right
                        ctx.fillStyle = '#FFA500'; // Orange beak
                        ctx.beginPath();
                        ctx.moveTo(botScreenX + 30, botScreenY + 35);
                        ctx.lineTo(botScreenX + 25, botScreenY + 45);
                        ctx.lineTo(botScreenX + 35, botScreenY + 45);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
            
            ctx.restore();
            
            // Draw speech bubble if there's a tip
            if (game.aiBot.currentTip) {
                drawSpeechBubble(botScreenX, botScreenY);
            }
        }
        
        function drawPlayerHat(playerX, playerY, player) {
            ctx.save();
            
            // Position hat on player's head
            const hatX = playerX + player.collisionOffsetX + player.collisionWidth/2;
            const hatY = playerY + player.collisionOffsetY - 10; // Above the player's head
            
            // Scale hat based on player size and giant mode
            const hatScale = (player.isGiant ? 1.5 : 1.0);
            
            // Get the current hat image
            const currentHat = marketplaceItems.hats.find(hat => hat.id === game.marketplace.currentHat);
            if (currentHat && currentHat.image) {
                // Create a new image object for the hat
                const hatImage = new Image();
                hatImage.src = currentHat.image;
                
                if (hatImage.complete) {
                    // Draw the hat image
                    const hatWidth = 32 * hatScale; // Adjust size as needed
                    const hatHeight = 24 * hatScale;
                    ctx.drawImage(hatImage, hatX - hatWidth/2, hatY - hatHeight, hatWidth, hatHeight);
                } else {
                    // Fallback to colored rectangle if image not loaded
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(hatX - 8 * hatScale, hatY - 5 * hatScale, 16 * hatScale, 8 * hatScale);
                }
            }
            
            ctx.restore();
        }
        
        function drawOwlHat(botX, botY) {
            ctx.save();
            
            // Get the current hat image from marketplace
            const currentHat = marketplaceItems.hats.find(hat => hat.id === game.marketplace.currentHat);
            if (currentHat && currentHat.image) {
                // Create a new image object for the hat-equipped owl
                const hatOwlImage = new Image();
                hatOwlImage.src = currentHat.image;
                
                if (hatOwlImage.complete) {
                    // Draw the complete hat-equipped owl image with proper sizing
                    const owlWidth = game.aiBot.width;
                    const owlHeight = game.aiBot.height;
                    
                    // Handle directional flipping like the default owl
                    if (game.aiBot.lookDirection === -1) {
                        ctx.scale(-1, 1);
                        ctx.drawImage(hatOwlImage, -botX - owlWidth, botY, owlWidth, owlHeight);
                    } else {
                        ctx.drawImage(hatOwlImage, botX, botY, owlWidth, owlHeight);
                    }
                } else {
                    // Fallback to default owl if image not loaded
                    if (gameAssets.owl) {
                        if (game.aiBot.lookDirection === -1) {
                            ctx.scale(-1, 1);
                            ctx.drawImage(gameAssets.owl, -botX - game.aiBot.width, botY, game.aiBot.width, game.aiBot.height);
                        } else {
                            ctx.drawImage(gameAssets.owl, botX, botY, game.aiBot.width, game.aiBot.height);
                        }
                    }
                }
            }
            
            ctx.restore();
            
            // Draw speech bubble if there's a message
            if (game.aiBot.currentTip) {
                drawSpeechBubble(botX, botY);
            }
        }
        
        function drawSpeechBubble(botX, botY) {
            const bubbleX = botX + game.aiBot.width + 10;
            const bubbleY = botY - 120; // Moved much higher to avoid covering otter's face
            const bubbleWidth = 280; // Made much wider to accommodate longer text
            const bubbleHeight = 100; // Made much taller to fit more lines
            
            ctx.save();
            
            // Draw bubble background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.strokeStyle = '#4169E1';
            ctx.lineWidth = 2;
            
            // Main bubble (using manual rounded rectangle)
            ctx.beginPath();
            ctx.moveTo(bubbleX + 10, bubbleY);
            ctx.lineTo(bubbleX + bubbleWidth - 10, bubbleY);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + 10);
            ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - 10);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - 10, bubbleY + bubbleHeight);
            ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight);
            ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - 10);
            ctx.lineTo(bubbleX, bubbleY + 10);
            ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + 10, bubbleY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Speech bubble tail
            ctx.beginPath();
            ctx.moveTo(botX + game.aiBot.width, botY + 10);
            ctx.lineTo(bubbleX, bubbleY + bubbleHeight/2);
            ctx.lineTo(bubbleX + 5, bubbleY + bubbleHeight/2 + 5);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw tip text
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 13px Arial'; // Slightly smaller font for better fit
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            
            // Wrap text if needed
            const words = game.aiBot.currentTip.split(' ');
            let line = '';
            let lineHeight = 16; // Adjusted line height for better spacing
            let currentY = bubbleY + 25; // Better starting position for larger bubble
            
            for (let word of words) {
                const testLine = line + word + ' ';
                const testWidth = ctx.measureText(testLine).width;
                
                if (testWidth > bubbleWidth - 30 && line !== '') {
                    ctx.fillText(line, bubbleX + 15, currentY);
                    line = word + ' ';
                    currentY += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, bubbleX + 15, currentY);
            
            ctx.restore();
        }
        
        // ðŸ”‘ KEY GENERATION FUNCTION - HIGH WATER PROBABILITY
        function generateRandomKeys(platforms, levelNum) {
            const keys = [];
            
            console.log('ðŸ”‘ generateRandomKeys called for level:', levelNum, 'with platforms:', platforms.length);
            
            // FORCE key to spawn on EVERY level - GUARANTEED but DIFFICULT (MAX 1 KEY)
            if (platforms.length > 0 && keys.length === 0) { // Ensure only 1 key per level
                // Find a DIFFICULT platform - prioritize water areas
                let targetPlatform = null;
                
                // Filter for challenging platforms based on level
                let challengingPlatforms = [];
                
                // ðŸŒŠ HIGH PRIORITY: Water platforms (underwater platforms)
                let waterPlatforms = platforms.filter(p => p.type === 'underwater');
                console.log('ðŸ”‘ Found', waterPlatforms.length, 'water platforms for key placement');
                
                // Skip lava areas on boss levels
                if (game.bossActive) {
                    waterPlatforms = waterPlatforms.filter(p => p.y < game.lavaLevel - 100);
                    console.log('ðŸ”‘ Filtered out lava areas, remaining water platforms:', waterPlatforms.length);
                }
                
                // If we have water platforms, use them with high probability
                if (waterPlatforms.length > 0 && Math.random() < 0.8) { // 80% chance to use water platforms
                    challengingPlatforms = waterPlatforms;
                    console.log('ðŸ”‘ Using water platforms for key placement!');
                } else {
                    // Fallback to regular challenging platforms - NEVER spawn keys in lava
                    if (levelNum === 1) {
                        // First level: place on higher platforms (above 1000 Y) but not in lava
                        challengingPlatforms = platforms.filter(p => p.y < 1000 && p.x > 1000 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    } else if (levelNum <= 3) {
                        // Early levels: place on high platforms (above 800 Y) and far into level but not in lava
                        challengingPlatforms = platforms.filter(p => p.y < 800 && p.x > 1500 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    } else if (levelNum <= 5) {
                        // Mid levels: place on very high platforms (above 600 Y) and very far but not in lava
                        challengingPlatforms = platforms.filter(p => p.y < 600 && p.x > 2000 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    } else {
                        // Later levels: place on extremely high platforms (above 400 Y) and extremely far but not in lava
                        challengingPlatforms = platforms.filter(p => p.y < 400 && p.x > 2500 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    }
                    
                    // If no challenging platforms found, use fallback - still make it difficult but not in lava
                    if (challengingPlatforms.length === 0) {
                        // Find platforms in the second half of the level but not in lava
                        const midPoint = Math.floor(platforms.length / 2);
                        challengingPlatforms = platforms.slice(midPoint).filter(p => p.y < 1200 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    }
                    
                    // If still no platforms, use any platform but make it higher and not in lava
                    if (challengingPlatforms.length === 0) {
                        challengingPlatforms = platforms.filter(p => p.y < 1200 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    }
                    
                    // If still no platforms, use any platform but not in lava
                    if (challengingPlatforms.length === 0) {
                        challengingPlatforms = platforms.filter(p => !game.bossActive || p.y < game.lavaLevel - 100);
                    }
                }
                
                // Select a random challenging platform
                targetPlatform = challengingPlatforms[Math.floor(Math.random() * challengingPlatforms.length)];
                
                // Place key in a challenging position on the platform
                const keyX = targetPlatform.x + (targetPlatform.width * 0.8); // Near the edge of platform
                const keyY = targetPlatform.y - 60; // Higher above platform for more challenge
                
                keys.push({
                    x: keyX,
                    y: keyY,
                    collected: false,
                    type: 'key'
                });
                
                console.log('ðŸ”‘ DIFFICULT Key placed at position:', keyX, keyY, 'on platform at:', targetPlatform.x, targetPlatform.y);
                console.log('ðŸ”‘ Platform difficulty - Y:', targetPlatform.y, 'X:', targetPlatform.x, 'Level:', levelNum);
            } else {
                console.warn('ðŸ”‘ No platforms available for key placement!');
            }
            
            console.log('ðŸ”‘ Generated', keys.length, 'key items for level', levelNum);
            return keys;
        }

        // Otter player
        const player = {
            x: 240, // Start at correct X position (scaled from 100)
            y: 1200, // Start at correct Y position on starting platform (1320 - 80 - 40)
            width: 64, // Rectangular sprite
            height: 93, // Rectangular sprite
            velX: 0,
            velY: 0,
            speed: 10.5, // Increased movement speed for better responsiveness (7.035 * 1.5 = 10.5)
            jumpPower: 28, // Increased jump power for better feel (20 * 1.4 = 28)
            onGround: true, // Start on ground to prevent immediate falling
            canDoubleJump: true,
            direction: 1,
            // Collision box that matches the visual sprite exactly
            collisionWidth: 64, // Same as sprite width
            collisionHeight: 93, // Same as sprite height
            collisionOffsetX: 0, // No offset - collision matches sprite exactly
            collisionOffsetY: 0, // No offset - collision matches sprite exactly
            // Health system
            health: 100,
            maxHealth: 100,
            // Armor system
            armor: 0,
            maxArmor: 100,
            // Invulnerability system
            invulnerable: false,
            invulnerableTime: 0,
            invulnerableDuration: 2000, // 2 seconds of invulnerability after taking damage
            damageInvulnerable: false, // Separate from mushroom invulnerability
            // Mushroom power-up system
            isGiant: false,
            giantTime: 0,
            giantDuration: 10000, // 10 seconds of giant mode
            // Last platform tracking for respawn
            lastPlatform: null,
            // Platform movement tracking
            onMovingPlatform: false,
            platformOffsetX: 0,
            platformOffsetY: 0,
            platformStartTime: 0,
            // Extra abilities

            // Jetpack system
            hasJetpack: false,
            jetpackActive: false,
            jetpackTime: 0,
            jetpackDuration: Infinity, // No time limit - usable for entire level
            jetpackPower: 30, // Increased jetpack power for better feel (22.5 * 1.33 = 30)
            waterJetpackPower: 500, // Increased water jetpack power (375 * 1.33 = 500)
            lastJumpTime: 0,
            // Laser system
            hasLaser: false,
            laserActive: false,
            laserTime: 0,
            laserDuration: Infinity, // No time limit - usable for entire level
            laserCooldown: 0,
            laserSpeed: 10, // 25% faster laser speed (8 * 1.25 = 10)
            laserColors: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'], // Red, Green, Blue, Yellow, Magenta, Cyan
            currentLaserColor: 0,
              // Laser charging system
              isCharging: false,
              chargeStartTime: 0,
              chargeLevel: 0,
            maxChargeLevel: 6, // Fixed max charge level
              chargeTime: 1000, // 1 second to fully charge
            
            // Fireball system
            hasFireball: false,
            fireballCooldown: 0,
            fireballSpeed: 7.5, // 25% faster fireball speed (6 * 1.25 = 7.5)
            fireballLifetime: 0,
            maxFireballLifetime: 3000, // 3 seconds in milliseconds
            
            // Armor system
            hasArmorBoost: false,
            armorLevel: 0, // 0 = no boost, 1 = +25%, 2 = +50%, 3 = +75%
            maxArmorLevel: 3,
            
            // XP and Reward System
            xp: 0,
            level: 1,
            xpToNextLevel: 1000, // XP needed for next level (will be calculated dynamically)
            totalScore: 0,

            laserChargingLevel: 0, // Start at 0 - must be unlocked
            maxLaserChargingLevel: 6, // Maximum charging level
            unlockedRewards: [], // Track unlocked rewards
            laserChargeLockedMessageShown: false, // Track if laser charge locked message has been shown
                    rewards: {
                xpPerScore: 0.1, // Reduced XP gained per score point (was 1)
                levelCompletionBonus: 50, // Reduced base XP for completing a level (was 100)

                // Laser charge ability unlocks every 10 levels (10, 20, 30, 40, 50, 60)
                laserChargeUnlockLevels: [10, 20, 30, 40, 50, 60], // Levels where laser charge ability unlocks
                laserUpgradeLevels: [10, 20, 30, 40, 50, 60], // Levels where laser charging upgrades (max 6 upgrades)
                // New unlock rewards system
                unlockRewards: {
                    5: { type: 'cosmetic', name: 'Golden Otter Skin', description: 'Unlock golden otter skin' },
                    10: { type: 'laser', name: 'Laser Level 2', description: 'Upgrade laser charging to level 2' },
                    15: { type: 'cosmetic', name: 'Rainbow Trail', description: 'Unlock rainbow trail effect' },
                    20: { type: 'laser', name: 'Laser Level 3', description: 'Upgrade laser charging to level 3' },
                    25: { type: 'ability', name: 'Double Jump', description: 'Unlock double jump ability' },
                    30: { type: 'laser', name: 'Laser Level 4', description: 'Upgrade laser charging to level 4' },
                    35: { type: 'cosmetic', name: 'Particle Effects', description: 'Unlock enhanced particle effects' },
                    40: { type: 'laser', name: 'Laser Level 5', description: 'Upgrade laser charging to level 5' },
                    50: { type: 'laser', name: 'Laser Level 6', description: 'Upgrade laser charging to level 6' },
                    60: { type: 'cosmetic', name: 'Legendary Status', description: 'Unlock legendary player status' }
                },
                
                // Armor upgrade levels (requires armor ability to be purchased first)
                armorUpgradeLevels: [15, 30, 45] // Levels where armor upgrades (Level 2, 3, 4)
            },
            // Key system
            keys: 0,
            // Water system
            inWater: false,
            swimming: false,
            swimSpeed: 7.5, // Increased swimming speed for better responsiveness (5.16 * 1.45 = 7.5)
            waterResistance: 0.3,
            // Lava system
            inLava: false,
                          lavaSinkTime: 0,
              lavaDamageTime: 0,
              lastLavaDamageTime: 0,
              lavaInvulnerable: false
        };
        
        // Level generator functions
        function generateRandomPlatforms(levelNum) {
            const platforms = [
                { x: 0, y: 1320, width: 480, height: 120, type: 'static' }, // Starting platform (scaled from 200x50)
                { x: -100, y: 0, width: 50, height: 2000, type: 'barrier' } // Left barrier wall to prevent going too far left
            ];
            
            const difficulty = Math.min(levelNum, 10); // Cap difficulty scaling
            const platformCount = 20 + Math.floor(difficulty * 2); // More platforms for better coverage
            const minGap = levelNum === 1 ? Math.max(400, 500 - difficulty * 2.4) : Math.max(500, 600 - difficulty * 2.4); // MUCH larger gaps for proper spacing
            const maxGap = levelNum === 1 ? Math.max(600, 700 - difficulty * 2.4) : Math.max(700, 800 - difficulty * 2.4); // MUCH larger gaps for proper spacing
            
            let currentX = 720; // Scaled from 300 (300*2.4=720)
            
            // Create multiple paths and exploration areas
            for (let i = 0; i < platformCount; i++) {
                // Chaotic gap and width generation
                const gapX = minGap + Math.random() * (maxGap - minGap) + (Math.random() < 0.3 ? Math.random() * 200 : 0); // Sometimes add extra random gap
                
                // Generate longer platforms more frequently
                let platformWidth;
                if (Math.random() < 0.6) { // 60% chance for long platforms
                    platformWidth = 300 + Math.random() * 400; // Long platforms (300-700 pixels)
                } else {
                    platformWidth = 120 + Math.random() * 200; // Regular platforms (120-320 pixels)
                }
                
                // Create VARIED platform heights - much more accessible
                let platformY;
                
                // Generate more low platforms for better gameplay
                if (Math.random() < 0.6) { // 60% chance for low platforms
                    platformY = 1000 + Math.random() * 200; // Low platforms (1000-1200) - close to water
                } else if (Math.random() < 0.3) { // 30% chance for medium platforms
                    platformY = 800 + Math.random() * 200; // Medium platforms (800-1000)
                } else {
                    // 10% chance for higher platforms - much more limited
                    if (levelNum === 1) {
                        platformY = 700 + Math.random() * 100; // First level: moderate heights
                    } else if (levelNum <= 3) {
                        platformY = 650 + Math.random() * 150; // Early levels: varied heights
                    } else {
                        platformY = 600 + Math.random() * 200; // Later levels: higher heights (but still reachable)
                    }
                }
                
                // Determine platform type based on level and position
                let platformType = 'static';
                if (levelNum >= 2 && Math.random() < 0.2) {
                    platformType = 'linear';
                } else if (levelNum >= 4 && Math.random() < 0.15) {
                    platformType = 'disappearing';
                } else if (levelNum >= 3 && Math.random() < 0.25) {
                    platformType = 'cloud'; // Add cloud platforms
                }
                
                // Add random X offset for more chaotic positioning
                const randomXOffset = Math.random() < 0.4 ? (Math.random() - 0.5) * 200 : 0; // 40% chance for random X offset
                
                const platform = {
                    x: currentX + randomXOffset,
                    y: Math.max(700, Math.min(1200, platformY)), // Lower maximum Y to ensure reachability
                    width: platformWidth,
                    height: 48, // Scaled from 20 (20*2.4=48)
                    type: platformType
                };
                
                // Adjust cloud platform Y position to be 200px higher than regular platforms (more reachable)
                if (platformType === 'cloud') {
                    platform.y = Math.max(400, platform.y - 200); // 200px higher, but not below 400
                }
                
                // Add movement properties for moving platforms
                if (platformType === 'linear') {
                    platform.moveSpeed = 0.625 + Math.random() * 0.625; // 25% faster platform speed (0.5*1.25=0.625, 0.5*1.25=0.625)
                    platform.moveDistance = 50 + Math.random() * 100; // Shorter distance (50-150)
                    platform.startX = currentX;
                    platform.startY = platform.y;
                    platform.moveDirection = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                    platform.moveProgress = 0;
                } else if (platformType === 'disappearing') {
                    platform.disappearTime = 3000 + Math.random() * 2000; // 3-5 seconds
                    platform.reappearTime = 2000 + Math.random() * 2000; // 2-4 seconds
                    platform.isVisible = true;
                    platform.lastToggle = Date.now();
                } else if (platformType === 'cloud') {
                    // Cloud platform properties
                    platform.cloudType = Math.floor(Math.random() * 3); // 0, 1, or 2 for different cloud styles
                    platform.cloudOpacity = 0.7 + Math.random() * 0.3; // 0.7-1.0 opacity
                    platform.cloudPuffiness = 0.8 + Math.random() * 0.4; // 0.8-1.2 puffiness
                    platform.cloudColor = Math.random() < 0.3 ? '#E6F3FF' : '#FFFFFF'; // Sometimes light blue
                    platform.cloudTime = Date.now(); // For animation
                    
                    // Cloud disappearing behavior
                    platform.isVisible = true;
                    platform.cloudStartTime = null; // When player first steps on cloud
                    platform.cloudDisappearTime = 3000; // 3 seconds to disappear
                    platform.isDisappearing = false;
                    
                    // Special cloud properties
                    if (Math.random() < 0.2) {
                        // Rain cloud removed for performance
                    }
                    if (Math.random() < 0.15) {
                        platform.isThunderCloud = true; // 15% chance for thunder cloud
                        platform.thunderTimer = 0;
                    }
                    if (Math.random() < 0.1) {
                        platform.isGoldenCloud = true; // 10% chance for golden cloud (special rewards)
                    }
                }
                
                platforms.push(platform);
                
                // Add intermediate platforms randomly for chaotic layout
                if (levelNum > 1 && Math.random() < 0.1 && i > 2) { // Very rare for chaotic layout
                    const intermediateX = currentX + Math.random() * platformWidth;
                    const intermediateY = platformY - 72 - Math.random() * 72; // Closer to main platform (scaled from 30, 30)
                    platforms.push({
                        x: intermediateX,
                        y: Math.max(672, intermediateY), // Scaled from 280 (280*2.4=672)
                        width: 144 + Math.random() * 96, // Scaled from 60, 40 (60*2.4=144, 40*2.4=96)
                        height: 48 // Scaled from 20 (20*2.4=48)
                    });
                }
                
                // Add extra stepping stone platforms randomly for chaotic layout
                if (levelNum > 1 && Math.random() < 0.05 && i > 3) { // Very rare for chaotic layout
                    const stepX = currentX + Math.random() * platformWidth;
                    const stepY = platformY - 120 - Math.random() * 60; // Lower stepping stone
                    platforms.push({
                        x: stepX,
                        y: Math.max(672, stepY),
                        width: 120 + Math.random() * 72, // Smaller stepping stone
                        height: 48,
                        isSteppingStone: true
                    });
                }
                
                // Add some branching platforms for exploration (only in later levels)
                if (levelNum > 2 && Math.random() < 0.3 && i > 5) { // Increased from 0.2 to 0.3
                    const branchX = currentX + Math.random() * platformWidth;
                    const branchY = platformY - 96 - Math.random() * 96; // Scaled from 40, 40 (40*2.4=96, 40*2.4=96)
                    platforms.push({
                        x: branchX,
                        y: Math.max(672, branchY), // Scaled from 280 (280*2.4=672)
                        width: 144 + Math.random() * 96, // Scaled from 60, 40 (60*2.4=144, 40*2.4=96)
                        height: 48 // Scaled from 20 (20*2.4=48)
                    });
                }
                
                // Add high platforms with rare treasures (challenging to reach)
                if (levelNum > 1 && Math.random() < 0.15 && i > 3) {
                    const highPlatformX = currentX + Math.random() * platformWidth;
                    const highPlatformY = 480 + Math.random() * 192; // Scaled from 200, 80 (200*2.4=480, 80*2.4=192)
                    platforms.push({
                        x: highPlatformX,
                        y: highPlatformY,
                        width: 192 + Math.random() * 96, // Scaled from 80, 40 (80*2.4=192, 40*2.4=96)
                        height: 48, // Scaled from 20 (20*2.4=48)
                        isHighPlatform: true // Mark as high platform for treasure placement
                    });
                    
                    // Add stepping stone platforms to reach high platforms
                    if (Math.random() < 0.7) { // 70% chance to add stepping stones
                        const step1X = highPlatformX - 144 - Math.random() * 72; // Scaled from 60, 30
                        const step1Y = highPlatformY + 96 + Math.random() * 48; // Scaled from 40, 20
                        platforms.push({
                            x: step1X,
                            y: step1Y,
                            width: 120 + Math.random() * 72, // Scaled from 50, 30
                            height: 48, // Scaled from 20 (20*2.4=48)
                            isSteppingStone: true
                        });
                        
                        const step2X = step1X - 120 - Math.random() * 72; // Scaled from 50, 30
                        const step2Y = step1Y + 72 + Math.random() * 48; // Scaled from 30, 20
                        platforms.push({
                            x: step2X,
                            y: step2Y,
                            width: 120 + Math.random() * 72, // Scaled from 50, 30
                            height: 48, // Scaled from 20 (20*2.4=48)
                            isSteppingStone: true
                        });
                    }
                }
                
                currentX += gapX + platformWidth;
            }
            
            // Note: Final goal platform is now added at the very end after floating platforms
            
            // Add multiple tiers of platforms for proper progression
            const screenHeight = 1800;
            const groundExtensions = [];
            
            // Create multiple height tiers for climbing progression
            const tierHeights = [1200, 1000, 800, 600, 400, 200]; // Multiple tiers from ground up
            const levelWidth = currentX + 600;
            
            // Add intermediate platforms at different tiers
            for (let x = 200; x < levelWidth; x += 400) { // More frequent platforms
                if (Math.random() < 0.6) { // 60% chance for more platforms
                    const tierIndex = Math.floor(Math.random() * tierHeights.length);
                    const tierY = tierHeights[tierIndex];
                    const platformWidth = 120 + Math.random() * 200;
                    const platformX = x + Math.random() * 200;
                    
                    // Check if this area is empty (no existing platform nearby)
                    const isAreaEmpty = !platforms.some(p => 
                        Math.abs(p.x - platformX) < 150 && Math.abs(p.y - tierY) < 100
                    );
                    
                    if (isAreaEmpty) {
            platforms.push({
                            x: platformX,
                            y: tierY,
                            width: platformWidth,
                            height: 40,
                            type: 'static'
                        });
                    }
                }
            }
            
            // Add ground extensions for platforms that are too high to reach
            platforms.forEach(platform => {
                if (platform.y < 800) { // For platforms that are high up
                    const actualBottom = screenHeight;
                    const platformBottom = platform.y + platform.height;
                    const extensionHeight = actualBottom - platformBottom;
                    
                    if (extensionHeight > 300) { // Only if there's significant space to fill
                        groundExtensions.push({
                            x: platform.x,
                            y: platformBottom,
                            width: platform.width,
                            height: extensionHeight,
                            type: 'ground',
                            isGroundExtension: true
                        });
                    }
                }
            });
            
            // Add strategic ground pillars for climbing
            for (let x = 0; x < levelWidth; x += 600) { // More frequent pillars
                if (Math.random() < 0.5) { // 50% chance
                    const pillarWidth = 100 + Math.random() * 150;
                    const pillarY = 1100 + Math.random() * 200; // Near ground level
                    const pillarHeight = screenHeight - pillarY;
                    
                    groundExtensions.push({
                        x: x + Math.random() * 200,
                        y: pillarY,
                        width: pillarWidth,
                        height: pillarHeight,
                        type: 'ground',
                        isGroundExtension: true
                    });
                }
            }
            
            // Add ground extensions to the main platforms array
            platforms.push(...groundExtensions);
            
            // Add some floating platforms in the air for better respawn points
            const floatingPlatforms = [];
            for (let i = 0; i < 3; i++) { // Add 3 floating platforms
                const floatX = 800 + i * 600 + Math.random() * 400; // Spread them out
                const floatY = 800 + Math.random() * 200; // Mid-height platforms
                const floatWidth = 200 + Math.random() * 200; // 200-400 pixels wide
                
                floatingPlatforms.push({
                    x: floatX,
                    y: floatY,
                    width: floatWidth,
                    height: 48, // Standard platform height
                    type: 'static',
                    isFloating: true
                });
            }
            
            platforms.push(...floatingPlatforms);
            
            // Add cloud platforms - GUARANTEED on every level, dispersed throughout
            const cloudPlatforms = [];
            
            // Calculate level width and add clouds throughout the entire level (but stop before goal)
            const goalArea = currentX + 600; // Goal flag position
            const cloudCutoff = goalArea - 800; // Stop clouds 800px before the goal
            const cloudSpacing = 600; // Distance between cloud platforms
            const cloudCount = Math.floor(cloudCutoff / cloudSpacing) + 1; // Ensure clouds cover the level but stop before goal
            
            for (let i = 0; i < cloudCount; i++) {
                // Find the highest platform to position clouds above it
                const highestPlatform = platforms.reduce((highest, platform) => 
                    platform.y < highest.y ? platform : highest, platforms[0]);
                
                const cloudX = 200 + i * cloudSpacing + Math.random() * 400; // Spread clouds evenly across the level
                // Ensure cloud doesn't go beyond the cutoff point
                if (cloudX > cloudCutoff) continue; // Skip this cloud if it would be too close to goal
                const baseCloudY = Math.max(200, highestPlatform.y - 300); // Base position 300px above highest platform
                const heightVariation = Math.random() * 400; // 0-400px additional height variation
                const cloudY = baseCloudY - heightVariation; // Vary height above the base position
                const cloudWidth = 200 + Math.random() * 300; // 200-500 pixels wide
                
                const cloudPlatform = {
                    x: cloudX,
                    y: cloudY,
                    width: cloudWidth,
                    height: 48,
                    type: 'cloud',
                    cloudType: Math.floor(Math.random() * 3), // 0, 1, or 2 for different cloud styles
                    cloudOpacity: 0.7 + Math.random() * 0.3, // 0.7-1.0 opacity
                    cloudPuffiness: 0.8 + Math.random() * 0.4, // 0.8-1.2 puffiness
                    cloudColor: Math.random() < 0.3 ? '#E6F3FF' : '#FFFFFF', // Sometimes light blue
                    cloudTime: Date.now(), // For animation
                    
                    // Cloud disappearing behavior
                    isVisible: true,
                    cloudStartTime: null, // When player first steps on cloud
                    cloudDisappearTime: 3000, // 3 seconds to disappear
                    isDisappearing: false,
                    respawnStartTime: null // When cloud starts respawning
                };
                
                // Special cloud properties
                if (Math.random() < 0.2) {
                    // Rain cloud removed for performance
                }
                if (Math.random() < 0.15) {
                    cloudPlatform.isThunderCloud = true; // 15% chance for thunder cloud
                    cloudPlatform.thunderTimer = 0;
                }
                if (Math.random() < 0.1) {
                    cloudPlatform.isGoldenCloud = true; // 10% chance for golden cloud (special rewards)
                }
                
                cloudPlatforms.push(cloudPlatform);
            }
            
            platforms.push(...cloudPlatforms);
            
            // ðŸŒŠ Add underwater platforms extending down to death barrier
            const underwaterPlatformCount = 15 + Math.floor(levelNum * 3); // Much more underwater platforms
            const underwaterStartY = game.waterLevel + 200; // Start 200px below water surface
            const underwaterEndY = game.deathBarrier - 200; // Stop 200px above death barrier
            
            // Skip underwater platforms on boss levels (lava instead of water)
            if (!game.bossActive) {
            
            for (let i = 0; i < underwaterPlatformCount; i++) {
                const underwaterX = 200 + Math.random() * (currentX + 400); // Spread across level width
                const underwaterY = underwaterStartY + (i * (underwaterEndY - underwaterStartY) / underwaterPlatformCount) + Math.random() * 200;
                const underwaterWidth = 120 + Math.random() * 240; // 120-360px wide
                
            platforms.push({
                    x: underwaterX,
                    y: underwaterY,
                    width: underwaterWidth,
                    height: 60, // Thinner underwater platforms
                    type: 'underwater' // New platform type for underwater
                });
            }
            } // Close the if (!game.bossActive) block
            
            // Add final goal platform at the very end (after all other platforms)
            const finalLevelWidth = Math.max(...platforms.map(p => p.x + p.width)) + 1200; // 1200px beyond the last platform
            
            // Add extra space for boss levels to prevent accidental goal completion
            const isBossLevel = levelNum % 5 === 0;
            const extraBossSpace = isBossLevel ? 2000 : 0; // 2000px extra space for boss levels
            const goalPlatformX = finalLevelWidth + extraBossSpace;
            
            // For boss levels, create a long boss platform before the goal
            if (isBossLevel) {
                const bossPlatformX = finalLevelWidth + 800; // 800px before the goal
                const bossPlatformWidth = 1200; // Very long platform for boss battles
                
                platforms.push({
                    x: bossPlatformX,
                    y: 1200, // Same height as goal platform
                    width: bossPlatformWidth,
                    height: 120,
                    type: 'boss' // Special boss platform type
                });
                
                // Store boss platform info for positioning
                game.bossPlatformX = bossPlatformX;
                game.bossPlatformWidth = bossPlatformWidth;
            }
            
            platforms.push({
                x: goalPlatformX,
                y: 1200, // Scaled from 500 (500*2.4=1200)
                width: 360, // Scaled from 150 (150*2.4=360)
                height: 120 // Scaled from 50 (50*2.4=120)
            });
            
            // Store goal position for collision detection
            game.goalX = goalPlatformX;
            game.goalY = 1200;
            
            return platforms;
        }
        
        function generateRandomFish(platforms, levelNum) {
            const fish = [];
            const fishCount = 8 + Math.floor(levelNum * 1.5); // More fish for longer levels
            
            // Place fish on or above platforms
            for (let i = 1; i < Math.min(platforms.length - 1, fishCount + 1); i++) {
                const platform = platforms[i];
                const fishX = platform.x + platform.width / 2;
                const fishY = platform.y - 72 - Math.random() * 120; // Scaled from 30, 50 (30*2.4=72, 50*2.4=120)
                
                fish.push({
                    x: fishX,
                    y: fishY,
                    collected: false
                });
            }
            
            return fish;
        }
        
        function generateRandomEnemies(platforms, levelNum) {
            const enemies = [];
            const enemyCount = Math.min(12 + Math.floor(levelNum * 5), 60); // Much more enemies for higher levels
            const enemySpeed = Math.min(1.0 + levelNum * 0.19, 4.0); // 25% faster enemies (0.8*1.25=1.0, 0.15*1.25=0.19, 3.2*1.25=4.0)
            
            // Enemy types and properties
            const enemyTypes = {
                basic: { width: 60, height: 50, speed: enemySpeed, health: 1, type: 'crab', collisionWidth: 50, collisionHeight: 40, collisionOffsetX: 5, collisionOffsetY: 5 },
                shooter: { width: 60, height: 50, speed: enemySpeed * 0.5, health: 1, type: 'crab', canShoot: true, shotCooldown: 2000, collisionWidth: 50, collisionHeight: 40, collisionOffsetX: 5, collisionOffsetY: 5 },
                eagle: { width: 100, height: 80, speed: 1.5, health: 1, type: 'eagle', canFly: true, diveSpeed: 2.75, diveRange: 300, sineOffset: 0, collisionWidth: 90, collisionHeight: 70, collisionOffsetX: 4, collisionOffsetY: 4, isAttacking: false, targetPlayer: false, isFlyingBack: false, originalYSet: false, isRetreating: false, retreatStartTime: undefined, originalPatrolY: undefined },
                charger: { width: 70, height: 60, speed: enemySpeed * 0.8, health: 2, type: 'charger', canCharge: true, chargeSpeed: 5, chargeWindup: 1000, chargeCooldown: 3000, isCharging: false, chargeStartTime: 0, collisionWidth: 60, collisionHeight: 50, collisionOffsetX: 5, collisionOffsetY: 5 },
                goldfish: { width: 80, height: 60, speed: enemySpeed * 1.2, health: 1, type: 'goldfish', canSwim: true, swimSpeed: enemySpeed * 1.2, collisionWidth: 70, collisionHeight: 50, collisionOffsetX: 5, collisionOffsetY: 5, canShoot: false, shotCooldown: 3000 },
                gator: { width: 80, height: 53, speed: enemySpeed * 0.3, health: 2, type: 'gator', canSwim: true, isOnWaterSurface: true, chaseRange: 300, chaseSpeed: enemySpeed * 0.75, chaseDuration: 1500, isChasing: false, chaseStartTime: 0, collisionWidth: 73, collisionHeight: 47, collisionOffsetX: 3, collisionOffsetY: 3 },
                wizgator: { width: 80, height: 53, speed: enemySpeed * 0.3, health: 2, type: 'wizgator', canSwim: true, isOnLiquidSurface: true, chaseRange: 300, chaseSpeed: enemySpeed * 0.75, chaseDuration: 1500, isChasing: false, chaseStartTime: 0, collisionWidth: 73, collisionHeight: 47, collisionOffsetX: 3, collisionOffsetY: 3, canShoot: true, shotCooldown: 3000 },
                shark: { width: 120, height: 60, speed: 1.875, health: 3, type: 'shark', canSwim: true, isUnderwater: true, diveSpeed: 3.125, diveRange: 400, sineOffset: 0, collisionWidth: 110, collisionHeight: 50, collisionOffsetX: 5, collisionOffsetY: 5, isAttacking: false, targetPlayer: false, isSwimmingBack: false, originalYSet: false, isRetreating: false, retreatStartTime: undefined, originalPatrolY: undefined }
            };
            
            // Distribute enemies evenly across the entire level
            const totalPlatforms = platforms.length;
            const platformsPerEnemy = Math.max(1, Math.floor(totalPlatforms / enemyCount)); // Ensure at least 1 platform per enemy
            
            console.log('ðŸ” ENEMY SPAWNING DEBUG: Level', levelNum, 'Boss Active:', game.bossActive, 'Platforms:', platforms.length, 'Enemy Count:', enemyCount, 'Platforms per Enemy:', platformsPerEnemy);
            
            // Place enemies on platforms (skip first 2 platforms for safety)
            for (let i = 2; i < Math.min(platforms.length - 1, enemyCount * 2); i++) { // Check more platforms for better distribution
                let spawnChance = 0.4; // Base 40% chance per platform
                
                // Even distribution across all sections
                const sectionProgress = i / totalPlatforms;
                if (sectionProgress <= 0.33) {
                    spawnChance = 0.5; // Beginning section
                } else if (sectionProgress <= 0.66) {
                    spawnChance = 0.6; // Middle section
                } else {
                    spawnChance = 0.7; // End section
                }
                
                // Increase spawn chance based on level difficulty
                spawnChance += levelNum * 0.05; // +5% per level for more balanced progression
                spawnChance = Math.min(spawnChance, 0.85); // Cap at 85% for better distribution
                
                console.log('ðŸŽ² PLATFORM SPAWN CHECK! Platform', i, 'Spawn Chance:', spawnChance.toFixed(2), 'Random:', Math.random().toFixed(2));
                if (Math.random() < spawnChance) {
                    console.log('âœ… SPAWN CHANCE PASSED! Platform', i, 'will spawn enemy');
                    const platform = platforms[i];
                    
                    // Check distance from player starting position (240, ~1170)
                    const playerStartX = 240;
                    const playerStartY = 1170; // Approximate player Y position on starting platform
                    const enemySpawnX = platform.x + 72;
                    const enemySpawnY = platform.y;
                    
                    const distanceFromPlayer = Math.sqrt(
                        Math.pow(enemySpawnX - playerStartX, 2) + 
                        Math.pow(enemySpawnY - playerStartY, 2)
                    );
                    
                    // Additional check: prevent spawning on the starting platform itself
                    const startingPlatform = platforms.find(p => p.x === 0 && p.y === 1320);
                    if (startingPlatform && platform === startingPlatform) {
                        console.log('ðŸš« STARTING PLATFORM DETECTED! Skipping enemy spawn');
                        continue; // Skip the starting platform entirely
                    }
                    
                    if (distanceFromPlayer < 150) {
                        console.log('ðŸš« ENEMY TOO CLOSE TO PLAYER! Distance:', distanceFromPlayer.toFixed(0), 'px, Skipping spawn');
                        continue; // Skip this platform
                    }
                    
                    // Check if this platform is suitable for enemies
                    const isUnderwaterPlatform = platform.type === 'underwater';
                    const hasSolidGround = platform.y >= 1100 || // Platform is near ground level
                                          platform.isGroundExtension || // Platform is a ground extension
                                          platform.type === 'ground'; // Platform is ground type
                    
                    // Skip spawning enemies in lava areas on boss levels (but allow some platforms for wizgators)
                    if (game.bossActive && platform.y > game.lavaLevel - 100) {
                        console.log('ðŸŒ‹ LAVA PLATFORM DETECTED! Platform Y:', platform.y, 'Lava Level:', game.lavaLevel);
                        // Allow 20% of lava-adjacent platforms for potential wizgator spawning
                        if (Math.random() > 0.2) {
                            console.log('ðŸŒ‹ SKIPPING LAVA PLATFORM');
                            continue; // Skip most platforms near lava on boss levels
                        } else {
                            console.log('ðŸŒ‹ ALLOWING LAVA PLATFORM FOR WIZGATOR');
                        }
                    }
                    
                    // Spawn enemies on underwater platforms, solid ground, or easily reachable platforms
                    if (!hasSolidGround && !isUnderwaterPlatform && platform.y < 1000) {
                        console.log('ðŸš« SKIPPING HIGH PLATFORM! Platform Y:', platform.y, 'Has Solid Ground:', hasSolidGround, 'Is Underwater:', isUnderwaterPlatform);
                        continue; // Skip floating platforms that are too high (unless underwater)
                    }
                    
                    // Increase spawn chance for underwater platforms
                    if (isUnderwaterPlatform) {
                        spawnChance += 0.3; // +30% bonus for underwater platforms
                        spawnChance = Math.min(spawnChance, 0.98); // Cap at 98%
                    }
                    
                    // Choose enemy type based on level and position
                    let enemyType = 'basic';
                    
                    // Balanced enemy type selection based on level
                    if (levelNum >= 6 && Math.random() < 0.25) {
                        enemyType = 'shooter';
                    } else if (levelNum >= 4 && Math.random() < 0.2) {
                        enemyType = 'charger';
                    } else if (levelNum >= 3 && Math.random() < 0.3) {
                        enemyType = 'eagle';
                    } else if (levelNum >= 2 && Math.random() < 0.25) {
                        enemyType = 'gator';
                    } else if (levelNum >= 4 && Math.random() < 0.15) {
                        enemyType = 'wizgator';
                    } else if (levelNum >= 2 && Math.random() < 0.4) {
                        enemyType = 'shark';
                    }
                    
                    // Prevent eagles from spawning on underwater platforms
                    if (enemyType === 'eagle' && platform.y > 1200) {
                        console.log('ðŸ¦… Skipping underwater platform for eagle - platform Y:', platform.y, 'water level:', game.waterLevel);
                        continue; // Skip this platform for eagles
                    }
                    
                    // Prevent sharks from spawning on boss levels (lava levels)
                    if (enemyType === 'shark' && game.bossActive) {
                        console.log('ðŸ¦ˆ Skipping shark spawn on boss level - sharks only spawn in water levels');
                        continue; // Skip shark spawning on boss levels
                    }
                    

                    
                    const enemyConfig = enemyTypes[enemyType];
                    const enemy = {
                        x: platform.x + 72,
                        y: platform.y - enemyConfig.height, // Position on top of platform
                        width: enemyConfig.width,
                        height: enemyConfig.height,
                        velX: enemyConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: enemyConfig.type,
                        health: enemyConfig.health,
                        ...enemyConfig
                    };
                    
                    // Ensure enemy is properly positioned on top of the platform
                    enemy.y = platform.y - enemy.height;
                    
                    // Additional safety check: ensure enemy is not floating above platform
                    if (enemy.y < platform.y - enemy.height - 5) {
                        enemy.y = platform.y - enemy.height;
                    }
                    
                    // Debug: Log enemy positioning and health
                    console.log(`Enemy spawned: type=${enemy.type}, health=${enemy.health}, at y=${enemy.y}, platform at y=${platform.y}, enemy height=${enemy.height}, platform type=${platform.type}, collisionBox=${enemy.collisionWidth}x${enemy.collisionHeight}, offset=(${enemy.collisionOffsetX},${enemy.collisionOffsetY})`);
                    
                    // Special debug for eagles
                    if (enemy.type === 'eagle') {
                        console.log('ðŸ¦… EAGLE SPAWNED! Position:', enemy.x, enemy.y, 'Platform Y:', platform.y, 'Water Level:', game.waterLevel, 'Level:', levelNum);
                    }
                    
                    // Add type-specific properties
                    if (enemyType === 'eagle') {
                        enemy.y = platform.y - 200; // Fly above platforms
                        enemy.sineOffset = Math.random() * Math.PI * 2;
                        enemy.originalY = enemy.y;
                        enemy.originalPatrolY = enemy.y; // Store original patrol height
                        enemy.originalSpawnY = enemy.y; // Store original spawn position for retreat
                        enemy.originalSpawnX = enemy.x; // Store original spawn X position for retreat
                    } else if (enemyType === 'charger') {
                        enemy.lastChargeTime = 0;
                    } else if (enemyType === 'shooter') {
                        enemy.lastShot = 0;
                        enemy.canShoot = true;
                        enemy.shotCooldown = 2000 + Math.random() * 1000; // 2-3 seconds between shots
                        console.log('ðŸ”« SHOOTER CRAB SPAWNED! Position:', enemy.x, enemy.y, 'Level:', levelNum);
                    } else if (enemyType === 'gator') {
                        // Position gator on water surface
                        enemy.y = game.waterLevel - enemy.height + 20; // Sit on water surface
                        enemy.originalX = enemy.x; // Store original position for patrol
                        enemy.patrolDirection = Math.random() < 0.5 ? 1 : -1;
                        enemy.isChasing = false; // Ensure chase state is initialized
                        enemy.chaseStartTime = 0; // Initialize chase timer
                        
                        console.log('ðŸŠ GATOR SPAWNED! Position:', enemy.x, enemy.y, 'Water Level:', game.waterLevel, 'Level:', levelNum);
                    } else if (enemyType === 'wizgator') {
                        // Position wizgator on water/lava surface
                        enemy.y = game.waterLevel - enemy.height + 20; // Sit on water/lava surface
                        enemy.originalX = enemy.x; // Store original position for patrol
                        enemy.patrolDirection = Math.random() < 0.5 ? 1 : -1;
                        enemy.isChasing = false; // Ensure chase state is initialized
                        enemy.chaseStartTime = 0; // Initialize chase timer
                        enemy.lastShot = 0; // Initialize shooting timer
                        
                        console.log('ðŸ”® WIZGATOR SPAWNED! Position:', enemy.x, enemy.y, 'Surface Level:', game.waterLevel, 'Level:', levelNum, game.bossActive ? '(Boss Level - Lava)' : '(Water)');
                        console.log('ðŸ”® WIZGATOR ADDED TO ENEMIES ARRAY! Total enemies:', enemies.length);
                                            } else if (enemyType === 'goldfish') {
                            // Set goldfish level for proper speed scaling
                            enemy.level = levelNum;
                            
                            // Enable shooting for goldfish at level 5+
                            if (levelNum >= 5) {
                                enemy.canShoot = true;
                                enemy.lastShot = 0;
                                enemy.shotCooldown = 3000 + Math.random() * 1000; // 3-4 seconds between shots
                                console.log('ðŸ”« SHOOTING GOLDFISH SPAWNED! Position:', enemy.x, enemy.y, 'Level:', levelNum);
                            }
                        } else if (enemyType === 'shark') {
                            // Position shark underwater
                            enemy.y = game.waterLevel + 100 + Math.random() * 200; // Swim underwater at varying depths
                            enemy.sineOffset = Math.random() * Math.PI * 2;
                            enemy.originalY = enemy.y;
                            enemy.originalPatrolY = enemy.y; // Store original patrol depth
                            
                            console.log('ðŸ¦ˆ SHARK SPAWNED! Position:', enemy.x, enemy.y, 'Water Level:', game.waterLevel, 'Level:', levelNum);
                        }
                    
                    enemies.push(enemy);
                }
            }
            
            // Ensure minimum enemy count for higher levels
            const currentEnemyCount = enemies.length;
            const minimumEnemies = Math.max(8, Math.floor(levelNum * 2)); // At least 8 enemies, or 2 per level
            
            if (currentEnemyCount < minimumEnemies) {
                console.log('âš ï¸ Not enough enemies spawned! Current:', currentEnemyCount, 'Minimum:', minimumEnemies);
                
                // Force spawn additional enemies on suitable platforms
                const suitablePlatforms = platforms.filter(p => 
                    p.y >= 1000 || p.type === 'underwater' || p.type === 'ground' || p.isGroundExtension
                );
                
                const additionalEnemiesNeeded = minimumEnemies - currentEnemyCount;
                for (let i = 0; i < additionalEnemiesNeeded && i < suitablePlatforms.length; i++) {
                    const platform = suitablePlatforms[i];
                    
                    // Check distance from player starting position for forced spawns too
                    const playerStartX = 240;
                    const playerStartY = 1170;
                    const enemySpawnX = platform.x + 72;
                    const enemySpawnY = platform.y;
                    
                    const distanceFromPlayer = Math.sqrt(
                        Math.pow(enemySpawnX - playerStartX, 2) + 
                        Math.pow(enemySpawnY - playerStartY, 2)
                    );
                    
                    // Additional check: prevent spawning on the starting platform itself
                    const startingPlatform = platforms.find(p => p.x === 0 && p.y === 1320);
                    if (startingPlatform && platform === startingPlatform) {
                        console.log('ðŸš« FORCED ENEMY: STARTING PLATFORM DETECTED! Skipping forced spawn');
                        continue; // Skip the starting platform entirely
                    }
                    
                    if (distanceFromPlayer < 150) {
                        console.log('ðŸš« FORCED ENEMY TOO CLOSE TO PLAYER! Distance:', distanceFromPlayer.toFixed(0), 'px, Skipping forced spawn');
                        continue; // Skip this platform
                    }
                    const enemyType = 'basic'; // Use basic enemies for guaranteed spawns
                    const enemyConfig = enemyTypes[enemyType];
                    
                    const enemy = {
                        x: platform.x + 72,
                        y: platform.y - enemyConfig.height,
                        width: enemyConfig.width,
                        height: enemyConfig.height,
                        velX: enemyConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: enemyConfig.type,
                        health: enemyConfig.health,
                        ...enemyConfig
                    };
                    
                    enemies.push(enemy);
                    console.log('âš ï¸ FORCED ENEMY SPAWN! Type:', enemyType, 'Platform:', platform.x, platform.y);
                }
            }
            
            // GUARANTEED EAGLE SPAWN - Force at least one eagle on every level
            const currentEagleCount = enemies.filter(e => e.type === 'eagle').length;
            if (currentEagleCount === 0) {
                console.log('ðŸ¦… No eagles found, forcing eagle spawn!');
                
                // Find a suitable platform for the eagle (middle section)
                const middleStart = Math.floor(platforms.length * 0.3);
                const middleEnd = Math.floor(platforms.length * 0.7);
                
                for (let i = middleStart; i < middleEnd; i++) {
                    if (i >= 0 && i < platforms.length) {
                        const platform = platforms[i];
                        
                        // Check if platform is suitable for eagle (not underwater)
                        if (platform.y < 1200 && platform.width > 100) {
                            console.log('ðŸ¦… Found suitable platform for guaranteed eagle - platform Y:', platform.y, 'water level:', game.waterLevel);
                            const eagleConfig = enemyTypes.eagle;
                            const eagle = {
                                x: platform.x + platform.width / 2,
                                y: platform.y - 200, // Fly above platform
                                width: eagleConfig.width,
                                height: eagleConfig.height,
                                velX: eagleConfig.speed,
                                direction: Math.random() < 0.5 ? 1 : -1,
                                type: 'eagle',
                                health: eagleConfig.health,
                                canFly: true,
                                diveSpeed: 2.2,
                                diveRange: 300,
                                sineOffset: Math.random() * Math.PI * 2,
                                originalY: platform.y - 200,
                                originalPatrolY: platform.y - 200, // Store original patrol height
                                isAttacking: false,
                                targetPlayer: false,
                                isFlyingBack: false,
                                originalYSet: false,
                                collisionWidth: 90,
                                collisionHeight: 70,
                                collisionOffsetX: 4,
                                collisionOffsetY: 4
                            };
                            
                            enemies.push(eagle);
                            console.log('ðŸ¦… FORCED EAGLE SPAWNED! Position:', eagle.x, eagle.y, 'Level:', levelNum);
                            break; // Only spawn one guaranteed eagle
                        }
                    }
                }
            }
            
            // ðŸ¦ˆ GUARANTEED SHARK SPAWN - Exactly 4 sharks equally spaced in water per level
            const currentSharkCount = enemies.filter(e => e.type === 'shark').length;
            const targetSharkCount = 4; // Exactly 4 sharks per level
            
            if (currentSharkCount < targetSharkCount && !game.bossActive) {
                console.log('ðŸ¦ˆ Generating', targetSharkCount - currentSharkCount, 'equally spaced sharks for level', levelNum);
                
                // Calculate level width for equal spacing
                const levelWidth = Math.max(...platforms.map(p => p.x + p.width));
                const sharkSpacing = levelWidth / (targetSharkCount + 1); // +1 to avoid edges
                
                for (let i = currentSharkCount; i < targetSharkCount; i++) {
                    // Calculate equally spaced X position
                    const sharkX = sharkSpacing * (i + 1);
                    
                    // Vary the depth for each shark
                    const sharkDepth = game.waterLevel + 100 + (i * 50) + Math.random() * 100;
                    
                    const sharkConfig = enemyTypes.shark;
                    const shark = {
                        x: sharkX,
                        y: sharkDepth,
                        width: sharkConfig.width,
                        height: sharkConfig.height,
                        velX: sharkConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'shark',
                        health: sharkConfig.health,
                        canSwim: true,
                        isUnderwater: true,
                        diveSpeed: 2.5,
                        diveRange: 400,
                        sineOffset: Math.random() * Math.PI * 2,
                        originalY: sharkDepth,
                        originalPatrolY: sharkDepth,
                        isAttacking: false,
                        targetPlayer: false,
                        isSwimmingBack: false,
                        originalYSet: false,
                        isRetreating: false,
                        retreatStartTime: undefined,
                        isBackingAway: false,
                        backAwayStartTime: undefined,
                        backAwayDirection: undefined,
                        attackCooldown: false,
                        collisionWidth: 110,
                        collisionHeight: 50,
                        collisionOffsetX: 5,
                        collisionOffsetY: 5
                    };
                    
                    enemies.push(shark);
                    console.log('ðŸ¦ˆ EQUALLY SPACED SHARK SPAWNED! Position:', shark.x, shark.y, 'Water Level:', game.waterLevel, 'Level:', levelNum, 'Shark #', i + 1, 'of 4');
                }
            }
            
            // CLOUD EAGLE GENERATION - Add eagles specifically in cloud areas
            const cloudEagleCount = Math.min(3 + Math.floor(levelNum / 1.5), 8); // 3-8 eagles in clouds
            console.log('ðŸ¦… Generating', cloudEagleCount, 'cloud eagles for level', levelNum);
            
            // ðŸŠ GUARANTEED GATOR SPAWN - Force at least 2-4 gators on every level
            const guaranteedGatorCount = Math.min(2 + Math.floor(levelNum / 3), 6); // 2-6 gators guaranteed
            console.log('ðŸŠ Generating', guaranteedGatorCount, 'guaranteed gators for level', levelNum);
            
            for (let i = 0; i < cloudEagleCount; i++) {
                // Find cloud platforms
                const cloudPlatforms = platforms.filter(p => p.type === 'cloud');
                
                if (cloudPlatforms.length > 0) {
                    // Pick a random cloud platform
                    const cloudPlatform = cloudPlatforms[Math.floor(Math.random() * cloudPlatforms.length)];
                    
                    const eagleConfig = enemyTypes.eagle;
                    const cloudEagle = {
                        x: cloudPlatform.x + cloudPlatform.width / 2,
                        y: cloudPlatform.y - 100, // Fly just above the cloud
                        width: eagleConfig.width,
                        height: eagleConfig.height,
                        velX: eagleConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'eagle',
                        health: eagleConfig.health,
                        canFly: true,
                        diveSpeed: 2.2,
                        diveRange: 300, // 300px detection range
                        sineOffset: Math.random() * Math.PI * 2,
                        originalY: cloudPlatform.y - 100,
                        originalPatrolY: cloudPlatform.y - 100, // Store original patrol height
                        isAttacking: false,
                        targetPlayer: false,
                        isFlyingBack: false,
                        originalYSet: false,
                        collisionWidth: 90,
                        collisionHeight: 70,
                        collisionOffsetX: 4,
                        collisionOffsetY: 4,
                        isCloudEagle: true // Mark as cloud eagle
                    };
                    
                    enemies.push(cloudEagle);
                    console.log('ðŸ¦… CLOUD EAGLE SPAWNED! Position:', cloudEagle.x, cloudEagle.y, 'Above cloud at:', cloudPlatform.x, cloudPlatform.y, 'Level:', levelNum);
                }
            }
            
            // ðŸŠ GUARANTEED GATOR SPAWNING - Add gators specifically in water areas (skip on boss levels)
            if (!game.bossActive) {
                for (let i = 0; i < guaranteedGatorCount; i++) {
                // Find a suitable position near water
                const waterAreaX = 800 + i * 600 + Math.random() * 400; // Spread gators across the level
                const waterAreaY = game.waterLevel - 80; // Position on water surface
                
                // Check if this area is suitable (not too close to other enemies)
                const isAreaClear = !enemies.some(enemy => 
                    Math.abs(enemy.x - waterAreaX) < 200 && Math.abs(enemy.y - waterAreaY) < 100
                );
                
                if (isAreaClear) {
                    const gatorConfig = enemyTypes.gator;
                    const guaranteedGator = {
                        x: waterAreaX,
                        y: waterAreaY,
                        width: gatorConfig.width,
                        height: gatorConfig.height,
                        velX: gatorConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'gator',
                        health: gatorConfig.health,
                        canSwim: true,
                        isOnWaterSurface: true,
                        chaseRange: 300,
                        chaseSpeed: gatorConfig.chaseSpeed,
                        chaseDuration: 1500,
                        isChasing: false,
                        chaseStartTime: 0,
                        collisionWidth: 110,
                        collisionHeight: 70,
                        collisionOffsetX: 5,
                        collisionOffsetY: 5,
                        originalX: waterAreaX,
                        patrolDirection: Math.random() < 0.5 ? 1 : -1,
                        isChasing: false,
                        chaseStartTime: 0
                    };
                    
                    // Enable shooting for guaranteed gators at level 5+
                    if (levelNum >= 5) {
                        guaranteedGator.canShoot = true;
                        guaranteedGator.lastShot = 0;
                        guaranteedGator.shotCooldown = 2500 + Math.random() * 1000;
                        console.log('ðŸ”« SHOOTING GUARANTEED GATOR SPAWNED! Position:', guaranteedGator.x, guaranteedGator.y, 'Level:', levelNum);
                    }
                    
                    enemies.push(guaranteedGator);
                    console.log('ðŸŠ GUARANTEED GATOR SPAWNED! Position:', guaranteedGator.x, guaranteedGator.y, 'Level:', levelNum);
                }
            }
            } // Close the if (!game.bossActive) block for guaranteed gators
            
            // Add extra enemies throughout the level for more challenge
            const extraEnemyCount = Math.min(5 + Math.floor(levelNum * 2), 12); // More extra enemies
            
            for (let i = 0; i < extraEnemyCount; i++) {
                // Pick a random platform from the middle and end sections
                const startIndex = Math.floor(platforms.length * 0.2); // Start from 20% into the level
                const endIndex = platforms.length - 2; // Don't place on last 2 platforms
                const randomIndex = startIndex + Math.floor(Math.random() * (endIndex - startIndex));
                
                if (randomIndex >= 0 && randomIndex < platforms.length) {
                    const platform = platforms[randomIndex];
                    
                    // Check if this platform has solid ground beneath it or is easily reachable
                    const hasSolidGround = platform.y >= 1100 || // Platform is near ground level
                                          platform.isGroundExtension || // Platform is a ground extension
                                          platform.type === 'ground'; // Platform is ground type
                    
                    // Only spawn enemies on platforms with solid ground or that are easily reachable
                    if (!hasSolidGround && platform.y < 1000) {
                        continue; // Skip floating platforms that are too high
                    }
                    
                    const enemyWidth = 60;
                    const enemyHeight = 50;
                    const enemyX = platform.x + 72 + Math.random() * (platform.width - 144);
                    let enemyY = platform.y - enemyHeight; // Position on top of platform
                    
                    // Ensure enemy is properly positioned on top of the platform
                    enemyY = platform.y - enemyHeight;
                    
                    enemies.push({
                        x: enemyX,
                        y: enemyY,
                        width: enemyWidth,
                        height: enemyHeight,
                        velX: enemySpeed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'crab',
                        health: 1, // Add missing health property
                        canShoot: levelNum >= 5, // Enable shooting from level 5
                        lastShot: 0,
                        shotCooldown: 2000 + Math.random() * 1000, // 2-3 seconds between shots
                        collisionWidth: 50, // Match the updated collision box size
                        collisionHeight: 40, // Match the updated collision box size
                        collisionOffsetX: 5, // Match the updated offset
                        collisionOffsetY: 5 // Match the updated offset
                    });
                    console.log(`Extra enemy spawned: type=crab, health=1, collisionBox=50x40, offset=(5,5)`);
                }
            }
            
            // Add extra enemies specifically at the very end of the level
            const finalPlatforms = platforms.slice(-4); // Last 4 platforms
            const finalEnemyCount = Math.min(4 + Math.floor(levelNum), 10); // 4-10 extra enemies based on level
            
            for (let i = 0; i < finalEnemyCount; i++) {
                if (finalPlatforms.length > 0) {
                    const platform = finalPlatforms[Math.floor(Math.random() * finalPlatforms.length)];
                    
                    // Check if this platform has solid ground beneath it or is easily reachable
                    const hasSolidGround = platform.y >= 1100 || // Platform is near ground level
                                          platform.isGroundExtension || // Platform is a ground extension
                                          platform.type === 'ground'; // Platform is ground type
                    
                    // Only spawn enemies on platforms with solid ground or that are easily reachable
                    if (!hasSolidGround && platform.y < 1000) {
                        continue; // Skip floating platforms that are too high
                    }
                    
                    const enemyWidth = 60;
                    const enemyHeight = 50;
                    const enemyX = platform.x + 72 + Math.random() * (platform.width - 144);
                    let enemyY = platform.y - enemyHeight; // Position on top of platform
                    
                    // Ensure enemy is properly positioned on top of the platform
                    enemyY = platform.y - enemyHeight;
                    
                    enemies.push({
                        x: enemyX,
                        y: enemyY,
                        width: enemyWidth,
                        height: enemyHeight,
                        velX: enemySpeed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'crab',
                        health: 1, // Add missing health property
                        canShoot: levelNum >= 5, // Enable shooting from level 5
                        lastShot: 0,
                        shotCooldown: 2000 + Math.random() * 1000, // 2-3 seconds between shots
                        collisionWidth: 50, // Match the updated collision box size
                        collisionHeight: 40, // Match the updated collision box size
                        collisionOffsetX: 5, // Match the updated offset
                        collisionOffsetY: 5 // Match the updated offset
                    });
                    console.log(`Final enemy spawned: type=crab, health=1, collisionBox=50x40, offset=(5,5)`);
                }
            }
            
            // ðŸ  GOLDFISH ENEMY GENERATION - Spawn underwater enemies (skip on boss levels)
            if (!game.bossActive) {
                const goldfishCount = Math.min(8 + Math.floor(levelNum * 2), 25); // 8-25 goldfish per level, scales aggressively
                console.log('ðŸ  Generating', goldfishCount, 'goldfish enemies for level', levelNum);
                
                for (let i = 0; i < goldfishCount; i++) {
                // Find underwater platforms (below water level)
                const underwaterPlatforms = platforms.filter(p => p.y > game.waterLevel + 200);
                
                if (underwaterPlatforms.length > 0) {
                    // Pick a random underwater platform
                    const underwaterPlatform = underwaterPlatforms[Math.floor(Math.random() * underwaterPlatforms.length)];
                    
                    const goldfishConfig = enemyTypes.goldfish;
                    
                    // Progressive difficulty scaling (no size changes)
                    const speedMultiplier = 1 + (levelNum - 1) * 0.2; // 20% faster each level
                    const healthMultiplier = Math.min(1 + Math.floor(levelNum / 3), 3); // Extra health every 3 levels, max 3x
                    
                    const goldfish = {
                        x: underwaterPlatform.x + Math.random() * underwaterPlatform.width,
                        y: game.waterLevel + 150 + Math.random() * 300, // Random depth in water
                        width: goldfishConfig.width, // Fixed size - no scaling
                        height: goldfishConfig.height, // Fixed size - no scaling
                        velX: goldfishConfig.speed * speedMultiplier, // Faster fish in higher levels
                        velY: (Math.random() - 0.5) * 3 * speedMultiplier, // More erratic vertical movement
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'goldfish',
                        health: Math.floor(goldfishConfig.health * healthMultiplier), // More health in higher levels
                        canSwim: true,
                        swimSpeed: goldfishConfig.swimSpeed * speedMultiplier,
                        collisionWidth: goldfishConfig.collisionWidth, // Fixed collision size
                        collisionHeight: goldfishConfig.collisionHeight, // Fixed collision size
                        collisionOffsetX: goldfishConfig.collisionOffsetX,
                        collisionOffsetY: goldfishConfig.collisionOffsetY,
                        isUnderwater: true,
                        level: levelNum, // Store level for difficulty tracking
                        speedMultiplier: speedMultiplier
                    };
                    
                    enemies.push(goldfish);
                    console.log('ðŸ  GOLDFISH SPAWNED! Position:', goldfish.x, goldfish.y, 'Underwater near platform:', underwaterPlatform.x, underwaterPlatform.y, 'Level:', levelNum);
                }
            }
            } // Close the if (!game.bossActive) block for goldfish
            
            // ðŸ¦€ UNDERWATER CRAB GENERATION - Spawn extra crabs on platforms ABOVE water (skip on boss levels)
            if (!game.bossActive) {
                const underwaterCrabCount = Math.min(6 + Math.floor(levelNum * 2), 20); // 6-20 crabs per level
                console.log('ðŸ¦€ Generating', underwaterCrabCount, 'extra crabs for level', levelNum);
                
                for (let i = 0; i < underwaterCrabCount; i++) {
                // Find platforms that are ABOVE water level (not underwater platforms)
                // Crabs should spawn on regular platforms, not floating in water
                const validPlatforms = platforms.filter(p => 
                    p.type !== 'underwater' && // Not underwater platforms
                    p.y < game.waterLevel - 50 && // Above water level with margin
                    p.isVisible !== false && // Platform is visible
                    p.width >= 100 // Platform is wide enough
                );
                
                if (validPlatforms.length > 0) {
                    // Pick a random valid platform
                    const platform = validPlatforms[Math.floor(Math.random() * validPlatforms.length)];
                    
                    // Choose crab type (basic or shooter)
                    const isShooter = levelNum >= 5 && Math.random() < 0.4; // 40% chance for shooter crabs at level 5+
                    const crabType = isShooter ? 'shooter' : 'basic';
                    const crabConfig = enemyTypes[crabType];
                    
                    const crab = {
                        x: platform.x + 72 + Math.random() * (platform.width - 144),
                        y: platform.y - crabConfig.height, // Position on top of platform
                        width: crabConfig.width,
                        height: crabConfig.height,
                        velX: crabConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: crabConfig.type,
                        health: crabConfig.health,
                        collisionWidth: crabConfig.collisionWidth,
                        collisionHeight: crabConfig.collisionHeight,
                        collisionOffsetX: crabConfig.collisionOffsetX,
                        collisionOffsetY: crabConfig.collisionOffsetY
                    };
                    
                    // Add shooter properties if it's a shooter crab
                    if (isShooter) {
                        crab.canShoot = true;
                        crab.lastShot = 0;
                        crab.shotCooldown = 2000 + Math.random() * 1000;
                    }
                    
                    enemies.push(crab);
                }
            }
            } // Close the if (!game.bossActive) block for crabs
            
            // Count enemies for debugging
            const eagleCount = enemies.filter(e => e.type === 'eagle').length;
            const totalGoldfishCount = enemies.filter(e => e.type === 'goldfish').length;
            const totalCrabCount = enemies.filter(e => e.type === 'crab').length;
            console.log(`ðŸ¦… Enemy generation complete: ${enemies.length} total enemies, ${eagleCount} eagles, ${totalGoldfishCount} goldfish, ${totalCrabCount} crabs`);
            
            return enemies;
        }
        
        function generateCheckpoints(platforms, levelNum) {
            const checkpoints = [];
            
            // Filter for static platforms only (no moving or disappearing platforms)
            const staticPlatforms = platforms.filter(p => p.type !== 'linear' && p.type !== 'disappearing');
            
            if (staticPlatforms.length === 0) {
                console.log('No static platforms found for checkpoints');
                return checkpoints;
            }
            
            // Get the last platform (where goal flag is)
            const lastPlatform = platforms[platforms.length - 1];
            
            // Find the actual middle X position of the level
            const levelStartX = Math.min(...platforms.map(p => p.x));
            const levelEndX = Math.max(...platforms.map(p => p.x + p.width));
            const levelMiddleX = levelStartX + (levelEndX - levelStartX) / 2;
            
            console.log('Level X range:', levelStartX, 'to', levelEndX, 'Middle X:', levelMiddleX);
            
            // Find the static platform closest to the middle X position
            let closestPlatform = staticPlatforms[0];
            let closestDistance = Math.abs(levelMiddleX - (closestPlatform.x + closestPlatform.width / 2));
            
            for (let i = 0; i < staticPlatforms.length; i++) {
                const platform = staticPlatforms[i];
                const platformCenterX = platform.x + platform.width / 2;
                const distance = Math.abs(levelMiddleX - platformCenterX);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPlatform = platform;
                }
            }
                
                // Double-check that this platform is not too close to the goal
            const distanceToGoal = lastPlatform.x - closestPlatform.x;
            if (distanceToGoal > 800) { // Increased minimum distance to ensure it's not too close to end
                    checkpoints.push({
                    x: closestPlatform.x + closestPlatform.width / 2,
                    y: closestPlatform.y - 120, // Adjusted for 2x bigger checkpoint (was 60)
                    width: 80, // Updated to match the 2x bigger size
                    height: 120, // Updated to match the 2x bigger size
                        activated: false,
                    platform: closestPlatform
                    });
                console.log('Checkpoint placed at true middle X position:', closestPlatform.x, closestPlatform.y, 'Distance to goal:', distanceToGoal, 'Level middle X was:', levelMiddleX);
                } else {
                    console.log('Skipping checkpoint placement - too close to goal (distance:', distanceToGoal, ')');
            }
            
            return checkpoints;
        }
        
        function generateBreakableTiles(platforms, levelNum) {
            const breakables = [];
            // Generate exactly 5 breakable walls per level
            const breakableCount = 5;
            
            // Filter out platforms in lava areas
            const safePlatforms = platforms.filter(p => !game.bossActive || p.y < game.lavaLevel - 100);
            
            for (let i = 0; i < breakableCount; i++) {
                if (safePlatforms.length === 0) break; // No safe platforms available
                
                const platform = safePlatforms[Math.floor(Math.random() * safePlatforms.length)];
                if (platform && platform.width > 100) {
                    // Determine reward type for this breakable tile
                    const rewardTypes = ['mushroom', 'health'];
                    const rewardType = rewardTypes[Math.floor(Math.random() * rewardTypes.length)];
                    
                    breakables.push({
                        x: platform.x + Math.random() * (platform.width - 50),
                        y: platform.y - 50,
                        width: 50,
                        height: 50,
                        broken: false,
                        health: 3,
                        type: 'breakable',
                        reward: rewardType // Add reward type to the tile
                    });
                }
            }
            
            console.log(`ðŸ§± Generated ${breakables.length} breakable walls for level ${levelNum} (lava-protected)`);
            return breakables;
        }
        
        function generateSecretRooms(levelNum) {
            const secretRooms = [];
            if (levelNum >= 3 && Math.random() < 0.3) { // 30% chance for secret room from level 3
                secretRooms.push({
                    x: 2000 + Math.random() * 1000,
                    y: 400 + Math.random() * 400,
                    width: 300,
                    height: 200,
                    discovered: false,
                    contains: Math.random() < 0.5 ? 'treasure' : 'mushroom',
                    parallaxLayer: 0.5
                });
            }
            
            return secretRooms;
        }
        
        function generateRandomCoins(platforms, levelNum) {
            const coins = [];
            
            // Always generate exactly 50 coins per level
            const coinCount = 50;
            
            // Calculate level boundaries from platforms
            const levelMinX = Math.min(...platforms.map(p => p.x));
            const levelMaxX = Math.max(...platforms.map(p => p.x + p.width));
            const levelWidth = levelMaxX - levelMinX;
            
            // Filter out platforms in lava areas, ensure platforms are wide enough, and within level bounds
            const safePlatforms = platforms.filter(p => {
                const isSafe = !game.bossActive || p.y < game.lavaLevel - 100;
                const isWideEnough = p.width >= 50; // Ensure platform is wide enough for coin placement
                const isWithinBounds = p.x >= levelMinX && (p.x + p.width) <= levelMaxX;
                return isSafe && isWideEnough && isWithinBounds;
            });
            
            if (safePlatforms.length === 0) {
                console.warn(`âš ï¸ No safe platforms available for coins in level ${levelNum}`);
                return coins;
            }
            
            // Distribute coins evenly across safe platforms
            // Calculate how many coins per platform, with remainder distributed randomly
            const coinsPerPlatform = Math.floor(coinCount / safePlatforms.length);
            const remainder = coinCount % safePlatforms.length;
            
            // Shuffle platforms for random distribution
            const shuffledPlatforms = [...safePlatforms].sort(() => Math.random() - 0.5);
            
            let coinIndex = 0;
            
            // Place coins evenly across all platforms
            for (let i = 0; i < shuffledPlatforms.length && coinIndex < coinCount; i++) {
                const platform = shuffledPlatforms[i];
                const coinsForThisPlatform = coinsPerPlatform + (i < remainder ? 1 : 0);
                
                for (let j = 0; j < coinsForThisPlatform && coins.length < coinCount; j++) {
                    // Distribute coins evenly across the platform width
                    const spacing = platform.width / (coinsForThisPlatform + 1);
                    const coinX = platform.x + spacing * (j + 1) + (Math.random() - 0.5) * spacing * 0.4; // Add slight randomness
                    
                    // Ensure coin is within platform bounds
                    let clampedX = Math.max(platform.x + 20, Math.min(platform.x + platform.width - 20, coinX));
                    
                    // Ensure coin is within level boundaries
                    clampedX = Math.max(levelMinX + 20, Math.min(levelMaxX - 20, clampedX));
                    
                    // Place coin above platform with some variation
                    const coinY = platform.y - 40; // Use safe Y position
                    
                    // Always add coin - we've already clamped it to safe bounds
                    coins.push({
                        x: clampedX,
                        y: coinY,
                        collected: false,
                        type: 'coin'
                    });
                }
            }
            
            // If we still don't have exactly 50 coins, fill remaining with safe positions
            // This ensures we ALWAYS have exactly 50 coins
            while (coins.length < coinCount && safePlatforms.length > 0) {
                const platform = safePlatforms[Math.floor(Math.random() * safePlatforms.length)];
                const safeX = Math.max(levelMinX + 20, Math.min(levelMaxX - 20, platform.x + platform.width / 2));
                const safeY = platform.y - 40;
                
                coins.push({
                    x: safeX,
                    y: safeY,
                    collected: false,
                    type: 'coin'
                });
            }
            
            // If we somehow have more than 50 (shouldn't happen), trim to exactly 50
            if (coins.length > coinCount) {
                coins = coins.slice(0, coinCount);
            }
            
            // All coins should be valid since we clamped positions, but verify
            const validCoins = coins.filter(coin => {
                return coin.x >= levelMinX && coin.x <= levelMaxX && coin.y >= 0 && coin.y <= 2500;
            });
            
            // If validation removed any coins, replace them
            while (validCoins.length < coinCount && safePlatforms.length > 0) {
                const platform = safePlatforms[Math.floor(Math.random() * safePlatforms.length)];
                const safeX = Math.max(levelMinX + 20, Math.min(levelMaxX - 20, platform.x + platform.width / 2));
                const safeY = platform.y - 40;
                
                validCoins.push({
                    x: safeX,
                    y: safeY,
                    collected: false,
                    type: 'coin'
                });
            }
            
            console.log(`ðŸ’° Generated ${validCoins.length} coins for level ${levelNum} (target: ${coinCount}, lava-protected, distributed across ${safePlatforms.length} platforms, boundaries: ${levelMinX} to ${levelMaxX})`);
            return validCoins;
        }
        
        function generateRandomHealth(platforms, levelNum) {
            const health = [];
            
            // Score-based health system: 1 health for every 30,000 points
            const currentScore = game.score || 0;
            const healthThreshold = 30000;
            const healthCount = Math.floor(currentScore / healthThreshold);
            
            // Only spawn health if player has earned it through score AND it's an even-numbered level
            if (healthCount > 0 && levelNum % 2 === 0) {
                // Place health in difficult locations based on score
                let targetPlatforms;
                if (currentScore < 60000) {
                    // First health: medium difficulty
                    targetPlatforms = platforms.filter(p => p.y < 1080 && p.y > 840);
                } else if (currentScore < 120000) {
                    // Second health: high difficulty
                    targetPlatforms = platforms.filter(p => p.y < 840 && p.y > 600);
                } else {
                    // Third+ health: very high difficulty
                    targetPlatforms = platforms.filter(p => p.y < 600 && p.y > 360);
                }
            
            if (targetPlatforms.length > 0) {
                const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                const healthX = platform.x + Math.random() * platform.width;
                const healthY = platform.y - 48; // Scaled from 20 (20*2.4=48)
                
                health.push({
                    x: healthX,
                    y: healthY,
                    collected: false,
                    type: 'health'
                });
                    console.log(`â¤ï¸ Health pickup earned at ${currentScore} score on level ${levelNum}, placed at:`, healthX, healthY);
                }
            } else if (healthCount === 0) {
                console.log(`â¤ï¸ No health pickup - need ${healthThreshold - (currentScore % healthThreshold)} more points for next health`);
            } else if (levelNum % 2 !== 0) {
                console.log(`â¤ï¸ No health pickup - health only spawns on even-numbered levels (level ${levelNum} is odd)`);
            }
            
            return health;
        }
        
        function generateRandomArmor(platforms, levelNum) {
            const armor = [];
            
            // Base armor count - more armor on higher levels
            let baseArmorCount = 1;
            if (levelNum >= 5) baseArmorCount = 2;
            if (levelNum >= 10) baseArmorCount = 3;
            if (levelNum >= 15) baseArmorCount = 4;
            
            // Additional armor for exploration (hidden in secret areas)
            let hiddenArmorCount = 0;
            if (levelNum >= 3) hiddenArmorCount = 1;
            if (levelNum >= 7) hiddenArmorCount = 2;
            if (levelNum >= 12) hiddenArmorCount = 3;
            
            const totalArmorCount = baseArmorCount + hiddenArmorCount;
            
            console.log(`ðŸ›¡ï¸ Generating ${totalArmorCount} armor pickups for level ${levelNum} (${baseArmorCount} base + ${hiddenArmorCount} hidden)`);
            
            // Generate base armor pickups (accessible)
            for (let i = 0; i < baseArmorCount; i++) {
                let targetPlatforms;
                
                // Different difficulty tiers based on level
                if (levelNum <= 3) {
                    // Early levels: medium difficulty, spread across level
                    targetPlatforms = platforms.filter(p => p.y < 1080 && p.y > 840 && p.x > 500);
                } else if (levelNum <= 7) {
                    // Mid levels: high difficulty, further into level
                    targetPlatforms = platforms.filter(p => p.y < 840 && p.y > 600 && p.x > 800);
                } else {
                    // High levels: very high difficulty, deep into level
                    targetPlatforms = platforms.filter(p => p.y < 600 && p.y > 360 && p.x > 1200);
                }
                
                if (targetPlatforms.length > 0) {
                    const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                    const armorX = platform.x + Math.random() * platform.width;
                    const armorY = platform.y - 48; // Scaled from 20 (20*2.4=48)
                    
                    armor.push({
                        x: armorX,
                        y: armorY,
                        collected: false,
                        type: 'armor',
                        isHidden: false
                    });
                    console.log(`ðŸ›¡ï¸ Base armor pickup ${i + 1} placed on level ${levelNum} at:`, armorX, armorY);
                }
            }
            
            // Generate hidden armor pickups (in secret areas)
            for (let i = 0; i < hiddenArmorCount; i++) {
                let targetPlatforms;
                
                // Hidden armor in very difficult locations
                if (levelNum <= 5) {
                    // Early levels: hidden in high areas
                    targetPlatforms = platforms.filter(p => p.y < 600 && p.y > 400 && p.x > 1000);
                } else if (levelNum <= 10) {
                    // Mid levels: hidden in very high areas or underwater
                    targetPlatforms = platforms.filter(p => 
                        (p.y < 500 && p.y > 300 && p.x > 1200) || 
                        (p.type === 'underwater' && p.y > 1400 && p.x > 800)
                    );
                } else {
                    // High levels: hidden in extreme locations
                    targetPlatforms = platforms.filter(p => 
                        (p.y < 400 && p.y > 200 && p.x > 1500) || 
                        (p.type === 'underwater' && p.y > 1600 && p.x > 1000) ||
                        (p.type === 'cloud' && p.y < 300 && p.x > 1200)
                    );
                }
                
                if (targetPlatforms.length > 0) {
                    const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                    const armorX = platform.x + Math.random() * platform.width;
                    const armorY = platform.y - 48;
                    
                    armor.push({
                        x: armorX,
                        y: armorY,
                        collected: false,
                        type: 'armor',
                        isHidden: true,
                        hiddenType: platform.type === 'underwater' ? 'underwater' : 
                                   platform.type === 'cloud' ? 'cloud' : 'high'
                    });
                    console.log(`ðŸ›¡ï¸ Hidden armor pickup ${i + 1} placed on level ${levelNum} at:`, armorX, armorY, `(${platform.type} platform)`);
                }
            }
            
            // Add bonus armor for boss levels (every 5 levels)
            if (levelNum % 5 === 0) {
                const bossArmorCount = Math.floor(levelNum / 5); // More armor on higher boss levels
                for (let i = 0; i < bossArmorCount; i++) {
                    // Boss level armor near the boss platform
                    const bossPlatforms = platforms.filter(p => p.type === 'boss' || (p.x > 2000 && p.y < 1200));
                    if (bossPlatforms.length > 0) {
                        const platform = bossPlatforms[Math.floor(Math.random() * bossPlatforms.length)];
                        const armorX = platform.x + Math.random() * platform.width;
                        const armorY = platform.y - 48;
                        
                        armor.push({
                            x: armorX,
                            y: armorY,
                            collected: false,
                            type: 'armor',
                            isHidden: false,
                            isBossArmor: true
                        });
                        console.log(`ðŸ›¡ï¸ Boss level armor pickup ${i + 1} placed on level ${levelNum} at:`, armorX, armorY);
                    }
                }
            }
            
            console.log(`ðŸ›¡ï¸ Total armor pickups generated for level ${levelNum}:`, armor.length);
            return armor;
        }
        
        function generateRandomTreasures(platforms, levelNum) {
            const treasures = [];
            
            // Generate exactly 10 chests per level
            const treasureCount = 10;
            
            // Filter out platforms in lava areas - NEVER spawn chests in lava
            const safePlatforms = platforms.filter(p => !game.bossActive || p.y < game.lavaLevel - 100);
            
            for (let i = 0; i < treasureCount; i++) {
                if (safePlatforms.length === 0) break; // No safe platforms available
                
                // Place treasures evenly across safe platforms
                const platform = safePlatforms[Math.floor(Math.random() * safePlatforms.length)];
                    const treasureX = platform.x + Math.random() * platform.width;
                    const treasureY = platform.y - 60; // Scaled from 25 (25*2.4=60)
                    
                    treasures.push({
                        x: treasureX,
                        y: treasureY,
                        collected: false,
                        type: 'treasure',
                        value: 500 + Math.floor(Math.random() * 500) // 500-1000 points
                    });
                    
                console.log(`ðŸ’Ž Treasure chest ${i + 1} placed at:`, treasureX, treasureY, 'Level:', levelNum, '(lava-protected)');
            }
            
            // Add 1 golden chest on every level that requires a key
            if (platforms.length > 0) {
                // ðŸŒŠ HIGH PRIORITY: Find a suitable platform for the golden chest - heavily prefer water
                let targetPlatforms;
                
                // First, try to find water platforms (underwater platforms)
                let waterPlatforms = platforms.filter(p => p.type === 'underwater');
                console.log('ðŸ”‘ Found', waterPlatforms.length, 'water platforms for golden chest placement');
                
                // Skip lava areas on boss levels
                if (game.bossActive) {
                    waterPlatforms = waterPlatforms.filter(p => p.y < game.lavaLevel - 100);
                    console.log('ðŸ”‘ Filtered out lava areas, remaining water platforms:', waterPlatforms.length);
                }
                
                // Then, try to find cloud platforms
                let cloudPlatforms = platforms.filter(p => p.type === 'cloud');
                
                // ðŸŒŠ VERY HIGH PRIORITY: Use water platforms with 90% probability
                if (waterPlatforms.length > 0 && Math.random() < 0.9) {
                    targetPlatforms = waterPlatforms;
                    console.log('ðŸ”‘ Golden chest will spawn in WATER area!');
                } else if (cloudPlatforms.length > 0 && Math.random() < 0.7) {
                    // Use cloud platforms with 70% probability if no water
                    targetPlatforms = cloudPlatforms;
                    console.log('ðŸ”‘ Golden chest will spawn in cloud area!');
                } else {
                    // Fallback to regular platform selection - NEVER spawn in lava
                    if (levelNum === 1) {
                        // First level: place on any platform (but not in lava)
                        targetPlatforms = platforms.filter(p => p.y < 1200 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    } else if (levelNum <= 3) {
                        // Early levels: place on medium platforms (but not in lava)
                        targetPlatforms = platforms.filter(p => p.y < 1080 && p.y > 840 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    } else {
                        // Later levels: place on higher platforms for challenge (but not in lava)
                        targetPlatforms = platforms.filter(p => p.y < 960 && p.y > 672 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    }
                }
                
                if (targetPlatforms.length > 0) {
                    const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                    const goldenChestX = platform.x + platform.width / 2; // Center on platform
                    const goldenChestY = platform.y - 76; // Sit on platform (doubled size: 38*2=76)
                
                treasures.push({
                        x: goldenChestX,
                        y: goldenChestY,
                    collected: false,
                    type: 'rareTreasure',
                        value: 2000 + Math.floor(Math.random() * 1000), // 2000-3000 points for golden chests
                        requiresKey: true, // New property to indicate key requirement
                        isGoldenChest: true // New property to identify golden chests
                });
                    
                    console.log('ðŸ”‘ Golden chest placed on level', levelNum, 'at:', goldenChestX, goldenChestY, 'on platform:', platform.x, platform.y);
                }
            } else {
                console.log('ðŸ”‘ No golden chest - no suitable platforms found for level', levelNum);
            }
            
            return treasures;
        }
        
        function generateRandomJetpacks(platforms, levelNum) {
            const jetpacks = [];
            
            // Add multiple jetpacks per level based on level difficulty
            const jetpackCount = Math.min(2 + Math.floor(levelNum / 2), 5); // 2-5 jetpacks per level
            
            console.log('ðŸš€ Generating', jetpackCount, 'jetpacks for level', levelNum);
            
            for (let i = 0; i < jetpackCount; i++) {
                if (platforms.length > 0) {
                    // Different placement strategies for each jetpack
                    let targetPlatforms = [];
                    let placementType = '';
                    
                    if (i === 0) {
                        // First jetpack: early section (200-400px from start)
                        const earlyPlatforms = platforms.filter(p => 
                            p.x >= 200 && p.x <= 400 &&
                            (!game.bossActive || p.y < game.lavaLevel - 100)
                        );
                        
                        targetPlatforms = earlyPlatforms;
                        placementType = 'early-section';
                    } else if (i === 1) {
                        // Second jetpack: late section (900-1100px from start)
                        const latePlatforms = platforms.filter(p => 
                            p.x >= 900 && p.x <= 1100 &&
                            (!game.bossActive || p.y < game.lavaLevel - 100)
                        );
                        
                        targetPlatforms = latePlatforms;
                        placementType = 'late-section';
                    } else if (i === 2) {
                        // Third jetpack: higher up, mix of cloud and regular platforms
                        const highCloudPlatforms = platforms.filter(p => 
                            p.type === 'cloud' && 
                            p.y < game.waterLevel - 200
                        );
                        
                        const highRegularPlatforms = platforms.filter(p => 
                            p.y < game.waterLevel - 200 && 
                            p.type !== 'cloud' &&
                            p.type !== 'underwater'
                        );
                        
                        targetPlatforms = [...highCloudPlatforms, ...highRegularPlatforms];
                        placementType = 'high-mixed';
                    } else {
                        // Additional jetpacks: random placement across all platform types
                        targetPlatforms = platforms.filter(p => 
                            p.y < game.waterLevel - 100 || 
                            p.y > game.waterLevel + 200
                        );
                        placementType = 'random-mixed';
                    }
                    
                    // Fallback to any platform if no specific targets found
                    if (targetPlatforms.length === 0) {
                        targetPlatforms = platforms.filter(p => p.y < 1200);
                    }
                    
                    if (targetPlatforms.length > 0) {
                        const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                        const isUnderwater = platform.y > game.waterLevel + 200;
                        const isCloud = platform.type === 'cloud';
                        
                        let jetpackX, jetpackY;
                        
                        if (isUnderwater) {
                            // Place jetpack ON underwater platform (not floating in water)
                            jetpackX = platform.x + Math.random() * platform.width;
                            jetpackY = platform.y - 60; // ON the platform, just like regular platforms
                            console.log('ðŸŒŠ Underwater jetpack', i+1, 'placed ON platform at:', jetpackX, jetpackY, 'Platform Y:', platform.y, '(', placementType, ')');
                        } else if (isCloud) {
                            // Place jetpack on cloud platform
                            jetpackX = platform.x + Math.random() * platform.width;
                            jetpackY = platform.y - 60; // Above the cloud
                            console.log('â˜ï¸ Cloud jetpack', i+1, 'placed at:', jetpackX, jetpackY, '(', placementType, ')');
                        } else {
                            // Place jetpack on regular platform
                            jetpackX = platform.x + Math.random() * platform.width;
                            jetpackY = platform.y - 60; // Above the platform
                            console.log('ðŸš€ Regular jetpack', i+1, 'placed at:', jetpackX, jetpackY, '(', placementType, ')');
                        }
                        
                        // Check distance from existing jetpacks
                        let tooClose = false;
                        for (const existingJetpack of jetpacks) {
                            const distance = Math.sqrt(
                                Math.pow(jetpackX - existingJetpack.x, 2) + 
                                Math.pow(jetpackY - existingJetpack.y, 2)
                            );
                            if (distance < 500) {
                                console.log('ðŸš« Jetpack too close to existing jetpack! Distance:', distance.toFixed(0), 'px, Skipping spawn');
                                tooClose = true;
                                break;
                            }
                        }
                        
                        if (!tooClose) {
                            jetpacks.push({
                                x: jetpackX,
                                y: jetpackY,
                                collected: false,
                                type: 'jetpack'
                            });
                            console.log('âœ… Jetpack', i+1, 'placed successfully at:', jetpackX, jetpackY, '(', placementType, ')');
                        } else {
                            console.log('âš ï¸ Skipping jetpack', i+1, 'due to proximity to existing jetpack');
                        }
                    }
                }
            }
            
            console.log('ðŸš€ Generated', jetpacks.length, 'jetpacks for level', levelNum);
            return jetpacks;
        }
        
        function generateRandomHearts(platforms, levelNum) {
            const hearts = [];
            
            // Spawn 1 heart every 3 levels, starting from level 3
            if (levelNum >= 3 && levelNum % 3 === 0) {
                console.log('â¤ï¸ Generating heart for level', levelNum);
                
                // Place heart on a medium-height platform for accessibility
                const targetPlatforms = platforms.filter(p => 
                    p.y < 1080 && p.y > 960 && // Medium height platforms
                    p.type !== 'cloud' && // Not on cloud platforms
                    p.type !== 'underwater' // Not underwater
                );
                
                if (targetPlatforms.length > 0) {
                    const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                    const heartX = platform.x + Math.random() * platform.width;
                    const heartY = platform.y - 60; // Above the platform
                    
                    hearts.push({
                        x: heartX,
                        y: heartY,
                        collected: false,
                        type: 'heart'
                    });
                    
                    console.log('â¤ï¸ Heart placed at:', heartX, heartY, 'on platform Y:', platform.y);
                } else {
                    console.log('âš ï¸ No suitable platforms found for heart placement');
                }
            }
            
            return hearts;
        }
        
        function generateRandomMushrooms(platforms, levelNum) {
            const mushrooms = [];
            // Very rare - only 1 mushroom per 3 levels, starting from level 3
            if (levelNum >= 3 && levelNum % 3 === 0) {
                // Place mushroom on a medium-height platform for accessibility
                const targetPlatforms = platforms.filter(p => p.y < 1080 && p.y > 960); // Scaled from 450, 400 (450*2.4=1080, 400*2.4=960)
                
                if (targetPlatforms.length > 0) {
                    const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                    const mushroomX = platform.x + Math.random() * platform.width;
                    const mushroomY = platform.y - 60; // Scaled from 25 (25*2.4=60)
                    
                    mushrooms.push({
                        x: mushroomX,
                        y: mushroomY,
                        collected: false,
                        type: 'mushroom',
                        value: 1000 // 1000 points for mushroom
                    });
                }
            }
            
            return mushrooms;
        }
        
        // ðŸ”« LASER GENERATION FUNCTION - FIXED VERSION
        function generateRandomLasers(platforms, levelNum) {
            const laserPowerups = [];
            
            // Debug logging to check if function is called
            console.log('ðŸ”« generateRandomLasers called for level:', levelNum, 'with platforms:', platforms.length);

            // FORCE laser to spawn on EVERY level - GUARANTEED
            if (platforms.length > 0) {
                // Place laser in the early-middle section of the level (300-600px from start)
                let targetPlatform = platforms[0];
                for (let i = 0; i < platforms.length; i++) {
                    const platform = platforms[i];
                    if (platform.x >= 300 && platform.x <= 600) {
                        targetPlatform = platform;
                        break;
                    }
                }
                
                const laserX = targetPlatform.x + targetPlatform.width / 2; // Center of platform
                const laserY = targetPlatform.y - 40; // 40 pixels above platform
                
                laserPowerups.push({
                    x: laserX,
                    y: laserY,
                    collected: false,
                    type: 'laser'
                });
                
                console.log('ðŸ”« FORCED Laser placed at position:', laserX, laserY, 'on platform at:', targetPlatform.x, targetPlatform.y);
            } else {
                console.warn('ðŸ”« No platforms available for laser placement!');
            }
            
            console.log('ðŸ”« Generated', laserPowerups.length, 'laser items for level', levelNum);
            return laserPowerups;
        }
        
        // ðŸ”¥ FIREBALL GENERATION FUNCTION
        function generateRandomFireballs(platforms, levelNum) {
            const fireballPowerups = [];
            
            console.log('ðŸ”¥ generateRandomFireballs called for level:', levelNum, 'with platforms:', platforms.length);

            // FORCE fireball to spawn on EVERY level - GUARANTEED
            if (platforms.length > 0) {
                // Place fireball in the middle-late section of the level (600-900px from start)
                let targetPlatform = platforms[0];
                for (let i = 0; i < platforms.length; i++) {
                    const platform = platforms[i];
                    if (platform.x >= 600 && platform.x <= 900) {
                        targetPlatform = platform;
                        break;
                    }
                }
                
                const fireballX = targetPlatform.x + targetPlatform.width / 2;
                const fireballY = targetPlatform.y - 40;
                
                fireballPowerups.push({
                    x: fireballX,
                    y: fireballY,
                    collected: false,
                    type: 'fireball'
                });
                
                console.log('ðŸ”¥ FORCED Fireball placed at position:', fireballX, fireballY, 'on platform at:', targetPlatform.x, targetPlatform.y);
            } else {
                console.warn('ðŸ”¥ No platforms available for fireball placement!');
            }
            
            console.log('ðŸ”¥ Generated', fireballPowerups.length, 'fireball items for level', levelNum);
            return fireballPowerups;
        }
        
        function getLevelTheme(levelNum) {
            const themes = [
                {
                    name: "Sunny Shores",
                    skyColors: ['#87CEEB', '#98FB98'],
                    groundColor: '#228B22',
                    platformColor: '#654321'
                },
                {
                    name: "Sunset Cliffs", 
                    skyColors: ['#FF6B35', '#F7931E'],
                    groundColor: '#D2691E',
                    platformColor: '#8B4513'
                },
                {
                    name: "Moonlit Waters",
                    skyColors: ['#2C3E50', '#34495E'],
                    groundColor: '#1B4F72',
                    platformColor: '#566573'
                },
                {
                    name: "Storm Peaks",
                    skyColors: ['#34495E', '#2C3E50'],
                    groundColor: '#5D4E75',
                    platformColor: '#85929E'
                },
                {
                    name: "Crystal Caves",
                    skyColors: ['#8E44AD', '#3498DB'],
                    groundColor: '#9B59B6',
                    platformColor: '#A569BD'
                },
                {
                    name: "Lava Lands",
                    skyColors: ['#E74C3C', '#C0392B'],
                    groundColor: '#E67E22',
                    platformColor: '#D35400'
                },
                {
                    name: "Ice Fields",
                    skyColors: ['#EBF5FB', '#AED6F1'],
                    groundColor: '#5DADE2',
                    platformColor: '#85C1E9'
                },
                {
                    name: "Alien World",
                    skyColors: ['#1ABC9C', '#16A085'],
                    groundColor: '#27AE60',
                    platformColor: '#2ECC71'
                }
            ];
            
            return themes[(levelNum - 1) % themes.length];
        }
        
        function generateLevel(levelNum) {
            console.log('ðŸ”« generateLevel called for level:', levelNum);
            
            const theme = getLevelTheme(levelNum);
            const platforms = generateRandomPlatforms(levelNum);
            const goalX = platforms[platforms.length - 1].x + 480; // Scaled from 200 (200*2.4=480)
            
            console.log('ðŸ”« About to generate lasers for level:', levelNum, 'with platforms:', platforms.length);
            
            // Force laser generation with error handling
            let laserArray = [];
            try {
                laserArray = generateRandomLasers(platforms, levelNum);
                console.log('ðŸ”« Laser generation successful, generated:', laserArray.length, 'lasers');
            } catch (error) {
                console.error('ðŸ”« ERROR in laser generation:', error);
                // Create a fallback laser
                if (platforms.length > 0) {
                    const platform = platforms[0];
                    laserArray = [{
                        x: platform.x + 100,
                        y: platform.y - 80,
                        collected: false,
                        type: 'laser'
                    }];
                    console.log('ðŸ”« Created fallback laser at:', platform.x + 100, platform.y - 80);
                }
            }
            
            // Generate fireballs with error handling
            let fireballArray = [];
            try {
                fireballArray = generateRandomFireballs(platforms, levelNum);
                console.log('ðŸ”¥ Fireball generation successful, generated:', fireballArray.length, 'fireballs');
            } catch (error) {
                console.error('ðŸ”¥ ERROR in fireball generation:', error);
            }
            
            // Generate keys for this level
            console.log('ðŸ”‘ About to generate keys for level:', levelNum, 'with platforms:', platforms.length);
            let keyArray = [];
            try {
                keyArray = generateRandomKeys(platforms, levelNum);
                console.log('ðŸ”‘ Key generation successful, generated:', keyArray.length, 'keys');
            } catch (error) {
                console.error('ðŸ”‘ ERROR in key generation:', error);
                // Create a fallback key
                if (platforms.length > 0) {
                    const platform = platforms[0];
                    keyArray = [{
                        x: platform.x + 100,
                        y: platform.y - 80,
                        collected: false,
                        type: 'key'
                    }];
                    console.log('ðŸ”‘ Created fallback key at:', platform.x + 100, platform.y - 80);
                }
            }
            
            const levelData = {
                name: theme.name,
                skyColors: theme.skyColors,
                groundColor: theme.groundColor,
                platformColor: theme.platformColor,
                platforms: platforms,
                fish: generateRandomFish(platforms, levelNum),
                enemies: generateRandomEnemies(platforms, levelNum),
                coins: generateRandomCoins(platforms, levelNum),
                health: generateRandomHealth(platforms, levelNum),
                hearts: generateRandomHearts(platforms, levelNum),
                armor: generateRandomArmor(platforms, levelNum),
                treasures: generateRandomTreasures(platforms, levelNum),
                jetpacks: generateRandomJetpacks(platforms, levelNum),
                mushrooms: generateRandomMushrooms(platforms, levelNum),
                keys: keyArray,
                lasers: laserArray,
                fireballs: fireballArray,
                checkpoints: generateCheckpoints(platforms, levelNum),
                breakables: generateBreakableTiles(platforms, levelNum),
                secretRooms: generateSecretRooms(levelNum),
                goalX: goalX
            };
            
            console.log('ðŸ”« Level generated with lasers:', levelData.lasers.length);
            return levelData;
        }
        
        function loadLevel(levelNum) {
            console.log('ðŸ”« loadLevel called for level:', levelNum);
            
            // Safety check: ensure canvas is available
            if (!canvas) {
                console.error('âŒ Canvas not available in loadLevel, retrying in 100ms...');
                setTimeout(() => loadLevel(levelNum), 100);
                return;
            }
            
            // PERFORMANCE: Clear all arrays and particles before loading new level to prevent memory leaks
            game.particles = [];
            if (typeof playerLasers !== 'undefined') playerLasers.length = 0;
            if (typeof playerFireballs !== 'undefined') playerFireballs.length = 0;
            if (typeof lasers !== 'undefined') lasers.length = 0;
            if (typeof bossLasers !== 'undefined') bossLasers.length = 0;
            
            currentLevel = generateLevel(levelNum);
            platforms = [...currentLevel.platforms];
            fish = currentLevel.fish.map(f => ({ ...f, collected: false }));
            enemies = [...currentLevel.enemies];
            coins = currentLevel.coins.map(c => ({ ...c, collected: false }));
            health = currentLevel.health.map(h => ({ ...h, collected: false }));
            hearts = currentLevel.hearts ? currentLevel.hearts.map(h => ({ ...h, collected: false })) : [];
            armor = currentLevel.armor ? currentLevel.armor.map(a => ({ ...a, collected: false })) : [];
            treasures = currentLevel.treasures.map(t => ({ ...t, collected: false }));
            jetpacks = currentLevel.jetpacks.map(j => ({ ...j, collected: false }));
            mushrooms = currentLevel.mushrooms.map(m => ({ ...m, collected: false }));
            
            // Load keys for this level
            console.log('ðŸ”‘ Loading keys from currentLevel:', currentLevel.keys ? currentLevel.keys.length : 'undefined');
            keys = currentLevel.keys ? currentLevel.keys.map(k => ({ ...k, collected: false })) : [];
            console.log('ðŸ”‘ Keys loaded:', keys.length);
            
            // Debug: Log all key positions
            if (keys.length > 0) {
                keys.forEach((key, index) => {
                    console.log(`ðŸ”‘ Key ${index}: x=${key.x}, y=${key.y}, collected=${key.collected}`);
                });
            }
            
            console.log('ðŸ”« Loading lasers from currentLevel:', currentLevel.lasers ? currentLevel.lasers.length : 'undefined');
            laserPowerups = currentLevel.lasers ? currentLevel.lasers.map(l => ({ ...l, collected: false })) : [];
            console.log('ðŸ”« Laser powerups loaded:', laserPowerups.length);
            
            console.log('ðŸ”¥ Loading fireballs from currentLevel:', currentLevel.fireballs ? currentLevel.fireballs.length : 'undefined');
            fireballPowerups = currentLevel.fireballs ? currentLevel.fireballs.map(f => ({ ...f, collected: false })) : [];
            console.log('ðŸ”¥ Fireball powerups loaded:', fireballPowerups.length);
            
            checkpoints = [...currentLevel.checkpoints];
            
            // Reset checkpoints for this level (they should be fresh each time)
            game.activeCheckpoint = null;
            if (game.checkpointProgress[levelNum]) {
                delete game.checkpointProgress[levelNum];
            }
            console.log('Checkpoints reset for level', levelNum);
            breakables = [...currentLevel.breakables];
            secretRooms = [...currentLevel.secretRooms];
            // Note: lasers array is already set above, don't clear it here
            
            // Reset player position - ensure they start exactly on the starting platform
            player.x = 240; // Scaled from 100 (100*2.4=240)
            player.velX = 0;
            player.velY = 0;
            player.canDoubleJump = true;
            player.onGround = true; // Start on ground to prevent immediate falling
                                player.onMovingPlatform = false;
                    player.health = player.maxHealth; // Reset health to full for new level
                    player.armor = 0; // Reset armor to 0 for new level
            
            // Reset jetpack system for each level
            player.hasJetpack = false;
            player.jetpackActive = false;
            player.jetpackTime = 0;
            
            // Reset laser system for each level (but preserve laser charging level)
            player.hasLaser = false;
            player.laserActive = false;
            player.laserTime = 0;
            player.laserCooldown = 0;
            player.currentLaserColor = 0;
            // Reset charging system (but preserve unlocked charging level)
              player.isCharging = false;
              player.chargeStartTime = 0;
              player.chargeLevel = 0;
            // Note: player.laserChargingLevel and player.maxChargeLevel are preserved across levels
              
            // Reset fireball system for each level
            player.hasFireball = false;
            player.fireballCooldown = 0;
              
            // Check for equipped abilities from marketplace
            if (game.marketplace.currentAbilities && game.marketplace.currentAbilities.length > 0) {
                game.marketplace.currentAbilities.forEach(abilityId => {
                    if (abilityId === 'jetpack') {
                        player.hasJetpack = true;
                        console.log('âš¡ Jetpack ability equipped from marketplace!');
                    } else if (abilityId === 'laser') {
                        player.hasLaser = true;
                        console.log('âš¡ Laser ability equipped from marketplace!');
                    } else if (abilityId === 'fireball') {
                        player.hasFireball = true;
                        console.log('ðŸ”¥ Fireball ability equipped from marketplace!');
                    } else if (abilityId === 'armor') {
                        player.hasArmorBoost = true;
                        player.armorLevel = 1; // Start at level 1 (+25% armor)
                        console.log('ðŸ›¡ï¸ Armor ability equipped from marketplace! Level 1 (+25% armor)');
                    }
                });
            }
            
            // Update abilities display after resetting/equipping abilities
            updateAbilitiesDisplay();
            
            playerLasers = []; // Clear player lasers
            bossLasers = []; // Clear boss lasers
            playerFireballs = []; // Clear player fireballs
            
            // Reset key count for each level (only 1 key per level)
            game.keyCount = 0;
            player.keys = 0;
            
            // Force exact positioning on starting platform using collision box
            const startingPlatform = platforms.find(p => p.x === 0 && p.y === 1320);
            if (startingPlatform) {
                player.y = startingPlatform.y - player.collisionHeight - player.collisionOffsetY;
                player.lastPlatform = startingPlatform; // Set initial last platform
                player.onGround = true; // Ensure player starts on ground
                player.canDoubleJump = true; // Ensure double jump is available
                console.log('Player positioned at:', player.y, 'on platform at:', startingPlatform.y); // Debug
            } else {
                // Fallback position
                player.y = 1200;
                player.onGround = true; // Ensure player starts on ground
                player.canDoubleJump = true; // Ensure double jump is available
                console.log('Using fallback position:', player.y); // Debug
            }
            
            game.camera.x = 0;
            // Safety check for canvas height
            if (canvas && canvas.height) {
                game.camera.y = player.y - canvas.height / 2; // Position camera to show player
            } else {
                game.camera.y = player.y - 540; // Default to half of 1080p
                console.log('âš ï¸ Using default camera height - canvas not ready');
            }
            // No limits - camera can follow player anywhere
            game.levelComplete = false;
            game.levelTransition = false;
            
            // Reset level start time for timing
            game.sessionStats.levelStartTime = Date.now();
            
            // Reset collectibles counter for new level
            game.collectiblesCount.coinsCollected = 0;
            game.collectiblesCount.chestsCollected = 0;
            game.collectiblesCount.goldenChestsCollected = 0;
            
            // Update counter display with new level totals
            updateCollectiblesCounter();
            
            // ðŸ¤– Initialize AI Bot for new level
            game.aiBot.lastTipTime = Date.now();
            game.aiBot.currentTip = '';
            game.aiBot.tipTimer = 0;
            game.aiBot.isVisible = true;
            game.aiBot.lookDirection = player.direction; // Initialize owl direction
            game.aiBot.lookDelay = 0;
            
            // Initialize boss for boss levels
            game.currentBoss = createBoss(levelNum);
            if (game.currentBoss) {
                // Position boss on the boss platform (if it exists)
                if (game.bossPlatformX !== undefined) {
                    // Position boss on the long boss platform
                    game.currentBoss.x = game.bossPlatformX + game.bossPlatformWidth / 2 - game.currentBoss.width / 2;
                    game.currentBoss.y = 1200 - game.currentBoss.height; // On the boss platform
                    console.log('ðŸ”« BOSS CREATED on boss platform!', game.currentBoss);
                } else {
                    // Fallback to last platform positioning
                const lastPlatform = platforms[platforms.length - 1];
                game.currentBoss.x = lastPlatform.x + lastPlatform.width / 2 - game.currentBoss.width / 2;
                game.currentBoss.y = lastPlatform.y - game.currentBoss.height;
                console.log('ðŸ”« BOSS CREATED!', game.currentBoss);
                }
                game.bossActive = true;
                console.log('Boss level! Captain Claws appears!');
            } else {
                // No boss for this level - ensure boss mode is off
                game.bossActive = false;
                console.log('Regular level - boss mode disabled');
            }
        }
        
        function createBoss(levelNum) {
            if (levelNum % 5 === 0) { // Boss every 5 levels
                // Scale boss health with level
                const baseHealth = 100;
                const healthScaling = Math.floor(levelNum / 5) * 50; // +50 health per boss level
                const bossHealth = baseHealth + healthScaling;
                
                console.log('ðŸ‘‘ Creating boss for level', levelNum, 'with health:', bossHealth);
                
                return {
                    name: "Captain Claws",
                    x: 0,
                    y: 0,
                    width: 200,
                    height: 150,
                    health: bossHealth,
                    maxHealth: bossHealth,
                    state: 'shoot', // Boss ONLY shoots lasers
                    stateTimer: 0,
                    stateDuration: 2000,
                    direction: 1,
                    velX: 0,
                    velY: 0,
                    isGrounded: false,
                    lastAttack: 0,
                    attackCooldown: 3000,
                    addSpawnTimer: 0,
                    addSpawnCooldown: 5000,
                    adds: []
                };
            }
            return null;
        }
        
        function createParticle(x, y, type) {
            // Limit particles if we already have too many
            // Mobile optimization: reduce particles significantly
            const isMobile = game.isMobile || window.innerWidth < 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const MAX_PARTICLES = isMobile ? 50 : 100; // Even fewer particles on mobile
            if (game.particles && game.particles.length > MAX_PARTICLES * 0.8) {
                return []; // Don't create more particles if we're near the limit
            }
            
            const particles = [];
            // Further reduced particle counts for better performance (50% reduction, even more on mobile)
            const baseCount = type === 'land' ? 3 : type === 'splash' ? 4 : type === 'stomp' ? 5 : type === 'golden' ? 4 : 2;
            const count = isMobile ? Math.max(1, Math.floor(baseCount * 0.5)) : baseCount; // 50% fewer on mobile
            
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    velX: (Math.random() - 0.5) * 8,
                    velY: (Math.random() - 0.5) * 8 - 2,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.03,
                    color: type === 'land' ? '#8B4513' : 
                           type === 'splash' ? '#00FFFF' : 
                           type === 'stomp' ? '#FFD700' : 
                           type === 'golden' ? '#FFD700' : '#FFFFFF',
                    size: type === 'golden' ? 3 + Math.random() * 4 : 2 + Math.random() * 3
                });
            }
            
            return particles;
        }
        
        function addScreenShake(intensity) {
            game.screenShake = Math.min(game.screenShake + intensity, 20);
        }
        
        function addFreezeFrame(duration) {
            game.freezeFrame = Math.min(duration, 100);
        }
        
        // Asset management system
        const gameAssets = {
            player: null,
            enemy: null,
            coin: null,
            health: null,
            heart: null,
            treasure: null,
            rareTreasure: null,
            mushroom: null,
            fish: null,
            background: null,
            platform: null,
            crate: null,
            crate1: null,
            crate2: null,
            key: null,
                              eagle: null, // Idle eagle
                  eagle1: null, // Attacking eagle
                  swimmingOtter: null, // Swimming otter asset
            redPlumberSwimming: null,
            greenPlumberSwimming: null,
            yellowPlumberSwimming: null,
            purplePlumberSwimming: null,
            snowPlumberSwimming: null,
                  jetpack1: null, // Jetpack1 asset
                                     goldfish: null, // Goldfish enemy asset
                   wizgator: null, // Wizgator asset
            useCustomAssets: false
        };
        
        let currentLevel = generateLevel(1);
        let platforms = [...currentLevel.platforms];
        let fish = [...currentLevel.fish];
        let enemies = [...currentLevel.enemies];
        let coins = [...currentLevel.coins];
        let health = [...currentLevel.health];
        let hearts = []; // Array to store hearts (extra lives)
        let armor = []; // Array to store armor pickups
        let treasures = [...currentLevel.treasures];
        let mushrooms = [...currentLevel.mushrooms];
        let keys = []; // Array to store keys
        let checkpoints = [...currentLevel.checkpoints];
        let breakables = [...currentLevel.breakables];
        let secretRooms = [...currentLevel.secretRooms];
        let lasers = []; // Array to store enemy lasers
        let playerLasers = []; // Array to store player lasers
        let bossLasers = []; // Array to store boss lasers
        
        // Load saved stats from localStorage
        loadStats();
        
        // Load marketplace data
        loadMarketplaceData();
        
        // Load profile data
        loadProfileData();
        
        // Load player progress (XP, level, etc.)
        loadPlayerProgress();
        
        // Check for saved game and show continue button if available
        updateContinueButtonVisibility();
        
        // Initialize home screen particle effects
        initHomeScreenParticles();
        
        // Add dynamic background effect
        addDynamicBackground();
        
        // ========================================
        // ðŸ”§ ENHANCED INPUT HANDLING
        // ========================================
        document.addEventListener('keydown', (e) => {
            // ðŸ›¡ï¸ Prevent browser conflicts with game keys
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
                e.preventDefault();
            }
            
            game.keys[e.code] = true;
            
            // ðŸš€ ENHANCED JUMP DETECTION - Prevents input conflicts
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                if (!game.jumpPressed) {
                    game.jumpPressed = true;
                    game.keys['jumpJustPressed'] = true;
                    console.log('ðŸŽ¯ Jump key pressed:', e.code, 'Frame time:', Date.now());
                }
            }
            
            // ðŸ”½ DOWN JUMP - Drop through platforms
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                if (player.onGround && !game.keys['downJumpPressed']) {
                    game.keys['downJumpPressed'] = true;
                    player.onGround = false;
                    player.velY = 2; // Small downward push to start falling
                    console.log('ðŸ”½ Down jump activated - dropping through platform', player.isGiant ? '(Giant Mode)' : '');
                } else if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                    // Debug: Log why down jump failed
                    console.log('ðŸ”½ Down jump failed:', {
                        onGround: player.onGround,
                        downJumpPressed: game.keys['downJumpPressed'],
                        isGiant: player.isGiant,
                        velY: player.velY.toFixed(2),
                        collisionHeight: player.collisionHeight
                    });
                }
            }
            
            // Toggle asset panel with 'C' key
            if (e.code === 'KeyC') {
                toggleAssetPanel();
            }
            

            
            // Jetpack activation (Shift key) - usable for entire level
            if (e.code === 'ShiftLeft' && player.hasJetpack) {
                const currentTime = Date.now();
                const timeSinceLastBoost = currentTime - player.jetpackTime;
                
                // Allow boost every 200ms while jetpack is active
                if (!player.jetpackActive || timeSinceLastBoost > 200) {
                    if (!player.jetpackActive) {
                        // Start jetpack mode
                        player.jetpackActive = true;
                        player.jetpackTime = currentTime;
                        game.sessionStats.jetpacksUsed++;
                        addScreenShake(2);
                        console.log('Jetpack activated for entire level!');
                    }
                    
                    // Apply boost - horizontal in water, vertical on land
                    if (player.inWater) {
                        // Horizontal boost in water - much stronger
                        player.velX = player.direction * player.waterJetpackPower;
                        console.log('Water jetpack boost - horizontal! velX:', player.velX);
                    } else {
                        // Vertical boost on land
                    player.velY = -player.jetpackPower;
                        console.log('Land jetpack boost - vertical!');
                    }
                    player.jetpackTime = currentTime;
                    addScreenShake(1);
                }
            }
            

            
            // ðŸŽ¨ Change laser color (K key)
            if (e.code === 'KeyK' && player.hasLaser) {
                player.currentLaserColor = (player.currentLaserColor + 1) % player.laserColors.length;
                console.log('ðŸŽ¨ Laser color changed to:', player.laserColors[player.currentLaserColor]);
            }
            

            
            // Debug: Show all enemies info (P key)
            if (e.code === 'KeyP') {
                console.log('ðŸ” All enemies info:');
                enemies.forEach((enemy, index) => {
                    const collisionBox = {
                        x: enemy.x + (enemy.collisionOffsetX || 0),
                        y: enemy.y + (enemy.collisionOffsetY || 0),
                        width: enemy.collisionWidth || enemy.width,
                        height: enemy.collisionHeight || enemy.height
                    };
                    console.log(`Enemy ${index}:`, {
                        type: enemy.type,
                        health: enemy.health,
                        position: { x: enemy.x, y: enemy.y },
                        collisionBox: collisionBox,
                        onPlatform: enemy.y === (enemy.lastPlatform?.y - enemy.height) || 'unknown'
                    });
                });
                
                console.log('ðŸ’Ž All treasures info:');
                treasures.forEach((treasure, index) => {
                    const collisionBox = {
                        x: treasure.x - 19,
                        y: treasure.y - 19,
                        width: 38,
                        height: 38
                    };
                    console.log(`Treasure ${index}:`, {
                        type: treasure.type,
                        value: treasure.value,
                        collected: treasure.collected,
                        position: { x: treasure.x, y: treasure.y },
                        collisionBox: collisionBox
                    });
                });
            }
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
            
            // Reset jump tracking when key is released
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                game.jumpPressed = false;
            }
            
            // Reset down jump tracking when key is released
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                game.keys['downJumpPressed'] = false;
            }
            

        });
        
        // Add click event listeners for buttons
        // Note: Removed event listeners for deleted buttons (leaderboardBtn, instructionsBtn, instructionsBtn2)

        
        // Setup canvas event listeners after canvas is initialized
        function setupCanvasEventListeners() {
            if (!canvas) {
                console.error('âŒ Canvas not available for event listeners');
                return;
            }
            
            // Mouse tracking for laser aiming
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                game.mouseX = e.clientX - rect.left;
                game.mouseY = e.clientY - rect.top;
            });
            
            // Mouse events for laser charging and shooting
            let mouseDownTime = 0;
            let isMouseDown = false;
            
            // Mouse down - start charging OR quick shoot (LEFT CLICK ONLY)
            canvas.addEventListener('mousedown', (e) => {
            // Only handle left click for laser shooting
            if (e.button === 0 && player.hasLaser && player.laserCooldown <= 0) {
                // Quick shoot on click (no charging)
                if (!player.isCharging) {
                    // Calculate direction from player to mouse
                    const playerScreenX = player.x - game.camera.x;
                    const playerScreenY = player.y - game.camera.y;
                    const deltaX = game.mouseX - playerScreenX;
                    const deltaY = game.mouseY - playerScreenY;
                    
                    // Normalize direction
                    const distance = Math.max(1, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                    const normalizedX = deltaX / distance;
                    const normalizedY = deltaY / distance;
                    
                    // Calculate otter's eye position
                    const otterEyeX = player.x + player.collisionOffsetX + player.collisionWidth / 2;
                    const otterEyeY = player.y + player.collisionOffsetY + player.collisionHeight * 0.15;
                    
                    // Create quick laser
                    const laser = {
                        x: otterEyeX,
                        y: otterEyeY,
                        velX: normalizedX * player.laserSpeed,
                        velY: normalizedY * player.laserSpeed,
                        width: 30,
                        height: 8,
                        color: player.laserColors[player.currentLaserColor],
                        active: true,
                        damage: 1,
                        chargeLevel: 0,
                        chargeTime: 0,
                        pierce: false,
                        maxPierce: 0,
                        explosionRadius: 0,
                        knockback: 0
                    };
                    
                    playerLasers.push(laser);
                    player.laserCooldown = 150; // Quick cooldown for rapid firing
                    game.sessionStats.lasersUsed++;
                    addScreenShake(1);
                    
                    console.log('ðŸ”« Quick laser shot! Direction:', { x: normalizedX.toFixed(3), y: normalizedY.toFixed(3) });
                }
                
                // Also start charging for hold-to-charge (only if laser charge ability is unlocked)
                if (!player.isCharging && player.laserChargingLevel > 0) {
                    player.isCharging = true;
                    player.chargeStartTime = Date.now();
                    player.chargeLevel = 0;
                    mouseDownTime = Date.now();
                    isMouseDown = true;
                    console.log('ðŸ”« Mouse laser charging started!');
                } else if (!player.isCharging && player.laserChargingLevel === 0) {
                    console.log('ðŸ”« Laser charge ability not unlocked yet! Complete level requirements to unlock.');
                    // Show a helpful notification to the player only once
                    if (!player.laserChargeLockedMessageShown) {
                        showLaserChargeLockedNotification();
                        player.laserChargeLockedMessageShown = true;
                    }
                }
            }
        });
        
        // Right click - fire fireball
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Prevent context menu
            console.log('ðŸ”¥ Right-click detected!');
            console.log('ðŸ”¥ Player hasFireball:', player.hasFireball);
            console.log('ðŸ”¥ Player fireballCooldown:', player.fireballCooldown);
            
            if (player.hasFireball && player.fireballCooldown <= 0) {
                // Fixed spawn position near the otter (regardless of mouse position)
                const spawnX = player.x + player.collisionOffsetX + player.collisionWidth / 2;
                const spawnY = player.y + player.collisionOffsetY + player.collisionHeight * 0.4;
                
                // Calculate direction from fixed spawn position to mouse
                const spawnScreenX = spawnX - game.camera.x;
                const spawnScreenY = spawnY - game.camera.y;
                const deltaX = game.mouseX - spawnScreenX;
                const deltaY = game.mouseY - spawnScreenY;
                
                // Normalize direction
                const distance = Math.max(1, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const normalizedX = deltaX / distance;
                const normalizedY = deltaY / distance;
                
                console.log('ðŸ”¥ Fixed Fireball Spawn:');
                console.log('  - Fixed spawn position:', { x: spawnX, y: spawnY });
                console.log('  - Mouse position:', { x: game.mouseX, y: game.mouseY });
                console.log('  - Direction:', { x: normalizedX.toFixed(3), y: normalizedY.toFixed(3) });
                
                // Create fireball
                const fireball = {
                    x: spawnX,
                    y: spawnY,
                    velX: normalizedX * player.fireballSpeed,
                    velY: normalizedY * player.fireballSpeed,
                    width: 24,
                    height: 24,
                    active: true,
                    damage: 3, // Increased damage to ensure enemies are killed
                    creationTime: Date.now(),
                    lifetime: 0,
                    maxLifetime: player.maxFireballLifetime,
                    color: '#FF4500' // Orange-red fireball color
                };
                
                console.log('  - Fireball created at:', { x: fireball.x, y: fireball.y });
                console.log('  - Fireball velocity:', { x: fireball.velX.toFixed(3), y: fireball.velY.toFixed(3) });
                
                playerFireballs.push(fireball);
                player.fireballCooldown = 300; // 300ms cooldown
                game.sessionStats.fireballsShot++;
                addScreenShake(2);
                
                console.log('ðŸ”¥ Fireball shot! Direction:', { x: normalizedX.toFixed(3), y: normalizedY.toFixed(3) });
            }
        });
        
        // Mouse up - fire charged laser (LEFT CLICK ONLY)
        // FIXED MOUSE-BASED LASER CONTROLS
        canvas.addEventListener('mouseup', (e) => {
            // Only handle left click for laser charging (only if laser charge ability is unlocked)
            if (e.button === 0 && player.hasLaser && player.isCharging && isMouseDown && player.laserChargingLevel > 0) {
                const currentTime = Date.now();
                const chargeDuration = currentTime - player.chargeStartTime;
                
                // Calculate charge level (0-6) with debugging
                const chargeTimePerLevel = player.chargeTime / player.maxChargeLevel;
                const rawChargeLevel = chargeDuration / chargeTimePerLevel;
                player.chargeLevel = Math.min(player.maxChargeLevel, Math.floor(rawChargeLevel));
                
                console.log('ðŸ”« Charge Calculation Debug:');
                console.log('  - Charge Duration:', chargeDuration, 'ms');
                console.log('  - Charge Time Per Level:', chargeTimePerLevel, 'ms');
                console.log('  - Raw Charge Level:', rawChargeLevel.toFixed(2));
                console.log('  - Final Charge Level:', player.chargeLevel);
                console.log('  - Max Charge Level:', player.maxChargeLevel);
                
                // Create laser from otter's eyes with mouse aiming
                const playerScreenX = player.x - game.camera.x;
                const playerScreenY = player.y - game.camera.y;
                const deltaX = game.mouseX - playerScreenX;
                const deltaY = game.mouseY - playerScreenY;
                
                // FIX: Ensure minimum distance for direction calculation
                const minDistance = 1; // Prevent division by zero
                const distance = Math.max(minDistance, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                
                // FIX: Always normalize direction properly, even for straight up
                let normalizedX = deltaX / distance;
                let normalizedY = deltaY / distance;
                
                // FIX: Special handling for straight up aiming
                if (Math.abs(deltaX) < 5 && deltaY < -10) {
                    // Force straight up direction
                    normalizedX = 0;
                    normalizedY = -1;
                    console.log('ðŸ”« FORCING STRAIGHT UP AIM');
                }
                
                // DEBUG: Comprehensive laser positioning troubleshooting
                console.log('=== ðŸ”« LASER DEBUG START ===');
                console.log('ðŸ”« Charge Level:', player.chargeLevel);
                console.log('ðŸ”« Max Charge Level:', player.maxChargeLevel);
                console.log('ðŸ”« Charge Duration:', chargeDuration, 'ms');
                console.log('ðŸ”« Player Position:', { x: player.x.toFixed(1), y: player.y.toFixed(1) });
                console.log('ðŸ”« Player Collision Box:', { 
                    offsetX: player.collisionOffsetX, 
                    offsetY: player.collisionOffsetY,
                    width: player.collisionWidth, 
                    height: player.collisionHeight 
                });
                
                // Calculate laser size first
                const laserWidth = 30 * Math.pow(2, player.chargeLevel);
                const laserHeight = 8 * Math.pow(2, player.chargeLevel);
                console.log('ðŸ”« Laser Size:', { width: laserWidth, height: laserHeight });
                
                // Calculate otter's eye position (center of head)
                const otterEyeX = player.x + player.collisionOffsetX + player.collisionWidth / 2;
                const otterEyeY = player.y + player.collisionOffsetY + player.collisionHeight * 0.15;
                console.log('ðŸ”« Otter Eye Position:', { x: otterEyeX.toFixed(1), y: otterEyeY.toFixed(1) });
                
                // Start with otter's eye position
                let laserX = otterEyeX;
                let laserY = otterEyeY;
                
                console.log('ðŸ”« Aiming Direction:', { 
                    normalizedX: normalizedX.toFixed(3), 
                    normalizedY: normalizedY.toFixed(3),
                    deltaX: deltaX.toFixed(1),
                    deltaY: deltaY.toFixed(1)
                });
                
                // Specific distance values for different charge levels (ONLY for left/right aiming)
                let distanceFromOtter = 0; // Default for levels 0-3
                if (player.chargeLevel === 4) {
                    distanceFromOtter = -200; // Level 4: -200px
                } else if (player.chargeLevel === 5) {
                    distanceFromOtter = -500; // Level 5: -500px
                } else if (player.chargeLevel === 6) {
                    distanceFromOtter = -1000; // Level 6: -1000px
                }
                
                if (normalizedX < -0.5) { // Aiming left
                    laserX -= laserWidth / 2; // Move left edge to otter's eyes
                    laserX += distanceFromOtter * normalizedX; // Apply distance for left aiming
                    console.log('ðŸ”« Aiming LEFT - Adjusted X by -', laserWidth / 2, 'and moved', distanceFromOtter, 'px');
                } else if (normalizedX > 0.5) { // Aiming right
                    laserX += laserWidth / 2; // Move right edge to otter's eyes
                    laserX += distanceFromOtter * normalizedX; // Apply distance for right aiming
                    console.log('ðŸ”« Aiming RIGHT - Adjusted X by +', laserWidth / 2, 'and moved', distanceFromOtter, 'px');
                } else {
                    laserX += distanceFromOtter * normalizedX; // Apply distance for horizontal
                }
                
                if (normalizedY < -0.5) { // Aiming up
                    laserY -= laserHeight / 2; // Move top edge to otter's eyes
                    // Apply distance for up aiming (levels 5-6 only)
                    if (player.chargeLevel === 5) {
                        laserY += -100 * normalizedY; // Level 5: -100px
                        console.log('ðŸ”« Aiming UP - Level 5: -100px distance');
                    } else if (player.chargeLevel === 6) {
                        laserY += -300 * normalizedY; // Level 6: -300px
                        console.log('ðŸ”« Aiming UP - Level 6: -300px distance');
                    } else {
                        console.log('ðŸ”« Aiming UP - Level', player.chargeLevel, ': 0px distance');
                    }
                } else if (normalizedY > 0.5) { // Aiming down
                    laserY += laserHeight / 2; // Move bottom edge to otter's eyes
                    // Apply distance for down aiming (levels 5-6 only)
                    if (player.chargeLevel === 5) {
                        laserY += -100 * normalizedY; // Level 5: -100px
                        console.log('ðŸ”« Aiming DOWN - Level 5: -100px distance');
                    } else if (player.chargeLevel === 6) {
                        laserY += -300 * normalizedY; // Level 6: -300px
                        console.log('ðŸ”« Aiming DOWN - Level 6: -300px distance');
                    } else {
                        console.log('ðŸ”« Aiming DOWN - Level', player.chargeLevel, ': 0px distance');
                    }
                } else {
                    // NO distance adjustment for vertical - always 0px
                }
                
                console.log('ðŸ”« Final Laser Position:', { 
                    x: laserX.toFixed(1), 
                    y: laserY.toFixed(1),
                    width: laserWidth,
                    height: laserHeight
                });
                console.log('ðŸ”« Laser should appear to come from otter eyes at:', { x: otterEyeX.toFixed(1), y: otterEyeY.toFixed(1) });
                console.log('=== ðŸ”« LASER DEBUG END ===');
                
                // Set laser velocity based on normalized direction
                const velX = normalizedX * player.laserSpeed;
                const velY = normalizedY * player.laserSpeed;
                
                console.log('ðŸ”« Laser direction - X:', normalizedX.toFixed(3), 'Y:', normalizedY.toFixed(3));
                console.log('ðŸ”« Laser velocity - X:', velX.toFixed(3), 'Y:', velY.toFixed(3));
                
                // Create laser with enhanced properties based on charge level
                const laser = {
                    x: laserX,
                    y: laserY,
                    velX: velX,
                    velY: velY,
                    width: laserWidth, // Use pre-calculated size
                    height: laserHeight, // Use pre-calculated size
                    color: player.laserColors[player.currentLaserColor],
                    active: true,
                    damage: 1 + (player.chargeLevel * 3), // Much more damage for higher charge (1, 4, 7, 10, 13, 16, 19)
                    chargeLevel: player.chargeLevel, // Store charge level for visual effects
                    chargeTime: chargeDuration, // Store charge time for particle effects
                    // Enhanced properties for charged lasers
                    pierce: player.chargeLevel > 0, // Charged lasers can pierce through enemies
                    maxPierce: player.chargeLevel, // Number of enemies it can pierce through
                    explosionRadius: player.chargeLevel * 20, // Explosion radius for charged lasers
                    knockback: player.chargeLevel * 50 // Knockback force for charged lasers
                };
                
                playerLasers.push(laser);
                game.sessionStats.lasersUsed++;
                
                // Set cooldown based on charge level
                player.laserCooldown = 100 + (player.chargeLevel * 50);
                
                // Add screen shake based on charge level
                addScreenShake(1 + player.chargeLevel);
                
                // Reset charging
                player.isCharging = false;
                player.chargeStartTime = 0;
                player.chargeLevel = 0;
                isMouseDown = false;
                
                console.log('ðŸ”« Charged mouse laser fired! Level:', laser.chargeLevel, 'Damage:', laser.damage, 'Size:', laser.width + 'x' + laser.height);
                console.log('ðŸ”« Laser Object Created:', {
                    x: laser.x.toFixed(1),
                    y: laser.y.toFixed(1),
                    width: laser.width,
                    height: laser.height,
                    velX: laser.velX.toFixed(3),
                    velY: laser.velY.toFixed(3)
                });
            }
        });
        }
        
        // Mobile Touch Controls Setup
        function setupMobileControls() {
            const isMobile = window.innerWidth < 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (!isMobile) return;
            
            const mobileControls = document.getElementById('mobileControls');
            if (!mobileControls) return;
            
            // Show mobile controls
            mobileControls.style.display = 'block';
            
            // Circular Joystick
            const mobileJoystick = document.getElementById('mobileJoystick');
            const joystickHandle = document.getElementById('joystickHandle');
            const joystickBase = document.getElementById('joystickBase');
            const mobileJump = document.getElementById('mobileJump');
            const mobileJetpack = document.getElementById('mobileJetpack');
            const mobileLaser = document.getElementById('mobileLaser');
            const mobileFireball = document.getElementById('mobileFireball');
            
            let joystickActive = false;
            let joystickCenterX = 0;
            let joystickCenterY = 0;
            const joystickRadius = 50; // Max distance handle can move from center
            
            if (mobileJoystick && joystickHandle) {
                const updateJoystick = (touch) => {
                    const rect = mobileJoystick.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const touchX = touch.clientX;
                    const touchY = touch.clientY;
                    
                    const deltaX = touchX - centerX;
                    const deltaY = touchY - centerY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Clamp to joystick radius
                    const clampedDistance = Math.min(distance, joystickRadius);
                    const angle = Math.atan2(deltaY, deltaX);
                    
                    // Update handle position
                    const handleX = Math.cos(angle) * clampedDistance;
                    const handleY = Math.sin(angle) * clampedDistance;
                    joystickHandle.style.transform = `translate(calc(-50% + ${handleX}px), calc(-50% + ${handleY}px))`;
                    
                    // Calculate normalized direction (-1 to 1)
                    const normalizedX = clampedDistance > 0 ? Math.cos(angle) : 0;
                    const normalizedY = clampedDistance > 0 ? Math.sin(angle) : 0;
                    
                    // Update movement keys based on joystick position
                    // Left/Right movement
                    if (normalizedX < -0.3) {
                        game.keys['ArrowLeft'] = true;
                        game.keys['KeyA'] = true;
                        game.keys['ArrowRight'] = false;
                        game.keys['KeyD'] = false;
                    } else if (normalizedX > 0.3) {
                        game.keys['ArrowRight'] = true;
                        game.keys['KeyD'] = true;
                        game.keys['ArrowLeft'] = false;
                        game.keys['KeyA'] = false;
                    } else {
                        game.keys['ArrowLeft'] = false;
                        game.keys['KeyA'] = false;
                        game.keys['ArrowRight'] = false;
                        game.keys['KeyD'] = false;
                    }
                    
                    // Up/Down movement (up for jetpack, down for downward movement)
                    // Allow independent control - don't block jump or down movement
                    // Only set up/down keys if joystick is significantly tilted
                    if (normalizedY < -0.3) {
                        // Pointing up - for jetpack (but don't block jump button)
                        game.keys['ArrowUp'] = true;
                        game.keys['KeyW'] = true;
                        // Don't set ArrowDown to false - allow jump button to work
                    } else if (normalizedY > 0.3) {
                        // Pointing down - for downward movement
                        game.keys['ArrowDown'] = true;
                        game.keys['KeyS'] = true;
                        game.keys['ArrowUp'] = false;
                        game.keys['KeyW'] = false;
                    } else {
                        // Neutral position - only clear if not actively using other controls
                        // Don't interfere with jump button
                        if (Math.abs(normalizedX) < 0.3) {
                            // Only clear up/down if joystick is in center (not moving horizontally)
                            game.keys['ArrowUp'] = false;
                            game.keys['KeyW'] = false;
                            game.keys['ArrowDown'] = false;
                            game.keys['KeyS'] = false;
                        } else {
                            // Moving horizontally - keep up/down keys as they were
                            // This allows jump button to work while moving horizontally
                        }
                    }
                };
                
                mobileJoystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    joystickActive = true;
                    updateJoystick(e.touches[0]);
                });
                
                mobileJoystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (joystickActive) {
                        updateJoystick(e.touches[0]);
                    }
                });
                
                mobileJoystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    joystickActive = false;
                    // Reset handle to center
                    joystickHandle.style.transform = 'translate(-50%, -50%)';
                    // Reset all movement keys
                    game.keys['ArrowLeft'] = false;
                    game.keys['KeyA'] = false;
                    game.keys['ArrowRight'] = false;
                    game.keys['KeyD'] = false;
                    game.keys['ArrowUp'] = false;
                    game.keys['KeyW'] = false;
                    game.keys['ArrowDown'] = false;
                    game.keys['KeyS'] = false;
                });
            }
            
            // Jump button
            if (mobileJump) {
                mobileJump.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    // Allow jump in all situations: on ground, in air (double jump), or in water
                    if (!game.keys['jumpJustPressed']) {
                        game.keys['Space'] = true;
                        game.keys['jumpJustPressed'] = true;
                    }
                });
                mobileJump.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    game.keys['Space'] = false;
                    // Don't reset jumpJustPressed here - let the game logic handle it
                });
            }
            
            // Laser button
            if (mobileLaser) {
                mobileLaser.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (player.hasLaser && player.laserCooldown <= 0) {
                        // Quick shoot
                        const playerScreenX = player.x - game.camera.x;
                        const playerScreenY = player.y - game.camera.y;
                        const touch = e.touches[0];
                        const rect = canvas.getBoundingClientRect();
                        const touchX = touch.clientX - rect.left;
                        const touchY = touch.clientY - rect.top;
                        
                        const deltaX = touchX - playerScreenX;
                        const deltaY = touchY - playerScreenY;
                        const distance = Math.max(1, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                        const normalizedX = deltaX / distance;
                        const normalizedY = deltaY / distance;
                        
                        const otterEyeX = player.x + player.collisionOffsetX + player.collisionWidth / 2;
                        const otterEyeY = player.y + player.collisionOffsetY + player.collisionHeight * 0.15;
                        
                        playerLasers.push({
                            x: otterEyeX,
                            y: otterEyeY,
                            velX: normalizedX * player.laserSpeed,
                            velY: normalizedY * player.laserSpeed,
                            width: 30,
                            height: 8,
                            color: player.laserColors[player.currentLaserColor],
                            active: true,
                            damage: 1,
                            chargeLevel: 0
                        });
                        
                        player.laserCooldown = 150;
                        game.sessionStats.lasersUsed++;
                        addScreenShake(1);
                    }
                });
            }
            
            // Fireball button
            if (mobileFireball) {
                mobileFireball.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (player.hasFireball && player.fireballCooldown <= 0) {
                        const touch = e.touches[0];
                        const rect = canvas.getBoundingClientRect();
                        const touchX = touch.clientX - rect.left;
                        const touchY = touch.clientY - rect.top;
                        
                        const spawnX = player.x + player.collisionOffsetX + player.collisionWidth / 2;
                        const spawnY = player.y + player.collisionOffsetY + player.collisionHeight * 0.4;
                        const spawnScreenX = spawnX - game.camera.x;
                        const spawnScreenY = spawnY - game.camera.y;
                        
                        const deltaX = touchX - spawnScreenX;
                        const deltaY = touchY - spawnScreenY;
                        const distance = Math.max(1, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                        const normalizedX = deltaX / distance;
                        const normalizedY = deltaY / distance;
                        
                        playerFireballs.push({
                            x: spawnX,
                            y: spawnY,
                            velX: normalizedX * player.fireballSpeed,
                            velY: normalizedY * player.fireballSpeed,
                            width: 24,
                            height: 24,
                            active: true,
                            damage: 3,
                            creationTime: Date.now(),
                            lifetime: 0,
                            maxLifetime: player.maxFireballLifetime,
                            color: '#FF4500'
                        });
                        
                        player.fireballCooldown = 300;
                        game.sessionStats.fireballsShot++;
                        addScreenShake(2);
                    }
                });
            }
            
            // Touch events for canvas (for aiming laser/fireball)
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                game.mouseX = touch.clientX - rect.left;
                game.mouseY = touch.clientY - rect.top;
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                game.mouseX = touch.clientX - rect.left;
                game.mouseY = touch.clientY - rect.top;
            });
            
            // Jetpack button
            if (mobileJetpack) {
                mobileJetpack.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent event from bubbling to joystick
                    if (player.hasJetpack) {
                        game.keys['ShiftLeft'] = true;
                        game.keys['ShiftRight'] = true;
                        
                        // Manually trigger jetpack activation (since setting keys doesn't trigger keydown event)
                        const currentTime = Date.now();
                        const timeSinceLastBoost = currentTime - (player.jetpackTime || 0);
                        
                        // Allow boost every 200ms while jetpack is active
                        if (!player.jetpackActive || timeSinceLastBoost > 200) {
                            if (!player.jetpackActive) {
                                // Start jetpack mode
                                player.jetpackActive = true;
                                player.jetpackTime = currentTime;
                                if (game.sessionStats) {
                                    game.sessionStats.jetpacksUsed++;
                                }
                                addScreenShake(2);
                                console.log('Jetpack activated via mobile button!');
                            }
                            
                            // Apply initial boost - horizontal in water, vertical on land
                            if (player.inWater) {
                                // Horizontal boost in water - much stronger
                                player.velX = player.direction * player.waterJetpackPower;
                                console.log('Water jetpack boost - horizontal! velX:', player.velX);
                            } else {
                                // Vertical boost on land
                                player.velY = -player.jetpackPower;
                            }
                            
                            player.jetpackTime = currentTime;
                        }
                    }
                });
                mobileJetpack.addEventListener('touchmove', (e) => {
                    // Allow touch to move over button without canceling
                    e.preventDefault();
                    e.stopPropagation();
                });
                mobileJetpack.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent event from bubbling to joystick
                    game.keys['ShiftLeft'] = false;
                    game.keys['ShiftRight'] = false;
                    // Don't deactivate jetpack - let it stay active until level ends or player dies
                });
            }
            
            // Update action button visibility based on player abilities
            function updateMobileActionButtons() {
                if (mobileLaser) {
                    mobileLaser.style.display = player.hasLaser ? 'block' : 'none';
                }
                if (mobileFireball) {
                    mobileFireball.style.display = player.hasFireball ? 'block' : 'none';
                }
                if (mobileJetpack) {
                    mobileJetpack.style.display = player.hasJetpack ? 'block' : 'none';
                }
            }
            
            // Update buttons periodically
            setInterval(updateMobileActionButtons, 500);
        }
        
        // Preload otter images
        const otterImages = {
            otter1: new Image(),
            otter2: new Image(),
            otter3: new Image(),
            otter4: new Image(),
            otter5: new Image()
        };
        otterImages.otter1.src = 'public/oggg.png';
        otterImages.otter2.src = 'public/otter-skins/Green Plumber.png'; // Green Plumber
        otterImages.otter3.src = 'public/otter-skins/Red Plumber.png';  // Red Plumber
        otterImages.otter4.src = 'public/otter-skins/Yellow Plumber.png';   // Yellow
        otterImages.otter5.src = 'public/otter-skins/Purple Plumber.png';  // Purple
        
        // Preload fish skeleton image
        gameAssets.fish = new Image();
        gameAssets.fish.onload = function() {
            console.log('Fish skeleton image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.fish.onerror = function() {
            console.log('Failed to load fish skeleton image, using default fish');
            gameAssets.fish = null;
        };
        gameAssets.fish.src = 'public/fishy-log.png.png';
        
        // Preload crab image
        gameAssets.enemy = new Image();
        gameAssets.enemy.onload = function() {
            console.log('Crab image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.enemy.onerror = function() {
            console.log('Failed to load crab image, using default crab');
            gameAssets.enemy = null;
        };
        gameAssets.enemy.src = 'public/crab.png';
        
        // Preload jetpack image
        gameAssets.jetpack = new Image();
        gameAssets.jetpack.onload = function() {
            console.log('Jetpack image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.jetpack.onerror = function() {
            console.log('Failed to load jetpack image, using default jetpack');
            gameAssets.jetpack = null;
        };
        gameAssets.jetpack.src = 'public/jetpack.png';
        
        // Preload jet image for jetpack powerups
        gameAssets.jet = new Image();
        gameAssets.jet.onload = function() {
            console.log('Jet image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.jet.onerror = function() {
            console.log('Failed to load jet image, using default jetpack');
            gameAssets.jet = null;
        };
        gameAssets.jet.src = 'public/jet.png';
        
        // Preload fireball image for fireball powerups
        gameAssets.fireball = new Image();
        gameAssets.fireball.onload = function() {
            console.log('Fireball image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.fireball.onerror = function() {
            console.log('Failed to load fireball image, using default fireball');
            gameAssets.fireball = null;
        };
        gameAssets.fireball.src = 'public/fireball.png';
        
        // Preload armor image for armor pickups
        gameAssets.armor = new Image();
        gameAssets.armor.onload = function() {
            console.log('Armor image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.armor.onerror = function() {
            console.log('Failed to load armor image, using default armor');
            gameAssets.armor = null;
        };
        gameAssets.armor.src = 'public/armor.png';
        
        // Preload piratecrab image for charger enemies
        gameAssets.piratecrab = new Image();
        gameAssets.piratecrab.onload = function() {
            console.log('Piratecrab image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.piratecrab.onerror = function() {
            console.log('Failed to load piratecrab image, using default charger');
            gameAssets.piratecrab = null;
        };
        gameAssets.piratecrab.src = 'public/piratecrab.png';
        
        // Preload kingcrab image for Captain Claws boss
        gameAssets.kingcrab = new Image();
        gameAssets.kingcrab.onload = function() {
            console.log('Kingcrab image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.kingcrab.onerror = function() {
            console.log('Failed to load kingcrab image, using default boss');
            gameAssets.kingcrab = null;
        };
        gameAssets.kingcrab.src = 'public/kingcrab.png';
        
        // Load regular treasure chest asset
        gameAssets.treasure = new Image();
        gameAssets.treasure.onload = function() {
            console.log('Regular treasure chest asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.treasure.onerror = function() {
            console.warn('Failed to load regular treasure chest asset, using default');
            gameAssets.treasure = null;
        };
        gameAssets.treasure.src = 'public/chest.png';
        
        // Load rare treasure chest asset (golden)
        gameAssets.rareTreasure = new Image();
        gameAssets.rareTreasure.onload = function() {
            console.log('Rare treasure chest asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.rareTreasure.onerror = function() {
            console.warn('Failed to load rare treasure chest asset, using default');
            gameAssets.rareTreasure = null;
        };
        gameAssets.rareTreasure.src = 'public/goldchest.png';
        
        // Load crate assets for breakable tiles
        gameAssets.crate = new Image();
        gameAssets.crate.onload = function() {
            console.log('Crate asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.crate.onerror = function() {
            console.warn('Failed to load crate asset, using default');
            gameAssets.crate = null;
        };
        gameAssets.crate.src = 'public/crate.png';
        
        gameAssets.crate1 = new Image();
        gameAssets.crate1.onload = function() {
            console.log('Crate1 asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.crate1.onerror = function() {
            console.warn('Failed to load crate1 asset, using default');
            gameAssets.crate1 = null;
        };
        gameAssets.crate1.src = 'public/crate1.png';
        
        gameAssets.crate2 = new Image();
        gameAssets.crate2.onload = function() {
            console.log('Crate2 asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.crate2.onerror = function() {
            console.warn('Failed to load crate2 asset, using default');
            gameAssets.crate2 = null;
        };
        gameAssets.crate2.src = 'public/crate2.png';
        
        // Load mushroom asset
        gameAssets.mushroom = new Image();
        gameAssets.mushroom.onload = function() {
            console.log('Mushroom asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.mushroom.onerror = function() {
            console.warn('Failed to load mushroom asset, using default');
            gameAssets.mushroom = null;
        };
        gameAssets.mushroom.src = 'public/mushroom.png';
        
        // Load key asset
        gameAssets.key = new Image();
        gameAssets.key.onload = function() {
            console.log('Key asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.key.onerror = function() {
            console.warn('Failed to load key asset, using default');
            gameAssets.key = null;
        };
        gameAssets.key.src = 'public/key.png';
        
        // Load heart asset
        gameAssets.heart = new Image();
        gameAssets.heart.onload = function() {
            console.log('Heart asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.heart.onerror = function() {
            console.warn('Failed to load heart asset, using default');
            gameAssets.heart = null;
        };
        gameAssets.heart.src = 'public/heart.png';
        
        // Load eagle assets
        gameAssets.eagle = new Image();
        gameAssets.eagle.onload = function() {
            console.log('ðŸ¦… Eagle (idle) asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.eagle.onerror = function() {
            console.warn('Failed to load eagle asset, using default');
            gameAssets.eagle = null;
        };
        gameAssets.eagle.src = 'public/eagle.png';
        
        gameAssets.eagle1 = new Image();
        gameAssets.eagle1.onload = function() {
            console.log('ðŸ¦… Eagle1 (attacking) asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.eagle1.onerror = function() {
            console.warn('Failed to load eagle1 asset, using default');
            gameAssets.eagle1 = null;
        };
        gameAssets.eagle1.src = 'public/eagle1.png';
        
        // Load swimming otter asset
        gameAssets.swimmingOtter = new Image();
        gameAssets.swimmingOtter.onload = function() {
            console.log('Swimming otter image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.swimmingOtter.onerror = function() {
            console.log('Swimming otter image failed to load, using default');
            gameAssets.swimmingOtter = null;
        };
                      gameAssets.swimmingOtter.src = 'public/swimmingotter.png';
            
            // Load plumber swimming assets
            gameAssets.redPlumberSwimming = new Image();
            gameAssets.redPlumberSwimming.onload = function() {
                console.log('âœ… Red Plumber Swimming loaded');
            };
            gameAssets.redPlumberSwimming.onerror = function() {
                console.log('âŒ Failed to load Red Plumber Swimming');
                gameAssets.redPlumberSwimming = null;
            };
            gameAssets.redPlumberSwimming.src = 'public/redplumberswimming.png';
            
            gameAssets.greenPlumberSwimming = new Image();
            gameAssets.greenPlumberSwimming.onload = function() {
                console.log('âœ… Green Plumber Swimming loaded');
            };
            gameAssets.greenPlumberSwimming.onerror = function() {
                console.log('âŒ Failed to load Green Plumber Swimming');
                gameAssets.greenPlumberSwimming = null;
            };
            gameAssets.greenPlumberSwimming.src = 'public/greenplumberswimming.png';
            
            gameAssets.yellowPlumberSwimming = new Image();
            gameAssets.yellowPlumberSwimming.onload = function() {
                console.log('âœ… Yellow Plumber Swimming loaded');
            };
            gameAssets.yellowPlumberSwimming.onerror = function() {
                console.log('âŒ Failed to load Yellow Plumber Swimming');
                gameAssets.yellowPlumberSwimming = null;
            };
            gameAssets.yellowPlumberSwimming.src = 'public/yellowplumberswimming.png';
            
            gameAssets.purplePlumberSwimming = new Image();
            gameAssets.purplePlumberSwimming.onload = function() {
                console.log('âœ… Purple Plumber Swimming loaded');
            };
            gameAssets.purplePlumberSwimming.onerror = function() {
                console.log('âŒ Failed to load Purple Plumber Swimming');
                gameAssets.purplePlumberSwimming = null;
            };
            gameAssets.purplePlumberSwimming.src = 'public/purpleplumberswimming.png';
            
            gameAssets.snowPlumberSwimming = new Image();
            gameAssets.snowPlumberSwimming.onload = function() {
                console.log('âœ… Snow Plumber Swimming loaded');
            };
            gameAssets.snowPlumberSwimming.onerror = function() {
                console.log('âŒ Failed to load Snow Plumber Swimming');
                gameAssets.snowPlumberSwimming = null;
            };
            gameAssets.snowPlumberSwimming.src = 'public/snowplumberswimming.png';
              
              // Load jetpack1 asset
              gameAssets.jetpack1 = new Image();
              gameAssets.jetpack1.onload = function() {
                  console.log('Jetpack1 image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.jetpack1.onerror = function() {
                  console.log('Jetpack1 image failed to load, using default');
                  gameAssets.jetpack1 = null;
              };
              gameAssets.jetpack1.src = 'public/jetpack1.png';
              
              // Load goldfish asset
              gameAssets.goldfish = new Image();
              gameAssets.goldfish.onload = function() {
                  console.log('Goldfish image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.goldfish.onerror = function() {
                  console.log('Goldfish image failed to load, using default');
                  gameAssets.goldfish = null;
              };
              gameAssets.goldfish.src = 'public/goldfish.png';
              
              // Load gator assets
              gameAssets.gator = new Image();
              gameAssets.gator.onload = function() {
                  console.log('Gator image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.gator.onerror = function() {
                  console.log('Gator image failed to load, using default');
                  gameAssets.gator = null;
              };
              gameAssets.gator.src = 'public/gator.png';
              
              gameAssets.gator1 = new Image();
              gameAssets.gator1.onload = function() {
                  console.log('Gator1 image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.gator1.onerror = function() {
                  console.log('Gator1 image failed to load, using default');
                  gameAssets.gator1 = null;
              };
              gameAssets.gator1.src = 'public/gator1.png';
              
              // Load wizgator assets
              gameAssets.wizgator = new Image();
              gameAssets.wizgator.onload = function() {
                  console.log('Wizgator image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.wizgator.onerror = function() {
                  console.log('Wizgator image failed to load, using default');
                  gameAssets.wizgator = null;
              };
              gameAssets.wizgator.src = 'public/wizgator1.png';
              
              // Load shark assets
              gameAssets.shark = new Image();
              gameAssets.shark.onload = function() {
                  console.log('Shark image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.shark.onerror = function() {
                  console.log('Shark image failed to load, using default');
                  gameAssets.shark = null;
              };
              gameAssets.shark.src = 'public/shark.png';
              
              gameAssets.shark1 = new Image();
              gameAssets.shark1.onload = function() {
                  console.log('Shark1 (attacking) image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.shark1.onerror = function() {
                  console.log('Shark1 image failed to load, using default');
                  gameAssets.shark1 = null;
              };
              gameAssets.shark1.src = 'public/shark1.png';
              
              // Load owl asset for AI bot
              gameAssets.owl = new Image();
              gameAssets.owl.onload = function() {
                  console.log('Owl image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.owl.onerror = function() {
                  console.log('Owl image failed to load, using fallback');
                  gameAssets.owl = null;
              };
              gameAssets.owl.src = 'public/owl.png';
              
              // Load checkpoint assets
              gameAssets.checkpoint = new Image();
              gameAssets.checkpoint.onload = function() {
                  console.log('Checkpoint image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.checkpoint.onerror = function() {
                  console.log('Checkpoint image failed to load, using default');
                  gameAssets.checkpoint = null;
              };
              gameAssets.checkpoint.src = 'public/Check.png';
              
              gameAssets.checkpointActivated = new Image();
              gameAssets.checkpointActivated.onload = function() {
                  console.log('Activated checkpoint image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.checkpointActivated.onerror = function() {
                  console.log('Activated checkpoint image failed to load, using default');
                  gameAssets.checkpointActivated = null;
              };
              gameAssets.checkpointActivated.src = 'public/Check1.png';
              
              // Load goal flag asset
              gameAssets.goalFlag = new Image();
              gameAssets.goalFlag.onload = function() {
                  console.log('Goal flag image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.goalFlag.onerror = function() {
                  console.log('Goal flag image failed to load, using default');
                  gameAssets.goalFlag = null;
              };
              gameAssets.goalFlag.src = 'public/GoalFlag.png';
              
              // Load laser assets for cycling
              gameAssets.laser = new Image();
              gameAssets.laser.onload = function() {
                  console.log('Laser image loaded successfully');
              };
              gameAssets.laser.onerror = function() {
                  console.log('Laser image failed to load');
                  gameAssets.laser = null;
              };
              gameAssets.laser.src = 'public/laser.png';
              
              gameAssets.laser1 = new Image();
              gameAssets.laser1.onload = function() {
                  console.log('Laser1 image loaded successfully');
              };
              gameAssets.laser1.onerror = function() {
                  console.log('Laser1 image failed to load');
                  gameAssets.laser1 = null;
              };
              gameAssets.laser1.src = 'public/laser1.png';
              
              gameAssets.laser2 = new Image();
              gameAssets.laser2.onload = function() {
                  console.log('Laser2 image loaded successfully');
              };
              gameAssets.laser2.onerror = function() {
                  console.log('Laser2 image failed to load');
                  gameAssets.laser2 = null;
              };
              gameAssets.laser2.src = 'public/laser2.png';
              
              gameAssets.laser3 = new Image();
              gameAssets.laser3.onload = function() {
                  console.log('Laser3 image loaded successfully');
              };
              gameAssets.laser3.onerror = function() {
                  console.log('Laser3 image failed to load');
                  gameAssets.laser3 = null;
              };
              gameAssets.laser3.src = 'public/laser3.png';
              
              gameAssets.laser4 = new Image();
              gameAssets.laser4.onload = function() {
                  console.log('Laser4 image loaded successfully');
              };
              gameAssets.laser4.onerror = function() {
                  console.log('Laser4 image failed to load');
                  gameAssets.laser4 = null;
              };
              gameAssets.laser4.src = 'public/laser4.png';
              
              gameAssets.laser5 = new Image();
              gameAssets.laser5.onload = function() {
                  console.log('Laser5 image loaded successfully');
              };
              gameAssets.laser5.onerror = function() {
                  console.log('Laser5 image failed to load');
                  gameAssets.laser5 = null;
              };
              gameAssets.laser5.src = 'public/laser5.png';
              
              gameAssets.laser6 = new Image();
              gameAssets.laser6.onload = function() {
                  console.log('Laser6 image loaded successfully');
              };
              gameAssets.laser6.onerror = function() {
                  console.log('Laser6 image failed to load');
                  gameAssets.laser6 = null;
              };
              gameAssets.laser6.src = 'public/laser6.png';
              
              gameAssets.laser7 = new Image();
              gameAssets.laser7.onload = function() {
                  console.log('Laser7 image loaded successfully');
              };
              gameAssets.laser7.onerror = function() {
                  console.log('Laser7 image failed to load');
                  gameAssets.laser7 = null;
              };
              gameAssets.laser7.src = 'public/laser7.png';
        
        // XP and Reward System Functions
        function addXP(amount) {
            player.xp += amount;
            player.totalScore += amount;
            
            // Calculate new level based on XP progression system
            let newLevel = 1;
            let totalXPNeeded = 0;
            
            // Calculate level using the new XP progression system
            // Level 1: 0-999 XP (1000 total)
            // Level 2: 1000-2499 XP (1500 total)
            // Level 3: 2500-4499 XP (2000 total)
            // ... and so on until level 10
            // Level 10+: 1000 XP per level
            
            if (player.xp < 1000) {
                newLevel = 1;
                player.xpToNextLevel = 1000;
            } else if (player.xp < 2500) {
                newLevel = 2;
                player.xpToNextLevel = 2500;
            } else if (player.xp < 4500) {
                newLevel = 3;
                player.xpToNextLevel = 4500;
            } else if (player.xp < 7000) {
                newLevel = 4;
                player.xpToNextLevel = 7000;
            } else if (player.xp < 10000) {
                newLevel = 5;
                player.xpToNextLevel = 10000;
            } else if (player.xp < 13500) {
                newLevel = 6;
                player.xpToNextLevel = 13500;
            } else if (player.xp < 17500) {
                newLevel = 7;
                player.xpToNextLevel = 17500;
            } else if (player.xp < 22000) {
                newLevel = 8;
                player.xpToNextLevel = 22000;
            } else if (player.xp < 27000) {
                newLevel = 9;
                player.xpToNextLevel = 27000;
            } else if (player.xp < 32500) {
                newLevel = 10;
                player.xpToNextLevel = 32500;
            } else {
                // Level 10+: 1000 XP per level
                const level10Plus = Math.floor((player.xp - 32500) / 1000) + 10;
                newLevel = level10Plus;
                player.xpToNextLevel = 32500 + (level10Plus - 10) * 1000;
            }
            
                if (newLevel > player.level) {
                levelUp(newLevel);
            }
            
            // Don't save progress here - only save when level is completed
            // savePlayerProgress();
            
            // Update profile XP bar if profile is open
            updateProfileXPBar();
            
            console.log(`ðŸŽ¯ Gained ${amount} XP! Total: ${player.xp}, Level: ${player.level}, XP to next: ${player.xpToNextLevel - player.xp}`);
        }
        
        function levelUp(newLevel) {
            const oldLevel = player.level;
            player.level = newLevel;
            
            // Check for laser charge ability unlock (every 10 levels)
            if (player.rewards.laserChargeUnlockLevels.includes(newLevel)) {
                unlockLaserChargeAbility();
            }
            
            // Check for laser charging level upgrade
            if (player.rewards.laserUpgradeLevels.includes(newLevel)) {
                upgradeLaserChargingLevel();
            }
            
            // Check for armor level upgrade (only if armor ability is purchased)
            if (player.hasArmorBoost && player.rewards.armorUpgradeLevels.includes(newLevel)) {
                upgradeArmorLevel();
            }
            
            // Check for unlock rewards
            if (player.rewards.unlockRewards[newLevel]) {
                const reward = player.rewards.unlockRewards[newLevel];
                if (!player.unlockedRewards.includes(newLevel)) {
                    player.unlockedRewards.push(newLevel);
                    showUnlockRewardNotification(reward);
                    console.log(`ðŸŽ UNLOCKED: ${reward.name} - ${reward.description}`);
                }
            }
            
            // Show level up notification
            showLevelUpNotification(newLevel, oldLevel);
            
            // Update profile XP bar after level up
            updateProfileXPBar();
            
                            console.log(`ðŸŽ‰ LEVEL UP! ${oldLevel} â†’ ${newLevel}`);
        }
        

        
        function unlockLaserChargeAbility() {
            if (player.laserChargingLevel === 0) {
                player.laserChargingLevel = 1;
                player.maxChargeLevel = 1; // Start with level 1 charge
                player.laserChargeLockedMessageShown = false; // Reset the flag so message can be shown again if needed
                
                showLaserChargeUnlockNotification();
                console.log(`ðŸ”« Laser charge ability unlocked! Level: ${player.laserChargingLevel}`);
            }
        }
        
        function upgradeLaserChargingLevel() {
            if (player.laserChargingLevel < 6) { // Cap at level 6
                player.laserChargingLevel++;
                player.maxChargeLevel = player.laserChargingLevel; // Update max charge level
                
                showLaserUpgradeNotification();
                console.log(`âš¡ Laser charging level upgraded! New max: ${player.maxChargeLevel}`);
            }
        }
        
        function showLevelUpNotification(newLevel, oldLevel) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FFD700, #FFA500);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                font-size: 24px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                animation: levelUpPulse 2s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 32px; margin-bottom: 10px;">ðŸŽ‰</div>
                <div>LEVEL UP!</div>
                <div style="font-size: 18px; margin-top: 5px;">${oldLevel} â†’ ${newLevel}</div>

            `;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        function showLaserChargeUnlockNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FF0000, #FF6B35);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(255,0,0,0.4);
                animation: laserUpgradePulse 2s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">ðŸ”«</div>
                <div>LASER CHARGE UNLOCKED!</div>
                <div style="font-size: 14px; margin-top: 5px;">Hold left mouse button to charge!</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2500);
        }
        
        function showLaserChargeLockedNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #666666, #999999);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 16px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(0,0,0,0.4);
                animation: laserUpgradePulse 2s ease-in-out;
            `;
            
            const nextUnlockLevel = player.rewards.laserChargeUnlockLevels.find(level => level > player.level) || 10;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">ðŸ”’</div>
                <div>LASER CHARGE LOCKED</div>
                <div style="font-size: 14px; margin-top: 5px;">Unlock at level ${nextUnlockLevel}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }
        
        function showLaserUpgradeNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FF0000, #FF6B35);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(255,0,0,0.4);
                animation: laserUpgradePulse 2s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">âš¡</div>
                <div>LASER UPGRADED!</div>
                <div style="font-size: 14px; margin-top: 5px;">Max Charge: ${player.maxChargeLevel}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2500);
        }
        
        function upgradeArmorLevel() {
            if (player.armorLevel < player.maxArmorLevel) {
                player.armorLevel++;
                showArmorUpgradeNotification();
                console.log(`ðŸ›¡ï¸ Armor level upgraded! New level: ${player.armorLevel} (+${player.armorLevel * 25}% armor)`);
            }
        }
        
        function showArmorUpgradeNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #4169E1, #87CEEB);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(65,105,225,0.4);
                animation: laserUpgradePulse 2s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">ðŸ›¡ï¸</div>
                <div>ARMOR UPGRADED!</div>
                <div style="font-size: 14px; margin-top: 5px;">Level ${player.armorLevel} (+${player.armorLevel * 25}% armor)</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        function showUnlockRewardNotification(reward) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FFD700, #FFA500);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(255,215,0,0.4);
                animation: levelUpPulse 3s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">ðŸŽ</div>
                <div>REWARD UNLOCKED!</div>
                <div style="font-size: 16px; margin-top: 5px;">${reward.name}</div>
                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">${reward.description}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        function savePlayerProgress() {
            const progress = {
                xp: player.xp,
                level: player.level,
                xpToNextLevel: player.xpToNextLevel,
                totalScore: player.totalScore,

                laserChargingLevel: player.laserChargingLevel,
                maxChargeLevel: player.maxChargeLevel,
                unlockedRewards: player.unlockedRewards,
                laserChargeLockedMessageShown: player.laserChargeLockedMessageShown,
                
                // Armor system
                hasArmorBoost: player.hasArmorBoost,
                armorLevel: player.armorLevel
            };
            localStorage.setItem('otterBrosProgress', JSON.stringify(progress));
        }
        
        function loadPlayerProgress() {
            // Load saved progress from localStorage
            const savedProgress = localStorage.getItem('otterBrosProgress');
            if (savedProgress) {
                try {
                    const progress = JSON.parse(savedProgress);
                    player.xp = progress.xp || 0;
                    player.level = progress.level || 1;
                    player.xpToNextLevel = progress.xpToNextLevel || 1000;
                    player.totalScore = progress.totalScore || 0;
                    player.laserChargingLevel = progress.laserChargingLevel || 0;
                    player.maxChargeLevel = progress.maxChargeLevel || 0;
                    player.unlockedRewards = progress.unlockedRewards || [];
                    player.laserChargeLockedMessageShown = progress.laserChargeLockedMessageShown || false;
                    player.hasArmorBoost = progress.hasArmorBoost || false;
                    player.armorLevel = progress.armorLevel || 0;
                    console.log('ðŸ“Š Loaded saved player progress - XP:', player.xp, 'Level:', player.level);
                } catch (error) {
                    console.error('âŒ Error loading player progress:', error);
                    resetPlayerProgress();
                }
            } else {
                console.log('ðŸ†• No saved progress found - starting fresh');
                resetPlayerProgress();
            }
        }
        
        function resetPlayerProgress() {
            // Reset player progress to fresh state
            player.xp = 0;
            player.level = 1;
            player.xpToNextLevel = 1000;
            player.totalScore = 0;
            player.laserChargingLevel = 0;
            player.maxChargeLevel = 0;
            player.unlockedRewards = [];
            player.laserChargeLockedMessageShown = false;
            player.hasArmorBoost = false;
            player.armorLevel = 0;
            console.log('ðŸ†• Reset player progress to fresh state');
        }
        
        function resetAllGameData() {
            // Clear all localStorage data
            localStorage.removeItem('otterBrosProgress');
            localStorage.removeItem('otterBrosMarketplace');
            localStorage.removeItem('otterBrosProfile');
            localStorage.removeItem('otterBrosSettings');
            
            // Reset player data
            resetPlayerProgress();
            
            // Reset marketplace data
            game.marketplace.coins = 0;
            game.marketplace.ownedHats = [];
            game.marketplace.ownedSkins = [];
            game.marketplace.ownedAbilities = [];
            game.marketplace.currentHat = null;
            game.marketplace.currentSkin = null;
            game.marketplace.currentAbilities = [];
            
            // Reset game stats
            game.sessionStats = {
                totalScore: 0,
                levelsCompleted: 0,
                totalCoins: 0,
                crabsDefeated: 0,
                eaglesDefeated: 0,
                gatorsDefeated: 0,
                sharksDefeated: 0,
                bossesDefeated: 0,
                treasuresFound: 0,
                keysCollected: 0,
                healthPickups: 0,
                mushroomsEaten: 0,
                currentSessionScore: 0,
                levelStartTime: Date.now(),
                // Additional properties needed by updateLeaderboard
                fishCollected: 0,
                healthCollected: 0,
                treasuresCollected: 0,
                mushroomsCollected: 0,
                levelTimes: [],
                highestScore: 0,
                highestLevels: 0,
                highestCoins: 0,
                highestCrabs: 0,
                highestFish: 0,
                highestHealth: 0,
                highestTreasures: 0,
                highestMushrooms: 0,
                currentSessionLevels: 0,
                currentSessionCoins: 0,
                currentSessionCrabs: 0,
                currentSessionBosses: 0,
                currentSessionFish: 0,
                currentSessionHealth: 0,
                currentSessionTreasures: 0,
                currentSessionMushrooms: 0
            };
            
            // Reset profile data
            game.profile = {
                gamesPlayed: 0,
                playTime: 0,
                bestScore: 0,
                achievements: [],
                recentAchievements: [],
                playerName: 'Otter Player',
                profilePicture: null
            };
            
            // Reset marketplace items but keep defaults
            marketplaceItems.hats.forEach(hat => {
                if (hat.id === 'none') {
                    hat.owned = true;
                    hat.equipped = true;
                } else {
                    hat.owned = false;
                    hat.equipped = false;
                }
            });
            
            marketplaceItems.skins.forEach(skin => {
                if (skin.id === 'default') {
                    skin.owned = true;
                    skin.equipped = true;
                } else {
                    skin.owned = false;
                    skin.equipped = false;
                }
            });
            
            marketplaceItems.abilities.forEach(ability => {
                ability.owned = false;
                ability.equipped = false;
            });
            
            console.log('ðŸ”„ All game data reset to fresh start');
        }
        
        function addScoreWithXP(baseScore, source = 'unknown') {
            // Apply wallet bonuses if connected (wallet system disabled)
            let scoreMultiplier = 1;
            // Wallet system removed - no score multipliers applied
            
            const finalScore = Math.floor(baseScore * scoreMultiplier);
            
            // Add to game score
            game.score += finalScore;
            game.sessionStats.totalScore += finalScore;
            game.sessionStats.currentSessionScore += finalScore;
            
            // Add XP (1 XP per score point)
            const xpGained = Math.floor(finalScore * player.rewards.xpPerScore);
            addXP(xpGained);
            
            console.log(`ðŸŽ¯ ${source}: Score ${finalScore} (${baseScore} Ã— ${scoreMultiplier}x), +${xpGained} XP`);
            
            return finalScore;
        }
        
        // Update collectibles counter display
        function updateCollectiblesCounter() {
            const coinsElement = document.getElementById('coinsCounter');
            const chestsElement = document.getElementById('chestsCounter');
            const keysElement = document.getElementById('keysCounter');
            
            // Get total counts for current level
            const totalCoins = coins ? coins.length : 0;
            const totalChests = treasures ? treasures.length : 0; // Include all chests (regular + golden)
            
            if (coinsElement) {
                coinsElement.textContent = `${game.collectiblesCount.coinsCollected}/${totalCoins}`;
                coinsElement.classList.add('updated');
                setTimeout(() => coinsElement.classList.remove('updated'), 500);
            }
            
            if (chestsElement) {
                chestsElement.textContent = `${game.collectiblesCount.chestsCollected}/${totalChests}`;
                chestsElement.classList.add('updated');
                setTimeout(() => chestsElement.classList.remove('updated'), 500);
            }
            
            if (keysElement) {
                keysElement.textContent = `${game.keyCount}/1`; // Always 1 key per level
                keysElement.classList.add('updated');
                setTimeout(() => keysElement.classList.remove('updated'), 500);
            }
        }
        
        // Character selection function
        function selectOtter(otterId) {
            game.selectedOtter = otterId;
            
            // Update visual selection
            document.querySelectorAll('.otter-option').forEach(option => {
                option.style.border = '3px solid #ccc';
                option.style.boxShadow = '0 0 20px rgba(255,215,0,0.1)';
                option.querySelector('p').style.color = '#ccc';
                option.querySelector('img').style.filter = 'drop-shadow(0 0 10px rgba(255,215,0,0.2))';
            });
            
            // Highlight selected otter
            const selectedOption = document.getElementById(otterId);
            selectedOption.style.border = '3px solid #FFD700';
            selectedOption.style.boxShadow = '0 0 20px rgba(255,215,0,0.3)';
            selectedOption.querySelector('p').style.color = '#FFD700';
            selectedOption.querySelector('img').style.filter = 'drop-shadow(0 0 10px rgba(255,215,0,0.5))';
            
            console.log('Selected otter:', otterId);
        }
        
        // Draw functions
        function drawBackground() {
            // Safety check: ensure canvas is ready
            if (!isCanvasReady()) {
                console.error('âŒ Canvas not ready in drawBackground()');
                return;
            }
            
            if (gameAssets.useCustomAssets && gameAssets.background && gameAssets.backgroundPattern) {
                // Draw custom background image using cached pattern
                ctx.save();
                ctx.fillStyle = gameAssets.backgroundPattern;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            } else {
                // Default sky gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, currentLevel.skyColors[0]);
                gradient.addColorStop(1, currentLevel.skyColors[1]);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Mobile optimization: skip stars and reduce clouds
                const isMobile = game.isMobile || window.innerWidth < 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Stars for night levels (skip on mobile for performance)
                if (!isMobile && game.level >= 3) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    for (let i = 0; i < 20; i++) {
                        const x = (i * 123 + game.level * 50) % canvas.width;
                        const y = (i * 67) % (canvas.height * 0.6);
                        ctx.beginPath();
                        ctx.arc(x, y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Clouds (lighter for day, darker for night) - fewer on mobile
                if (!isMobile) {
                    const cloudAlpha = game.level >= 3 ? 0.3 : 0.8;
                    ctx.fillStyle = `rgba(255, 255, 255, ${cloudAlpha})`;
                    for (let i = 0; i < 4; i++) {
                        const x = (i * 300 - game.camera.x * 0.3) % (canvas.width + 100);
                        const y = 50 + i * 40;
                        ctx.beginPath();
                        ctx.arc(x, y, 15 + i * 3, 0, Math.PI * 2);
                        ctx.arc(x + 20, y, 20 + i * 2, 0, Math.PI * 2);
                        ctx.arc(x + 40, y, 15 + i * 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        function drawWater() {
            // Check if this is a boss level (lava instead of water)
            const isBossLevel = game.bossActive;
            
            if (isBossLevel) {
                // Draw lava for boss levels
                drawLava();
            } else {
                // Draw water for normal levels
                drawNormalWater();
            }
        }
        
        function drawLava() {
            // Calculate lava position relative to camera
            const lavaTop = game.lavaLevel - game.camera.y;
            const lavaBottom = (game.lavaLevel + game.lavaDepth) - game.camera.y;
            
            // Only draw lava if it's visible on screen
            if (lavaBottom > 0 && lavaTop < canvas.height) {
                ctx.save();
                
                // Create lava overlay with 100% opaque orange/red colors
                const lavaOverlay = ctx.createLinearGradient(0, lavaTop, 0, lavaBottom);
                lavaOverlay.addColorStop(0, 'rgb(255, 140, 0)'); // Solid orange at top
                lavaOverlay.addColorStop(0.5, 'rgb(255, 69, 0)'); // Solid red-orange in middle
                lavaOverlay.addColorStop(1, 'rgb(255, 0, 0)'); // Solid red at bottom
                
                // Draw lava overlay (top layer)
                ctx.fillStyle = lavaOverlay;
                ctx.fillRect(0, lavaTop, canvas.width, lavaBottom - lavaTop);
                
                // Mobile optimization: skip lava effects for performance
                const isMobile = game.isMobile || window.innerWidth < 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                if (!isMobile) {
                    // Add lava surface effect (optimized: cache time, reduce particles)
                    const time = (game.frameCount || 0) * 0.033; // Use frame count instead of Date.now() for better performance
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    
                    // Animated lava surface waves (reduced resolution for performance)
                    for (let x = 0; x < canvas.width; x += 20) { // Increased from 15 to 20
                        const waveY = lavaTop + Math.sin(time + x * 0.02) * 5;
                        if (x === 0) {
                            ctx.moveTo(x, waveY);
                        } else {
                            ctx.lineTo(x, waveY);
                        }
                    }
                    ctx.stroke();
                    
                    // Add lava particles/bubbles (reduced count for performance)
                    ctx.fillStyle = 'rgb(255, 100, 0)';
                    for (let i = 0; i < 8; i++) { // Reduced from 12 to 8
                        const particleX = (i * 150 + Math.sin(time + i) * 40) % canvas.width;
                        const particleY = lavaBottom - 15 - Math.sin(time * 3 + i) * 8;
                        const particleSize = 3 + Math.sin(time + i * 0.7) * 2;
                        
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawNormalWater() {
            // Calculate water position relative to camera
            const waterTop = game.waterLevel - game.camera.y;
            const waterBottom = (game.waterLevel + game.waterDepth) - game.camera.y;
            
            // Only draw water if it's visible on screen
            if (waterBottom > 0 && waterTop < canvas.height) {
                ctx.save();
                
                // Create water overlay with 25% opacity
                const waterOverlay = ctx.createLinearGradient(0, waterTop, 0, waterBottom);
                waterOverlay.addColorStop(0, 'rgba(0, 150, 255, 0.25)'); // Light blue overlay at top
                waterOverlay.addColorStop(0.5, 'rgba(0, 100, 200, 0.25)'); // Medium blue overlay in middle
                waterOverlay.addColorStop(1, 'rgba(0, 50, 150, 0.25)'); // Dark blue overlay at bottom
                
                // Draw water overlay (top layer)
                ctx.fillStyle = waterOverlay;
                ctx.fillRect(0, waterTop, canvas.width, waterBottom - waterTop);
                
                // Mobile optimization: skip water effects for performance
                const isMobile = game.isMobile || window.innerWidth < 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                if (!isMobile) {
                    // Add water surface effect (optimized: use frame count instead of Date.now())
                    const time = (game.frameCount || 0) * 0.016; // Use frame count for better performance
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    // Animated water surface waves (reduced resolution for performance)
                    for (let x = 0; x < canvas.width; x += 25) { // Increased from 20 to 25
                        const waveY = waterTop + Math.sin(time + x * 0.01) * 3;
                        if (x === 0) {
                            ctx.moveTo(x, waveY);
                        } else {
                            ctx.lineTo(x, waveY);
                        }
                    }
                    ctx.stroke();
                    
                    // Add water bubbles (reduced count for performance)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    for (let i = 0; i < 6; i++) { // Reduced from 8 to 6
                        const bubbleX = (i * 180 + Math.sin(time + i) * 50) % canvas.width;
                        const bubbleY = waterBottom - 20 - Math.sin(time * 2 + i) * 10;
                        const bubbleSize = 2 + Math.sin(time + i * 0.5) * 1;
                        
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }
            
            // Draw death barrier at the bottom of the water
            const deathBarrierY = game.deathBarrier - game.camera.y;
            if (deathBarrierY > 0 && deathBarrierY < canvas.height) {
                ctx.save();
                
                // Create death barrier gradient (dark red/purple)
                const deathGradient = ctx.createLinearGradient(0, deathBarrierY - 50, 0, deathBarrierY + 50);
                deathGradient.addColorStop(0, 'rgba(139, 0, 0, 0.8)'); // Dark red
                deathGradient.addColorStop(0.5, 'rgba(128, 0, 128, 0.9)'); // Purple
                deathGradient.addColorStop(1, 'rgba(25, 25, 112, 1.0)'); // Midnight blue
                
                // Draw death barrier
                ctx.fillStyle = deathGradient;
                ctx.fillRect(0, deathBarrierY - 50, canvas.width, 100);
                
                // Add ominous warning pattern
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 10]);
                
                for (let x = 0; x < canvas.width; x += 40) {
                    ctx.beginPath();
                    ctx.moveTo(x, deathBarrierY - 20);
                    ctx.lineTo(x + 20, deathBarrierY + 20);
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                ctx.restore();
            }
        }
        
        function drawBarrierWall(platform) {
            const x = platform.x - game.camera.x;
            const y = platform.y - game.camera.y;
            
            // Only draw if barrier is visible on screen
            if (x + platform.width < 0 || x > game.canvasWidth) {
                return;
            }
            
            ctx.save();
            
            // Animated glow effect
            const time = Date.now() * 0.003;
            const glowIntensity = Math.sin(time) * 0.3 + 0.7;
            
            // Outer glow
            ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity * 0.3})`;
            ctx.fillRect(x - 5, y - 5, platform.width + 10, platform.height + 10);
            
            // Main barrier wall
            ctx.fillStyle = '#8B0000'; // Dark red
            ctx.fillRect(x, y, platform.width, platform.height);
            
            // Warning stripes
            ctx.fillStyle = '#FF0000';
            for (let i = 0; i < platform.height; i += 20) {
                ctx.fillRect(x, y + i, platform.width, 10);
            }
            
            // Warning text
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.save();
            ctx.translate(x + platform.width / 2, y + platform.height / 2);
            ctx.rotate(-Math.PI / 2); // Rotate text vertically
            ctx.strokeText('BARRIER', 0, 0);
            ctx.fillText('BARRIER', 0, 0);
            ctx.restore();
            
            // Pulsing border
            ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity})`;
            ctx.lineWidth = 3;
            ctx.strokeRect(x - 2, y - 2, platform.width + 4, platform.height + 4);
            
            ctx.restore();
        }
        
        function drawUnderwaterPlatform(platform) {
            const x = platform.x - game.camera.x;
            const y = platform.y - game.camera.y;
            
            ctx.save();
            
            // Underwater platform base (darker, more submerged look)
            const gradient = ctx.createLinearGradient(x, y, x, y + platform.height);
            gradient.addColorStop(0, 'rgba(139, 69, 19, 0.8)'); // Dark brown at top
            gradient.addColorStop(1, 'rgba(101, 67, 33, 0.9)'); // Darker brown at bottom
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, platform.width, platform.height);
            
            // Underwater algae/seaweed effect - STATIC (no animation for performance)
            // Removed animated algae to reduce lag
            ctx.fillStyle = 'rgba(34, 139, 34, 0.6)'; // Sea green
            // Static algae - use fixed positions instead of random
            for (let i = 0; i < platform.width; i += 30) {
                const algaeHeight = 20; // Fixed height, no random
                ctx.fillRect(x + i, y - algaeHeight, 8, algaeHeight);
            }
            
            // Underwater bubbles - STATIC (no animation for performance)
            // Removed animated bubbles to reduce lag
            
            ctx.restore();
        }
        
        function drawOtter(x, y) {
            // Draw jetpack behind the otter if they have it
            if (player.hasJetpack) {
                ctx.save();
                ctx.translate(x + player.collisionOffsetX + player.collisionWidth/2, y + player.collisionOffsetY + player.collisionHeight/2);
                ctx.scale(player.direction, 1);
                
                if (player.inWater && gameAssets.jetpack1 && gameAssets.jetpack1.complete) {
                    // Draw jetpack1 with giant mode scaling
                    const jetpack1Width = gameAssets.jetpack1.width * (player.isGiant ? 1.5 : 1.0);
                    const jetpack1Height = gameAssets.jetpack1.height * (player.isGiant ? 1.5 : 1.0);
                    ctx.drawImage(gameAssets.jetpack1, -jetpack1Width/2, -jetpack1Height/2, jetpack1Width, jetpack1Height);
                } else if (gameAssets.jetpack && gameAssets.jetpack.complete) {
                    // Position regular jetpack on otter's back (slightly behind and to the side) with giant mode scaling
                    const jetpackWidth = player.collisionWidth * 0.6 * (player.isGiant ? 1.5 : 1.0);
                    const jetpackHeight = player.collisionHeight * 0.4 * (player.isGiant ? 1.5 : 1.0);
                    const jetpackX = -jetpackWidth/2 - player.collisionWidth * 0.1 * (player.isGiant ? 1.5 : 1.0); // Slightly behind
                    const jetpackY = -jetpackHeight/2 - player.collisionHeight * 0.1 * (player.isGiant ? 1.5 : 1.0); // Slightly above
                    
                    // Draw regular jetpack image
                    ctx.drawImage(gameAssets.jetpack, jetpackX, jetpackY, jetpackWidth, jetpackHeight);
                }
                
                ctx.restore();
            }
            
            // Flash effect when invulnerable
            if (player.invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                return; // Skip drawing every other frame to create flashing effect
            }
            
            // Giant mode glow effect
            if (player.isGiant) {
                const time = Date.now() * 0.005;
                const glowIntensity = Math.sin(time) * 0.3 + 0.7;
                ctx.save();
                ctx.fillStyle = `rgba(255, 0, 255, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(x + player.collisionOffsetX + player.collisionWidth/2, y + player.collisionOffsetY + player.collisionHeight/2, player.collisionWidth/2 + 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw selected otter image - use marketplace skin or appropriate swimming asset when in water
            let selectedImage = otterImages[game.selectedOtter];
            
            // Use marketplace skin if equipped
            const currentSkin = marketplaceItems.skins.find(skin => skin.id === game.marketplace.currentSkin);
            if (currentSkin && currentSkin.image) {
                // Create a new image object for the marketplace skin
                const skinImage = new Image();
                skinImage.src = currentSkin.image;
                if (skinImage.complete) {
                    selectedImage = skinImage;
                }
            }
            
            // Use appropriate swimming asset when in water based on current skin
            if (player.inWater) {
                const swimmingAsset = getCurrentSwimmingAsset();
                if (swimmingAsset && swimmingAsset.complete) {
                    selectedImage = swimmingAsset;
                }
            }
            
            if (selectedImage && selectedImage.complete) {
                // Draw selected otter sprite
                ctx.save();
                ctx.translate(x + player.collisionOffsetX + player.collisionWidth/2, y + player.collisionOffsetY + player.collisionHeight/2);
                ctx.scale(player.direction, 1);
                
                                // Draw swimming otter with giant mode scaling
                if (player.inWater && selectedImage !== otterImages[game.selectedOtter]) {
                    // Swimming assets: 93x64 (landscape orientation) with giant mode scaling
                    const swimWidth = 93 * (player.isGiant ? 1.5 : 1.0);
                    const swimHeight = 64 * (player.isGiant ? 1.5 : 1.0);
                    ctx.drawImage(selectedImage, -swimWidth/2, -swimHeight/2, swimWidth, swimHeight);
                } else {
                    // Normal otter: 64x93 (portrait orientation) with giant mode scaling
                    const normalWidth = player.collisionWidth * (player.isGiant ? 1.5 : 1.0);
                    const normalHeight = player.collisionHeight * (player.isGiant ? 1.5 : 1.0);
                    ctx.drawImage(selectedImage, -normalWidth/2, -normalHeight/2, normalWidth, normalHeight);
                }
                
                ctx.restore();
            } else {
                // Fallback to default drawn otter if image not loaded
                // Draw default otter - sized to match collision box
                ctx.save();
                ctx.translate(x + player.collisionOffsetX + player.collisionWidth/2, y + player.collisionOffsetY + player.collisionHeight/2);
                ctx.scale(player.direction, 1);
                
                // Calculate scaled dimensions based on collision box for realistic otter
                const bodyWidth = player.collisionWidth * 0.7;
                const bodyHeight = player.collisionHeight * 0.4;
                const headWidth = player.collisionWidth * 0.25;
                const headHeight = player.collisionHeight * 0.3;
                const eyeRadius = player.collisionWidth * 0.03;
                const noseRadius = player.collisionWidth * 0.015;
                const earRadius = player.collisionWidth * 0.04;
                const tailLength = player.collisionWidth * 0.4;
                const tailWidth = player.collisionHeight * 0.15;
                const pawRadius = player.collisionWidth * 0.04;
                
                // Main body (more elongated like real otter)
                ctx.fillStyle = '#654321';
                ctx.fillRect(-bodyWidth/2, -bodyHeight/2, bodyWidth, bodyHeight);
                
                // Belly (lighter color)
                ctx.fillStyle = '#D2B48C';
                ctx.fillRect(-bodyWidth/2 + bodyWidth*0.15, -bodyHeight/2 + bodyHeight*0.2, bodyWidth*0.7, bodyHeight*0.6);
                
                // Head (more oval-shaped)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(-bodyWidth/2 - headWidth/2, -bodyHeight/2 - headHeight/3, headWidth/2, headHeight/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Ears (small and round)
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(-bodyWidth/2 - headWidth/2 - earRadius, -bodyHeight/2 - headHeight/2 - earRadius, earRadius, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 - headWidth/2 + earRadius, -bodyHeight/2 - headHeight/2 - earRadius, earRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes (with white highlights)
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-bodyWidth/2 - headWidth/2 - eyeRadius*1.5, -bodyHeight/2 - headHeight/3 - eyeRadius, eyeRadius*1.2, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 - headWidth/2 + eyeRadius*1.5, -bodyHeight/2 - headHeight/3 - eyeRadius, eyeRadius*1.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-bodyWidth/2 - headWidth/2 - eyeRadius*1.5, -bodyHeight/2 - headHeight/3 - eyeRadius, eyeRadius*0.6, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 - headWidth/2 + eyeRadius*1.5, -bodyHeight/2 - headHeight/3 - eyeRadius, eyeRadius*0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // Nose (small and dark)
                ctx.fillStyle = '#2F1B14';
                ctx.beginPath();
                ctx.arc(-bodyWidth/2 - headWidth/2, -bodyHeight/2 - headHeight/3 + noseRadius*2, noseRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Whiskers
                ctx.strokeStyle = '#8B7355';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Left whiskers
                ctx.moveTo(-bodyWidth/2 - headWidth/2 - noseRadius, -bodyHeight/2 - headHeight/3 + noseRadius);
                ctx.lineTo(-bodyWidth/2 - headWidth/2 - noseRadius*4, -bodyHeight/2 - headHeight/3 + noseRadius*2);
                ctx.moveTo(-bodyWidth/2 - headWidth/2 - noseRadius, -bodyHeight/2 - headHeight/3 + noseRadius*2);
                ctx.lineTo(-bodyWidth/2 - headWidth/2 - noseRadius*4, -bodyHeight/2 - headHeight/3 + noseRadius*3);
                // Right whiskers
                ctx.moveTo(-bodyWidth/2 - headWidth/2 + noseRadius, -bodyHeight/2 - headHeight/3 + noseRadius);
                ctx.lineTo(-bodyWidth/2 - headWidth/2 + noseRadius*4, -bodyHeight/2 - headHeight/3 + noseRadius*2);
                ctx.moveTo(-bodyWidth/2 - headWidth/2 + noseRadius, -bodyHeight/2 - headHeight/3 + noseRadius*2);
                ctx.lineTo(-bodyWidth/2 - headWidth/2 + noseRadius*4, -bodyHeight/2 - headHeight/3 + noseRadius*3);
                ctx.stroke();
                
                // Tail (long and tapered like real otter)
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.ellipse(bodyWidth/2 + tailLength/2, 0, tailLength/2, tailWidth/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Tail tip (darker)
                ctx.fillStyle = '#4A3728';
                ctx.beginPath();
                ctx.ellipse(bodyWidth/2 + tailLength - tailWidth/4, 0, tailWidth/2, tailWidth/3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Front paws (webbed feet)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(-bodyWidth/2 - pawRadius, bodyHeight/2 + pawRadius, pawRadius, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 + pawRadius*2, bodyHeight/2 + pawRadius, pawRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Back paws
                ctx.beginPath();
                ctx.arc(bodyWidth/2 - pawRadius*2, bodyHeight/2 + pawRadius, pawRadius, 0, Math.PI * 2);
                ctx.arc(bodyWidth/2 + pawRadius, bodyHeight/2 + pawRadius, pawRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Paw details (toes)
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                // Front paw toes
                ctx.arc(-bodyWidth/2 - pawRadius - pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 - pawRadius + pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 + pawRadius*2 - pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 + pawRadius*2 + pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                // Back paw toes
                ctx.arc(bodyWidth/2 - pawRadius*2 - pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(bodyWidth/2 - pawRadius*2 + pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(bodyWidth/2 + pawRadius - pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(bodyWidth/2 + pawRadius + pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function drawFish(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.fish) {
                // Draw custom fish skeleton sprite - made larger
                ctx.drawImage(gameAssets.fish, x - 25, y - 25, 50, 50); // Increased from 38x38 to 50x50
            } else {
                // Draw default fish - made larger
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
                ctx.arc(x, y, 18, 0, Math.PI * 2); // Increased from 14 to 18
            ctx.fill();
            
                // Fish tail - made larger
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
                ctx.moveTo(x + 18, y); // Increased from 14 to 18
                ctx.lineTo(x + 38, y - 13); // Increased from 29, 10 to 38, 13
                ctx.lineTo(x + 38, y + 13); // Increased from 29, 10 to 38, 13
            ctx.closePath();
            ctx.fill();
            
                // Eye - made larger
            ctx.fillStyle = 'black';
            ctx.beginPath();
                ctx.arc(x - 6, y - 3, 3, 0, Math.PI * 2); // Increased from 5, 2, 2 to 6, 3, 3
            ctx.fill();
            }
        }
        
        function drawCoin(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.coin) {
                // Draw custom coin sprite
                ctx.drawImage(gameAssets.coin, x - 19, y - 19, 38, 38); // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
            } else {
                // Draw default coin
                // Coin body
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2); // Scaled from 4 (4*2.4=9.6, rounded to 10)
                ctx.fill();
                
                // Coin shine
                ctx.fillStyle = '#FFF8DC';
                ctx.beginPath();
                ctx.arc(x - 2, y - 2, 5, 0, Math.PI * 2); // Scaled from 1, 2 (1*2.4=2.4, 2*2.4=4.8)
                ctx.fill();
                
                // Dollar sign
                ctx.fillStyle = '#B8860B';
                ctx.font = '19px Arial'; // Scaled from 8 (8*2.4=19.2, rounded to 19)
                ctx.textAlign = 'center';
                ctx.fillText('$', x, y + 5); // Scaled from 2 (2*2.4=4.8, rounded to 5)
            }
        }
        
        function drawHealth(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.heart && gameAssets.heart.complete) {
                // Draw custom heart sprite with enhanced effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.003;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Outer glow
                ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(0, 0, 29, 0, Math.PI * 2); // Scaled from 12 (12*2.4=28.8, rounded to 29)
                ctx.fill();
                
                // Draw the custom heart image
                ctx.drawImage(gameAssets.heart, -19, -19, 38, 38); // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 7, 0, Math.PI * 2); // Scaled from 3 (3*2.4=7.2, rounded to 7)
                ctx.fill();
                
                ctx.restore();
            } else {
                // Draw default heart
                ctx.save();
                ctx.translate(x, y);
                
                // Heart body
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(0, 10); // Scaled from 4 (4*2.4=9.6, rounded to 10)
                ctx.bezierCurveTo(-14, -5, -14, -19, 0, -19); // Scaled from 6, 2, 6, 8 (6*2.4=14.4, 2*2.4=4.8, 6*2.4=14.4, 8*2.4=19.2)
                ctx.bezierCurveTo(14, -19, 14, -5, 0, 10); // Scaled from 6, 8, 6, 2 (6*2.4=14.4, 8*2.4=19.2, 6*2.4=14.4, 2*2.4=4.8)
                ctx.fill();
                
                // Heart highlight
                ctx.fillStyle = '#FF6666';
                ctx.beginPath();
                ctx.moveTo(0, 5); // Scaled from 2 (2*2.4=4.8, rounded to 5)
                ctx.bezierCurveTo(-7, -7, -7, -14, 0, -14); // Scaled from 3, 3, 3, 6 (3*2.4=7.2, 3*2.4=7.2, 3*2.4=7.2, 6*2.4=14.4)
                ctx.bezierCurveTo(7, -14, 7, -7, 0, 5); // Scaled from 3, 6, 3, 3 (3*2.4=7.2, 6*2.4=14.4, 3*2.4=7.2, 3*2.4=7.2)
                ctx.fill();
                
                // Heart glow
                ctx.strokeStyle = '#FF4444';
                ctx.lineWidth = 5; // Scaled from 2 (2*2.4=4.8, rounded to 5)
                ctx.beginPath();
                ctx.moveTo(0, 10); // Scaled from 4 (4*2.4=9.6, rounded to 10)
                ctx.bezierCurveTo(-14, -5, -14, -19, 0, -19); // Scaled from 6, 2, 6, 8 (6*2.4=14.4, 2*2.4=4.8, 6*2.4=14.4, 8*2.4=19.2)
                ctx.bezierCurveTo(14, -19, 14, -5, 0, 10); // Scaled from 6, 8, 6, 2 (6*2.4=14.4, 8*2.4=19.2, 6*2.4=14.4, 2*2.4=4.8)
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        function drawHeart(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.heart && gameAssets.heart.complete) {
                // Draw custom heart sprite with enhanced effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect for extra life hearts
                const time = Date.now() * 0.004;
                const glowIntensity = Math.sin(time) * 0.5 + 0.5;
                
                // Outer glow (stronger than regular health)
                ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2); // Larger glow than regular health
                ctx.fill();
                
                // Draw the custom heart image (slightly larger than regular health)
                ctx.drawImage(gameAssets.heart, -24, -24, 48, 48); // Larger than regular health (38x38)
                
                // Extra life indicator
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('+1 LIFE', 0, 35);
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.8})`;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            } else {
                // Draw default heart (larger than regular health)
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect for extra life hearts
                const time = Date.now() * 0.004;
                const glowIntensity = Math.sin(time) * 0.5 + 0.5;
                
                // Outer glow (stronger than regular health)
                ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2); // Larger glow than regular health
                ctx.fill();
                
                // Heart body (larger than regular health)
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(0, 12); // Slightly larger than regular health
                ctx.bezierCurveTo(-16, -6, -16, -22, 0, -22); // Larger heart shape
                ctx.bezierCurveTo(16, -22, 16, -6, 0, 12);
                ctx.fill();
                
                // Heart highlight
                ctx.fillStyle = '#FF6666';
                ctx.beginPath();
                ctx.moveTo(0, 6);
                ctx.bezierCurveTo(-8, -8, -8, -16, 0, -16);
                ctx.bezierCurveTo(8, -16, 8, -8, 0, 6);
                ctx.fill();
                
                // Heart glow (stronger than regular health)
                ctx.strokeStyle = '#FF4444';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(0, 12);
                ctx.bezierCurveTo(-16, -6, -16, -22, 0, -22);
                ctx.bezierCurveTo(16, -22, 16, -6, 0, 12);
                ctx.stroke();
                
                // Extra life indicator
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('+1 LIFE', 0, 35);
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.8})`;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function drawArmor(x, y, armorData = {}) {
            ctx.save();
            ctx.translate(x, y);
            
            // Animated glow effect
            const time = Date.now() * 0.003;
            const glowIntensity = Math.sin(time) * 0.4 + 0.6;
            
            // All armor is blue, but different outer ring colors distinguish types
            const baseColor = '#4169E1'; // Blue for all armor
            const glowColor = 'rgba(65, 105, 225, 0.4)'; // Blue glow for all armor
            
            // Different outer ring colors for different armor types
            let outerRingColor = '#87CEEB'; // Light blue for regular armor
            
            if (armorData.isHidden) {
                if (armorData.hiddenType === 'underwater') {
                    outerRingColor = '#00CED1'; // Dark turquoise ring for underwater
                } else if (armorData.hiddenType === 'cloud') {
                    outerRingColor = '#9370DB'; // Purple ring for cloud
                } else {
                    outerRingColor = '#FFD700'; // Gold ring for high areas
                }
            } else if (armorData.isBossArmor) {
                outerRingColor = '#DC143C'; // Crimson ring for boss armor
            }
            
            // Outer glow (blue for all armor)
            ctx.fillStyle = glowColor;
            ctx.beginPath();
            ctx.arc(0, 0, 29, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw armor asset if available
            if (gameAssets.armor && gameAssets.armor.complete) {
                const armorWidth = gameAssets.armor.width * 0.7; // Scale down slightly
                const armorHeight = gameAssets.armor.height * 0.7;
                ctx.drawImage(gameAssets.armor, -armorWidth/2, -armorHeight/2, armorWidth, armorHeight);
            } else {
                // Fallback to custom armor drawing
                // Armor shield body (blue for all armor)
                ctx.fillStyle = baseColor;
                ctx.beginPath();
                ctx.arc(0, 0, 19, 0, Math.PI * 2); // Main shield circle
                ctx.fill();
                
                // Armor shield border (colored ring based on type)
                ctx.strokeStyle = outerRingColor;
                ctx.lineWidth = 4; // Thicker border to make color more visible
                ctx.beginPath();
                ctx.arc(0, 0, 19, 0, Math.PI * 2);
                ctx.stroke();
                
                // Armor cross symbol (white for all armor)
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-8, 0);
                ctx.lineTo(8, 0);
                ctx.moveTo(0, -8);
                ctx.lineTo(0, 8);
                ctx.stroke();
            }
            
            // Special effects for hidden armor
            if (armorData.isHidden) {
                // Sparkle effect for hidden armor
                const sparkleTime = Date.now() * 0.005;
                for (let i = 0; i < 4; i++) {
                    const angle = sparkleTime + (i * Math.PI / 2);
                    const sparkleX = Math.cos(angle) * 25;
                    const sparkleY = Math.sin(angle) * 25;
                    const sparkleSize = Math.sin(sparkleTime * 2 + i) * 2 + 3;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Pulsing center glow (white for all armor)
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
            ctx.beginPath();
            ctx.arc(0, 0, 7, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawJetpack(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Animated glow effect
            const time = Date.now() * 0.004;
            const glowIntensity = Math.sin(time) * 0.3 + 0.7;
            
            // Outer glow
            ctx.fillStyle = `rgba(0, 255, 255, ${glowIntensity * 0.4})`;
            ctx.beginPath();
            ctx.arc(0, 0, 29, 0, Math.PI * 2); // Scaled from 12 (12*2.4=28.8, rounded to 29)
            ctx.fill();
            
            // Draw jet asset if available
            if (gameAssets.jet && gameAssets.jet.complete) {
                const jetWidth = gameAssets.jet.width * 0.8; // Scale down slightly
                const jetHeight = gameAssets.jet.height * 0.8;
                ctx.drawImage(gameAssets.jet, -jetWidth/2, -jetHeight/2, jetWidth, jetHeight);
            } else {
                // Fallback to custom jetpack drawing
                // Jetpack body (blue)
                ctx.fillStyle = '#0066CC';
                ctx.fillRect(-12, -8, 24, 16); // Main body
                
                // Jetpack tanks (silver)
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(-14, -6, 6, 12); // Left tank
                ctx.fillRect(8, -6, 6, 12); // Right tank
                
                // Jetpack straps (brown)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-8, -12, 16, 4); // Top strap
                ctx.fillRect(-8, 8, 16, 4); // Bottom strap
                
                // Flame effect (animated)
                const flameIntensity = Math.sin(time * 2) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 100, 0, ${flameIntensity})`;
                ctx.beginPath();
                ctx.moveTo(-8, 8);
                ctx.lineTo(-4, 16);
                ctx.lineTo(0, 12);
                ctx.lineTo(4, 16);
                ctx.lineTo(8, 8);
                ctx.closePath();
                ctx.fill();
                
                // Inner flame (yellow)
                ctx.fillStyle = `rgba(255, 255, 0, ${flameIntensity * 0.8})`;
                ctx.beginPath();
                ctx.moveTo(-4, 8);
                ctx.lineTo(-2, 14);
                ctx.lineTo(0, 10);
                ctx.lineTo(2, 14);
                ctx.lineTo(4, 8);
                ctx.closePath();
                ctx.fill();
            }
            
            // Sparkles
            ctx.fillStyle = '#00FFFF';
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI / 2) + time;
                const sparkleX = Math.cos(angle) * 20;
                const sparkleY = Math.sin(angle) * 20;
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // ðŸ”« LASER DRAWING FUNCTION - CYCLING IMAGES
        function drawLaser(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Update laser cycle timer
            game.laserCycleTimer += 16; // Assuming 60fps (16ms per frame)
            if (game.laserCycleTimer >= game.laserCycleSpeed) {
                game.laserCycleIndex = (game.laserCycleIndex + 1) % 8; // Cycle through 8 laser images (0-7)
                game.laserCycleTimer = 0;
            }
            
            // Get current laser image based on cycle index
            let currentLaserImage = null;
            switch (game.laserCycleIndex) {
                case 0:
                    currentLaserImage = gameAssets.laser;
                    break;
                case 1:
                    currentLaserImage = gameAssets.laser1;
                    break;
                case 2:
                    currentLaserImage = gameAssets.laser2;
                    break;
                case 3:
                    currentLaserImage = gameAssets.laser3;
                    break;
                case 4:
                    currentLaserImage = gameAssets.laser4;
                    break;
                case 5:
                    currentLaserImage = gameAssets.laser5;
                    break;
                case 6:
                    currentLaserImage = gameAssets.laser6;
                    break;
                case 7:
                    currentLaserImage = gameAssets.laser7;
                    break;
            }
            
            // Draw the cycling laser image if available
            if (currentLaserImage && gameAssets.useCustomAssets) {
                // Draw the laser image with glow effect
                const time = Date.now() * 0.006;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Add glow effect behind the image
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 15 * glowIntensity;
                ctx.globalAlpha = 0.7;
                ctx.drawImage(currentLaserImage, -25, -20, 50, 40);
                
                // Draw the main image
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
                ctx.drawImage(currentLaserImage, -25, -20, 50, 40);
                
                // Add "LASER" text
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText('LASER', 0, 35);
                ctx.fillText('LASER', 0, 35);
                
                // Add pickup hint
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 10px Arial';
                ctx.strokeText('PICKUP!', 0, 50);
                ctx.fillText('PICKUP!', 0, 50);
            } else {
                // Fallback to original drawn version if images aren't loaded
            const time = Date.now() * 0.006;
            const glowIntensity = Math.sin(time) * 0.4 + 0.6;
            
            // MASSIVE outer glow for better visibility
            ctx.fillStyle = `rgba(255, 255, 0, ${glowIntensity * 0.3})`;
            ctx.beginPath();
            ctx.arc(0, 0, 50, 0, Math.PI * 2);
            ctx.fill();
            
            // Secondary glow (red)
            ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity * 0.5})`;
            ctx.beginPath();
            ctx.arc(0, 0, 35, 0, Math.PI * 2);
            ctx.fill();
            
            // White inner glow
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.7})`;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // Laser device body (dark gray) - larger and more visible
            ctx.fillStyle = '#222222';
            ctx.fillRect(-20, -15, 40, 30);
            
            // Laser barrel (silver) - larger
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(-25, -8, 15, 16);
            
            // Laser lens (glass effect) - larger
            ctx.fillStyle = '#00FFFF';
            ctx.beginPath();
            ctx.arc(-17, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner lens (reflection)
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-18, -2, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Energy core (pulsing) - larger
            const coreIntensity = Math.sin(time * 3) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, 0, 0, ${coreIntensity})`;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Energy particles - more visible and colorful
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI / 6) + time * 2;
                const particleX = Math.cos(angle) * 25;
                const particleY = Math.sin(angle) * 25;
                
                ctx.fillStyle = i % 2 === 0 ? '#FF0000' : '#FFFF00';
                ctx.beginPath();
                ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Add "LASER" text - bigger and more visible
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.strokeText('LASER', 0, 35);
            ctx.fillText('LASER', 0, 35);
            
            // Add pickup hint
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 10px Arial';
            ctx.strokeText('PICKUP!', 0, 50);
            ctx.fillText('PICKUP!', 0, 50);
            }
            
            ctx.restore();
        }
        
        function drawTreasure(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.treasure) {
                // Draw custom regular treasure chest sprite
                ctx.drawImage(gameAssets.treasure, x - 19, y - 19, 38, 38); // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
            } else {
                // Draw default treasure chest
                // Treasure chest
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - 14, y - 10, 29, 19); // Scaled from 6, 4, 12, 8 (6*2.4=14.4, 4*2.4=9.6, 12*2.4=28.8, 8*2.4=19.2)
                
                // Chest lid
                ctx.fillStyle = '#A0522D';
                ctx.fillRect(x - 14, y - 19, 29, 10); // Scaled from 6, 8, 12, 4 (6*2.4=14.4, 8*2.4=19.2, 12*2.4=28.8, 4*2.4=9.6)
                
                // Lock
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(x - 2, y - 5, 5, 5); // Scaled from 1, 2, 2, 2 (1*2.4=2.4, 2*2.4=4.8, 2*2.4=4.8, 2*2.4=4.8)
                
                // Sparkles
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(x - 19, y - 24, 2, 0, Math.PI * 2); // Scaled from 8, 10, 1 (8*2.4=19.2, 10*2.4=24, 1*2.4=2.4)
                ctx.arc(x + 19, y - 24, 2, 0, Math.PI * 2); // Scaled from 8, 10, 1 (8*2.4=19.2, 10*2.4=24, 1*2.4=2.4)
                ctx.arc(x, y - 29, 2, 0, Math.PI * 2); // Scaled from 0, 12, 1 (0*2.4=0, 12*2.4=28.8, 1*2.4=2.4)
                ctx.fill();
            }
        }
        
        function drawSecretChest(x, y, treasure) {
            ctx.save();
            ctx.translate(x, y);
            
            // Animated glow effect for secret chests
            const time = Date.now() * 0.005;
            const glowIntensity = Math.sin(time) * 0.3 + 0.7;
            
            // Outer glow
            ctx.fillStyle = `rgba(255, 0, 255, ${glowIntensity * 0.4})`;
            ctx.beginPath();
            ctx.arc(0, 0, 45, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw the secret chest (similar to regular chest but with special effects)
            if (gameAssets.useCustomAssets && gameAssets.treasure) {
                // Draw custom treasure chest sprite with secret effects
                ctx.drawImage(gameAssets.treasure, -19, -19, 38, 38);
            } else {
                // Draw default secret chest with special colors
                // Treasure chest base
                ctx.fillStyle = '#8B008B'; // Dark magenta
                ctx.fillRect(-14, -10, 29, 19);
                
                // Chest lid
                ctx.fillStyle = '#9932CC'; // Dark orchid
                ctx.fillRect(-14, -19, 29, 10);
                
                // Lock
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-2, -5, 5, 5);
            }
            
            // Magical sparkles
            ctx.fillStyle = '#FF00FF';
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI / 4) + time;
                const sparkleX = Math.cos(angle) * 30;
                const sparkleY = Math.sin(angle) * 30;
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Pulsing center glow
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Secret indicator text
            ctx.fillStyle = '#FF00FF';
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.strokeText('SECRET', 0, -35);
            ctx.fillText('SECRET', 0, -35);
            
            ctx.restore();
        }
        
        function drawRareTreasure(x, y, requiresKey = false) {
            if (gameAssets.useCustomAssets && gameAssets.rareTreasure) {
                // Draw custom golden treasure chest sprite (DOUBLED SIZE)
            ctx.save();
            ctx.translate(x, y);
            
            // Animated glow effect
            const time = Date.now() * 0.005;
            const glowIntensity = Math.sin(time) * 0.3 + 0.7;
            
                // Outer glow (doubled size)
            ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.3})`;
            ctx.beginPath();
                ctx.arc(0, 0, 58, 0, Math.PI * 2); // Doubled from 29 (29*2=58)
            ctx.fill();
            
                // Draw the golden chest image (doubled size)
                ctx.drawImage(gameAssets.rareTreasure, -38, -38, 76, 76); // Doubled from 38x38 (38*2=76)
                
                // Diamond sparkles (doubled size)
                ctx.fillStyle = '#00FFFF';
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI / 3) + time;
                    const sparkleX = Math.cos(angle) * 48; // Doubled from 24 (24*2=48)
                    const sparkleY = Math.sin(angle) * 48; // Doubled from 24 (24*2=48)
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 4, 0, Math.PI * 2); // Doubled from 2 (2*2=4)
                    ctx.fill();
                }
                
                // Pulsing center glow (doubled size)
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.5})`;
                ctx.beginPath();
                ctx.arc(0, 0, 14, 0, Math.PI * 2); // Doubled from 7 (7*2=14)
                ctx.fill();
                
                // Add key requirement indicator if needed
                if (requiresKey) {
                    // Shield effect to show laser immunity
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 65, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Shield text
                    ctx.fillStyle = '#00FFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeText('LASER IMMUNE', 0, -50);
                    ctx.fillText('LASER IMMUNE', 0, -50);
                    
                    ctx.fillStyle = '#FF0000';
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 3;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeText('KEY REQUIRED', 0, 50);
                    ctx.fillText('KEY REQUIRED', 0, 50);
                    
                    // Show key count
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = 'bold 14px Arial';
                    ctx.strokeText(`Keys: ${game.keyCount}`, 0, 70);
                    ctx.fillText(`Keys: ${game.keyCount}`, 0, 70);
                    
                    // Check if player is near to show F key prompt
                    const playerNear = checkCollision(player, { x: x + game.camera.x - 19, y: y + game.camera.y - 19, width: 38, height: 38 });
                    if (playerNear) {
                        // Show F key interaction prompt
                        ctx.fillStyle = '#00FF00';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.font = 'bold 18px Arial';
                        ctx.strokeText('Press F to Open', 0, 90);
                        ctx.fillText('Press F to Open', 0, 90);
                        
                        // Show if player has key or not
                        if (game.keyCount > 0) {
                            ctx.fillStyle = '#00FF00';
                            ctx.strokeText('âœ“ Has Key', 0, 110);
                            ctx.fillText('âœ“ Has Key', 0, 110);
                        } else {
                            ctx.fillStyle = '#FF0000';
                            ctx.strokeText('âœ— No Key', 0, 110);
                            ctx.fillText('âœ— No Key', 0, 110);
                        }
                    }
                }
                
                ctx.restore();
            } else {
                // Draw default rare treasure with special effects (DOUBLED SIZE)
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.005;
                const glowIntensity = Math.sin(time) * 0.3 + 0.7;
                
                // Outer glow (doubled size)
                ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.3})`;
                ctx.beginPath();
                ctx.arc(0, 0, 58, 0, Math.PI * 2); // Doubled from 29 (29*2=58)
                ctx.fill();
                
                // Treasure chest (golden) - doubled size
            ctx.fillStyle = '#FFD700';
                ctx.fillRect(-28, -20, 58, 38); // Doubled from 14, 10, 29, 19 (14*2=28, 10*2=20, 29*2=58, 19*2=38)
            
                // Chest lid - doubled size
            ctx.fillStyle = '#FFA500';
                ctx.fillRect(-28, -38, 58, 20); // Doubled from 14, 19, 29, 10 (14*2=28, 19*2=38, 29*2=58, 10*2=20)
            
                // Diamond lock - doubled size
            ctx.fillStyle = '#00FFFF';
                ctx.fillRect(-4, -10, 10, 10); // Doubled from 2, 5, 5, 5 (2*2=4, 5*2=10, 5*2=10, 5*2=10)
            
                // Diamond sparkles (doubled size)
            ctx.fillStyle = '#00FFFF';
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI / 3) + time;
                    const sparkleX = Math.cos(angle) * 48; // Doubled from 24 (24*2=48)
                    const sparkleY = Math.sin(angle) * 48; // Doubled from 24 (24*2=48)
                ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 4, 0, Math.PI * 2); // Doubled from 2 (2*2=4)
                ctx.fill();
            }
            
                // Pulsing center glow (doubled size)
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.5})`;
                ctx.beginPath();
                ctx.arc(0, 0, 14, 0, Math.PI * 2); // Doubled from 7 (7*2=14)
                ctx.fill();
                
                // Add key requirement indicator if needed
                if (requiresKey) {
                    // Shield effect to show laser immunity
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 65, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Shield text
                    ctx.fillStyle = '#00FFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeText('LASER IMMUNE', 0, -50);
                    ctx.fillText('LASER IMMUNE', 0, -50);
                    
                    ctx.fillStyle = '#FF0000';
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 3;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeText('KEY REQUIRED', 0, 50);
                    ctx.fillText('KEY REQUIRED', 0, 50);
                    
                    // Show key count
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = 'bold 14px Arial';
                    ctx.strokeText(`Keys: ${game.keyCount}`, 0, 70);
                    ctx.fillText(`Keys: ${game.keyCount}`, 0, 70);
                    
                    // Check if player is near to show F key prompt
                    const playerNear = checkCollision(player, { x: x + game.camera.x - 19, y: y + game.camera.y - 19, width: 38, height: 38 });
                    if (playerNear) {
                        // Show F key interaction prompt
                        ctx.fillStyle = '#00FF00';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.font = 'bold 18px Arial';
                        ctx.strokeText('Press F to Open', 0, 90);
                        ctx.fillText('Press F to Open', 0, 90);
                        
                        // Show if player has key or not
                        if (game.keyCount > 0) {
                            ctx.fillStyle = '#00FF00';
                            ctx.strokeText('âœ“ Has Key', 0, 110);
                            ctx.fillText('âœ“ Has Key', 0, 110);
                        } else {
                            ctx.fillStyle = '#FF0000';
                            ctx.strokeText('âœ— No Key', 0, 110);
                            ctx.fillText('âœ— No Key', 0, 110);
                        }
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawKey(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.key && gameAssets.key.complete) {
                // Draw custom key sprite with enhanced effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.004;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Golden outer glow
                ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2); // Reduced glow radius from 29 to 20
                ctx.fill();
                
                // Draw the custom key image (made skinnier)
                ctx.drawImage(gameAssets.key, -8, -13, 16, 26); // Reduced width from 26 to 16, kept height at 26
                
                // Pulsing center glow (shrunk by 1.5x)
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 7, 0, Math.PI * 2); // Scaled from 3 (3*2.4=7.2, rounded to 7)
                ctx.fill();
                
                ctx.restore();
            } else {
                // Draw default key with special effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.004;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Golden outer glow
                ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2); // Reduced glow radius from 29 to 20
                ctx.fill();
                
                // Key handle (golden) - made skinnier
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-3, -3, 6, 5); // Reduced width from 8 to 6, kept height at 5
                
                // Key shaft (golden) - made skinnier
                ctx.fillRect(-4, -1, 3, 3); // Reduced width from 4 to 3, kept height at 3
                
                // Key teeth (golden) - made skinnier
                ctx.fillRect(-4, -4, 1, 3); // Kept width at 1, kept height at 3
                ctx.fillRect(-3, -5, 1, 3); // Kept width at 1, kept height at 3
                ctx.fillRect(-2, -4, 1, 3); // Kept width at 1, kept height at 3
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
            ctx.beginPath();
            ctx.arc(0, 0, 7, 0, Math.PI * 2); // Scaled from 3 (3*2.4=7.2, rounded to 7)
            ctx.fill();
            
            ctx.restore();
            }
        }
        
        function drawMushroom(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.mushroom && gameAssets.mushroom.complete) {
                // Draw custom mushroom sprite with enhanced effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.003;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Outer glow
                ctx.fillStyle = `rgba(255, 0, 255, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(0, 0, 29, 0, Math.PI * 2); // Scaled from 12 (12*2.4=28.8, rounded to 29)
                ctx.fill();
                
                // Draw the custom mushroom image
                ctx.drawImage(gameAssets.mushroom, -19, -19, 38, 38); // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 7, 0, Math.PI * 2); // Scaled from 3 (3*2.4=7.2, rounded to 7)
                ctx.fill();
                
                ctx.restore();
            } else {
                // Draw default mushroom with special effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.003;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Outer glow
                ctx.fillStyle = `rgba(255, 0, 255, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(0, 0, 29, 0, Math.PI * 2); // Scaled from 12 (12*2.4=28.8, rounded to 29)
                ctx.fill();
                
                // Mushroom cap (red with white spots)
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(0, -5, 12, 0, Math.PI * 2); // Scaled from 5 (5*2.4=12)
                ctx.fill();
                
                // White spots on cap
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(-5, -8, 2, 0, Math.PI * 2); // Scaled from 2, 3, 1 (2*2.4=4.8, 3*2.4=7.2, 1*2.4=2.4)
                ctx.arc(5, -6, 2, 0, Math.PI * 2); // Scaled from 2, 2, 1 (2*2.4=4.8, 2*2.4=4.8, 1*2.4=2.4)
                ctx.arc(0, -2, 2, 0, Math.PI * 2); // Scaled from 0, 1, 1 (0*2.4=0, 1*2.4=2.4, 1*2.4=2.4)
                ctx.fill();
                
                // Mushroom stem (white)
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(-4, 0, 8, 12); // Scaled from 2, 0, 3, 5 (2*2.4=4.8, 0*2.4=0, 3*2.4=7.2, 5*2.4=12)
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 7, 0, Math.PI * 2); // Scaled from 3 (3*2.4=7.2, rounded to 7)
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function drawCrab(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (gameAssets.useCustomAssets && gameAssets.enemy) {
                // Draw custom enemy sprite
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                ctx.drawImage(gameAssets.enemy, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                ctx.restore();
            } else {
                // Draw default crab
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                // Body
                ctx.fillStyle = '#FF6B6B';
                ctx.fillRect(-12, -8, 20, 12);
                
                // Claws
                ctx.fillStyle = '#FF4444';
                ctx.fillRect(-16, -4, 4, 6);
                ctx.fillRect(12, -4, 4, 6);
                
                // Laser indicators for shooting crabs (level 5+)
                if (enemy.canShoot) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(-18, -2, 2, 2);
                    ctx.fillRect(14, -2, 2, 2);
                }
                
                // Eyes
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-6, -8, 1, 0, Math.PI * 2);
                ctx.arc(-2, -8, 1, 0, Math.PI * 2);
                ctx.fill();
                
                // Legs
                ctx.strokeStyle = '#FF4444';
                ctx.lineWidth = 2;
                for(let i = -8; i < 8; i += 4) {
                    ctx.beginPath();
                    ctx.moveTo(i, 4);
                    ctx.lineTo(i, 8);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        function drawEagle(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -77 && x < game.canvasWidth + 77) {
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                // Choose eagle image based on state
                let eagleImage = null;
                if (enemy.isAttacking || enemy.isDiving) {
                    eagleImage = gameAssets.eagle1; // Attacking eagle
                } else {
                    eagleImage = gameAssets.eagle; // Idle eagle
                }
                
                if (gameAssets.useCustomAssets && eagleImage && eagleImage.complete) {
                    // Draw custom eagle sprite
                    ctx.drawImage(eagleImage, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                } else {
                    // Fallback to default eagle drawing
                // Body
                    ctx.fillStyle = enemy.isAttacking ? '#8B0000' : '#8B4513';
                ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                
                // Wings
                    ctx.fillStyle = enemy.isAttacking ? '#A0522D' : '#A0522D';
                ctx.fillRect(-enemy.width/2 - 10, -enemy.height/2, 10, enemy.height);
                ctx.fillRect(enemy.width/2, -enemy.height/2, 10, enemy.height);
                
                // Eyes
                    ctx.fillStyle = enemy.isAttacking ? '#FF0000' : '#FF6600';
                ctx.beginPath();
                ctx.arc(-enemy.width/4, -enemy.height/3, 2, 0, Math.PI * 2);
                ctx.arc(enemy.width/4, -enemy.height/3, 2, 0, Math.PI * 2);
                ctx.fill();
                    
                    // Beak
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(enemy.width/2 - 5, -2, 5, 4);
                }
                
                ctx.restore();
            }
        }
        
        function drawShark(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -150 && x < game.canvasWidth + 150) {
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                // Choose shark image based on state
                let sharkImage = null;
                if (enemy.isAttacking || enemy.isDiving) {
                    sharkImage = gameAssets.shark1; // Attacking shark
                } else {
                    sharkImage = gameAssets.shark; // Idle shark
                }
                
                if (gameAssets.useCustomAssets && sharkImage && sharkImage.complete) {
                    // Draw custom shark sprite
                    ctx.drawImage(sharkImage, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                } else {
                    // Fallback to default shark drawing
                    // Shark body (dark blue/gray)
                    ctx.fillStyle = enemy.isAttacking ? '#2F4F4F' : '#4682B4';
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Shark fin (dorsal fin)
                    ctx.fillStyle = '#2F4F4F';
                    ctx.beginPath();
                    ctx.moveTo(-enemy.width/4, -enemy.height/2);
                    ctx.lineTo(-enemy.width/4 - 8, -enemy.height/2 - 15);
                    ctx.lineTo(-enemy.width/4 + 8, -enemy.height/2 - 15);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Tail fin
                    ctx.fillStyle = '#2F4F4F';
                    ctx.beginPath();
                    ctx.moveTo(enemy.width/2, 0);
                    ctx.lineTo(enemy.width/2 + 20, -enemy.height/3);
                    ctx.lineTo(enemy.width/2 + 20, enemy.height/3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Eyes (red when attacking)
                    ctx.fillStyle = enemy.isAttacking ? '#FF0000' : '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 3, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye pupils
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 1, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 1, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gills
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(-enemy.width/3, -enemy.height/3, 3, 6);
                    ctx.fillRect(-enemy.width/3 + 5, -enemy.height/3, 3, 6);
                }
                
                // Underwater bubbles effect (always show for custom assets)
                if (enemy.isAttacking || enemy.isDiving) {
                    const time = Date.now() * 0.005;
                    for (let i = 0; i < 3; i++) {
                        const bubbleX = Math.cos(time + i) * 30;
                        const bubbleY = Math.sin(time + i * 2) * 20;
                        const bubbleSize = Math.sin(time + i) * 2 + 3;
                        
                        ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawGoldfish(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -100 && x < game.canvasWidth + 100) {
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                if (gameAssets.useCustomAssets && gameAssets.goldfish && gameAssets.goldfish.complete) {
                    // Draw custom goldfish sprite
                    ctx.drawImage(gameAssets.goldfish, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                } else {
                    // Fallback to default goldfish drawing
                    // Body
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Tail
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.moveTo(enemy.width/2, 0);
                    ctx.lineTo(enemy.width/2 + 15, -enemy.height/3);
                    ctx.lineTo(enemy.width/2 + 15, enemy.height/3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Eyes
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Fins
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(-enemy.width/3, -enemy.height/2 - 5, 8, 5);
                    ctx.fillRect(-enemy.width/3, enemy.height/2, 8, 5);
                }
                
                ctx.restore();
            }
        }
        
        function drawGator(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -130 && x < game.canvasWidth + 130) {
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                // Choose sprite based on whether gator is chasing
                let gatorImage = gameAssets.gator; // Default sprite
                if (enemy.isChasing && gameAssets.gator1 && gameAssets.gator1.complete) {
                    gatorImage = gameAssets.gator1; // Chasing sprite
                }
                
                if (gameAssets.useCustomAssets && gatorImage && gatorImage.complete) {
                    // Draw custom gator sprite
                    ctx.drawImage(gatorImage, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                } else {
                    // Fallback to default gator drawing
                    // Body
                    ctx.fillStyle = enemy.isChasing ? '#FF4444' : '#228B22'; // Red when chasing, green when patrolling
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Snout
                    ctx.fillStyle = enemy.isChasing ? '#CC3333' : '#006400';
                    ctx.fillRect(enemy.width/2 - 10, -enemy.height/3, 15, enemy.height/1.5);
                    
                    // Eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 4, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Teeth (when chasing)
                    if (enemy.isChasing) {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(enemy.width/2 - 5, -enemy.height/4, 3, 3);
                        ctx.fillRect(enemy.width/2 - 5, enemy.height/4, 3, 3);
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawWizgator(enemy) {
            console.log('ðŸŽ¨ DRAWING WIZGATOR! Position:', enemy.x, enemy.y, 'Camera:', game.camera.x, game.camera.y);
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -130 && x < game.canvasWidth + 130) {
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                if (gameAssets.useCustomAssets && gameAssets.wizgator && gameAssets.wizgator.complete) {
                    console.log('ðŸŽ¨ DRAWING CUSTOM WIZGATOR SPRITE!');
                    // Draw custom wizgator sprite
                    ctx.drawImage(gameAssets.wizgator, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                } else {
                    console.log('ðŸŽ¨ DRAWING FALLBACK WIZGATOR GRAPHICS! useCustomAssets:', gameAssets.useCustomAssets, 'wizgator asset:', !!gameAssets.wizgator, 'complete:', gameAssets.wizgator ? gameAssets.wizgator.complete : 'N/A');
                    // Fallback to default wizgator drawing
                    // Body - purple/magenta theme for wizgators
                    ctx.fillStyle = enemy.isChasing ? '#FF00FF' : '#8B008B'; // Magenta when chasing, dark magenta when patrolling
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Snout
                    ctx.fillStyle = enemy.isChasing ? '#FF66FF' : '#4B0082'; // Light magenta when chasing, indigo when patrolling
                    ctx.fillRect(enemy.width/2 - 10, -enemy.height/3, 15, enemy.height/1.5);
                    
                    // Eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 4, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'purple';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Magic effects (when chasing)
                    if (enemy.isChasing) {
                        // Fireball charge effect
                        const time = Date.now() * 0.005;
                        const glowIntensity = Math.sin(time) * 0.3 + 0.7;
                        
                        // Fireball charge glow around snout
                        ctx.fillStyle = `rgba(255, 102, 0, ${glowIntensity * 0.6})`;
                        ctx.beginPath();
                        ctx.arc(enemy.width/2 + 5, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Magic sparkles
                        for (let i = 0; i < 3; i++) {
                            const sparkleX = Math.cos(time + i * 2) * 15;
                            const sparkleY = Math.sin(time + i * 2) * 15;
                            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.8})`;
                            ctx.beginPath();
                            ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawCharger(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -115 && x < game.canvasWidth + 115) {
                if (gameAssets.useCustomAssets && gameAssets.piratecrab) {
                    // Draw custom piratecrab sprite
                    ctx.save();
                    ctx.translate(x + enemy.width/2, y + enemy.height/2);
                    ctx.scale(enemy.direction, 1);
                    ctx.drawImage(gameAssets.piratecrab, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    ctx.restore();
                } else {
                    // Draw default charger (fallback)
                    ctx.save();
                    ctx.translate(x + enemy.width/2, y + enemy.height/2);
                    ctx.scale(enemy.direction, 1);
                    
                    // Body
                    ctx.fillStyle = enemy.isCharging ? '#FF0000' : '#CC3333';
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Horn
                    ctx.fillStyle = '#FF6666';
                    ctx.fillRect(-enemy.width/2 - 5, -enemy.height/2 + 5, 5, 10);
                    
                    // Eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/3, 3, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/3, 1.5, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/3, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
        }
        
        function drawCheckpoint(checkpoint) {
            const x = checkpoint.x - game.camera.x;
            const y = checkpoint.y - game.camera.y;
            
            if (x > -40 && x < game.canvasWidth + 40) {
                ctx.save();
                
                // Use custom checkpoint images if available
                if (gameAssets.useCustomAssets && gameAssets.checkpoint && gameAssets.checkpointActivated) {
                    const checkpointImage = checkpoint.activated ? gameAssets.checkpointActivated : gameAssets.checkpoint;
                    const imageWidth = 80; // 2x bigger (was 40)
                    const imageHeight = 120; // 2x bigger (was 60)
                    
                    // Draw the checkpoint image
                    ctx.drawImage(checkpointImage, x - 20, y - 20, imageWidth, imageHeight);
                    
                    // Add blue glow effect when activated
                    if (checkpoint.activated) {
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 15;
                        ctx.globalAlpha = 0.3;
                        ctx.drawImage(checkpointImage, x - 20, y - 20, imageWidth, imageHeight);
                        ctx.globalAlpha = 1.0;
                        ctx.shadowBlur = 0;
                    }
                } else {
                    // Fallback to original rectangle-based rendering
                // Checkpoint flag
                ctx.fillStyle = checkpoint.activated ? '#00FF00' : '#FFFF00';
                ctx.fillRect(x, y, 4, checkpoint.height);
                
                // Flag banner
                ctx.fillStyle = checkpoint.activated ? '#00CC00' : '#FFCC00';
                ctx.fillRect(x + 4, y, 20, 15);
                
                // Flag pole
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x + 2, y, 2, checkpoint.height);
                
                // Activation glow
                if (checkpoint.activated) {
                    ctx.shadowColor = '#00FF00';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.fillRect(x - 5, y - 5, 30, checkpoint.height + 10);
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawPlatform(platform) {
            // Skip invisible disappearing platforms
            if (platform.type === 'disappearing' && !platform.isVisible) {
                return;
            }
            
            // Handle barrier walls separately
            if (platform.type === 'barrier') {
                drawBarrierWall(platform);
                return;
            }
            
            // Handle cloud platforms separately
            if (platform.type === 'cloud') {
                drawCloudPlatform(platform);
                return;
            }
            
            // Handle underwater platforms separately
            if (platform.type === 'underwater') {
                drawUnderwaterPlatform(platform);
                return;
            }
            
            const x = platform.x - game.camera.x;
            const y = platform.y - game.camera.y;
            
            // Cut off platforms at water surface (only for regular platforms, not underwater ones)
            const waterSurfaceY = game.waterLevel - game.camera.y;
            const platformBottom = y + platform.height;
            
            // Calculate draw height (declare at function level)
            let drawHeight = platform.height;
            
            // If platform extends below water surface, cut it off
            if (platformBottom > waterSurfaceY && platform.type !== 'underwater') {
                const cutOffHeight = platformBottom - waterSurfaceY;
                const adjustedHeight = platform.height - cutOffHeight;
                
                // Don't draw if platform is completely underwater
                if (adjustedHeight <= 0) {
                    return;
                }
                
                // Use adjusted height for drawing
                drawHeight = adjustedHeight;
            }
            
            if (gameAssets.useCustomAssets && gameAssets.platform) {
                // Draw custom platform sprite (tiled)
                const tileWidth = 77; // Scaled from 32 (32*2.4=76.8, rounded to 77)
                const tileHeight = drawHeight;
                
                for (let i = 0; i < platform.width; i += tileWidth) {
                    const drawWidth = Math.min(tileWidth, platform.width - i);
                    ctx.drawImage(gameAssets.platform, x + i, y, drawWidth, tileHeight);
                }
            } else {
                // Draw default platform
                // Platform base
                ctx.fillStyle = currentLevel.platformColor;
                ctx.fillRect(x, y, platform.width, drawHeight);
                
                // Grass/surface on top - STATIC (no animation for performance)
                ctx.fillStyle = currentLevel.groundColor;
                ctx.fillRect(x, y - 12, platform.width, 12); // Scaled from 5 (5*2.4=12)
                
                // Surface details - STATIC (no moving grass animation)
                // Moving grass animation removed to reduce lag
                
                // Visual indicators for moving platforms

            }
        }
        
        function drawCloudPlatform(platform) {
            const x = platform.x - game.camera.x;
            const y = platform.y - game.camera.y;
            const time = Date.now() * 0.001;
            
            // Create realistic cloud with multiple layers and gradients
            const cloudWidth = platform.width;
            const cloudHeight = platform.height;
            
            ctx.save();
            
            // Calculate fade-out effect for disappearing clouds and respawn effect
            let fadeOpacity = platform.cloudOpacity || 0.8;
            if (platform.isDisappearing && platform.cloudStartTime) {
                const timeOnCloud = Date.now() - platform.cloudStartTime;
                const fadeStart = platform.cloudDisappearTime - 1000; // Start fading 1 second before disappearing
                if (timeOnCloud > fadeStart) {
                    const fadeProgress = (timeOnCloud - fadeStart) / 1000; // 0 to 1 over 1 second
                    fadeOpacity *= (1 - fadeProgress * 0.7); // Fade to 30% opacity
                }
                
                // Add warning indicator when cloud is about to disappear
                if (timeOnCloud > platform.cloudDisappearTime - 500) { // Last 0.5 seconds
                    const warningOpacity = Math.sin(timeOnCloud * 0.01) * 0.5 + 0.5; // Blinking effect
                    ctx.strokeStyle = `rgba(255, 0, 0, ${warningOpacity})`;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x - 5, y - 5, cloudWidth + 10, cloudHeight + 10);
                }
            }
            
            // Respawn effect - show ghost cloud when respawning
            if (!platform.isVisible && platform.respawnStartTime) {
                const timeSinceDisappear = Date.now() - platform.respawnStartTime;
                const respawnProgress = Math.min(timeSinceDisappear / 5000, 1); // 0 to 1 over 5 seconds
                
                if (respawnProgress > 0.8) { // Show ghost cloud in last 20% of respawn time
                    const ghostOpacity = (respawnProgress - 0.8) * 5; // Fade in over last 20%
                    fadeOpacity = ghostOpacity * 0.3; // Ghost cloud is very faint
                    
                    // Add respawn indicator
                    const respawnOpacity = Math.sin(timeSinceDisappear * 0.01) * 0.5 + 0.5; // Blinking effect
                    ctx.strokeStyle = `rgba(0, 255, 0, ${respawnOpacity * ghostOpacity})`;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x - 3, y - 3, cloudWidth + 6, cloudHeight + 6);
                } else {
                    return; // Don't draw anything if not respawning yet
                }
            }
            
            // Determine cloud color based on special properties
            let cloudColor = platform.cloudColor || '#FFFFFF';
            // Rain cloud color removed for performance
            if (platform.isThunderCloud) {
                cloudColor = '#4A4A4A'; // Dark gray for thunder clouds
            } else if (platform.isGoldenCloud) {
                cloudColor = '#FFD700'; // Gold for golden clouds
            }
            
            // Cloud base layer (bottom shadow)
            ctx.fillStyle = `rgba(200, 200, 200, ${fadeOpacity * 0.3})`;
            ctx.fillRect(x, y + cloudHeight * 0.7, cloudWidth, cloudHeight * 0.3);
            
            // Main cloud body with gradient
            const gradient = ctx.createLinearGradient(x, y, x, y + cloudHeight);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${fadeOpacity * 1.1})`);
            gradient.addColorStop(0.7, `rgba(240, 240, 240, ${fadeOpacity})`);
            gradient.addColorStop(1, `rgba(220, 220, 220, ${fadeOpacity * 0.75})`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, cloudWidth, cloudHeight);
            
            // Create multiple cloud puffs with realistic shapes
            const puffCount = platform.cloudType === 0 ? 4 : platform.cloudType === 1 ? 6 : 5;
            const puffSize = (cloudWidth / puffCount) * (platform.cloudPuffiness || 1.0);
            
            for (let i = 0; i < puffCount; i++) {
                const puffX = x + (cloudWidth / puffCount) * i + (cloudWidth / puffCount) / 2;
                const puffY = y + cloudHeight * 0.4;
                
                // Animated cloud puffs with subtle movement
                const puffOffset = Math.sin(time + i * 0.3) * 1.5;
                
                // Main puff with gradient
                const puffGradient = ctx.createRadialGradient(
                    puffX + puffOffset, puffY, 0,
                    puffX + puffOffset, puffY, puffSize * 0.8
                );
                puffGradient.addColorStop(0, `rgba(255, 255, 255, ${fadeOpacity * 1.2})`);
                puffGradient.addColorStop(0.7, `rgba(245, 245, 245, ${fadeOpacity * 1.1})`);
                puffGradient.addColorStop(1, `rgba(230, 230, 230, ${fadeOpacity * 0.9})`);
                
                ctx.fillStyle = puffGradient;
                ctx.beginPath();
                ctx.arc(puffX + puffOffset, puffY, puffSize * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                // Smaller overlapping puffs for realistic cloud shape
                for (let j = 0; j < 4; j++) {
                    const smallPuffX = puffX + Math.cos(j * Math.PI / 2) * puffSize * 0.5;
                    const smallPuffY = puffY + Math.sin(j * Math.PI / 2) * puffSize * 0.5;
                    
                    const smallPuffGradient = ctx.createRadialGradient(
                        smallPuffX + puffOffset * 0.3, smallPuffY, 0,
                        smallPuffX + puffOffset * 0.3, smallPuffY, puffSize * 0.4
                    );
                    smallPuffGradient.addColorStop(0, `rgba(255, 255, 255, ${fadeOpacity * 1.1})`);
                    smallPuffGradient.addColorStop(1, `rgba(235, 235, 235, ${fadeOpacity * 0.75})`);
                    
                    ctx.fillStyle = smallPuffGradient;
                    ctx.beginPath();
                    ctx.arc(smallPuffX + puffOffset * 0.3, smallPuffY, puffSize * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Add cloud highlights (top layer)
            ctx.fillStyle = `rgba(255, 255, 255, ${fadeOpacity * 0.5})`;
            ctx.fillRect(x, y, cloudWidth, cloudHeight * 0.3);
            
            // Cloud shadow/outline with softer edges
            ctx.strokeStyle = `rgba(180, 180, 180, ${fadeOpacity * 0.4})`;
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, cloudWidth, cloudHeight);
            

            
            // Special cloud effects - RAIN REMOVED FOR PERFORMANCE
            // Rain effects removed to reduce lag
            
            if (platform.isThunderCloud) {
                // Draw lightning effect
                if (Math.random() < 0.1) { // 10% chance per frame
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x + Math.random() * platform.width, y);
                    ctx.lineTo(x + Math.random() * platform.width, y + 50);
                    ctx.stroke();
                }
            }
            
            if (platform.isGoldenCloud) {
                // Draw golden sparkles
                ctx.fillStyle = '#FFD700';
                for (let i = 0; i < 5; i++) {
                    const sparkleX = x + Math.random() * platform.width;
                    const sparkleY = y + Math.random() * platform.height;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        function drawGoal() {
            // Use the stored goal coordinates for consistent positioning
            if (!game.goalX || !game.goalY) return;
            
            const x = game.goalX + 180 - game.camera.x; // Center of goal platform (360/2 = 180)
            const y = game.goalY - 192 - game.camera.y; // Above the goal platform
            
            // Use custom goal flag image if available
            if (gameAssets.useCustomAssets && gameAssets.goalFlag) {
                // Draw the goal flag image - reduced height by 30px
                const imageWidth = 120; // Keep width the same
                const imageHeight = 270; // Reduced from 300 to 270 (30px shorter)
                
                // Position the flag properly on the platform
                // The flag pole should be at the center of the platform, and the flag should extend upward
                const drawX = x - imageWidth / 2; // Center the flag horizontally on the platform
                const drawY = y - imageHeight + 192; // Position so the bottom of the flag is at platform level
                
                ctx.drawImage(gameAssets.goalFlag, drawX, drawY, imageWidth, imageHeight);
                
                // Add a subtle glow effect
                ctx.save();
                ctx.shadowColor = '#00FF00';
                ctx.shadowBlur = 10;
                ctx.globalAlpha = 0.3;
                ctx.drawImage(gameAssets.goalFlag, drawX, drawY, imageWidth, imageHeight);
                ctx.restore();
            } else {
                // Fallback to original rectangle-based rendering
            // Flag pole (larger)
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x, y, 19, 192); // Scaled from 8, 80 (8*2.4=19.2, 80*2.4=192)
            
            // Flag (larger)
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(x + 19, y, 96, 60); // Scaled from 8, 40, 25 (8*2.4=19.2, 40*2.4=96, 25*2.4=60)
            
            // Flag border
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 5; // Scaled from 2 (2*2.4=4.8, rounded to 5)
            ctx.strokeRect(x + 19, y, 96, 60); // Scaled from 8, 40, 25 (8*2.4=19.2, 40*2.4=96, 25*2.4=60)
            
            // GOAL text (smaller to fit in flag)
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Orbitron, Arial Black, sans-serif'; // Scaled from 10 (10*2.4=24)
            ctx.textAlign = 'center';
            ctx.fillText('GOAL', x + 67, y + 41); // Scaled from 28, 17 (28*2.4=67.2, 17*2.4=40.8)
            }
            
            // Reset text alignment
            ctx.textAlign = 'left';
        }
        
        // Collision detection
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // Triangle collision detection (point-in-triangle test)
        function checkTriangleCollision(px, py, x1, y1, x2, y2, x3, y3) {
            // Using barycentric coordinates to determine if point is inside triangle
            const denominator = ((y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3));
            const a = ((y2 - y3) * (px - x3) + (x3 - x2) * (py - y3)) / denominator;
            const b = ((y3 - y1) * (px - x3) + (x1 - x3) * (py - y3)) / denominator;
            const c = 1 - a - b;
            
            // Point is inside triangle if all barycentric coordinates are between 0 and 1
            return a >= 0 && a <= 1 && b >= 0 && b <= 1 && c >= 0 && c <= 1;
        }
        
        // Enhanced laser collision detection with larger hit area
        function checkLaserCollision(laser, enemy) {
            // Use a more generous collision area for lasers
            const laserHitArea = {
                x: laser.x - 5, // Extend hit area by 5 pixels on each side
                y: laser.y - 5,
                width: laser.width + 10,
                height: laser.height + 10
            };
            
            return checkCollision(laserHitArea, enemy);
        }
        
        // Update game logic
        function update() {
            if (game.gameOver) return;
            
            // Don't check achievements periodically - only check when making actual progress
            
            if (game.levelComplete) {
                if (game.keys['Space']) {
                    // Reset bossActive when changing levels (this is where lava should turn back to water)
                    game.bossActive = false;
                    game.level++;
                    loadLevel(game.level);
                    document.getElementById('level').textContent = game.level;
                    document.getElementById('levelComplete').style.display = 'none';
                    saveGameState(); // Save game state with new level
                }
                return;
            }
            
            // ========================================
            // ðŸŽ® PLAYER MOVEMENT LOGIC
            // ========================================
            // Apply wallet speed bonuses if connected (wallet system disabled)
            let currentSpeed = player.speed;
            // Wallet system removed - no speed bonuses applied
            
            if (game.keys['ArrowLeft'] || game.keys['KeyA']) {
                player.velX = -currentSpeed;
                player.direction = -1;
            } else if (game.keys['ArrowRight'] || game.keys['KeyD']) {
                player.velX = currentSpeed;
                player.direction = 1;
            } else {
                player.velX = 0;
            }

            // ========================================
            // ðŸš€ ROBUST DOUBLE JUMP SYSTEM
            // ========================================
            if (game.keys['jumpJustPressed']) {
                // Removed console.log for performance
                
                if (player.onGround) {
                    // âœ… FIRST JUMP - From ground
                    player.velY = -player.jumpPower;
                    player.onGround = false;
                    player.onMovingPlatform = false; // Reset moving platform state when jumping
                    // Force player slightly above platform to prevent immediate collision
                    if (player.lastPlatform) {
                        player.y = player.lastPlatform.y - player.collisionHeight - player.collisionOffsetY - 5;
                    }
                    game.sessionStats.jumpsMade++;
                } else if (player.canDoubleJump) {
                    // â­ DOUBLE JUMP - From air (always works regardless of velocity)
                    player.velY = -player.jumpPower * 0.7; // Reduced double jump power for better control
                    player.canDoubleJump = false;
                    game.sessionStats.jumpsMade++;
                } else if (player.inWater) {
                    // ðŸŒŠ WATER JUMP - Swim up when in water (always works, regardless of position)
                    player.velY = -player.swimSpeed * 0.25; // Reduced water jump power for better control
                    player.swimming = true;
                    player.onGround = false; // Ensure we're off ground when water jumping
                    game.sessionStats.jumpsMade++;
                }
                
                // ðŸ”„ ALWAYS reset the flag, even if jump failed
                game.keys['jumpJustPressed'] = false;
            }

            // ========================================
            // ðŸŒ PHYSICS & POSITION UPDATES
            // ========================================
                                        // Apply gravity (consistent for all movement)
            let gravityStrength = 0.65; // Increased gravity for better feel and performance
            
            // Keep gravity consistent even when jetpack is active
            // This prevents the "floaty" feeling when switching between walking and jetpack
            
            player.velY += gravityStrength;

            // ðŸ“‰ Cap maximum fall velocity for better feel
            let maxFallVelocity = 10.0; // Increased fall velocity for snappier feel
            
            if (player.velY > maxFallVelocity) {
                player.velY = maxFallVelocity;
            }

            // ðŸ“ˆ Cap maximum upward velocity to prevent excessive bouncing
            if (player.velY < -28) {
                player.velY = -28; // Match increased jump power
            }

            // ========================================
            // ðŸŒŠ WATER PHYSICS
            // ========================================
            // Check if player is in water (more precise detection)
            const playerBottom = player.y + player.collisionHeight + player.collisionOffsetY;
            const playerTop = player.y + player.collisionOffsetY;
            const waterTop = game.waterLevel;
            const waterBottom = game.waterLevel + game.waterDepth;
            
            // Player is in water if any part of them is below water surface
            if (playerTop < waterBottom && playerBottom > waterTop) {
                // Player is in water
                if (!player.inWater) {
                    player.inWater = true;
                    // Show owl underwater message
                    showSituationalOwlMessage('underwater');
                }
                
                // Check if player is at water surface (within 20px of surface for more reliable detection)
                const isAtWaterSurface = playerBottom <= waterTop + 20;
                
                // Always allow jumping when in water (both surface and underwater)
                if (isAtWaterSurface) {
                    // At water surface - treat like normal ground for jumping
                    player.onGround = true;
                    player.canDoubleJump = true;
                } else {
                    // Underwater - still allow jumping but apply water physics
                    if (player.onGround) {
                        player.onGround = false;
                    }
                }
                
                // Water physics - apply to all underwater movement
                if (!isAtWaterSurface) {
                    // Don't apply water resistance if jetpack is active (to preserve boost)
                    if (!player.jetpackActive || !(game.keys['ShiftLeft'] || game.keys['ShiftRight'])) {
                        player.velX *= player.waterResistance; // Reduce horizontal velocity
                    }
                    
                    // Buoyancy - only reduce fall speed, don't affect upward movement
                    if (player.velY > 0) {
                        player.velY *= 0.5; // Reduce fall speed in water
                    }
                    
                    // Swimming controls - much faster and more responsive
                    if (game.keys['ArrowUp'] || game.keys['KeyW']) {
                        // Much faster upward movement
                        player.velY = Math.max(player.velY - player.swimSpeed * 1.2, -player.swimSpeed * 2.0);
                        player.swimming = true;
                    } else if (game.keys['ArrowDown'] || game.keys['KeyS']) {
                        player.velY = Math.min(player.velY + player.swimSpeed * 0.8, player.swimSpeed * 1.6);
                        player.swimming = true;
                    } else {
                        // Gradually return to neutral when no keys pressed
                        if (player.velY < 0) {
                            player.velY = Math.min(player.velY + 0.2, 0);
                        } else if (player.velY > 0) {
                            player.velY = Math.max(player.velY - 0.2, 0);
                        }
                        player.swimming = false;
                    }
                    
                    // Horizontal swimming
                    if (game.keys['ArrowLeft'] || game.keys['KeyA']) {
                        player.velX = -player.swimSpeed;
                        player.swimming = true;
                    } else if (game.keys['ArrowRight'] || game.keys['KeyD']) {
                        player.velX = player.swimSpeed;
                        player.swimming = true;
                    }
                } else {
                    // At water surface - normal movement controls
                    player.swimming = false;
                }
                
            } else {
                // Player is not in water
                if (player.inWater) {
                    player.inWater = false;
                    player.swimming = false;
                }
            }
            
            // ========================================
            // ðŸ”¥ LAVA PHYSICS (BOSS LEVELS ONLY)
            // ========================================
            if (game.bossActive) {
                // Check if player is in lava (more precise detection)
                const playerBottom = player.y + player.collisionHeight + player.collisionOffsetY;
                const playerTop = player.y + player.collisionOffsetY;
                const lavaTop = game.lavaLevel;
                const lavaBottom = game.lavaLevel + game.lavaDepth;
                
                // Player is in lava if any part of them is below lava surface
                if (playerTop < lavaBottom && playerBottom > lavaTop) {
                    // Player is in lava
                                         if (!player.inLava) {
                         player.inLava = true;
                         player.lavaSinkTime = Date.now();
                         takeDamage(50); // Initial damage when falling into lava
                         addScreenShake(8);
                         console.log('ðŸ”¥ Player fell into lava! Took 50 initial damage. Health remaining:', player.health);
                     }
                    
                                         // Check if player is at lava surface (within 20px of surface)
                     const isAtLavaSurface = playerBottom <= lavaTop + 20;
                     
                     // Continuous lava damage every second
                     const currentTime = Date.now();
                     if (!player.lastLavaDamageTime) {
                         player.lastLavaDamageTime = currentTime;
                     }
                     
                     const timeSinceLastDamage = currentTime - player.lastLavaDamageTime;
                     if (timeSinceLastDamage >= 1000) { // Every 1000ms (1 second)
                         takeDamage(15); // 15 damage per second
                         player.lastLavaDamageTime = currentTime;
                         addScreenShake(2);
                         console.log('ðŸ”¥ Continuous lava damage! Took 15 damage. Health remaining:', player.health);
                     }
                     
                     if (isAtLavaSurface) {
                         // At lava surface - bounce up and take extra damage
                         if (!player.lavaInvulnerable) {
                             player.velY = -game.lavaBouncePower; // Bounce up
                             player.lavaInvulnerable = true;
                             player.lavaDamageTime = Date.now();
                             takeDamage(35); // Extra damage for touching surface (35 + 15 = 50 total)
                             addScreenShake(5);
                             console.log('ðŸ”¥ Lava surface damage! Bounced up, took 35 extra damage. Health remaining:', player.health);
                         }
                     } else {
                        // Sinking in lava - check for death
                        const sinkTime = Date.now() - player.lavaSinkTime;
                        if (sinkTime > game.lavaSinkDuration) {
                            // Player has been in lava too long - death
                            takeDamage(100); // Use damage system instead of direct life loss
                            addScreenShake(10);
                            console.log('ðŸ”¥ Lava death! Sunk for too long. Took 100 damage. Health remaining:', player.health);
                            
                            // Respawn at last platform
                            if (player.lastPlatform) {
                                player.x = player.lastPlatform.x + 100;
                                player.y = player.lastPlatform.y - player.collisionHeight - player.collisionOffsetY;
                                player.velX = 0;
                                player.velY = 0;
                                player.onGround = true;
                                player.canDoubleJump = true;
                                console.log('ðŸ”¥ Respawned at last platform:', player.lastPlatform.x, player.lastPlatform.y);
                            }
                            
                            // Reset lava state
                            player.inLava = false;
                            player.lavaSinkTime = 0;
                        }
                    }
                    
                    // Lava physics - slow movement and sinking
                    player.velX *= 0.3; // Heavy resistance
                    if (player.velY > 0) {
                        player.velY *= 0.7; // Slow sinking
                    }
                    
                } else {
                    // Player is not in lava
                                         if (player.inLava) {
                         player.inLava = false;
                         player.lavaSinkTime = 0;
                         player.lastLavaDamageTime = 0; // Reset damage timer
                         console.log('ðŸ”¥ Player left lava');
                     }
                }
                
                // Check lava invulnerability timer
                if (player.lavaInvulnerable) {
                    const invulnerabilityTime = Date.now() - player.lavaDamageTime;
                    if (invulnerabilityTime > game.lavaDamageInvulnerability) {
                        player.lavaInvulnerable = false;
                        console.log('ðŸ”¥ Lava invulnerability ended');
                    }
                }
                
                // Debug lava state
                if (player.inLava) {
                    const sinkTime = Date.now() - player.lavaSinkTime;
                    console.log('ðŸ”¥ Lava debug - sinkTime:', (sinkTime/1000).toFixed(1) + 's', 'invulnerable:', player.lavaInvulnerable);
                }
            }

            // ðŸš€ Continuous jetpack boost in water
            if (player.hasJetpack && player.jetpackActive && player.inWater && (game.keys['ShiftLeft'] || game.keys['ShiftRight'])) {
                const currentTime = Date.now();
                const timeSinceLastBoost = currentTime - player.jetpackTime;
                
                // Apply continuous boost every 100ms while holding Shift in water
                if (timeSinceLastBoost > 100) {
                    // Add to existing velocity for continuous boost - much stronger
                    player.velX += player.direction * player.waterJetpackPower * 0.3;
                    player.jetpackTime = currentTime;
                    console.log('ðŸŒŠ Continuous water jetpack boost - velX:', player.velX.toFixed(2));
                }
            }
            
            // ðŸš€ Continuous jetpack boost on land (for mobile button)
            if (player.hasJetpack && player.jetpackActive && !player.inWater && (game.keys['ShiftLeft'] || game.keys['ShiftRight'])) {
                const currentTime = Date.now();
                const timeSinceLastBoost = currentTime - player.jetpackTime;
                
                // Apply continuous boost every 200ms while holding Shift on land
                if (timeSinceLastBoost > 200) {
                    // Apply vertical boost on land
                    player.velY = -player.jetpackPower;
                    player.jetpackTime = currentTime;
                }
            }

            // ðŸŽ¯ Update player position
            player.x += player.velX;
            player.y += player.velY;

            // ðŸ§± Left boundary check - 200px from spawn
            const leftBoundaryX = 240 - 200; // 40px left of spawn
            if (player.x < leftBoundaryX) {
                player.x = leftBoundaryX;
                player.velX = 0; // Stop horizontal movement
            }

            // ðŸ’€ Death barrier check
            if (player.y > game.deathBarrier) {
                game.lives--;
                if (game.lives <= 0) {
                    game.gameOver = true;
                    saveSessionStats(); // Save stats when game ends
                } else {
                    // Respawn player at last checkpoint or starting position
                    if (game.activeCheckpoint) {
                        player.x = game.activeCheckpoint.platform.x + (game.activeCheckpoint.platform.width / 2) - (player.collisionWidth / 2);
                        player.y = game.activeCheckpoint.platform.y - player.collisionHeight - player.collisionOffsetY;
                    } else {
                        // Respawn at starting position
                        player.x = 240;
                        player.y = 1200;
                    }
                    player.velX = 0;
                    player.velY = 0;
                    player.onGround = false;
                    player.onMovingPlatform = false;
                    player.health = player.maxHealth; // Reset health to full on respawn
                    player.armor = 0; // Reset armor to 0 on respawn
                }
            }
            
            // ðŸ§± Invisible wall check - 300px past goal
            const invisibleWallX = game.goalX + 300;
            if (player.x > invisibleWallX) {
                player.x = invisibleWallX;
                player.velX = 0; // Stop horizontal movement
            }
            
            // Update invulnerability
            if (player.damageInvulnerable) {
                if (Date.now() - player.invulnerableTime > player.invulnerableDuration) {
                    player.damageInvulnerable = false;
                }
            }
            
            // Combined invulnerability check
            player.invulnerable = player.damageInvulnerable || player.isGiant;
            
            // Update giant mode
            if (player.isGiant) {
                if (Date.now() - player.giantTime > player.giantDuration) {
                    player.isGiant = false;
                    // Only reset invulnerability if it was set by the mushroom (not by damage)
                    if (Date.now() - player.invulnerableTime > player.invulnerableDuration) {
                        player.invulnerable = false;
                    }
                    // Reset player size to normal (new otter size)
                    player.width = 64;
                    player.height = 93;
                    player.collisionWidth = 64;
                    player.collisionHeight = 93;
                    // Adjust player position back down to keep feet on the same platform
                    player.y += 40; // Move player down to compensate for smaller collision box
                    console.log('Mushroom power-up expired! Back to normal size and vulnerable.');
                }
            }
            

            
            // No cooldown system - removed for simplicity
            

            
            // ========================================
            // ðŸ”« LASER PHYSICS & COOLDOWN
            // ========================================
            // Update laser cooldown
            if (player.laserCooldown > 0) {
                player.laserCooldown -= 16; // 60 FPS = 16ms per frame
            }
            
            // Update fireball cooldown
            if (player.fireballCooldown > 0) {
                player.fireballCooldown -= 16; // 60 FPS = 16ms per frame
            }
            

            
            // Update player lasers
            playerLasers.forEach((laser, index) => {
                // Move laser
                laser.x += laser.velX;
                laser.y += laser.velY;
                
                // Remove lasers that go off screen
                if (laser.x < game.camera.x - 100 || laser.x > game.camera.x + game.canvasWidth + 100) {
                    playerLasers.splice(index, 1);
                    return;
                }
                
                // Check collision with enemies
                enemies.forEach((enemy, enemyIndex) => {
                    // Use enemy collision box for more accurate detection
                    const enemyCollisionBox = {
                        x: enemy.x + (enemy.collisionOffsetX || 0),
                        y: enemy.y + (enemy.collisionOffsetY || 0),
                        width: enemy.collisionWidth || enemy.width,
                        height: enemy.collisionHeight || enemy.height
                    };
                    
                    // Use enhanced laser collision detection (removed verbose logging for performance)
                    if (checkLaserCollision(laser, enemyCollisionBox)) {
                        // Laser hit enemy - use enhanced damage for charged lasers
                        let damage = laser.damage || 1;
                        
                        // For charged lasers, use the stored damage value
                        if (laser.chargeLevel > 0) {
                            damage = laser.damage; // Use the enhanced damage from charge level
                            console.log('ðŸ”« Charged laser hit! Charge level:', laser.chargeLevel, 'Damage:', damage);
                        } else {
                            // Regular laser - adjust damage based on enemy type
                        if (enemy.type === 'basic' || enemy.type === 'crab') {
                                damage = 1;
                        } else if (enemy.type === 'charger' || enemy.type === 'eagle' || enemy.type === 'shooter' || enemy.type === 'gator') {
                                damage = 2;
                        } else if (enemy.type === 'shark') {
                                damage = 1;
                        } else {
                                damage = 1;
                            }
                        }
                        
                        // Wallet damage bonuses removed
                        let finalDamage = damage;
                        // Wallet system disabled - no damage multipliers
                        
                        // Removed verbose logging for performance
                        enemy.health -= finalDamage;
                        
                        if (enemy.health <= 0) {
                            // Enemy defeated
                            enemies.splice(enemyIndex, 1);
                            
                            // Track specific enemy types
                            switch (enemy.type) {
                                case 'crab':
                            game.sessionStats.crabsDefeated++;
                            game.sessionStats.currentSessionCrabs++;
                                    break;
                                case 'eagle':
                                    game.sessionStats.eaglesDefeated++;
                                    break;
                                case 'gator':
                                    game.sessionStats.gatorsDefeated++;
                                    break;
                                case 'shark':
                                    game.sessionStats.sharksDefeated++;
                                    break;
                                default:
                                    game.sessionStats.crabsDefeated++;
                                    game.sessionStats.currentSessionCrabs++;
                            }
                            
                            // Add score with XP and multiplier
                            addScoreWithXP(200, `${enemy.type} Defeat`);
                            
                            // Update highest crabs if current session is higher
                            if (game.sessionStats.currentSessionCrabs > game.sessionStats.highestCrabs) {
                                game.sessionStats.highestCrabs = game.sessionStats.currentSessionCrabs;
                            }
                            
                            
                            // Check for enemy-related achievements
                            if (game.sessionStats.crabsDefeated === 1) {
                                unlockAchievement('first_enemy');
                            }
                            
                            // Check all achievements after enemy defeat
                            checkAllAchievements();
                            
                            // Enhanced screen shake for charged lasers
                            addScreenShake(2 + (laser.chargeLevel || 0));
                            // Removed console.log for performance
                        }
                        
                        // Remove laser if it's not a piercing laser or if it's a regular laser
                        if (!laser.pierce || laser.chargeLevel === 0) {
                            playerLasers.splice(index, 1);
                            return;
                        }
                    }
                });
            
            // Check collision with breakable tiles
            breakables.forEach((tile, tileIndex) => {
                    if (!tile.broken && checkLaserCollision(laser, tile)) {
                        console.log('ðŸ”« Laser hit breakable tile! Health before:', tile.health);
                        tile.health--;
                        addScreenShake(3);
                        addFreezeFrame(30);
                        
                        // Create impact particles
                        game.particles.push(...createParticle(tile.x + tile.width/2, tile.y + tile.height/2, 'stomp'));
                        
                        if (tile.health <= 0) {
                            tile.broken = true;
                            console.log('ðŸ”« Breakable tile destroyed by laser!');
                            
                            // Give reward based on tile type
                            if (tile.reward) {
                                switch (tile.reward) {
                                    case 'mushroom':
                                        // Create mushroom at tile location
                                        mushrooms.push({
                                            x: tile.x + tile.width/2,
                                            y: tile.y + tile.height,
                                            collected: false,
                                            type: 'mushroom',
                                            value: 1000 // 1000 points for mushroom
                                        });
                                        console.log('ðŸ„ Mushroom reward from laser-destroyed tile!');
                                        break;
                                    case 'health':
                                        // Create health pickup at tile location
                                        health.push({
                                            x: tile.x + tile.width/2,
                                            y: tile.y + tile.height,
                                            collected: false,
                                            type: 'health'
                                        });
                                        console.log('â¤ï¸ Health reward from laser-destroyed tile!');
                                        break;

                                }
                                
                                // Create reward particles
                                game.particles.push(...createParticle(tile.x + tile.width/2, tile.y + tile.height, 'reward'));
                            }
                            
                            // Check if this reveals a secret room
                            secretRooms.forEach(room => {
                                if (!room.discovered && 
                                    Math.abs(tile.x - room.x) < 300 && 
                                    Math.abs(tile.y - room.y) < 200) {
                                    room.discovered = true;
                                    console.log('ðŸ” Secret room discovered by laser!');
                                }
                            });
                        }
                        
                        // Remove laser
                        playerLasers.splice(index, 1);
                        return;
                    }
                });
                
                // Check collision with treasures (but ignore golden chests)
                treasures.forEach((treasure, treasureIndex) => {
                    if (checkLaserCollision(laser, treasure)) {
                        console.log('ðŸ”« Laser collision detected with treasure:', {
                            treasureType: treasure.type,
                            isGoldenChest: treasure.isGoldenChest,
                            collected: treasure.collected,
                            x: treasure.x,
                            y: treasure.y
                        });
                    }
                    
                    if (!treasure.collected && !treasure.isGoldenChest && checkLaserCollision(laser, treasure)) {
                        // Regular treasure can be destroyed by laser
                            treasure.collected = true;
                        game.score += treasure.value;
                            game.sessionStats.treasuresCollected++;
                            game.sessionStats.treasuresFound++;
                        game.sessionStats.totalScore += treasure.value;
                            game.sessionStats.currentSessionTreasures++;
                        game.sessionStats.currentSessionScore += treasure.value;
                            
                            // Update highest treasures if current session is higher
                            if (game.sessionStats.currentSessionTreasures > game.sessionStats.highestTreasures) {
                                game.sessionStats.highestTreasures = game.sessionStats.currentSessionTreasures;
                            }
                        
                            
                            if (treasure.type === 'rareTreasure') {
                                game.coins += 25; // Extra bonus coins for rare treasures
                                game.lives = Math.min(game.lives + 1, game.maxLives); // Bonus life for rare treasure
                            } else {
                                game.coins += 10; // Regular bonus coins for normal treasures
                        }
                        
                        addScreenShake(3);
                        console.log('ðŸ”« Regular treasure destroyed by laser!');
                        
                        // Remove laser
                        playerLasers.splice(index, 1);
                        return;
                    } else if (!treasure.collected && treasure.isGoldenChest && checkLaserCollision(laser, treasure)) {
                        // Golden chest is immune to laser damage - just remove the laser
                        console.log('ðŸ”« Golden chest is immune to laser damage! Use F key with a key to open.');
                        console.log('ðŸ›¡ï¸ Golden chest has laser immunity - cannot be destroyed by shooting!');
                        console.log('ðŸ›¡ï¸ Golden chest protection activated - laser removed, chest unharmed!');
                        addScreenShake(1);
                        
                        // Create golden sparkle effect to show immunity
                        game.particles.push(...createParticle(treasure.x + treasure.width/2, treasure.y + treasure.height/2, 'golden'));
                            
                            // Remove laser
                            playerLasers.splice(index, 1);
                            return;
                        }
                });
                
                // Check collision with boss
                if (game.currentBoss && checkCollision(laser, game.currentBoss)) {
                    // Boss takes MASSIVE damage from charged lasers
                    let bossDamage = 1; // Default damage for regular lasers
                    
                    // Use enhanced charged laser damage with boss multiplier
                    if (laser.chargeLevel > 0) {
                        // Boss damage multiplier: charged lasers do 2x damage to bosses
                        bossDamage = laser.damage * 2; // Double the charged laser damage against bosses
                        console.log('ðŸ”« CHARGED LASER HIT BOSS! Charge level:', laser.chargeLevel, 'Base damage:', laser.damage, 'Boss damage:', bossDamage);
                    } else {
                        console.log('ðŸ”« Regular laser hit boss! Damage:', bossDamage);
                    }
                    
                    game.currentBoss.health -= bossDamage;
                    addScreenShake(3 + (laser.chargeLevel || 0));
                    console.log('ðŸ”« Boss hit by laser! Damage:', bossDamage, 'Health remaining:', game.currentBoss.health);
                    
                    if (game.currentBoss.health <= 0) {
                        // Boss defeated
                        game.currentBoss = null;
                        // Don't set bossActive to false yet - keep lava until level changes
                        // game.bossActive = false; // REMOVED - keep lava active
                        game.score += 1000;
                        game.sessionStats.bossesDefeated++;
                        game.sessionStats.currentSessionBosses++;
                        game.sessionStats.totalScore += 1000;
                        game.sessionStats.currentSessionScore += 1000;
                        
                        addScreenShake(5);
                        console.log('ðŸ”« Boss defeated by laser! Lava remains until level change.');
                    }
                    
                    // Remove laser
                    playerLasers.splice(index, 1);
                    return;
                }
                
                // REMOVED DUPLICATE TREASURE COLLISION - Golden chests are now properly protected!
                // The first treasure collision detection above handles golden chest immunity correctly.
            });
            
            // ðŸ”¥ Update player fireballs
            playerFireballs.forEach((fireball, index) => {
                // Update fireball lifetime
                fireball.lifetime = Date.now() - fireball.creationTime;
                
                // Remove fireballs that have exceeded their lifetime (3 seconds)
                if (fireball.lifetime >= fireball.maxLifetime) {
                    console.log('ðŸ”¥ Fireball expired after 3 seconds');
                    playerFireballs.splice(index, 1);
                    return;
                }
                
                // Move fireball
                fireball.x += fireball.velX;
                fireball.y += fireball.velY;
                
                                 // Remove fireballs that go off screen
                 if (fireball.x < game.camera.x - 100 || fireball.x > game.camera.x + game.canvasWidth + 100 ||
                     fireball.y < game.camera.y - 100 || fireball.y > game.camera.y + game.canvasHeight + 100) {
                     playerFireballs.splice(index, 1);
                     return;
                 }
                 
                 // Check if fireball hit water/lava - fireballs die in water
                 if (fireball.y + fireball.height > game.waterLevel) {
                     // Check if this is a boss level (boss levels have lava instead of water)
                     const isBossLevel = game.currentBoss !== null;
                     
                     if (isBossLevel) {
                         console.log('ðŸ”¥ Fireball hit lava - extinguishing!');
                         
                         // Create lava splash effect (reduced for performance)
                         for (let i = 0; i < 4; i++) { // Reduced from 8 to 4
                             const splashParticle = {
                                 x: fireball.x + fireball.width / 2,
                                 y: game.waterLevel,
                                 velX: (Math.random() - 0.5) * 4,
                                 velY: -Math.random() * 6 - 2,
                                 life: 60,
                                 maxLife: 60,
                                 size: Math.random() * 3 + 2,
                                 color: '#FF4500', // Orange-red lava splash
                                 type: 'lava_splash'
                             };
                             game.particles.push(splashParticle);
                         }
                         
                         // Create lava steam effect (reduced for performance)
                         for (let i = 0; i < 3; i++) { // Reduced from 5 to 3
                             const steamParticle = {
                                 x: fireball.x + fireball.width / 2,
                                 y: game.waterLevel,
                                 velX: (Math.random() - 0.5) * 2,
                                 velY: -Math.random() * 3 - 1,
                                 life: 90,
                                 maxLife: 90,
                                 size: Math.random() * 4 + 3,
                                 color: 'rgba(255, 165, 0, 0.8)', // Orange steam
                                 type: 'lava_steam'
                             };
                             game.particles.push(steamParticle);
                         }
                     } else {
                         console.log('ðŸ”¥ Fireball hit water - extinguishing!');
                         
                         // Create water splash effect (reduced for performance)
                         for (let i = 0; i < 4; i++) { // Reduced from 8 to 4
                             const splashParticle = {
                                 x: fireball.x + fireball.width / 2,
                                 y: game.waterLevel,
                                 velX: (Math.random() - 0.5) * 4,
                                 velY: -Math.random() * 6 - 2,
                                 life: 60,
                                 maxLife: 60,
                                 size: Math.random() * 3 + 2,
                                 color: '#87CEEB', // Light blue water splash
                                 type: 'splash'
                             };
                             game.particles.push(splashParticle);
                         }
                         
                         // Create steam effect (reduced for performance)
                         for (let i = 0; i < 3; i++) { // Reduced from 5 to 3
                             const steamParticle = {
                                 x: fireball.x + fireball.width / 2,
                                 y: game.waterLevel,
                                 velX: (Math.random() - 0.5) * 2,
                                 velY: -Math.random() * 3 - 1,
                                 life: 90,
                                 maxLife: 90,
                                 size: Math.random() * 4 + 3,
                                 color: 'rgba(255, 255, 255, 0.7)', // White steam
                                 type: 'steam'
                             };
                             game.particles.push(steamParticle);
                         }
                     }
                     
                     playerFireballs.splice(index, 1);
                     addScreenShake(1);
                     return;
                 }
                
                // Check collision with platforms for bouncing (unlimited bounces for 3 seconds)
                platforms.forEach(platform => {
                    if (platform.isVisible !== false) {
                        // Add a longer delay to prevent premature bounces (300ms after creation)
                        if (fireball.lifetime < 300) {
                            return; // Skip collision detection for first 300ms
                        }
                        
                        // Skip water surface platforms to prevent glitching
                        if (platform.y >= game.waterLevel - 10 && platform.y <= game.waterLevel + 10) {
                            return; // Skip water surface platforms
                        }
                        
                        // Skip the starting platform to prevent initial glitches
                        if (platform.x === 0 && platform.y === 1320) {
                            return; // Skip starting platform
                        }
                        
                        // Check if player is inside this platform's collision box
                        const playerInPlatform = (
                            player.x < platform.x + platform.width &&
                            player.x + player.width > platform.x &&
                            player.y < platform.y + platform.height &&
                            player.y + player.height > platform.y
                        );
                        
                        // If player is inside this platform, skip collision for this platform
                        if (playerInPlatform) {
                            console.log('ðŸ”¥ Player inside platform - fireball passes through');
                            return;
                        }
                        
                        // Use more precise collision detection
                        const fireballBounds = {
                            x: fireball.x,
                            y: fireball.y,
                            width: fireball.width,
                            height: fireball.height
                        };
                        
                        const platformBounds = {
                            x: platform.x,
                            y: platform.y,
                            width: platform.width,
                            height: platform.height
                        };
                        
                        if (checkCollision(fireballBounds, platformBounds)) {
                            // Bounce off platform (unlimited bounces within 3 second lifetime)
                            
                            // Determine bounce direction with more precise detection
                            const fireballCenterX = fireball.x + fireball.width / 2;
                            const fireballCenterY = fireball.y + fireball.height / 2;
                            const platformCenterX = platform.x + platform.width / 2;
                            const platformCenterY = platform.y + platform.height / 2;
                            
                            // Calculate which side of the platform was hit
                            const dx = fireballCenterX - platformCenterX;
                            const dy = fireballCenterY - platformCenterY;
                            
                            // More precise bounce detection
                            const horizontalOverlap = Math.min(fireball.x + fireball.width, platform.x + platform.width) - Math.max(fireball.x, platform.x);
                            const verticalOverlap = Math.min(fireball.y + fireball.height, platform.y + platform.height) - Math.max(fireball.y, platform.y);
                            
                            if (horizontalOverlap > 0 && verticalOverlap > 0) {
                                // Determine which side had the smaller overlap (the side that was hit)
                                if (horizontalOverlap < verticalOverlap) {
                                    // Hit left or right side
                                    fireball.velX = -fireball.velX;
                                    // Move fireball slightly away from platform to prevent sticking
                                    if (dx > 0) {
                                        fireball.x = platform.x + platform.width + 2;
                                    } else {
                                        fireball.x = platform.x - fireball.width - 2;
                                    }
                                } else {
                                    // Hit top or bottom side
                                    fireball.velY = -fireball.velY;
                                    // Move fireball slightly away from platform to prevent sticking
                                    if (dy > 0) {
                                        fireball.y = platform.y + platform.height + 2;
                                    } else {
                                        fireball.y = platform.y - fireball.height - 2;
                                    }
                                }
                                
                                // Add minimal randomness to bounce
                                fireball.velX += (Math.random() - 0.5) * 0.5; // Very minimal randomness
                                fireball.velY += (Math.random() - 0.5) * 0.5; // Very minimal randomness
                                
                                // Normalize velocity to maintain speed
                                const speed = Math.sqrt(fireball.velX * fireball.velX + fireball.velY * fireball.velY);
                                fireball.velX = (fireball.velX / speed) * player.fireballSpeed;
                                fireball.velY = (fireball.velY / speed) * player.fireballSpeed;
                                
                                addScreenShake(1);
                                console.log('ðŸ”¥ Fireball bounced off platform! Lifetime remaining:', (fireball.maxLifetime - fireball.lifetime).toFixed(0), 'ms');
                            }
                        }
                    }
                });
                
                // Check collision with enemies
                enemies.forEach((enemy, enemyIndex) => {
                    const enemyCollisionBox = {
                        x: enemy.x + (enemy.collisionOffsetX || 0),
                        y: enemy.y + (enemy.collisionOffsetY || 0),
                        width: enemy.collisionWidth || enemy.width,
                        height: enemy.collisionHeight || enemy.height
                    };
                    
                    // Enhanced collision detection with larger hit area for fireballs
                    const fireballHitArea = {
                        x: fireball.x - 5,
                        y: fireball.y - 5,
                        width: fireball.width + 10,
                        height: fireball.height + 10
                    };
                    
                    if (checkCollision(fireballHitArea, enemyCollisionBox)) {
                        console.log('ðŸ”¥ FIREBALL COLLISION DETECTED!');
                        console.log('ðŸ”¥ Enemy type:', enemy.type, 'Health before:', enemy.health);
                        console.log('ðŸ”¥ Fireball damage:', fireball.damage);
                        
                        // Fireball hit enemy
                        enemy.health -= fireball.damage;
                        game.sessionStats.fireballsHit++;
                        console.log('ðŸ”¥ Fireball hit enemy! Damage:', fireball.damage, 'Health remaining:', enemy.health);
                        
                        if (enemy.health <= 0) {
                            // Enemy defeated
                            console.log('ðŸ”¥ ENEMY KILLED BY FIREBALL! Type:', enemy.type);
                            enemies.splice(enemyIndex, 1);
                            
                            // Create explosion effect at enemy position
                            game.particles.push(...createParticle(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 'fireball'));
                            
                            // Track specific enemy types
                            switch (enemy.type) {
                                case 'crab':
                                    game.sessionStats.crabsDefeated++;
                                    game.sessionStats.currentSessionCrabs++;
                                    break;
                                case 'eagle':
                                    game.sessionStats.eaglesDefeated++;
                                    break;
                                case 'gator':
                                    game.sessionStats.gatorsDefeated++;
                                    break;
                                case 'shark':
                                    game.sessionStats.sharksDefeated++;
                                    break;
                                default:
                                    game.sessionStats.crabsDefeated++;
                                    game.sessionStats.currentSessionCrabs++;
                            }
                            
                            // Add score with XP and multiplier
                            addScoreWithXP(200, `${enemy.type} Defeat`);
                            
                            // Update highest crabs if current session is higher
                            if (game.sessionStats.currentSessionCrabs > game.sessionStats.highestCrabs) {
                                game.sessionStats.highestCrabs = game.sessionStats.currentSessionCrabs;
                            }
                            
                            
                            // Check for enemy-related achievements
                            if (game.sessionStats.crabsDefeated === 1) {
                                unlockAchievement('first_enemy');
                            }
                        }
                        
                        // Remove fireball after hitting enemy
                        playerFireballs.splice(index, 1);
                        addScreenShake(2);
                        return;
                    }
                });
                
                // Check collision with boss
                if (game.currentBoss && checkCollision(fireball, game.currentBoss)) {
                    game.currentBoss.health -= fireball.damage * 2; // Double damage to boss
                    addScreenShake(3);
                    console.log('ðŸ”¥ Fireball hit boss! Damage:', fireball.damage * 2, 'Health remaining:', game.currentBoss.health);
                    
                    if (game.currentBoss.health <= 0) {
                        // Boss defeated
                        game.currentBoss = null;
                        game.score += 1000;
                        game.sessionStats.bossesDefeated++;
                        game.sessionStats.currentSessionBosses++;
                        game.sessionStats.totalScore += 1000;
                        game.sessionStats.currentSessionScore += 1000;
                        
                        addScreenShake(5);
                        console.log('ðŸ”¥ Boss defeated by fireball!');
                    }
                    
                    // Remove fireball after hitting boss
                    playerFireballs.splice(index, 1);
                    return;
                }
            });
            
            // Safety check: prevent falling through platforms after size changes
            if (player.isGiant && player.lastPlatform && player.velY >= 0 && !player.onGround && !game.keys['downJumpPressed']) {
                const collisionX = player.x + player.collisionOffsetX;
                const collisionY = player.y + player.collisionOffsetY;
                
                // Check if player is over their last platform
                if (collisionX + player.collisionWidth > player.lastPlatform.x && 
                    collisionX < player.lastPlatform.x + player.lastPlatform.width &&
                    collisionY + player.collisionHeight >= player.lastPlatform.y - 16 &&
                    collisionY + player.collisionHeight <= player.lastPlatform.y + 16) {
                    
                    // Snap player back to platform
                    player.y = player.lastPlatform.y - player.collisionHeight - player.collisionOffsetY;
                    player.velY = 0;
                    player.onGround = true;
                    player.canDoubleJump = true; // Reset double jump when landing
                }
            }
            
            // Additional safety check for giant mode: if player is falling and not on ground, try to find platform
            if (player.isGiant && player.velY > 0 && !player.onGround && !game.keys['downJumpPressed']) {
                let foundPlatform = false;
                for (const platform of platforms) {
                    if (platform.isVisible !== false) {
                        const collisionX = player.x + player.collisionOffsetX;
                        const collisionY = player.y + player.collisionOffsetY;
                        
                        // Check if player is over this platform
                        // Allow landing on underwater platforms even when in water if platform is above water level
                        const platformAboveWater = platform.y < game.waterLevel - 50;
                        const canLand = !player.inWater || platformAboveWater || platform.type === 'underwater';
                        
                        if (collisionX + player.collisionWidth > platform.x && 
                            collisionX < platform.x + platform.width &&
                            collisionY + player.collisionHeight >= platform.y - 10 &&
                            collisionY + player.collisionHeight <= platform.y + 10 &&
                            canLand) {
                            
                            // Snap player to this platform
                            player.y = platform.y - player.collisionHeight - player.collisionOffsetY;
                            player.velY = 0;
                            player.onGround = true;
                            player.canDoubleJump = true;
                            player.lastPlatform = platform;
                            
                            // ðŸš€ Set moving platform state if this is a moving platform
                            if (platform.type === 'linear') {
                                player.onMovingPlatform = true;
                                player.platformStartTime = Date.now();
                            } else {
                                player.onMovingPlatform = false;
                            }
                            
                            foundPlatform = true;
                            break;
                        }
                    }
                }
            }
            
            // Update moving platforms
            platforms.forEach(platform => {
                if (platform.type === 'linear') {
                    // Store previous position for delta calculation
                    const previousX = platform.x;
                    const previousY = platform.y;
                    
                    // Linear moving platform - much slower movement
                    platform.moveProgress += platform.moveSpeed * 0.005; // Reduced from 0.01 to 0.005
                    if (platform.moveProgress > 1) {
                        platform.moveProgress = 0;
                    }
                    
                    const progress = Math.sin(platform.moveProgress * Math.PI * 2);
                    if (platform.moveDirection === 'horizontal') {
                        platform.x = platform.startX + progress * platform.moveDistance;
                    } else {
                        platform.y = platform.startY + progress * platform.moveDistance;
                    }
                    
                    // Store movement delta for player movement
                    platform.deltaX = platform.x - previousX;
                    platform.deltaY = platform.y - previousY;
                } else if (platform.type === 'disappearing') {
                    // Disappearing platform
                    const timeSinceToggle = Date.now() - platform.lastToggle;
                    if (platform.isVisible && timeSinceToggle > platform.disappearTime) {
                        platform.isVisible = false;
                        platform.lastToggle = Date.now();
                    } else if (!platform.isVisible && timeSinceToggle > platform.reappearTime) {
                        platform.isVisible = true;
                        platform.lastToggle = Date.now();
                    }
                } else if (platform.type === 'cloud') {
                    // Cloud platform disappearing behavior
                    if (platform.isDisappearing && platform.cloudStartTime) {
                        const timeOnCloud = Date.now() - platform.cloudStartTime;
                        if (timeOnCloud >= platform.cloudDisappearTime) {
                            platform.isVisible = false;
                            platform.isDisappearing = false;
                            platform.cloudStartTime = null;
                            platform.respawnStartTime = Date.now(); // Start respawn timer
                        }
                    }
                    
                    // Cloud respawn behavior
                    if (!platform.isVisible && platform.respawnStartTime) {
                        const timeSinceDisappear = Date.now() - platform.respawnStartTime;
                        if (timeSinceDisappear >= 5000) { // 5 seconds to respawn
                            platform.isVisible = true;
                            platform.respawnStartTime = null;
                        }
                    }
                }
            });
            
            // Move player with moving platform
            if (player.onMovingPlatform && player.lastPlatform && player.lastPlatform.type === 'linear') {
                const platform = player.lastPlatform;
                
                // Verify player is still on the platform
                const collisionX = player.x + player.collisionOffsetX;
                const collisionY = player.y + player.collisionOffsetY;
                
                if (collisionX + player.collisionWidth > platform.x && collisionX < platform.x + platform.width &&
                    collisionY + player.collisionHeight >= platform.y - 8 && collisionY + player.collisionHeight <= platform.y + 8) {
                    
                    // Move player with platform using stored delta
                    if (platform.deltaX !== undefined && platform.deltaY !== undefined) {
                        player.x += platform.deltaX;
                        player.y += platform.deltaY;
                    }
                } else {
                    // Player is no longer on the platform
                    player.onMovingPlatform = false;
                }
                
                // Safety check: force player off platform if stuck for too long (5 seconds)
                if (player.onMovingPlatform && Date.now() - player.platformStartTime > 5000) {
                    player.onMovingPlatform = false;
                    player.velY = -5; // Give player a small upward boost
                }
            }
            
            // ========================================
            // ðŸ—ï¸ ENHANCED PLATFORM COLLISION & DOUBLE JUMP RESET
            // ========================================
            const tolerance = 5; // ðŸŽ¯ Define collision tolerance
            let wasOnGround = player.onGround; // ðŸ“ Remember previous ground state
            player.onGround = false;

            // Optimize: Only check platforms near the player (spatial culling)
            const playerCollisionX = player.x + player.collisionOffsetX;
            const playerCollisionY = player.y + player.collisionOffsetY;
            const checkRadius = 300; // Only check platforms within 300px
            
            for (const platform of platforms) {
                // Quick distance check to skip far platforms
                const platformCenterX = platform.x + platform.width / 2;
                const platformCenterY = platform.y + platform.height / 2;
                const distanceX = Math.abs(platformCenterX - playerCollisionX);
                const distanceY = Math.abs(platformCenterY - playerCollisionY);
                
                // Skip platforms that are too far away
                if (distanceX > checkRadius || distanceY > checkRadius) {
                    continue;
                }
                
                if (platform.isVisible !== false) { // Skip invisible disappearing platforms and clouds
                    const collisionX = player.x + player.collisionOffsetX;
                    const collisionY = player.y + player.collisionOffsetY;
                    
                    const playerLeft = collisionX;
                    const playerRight = collisionX + player.collisionWidth;
                    const playerTop = collisionY;
                    const playerBottom = collisionY + player.collisionHeight;
                    
                    const platformLeft = platform.x;
                    const platformRight = platform.x + platform.width;
                    const platformTop = platform.y;
                    const platformBottom = platform.y + platform.height;
                    
                    // âœ… ENHANCED collision detection - more forgiving for moving players
                    const horizontalOverlap = playerRight > platformLeft + 2 && playerLeft < platformRight - 2;
                    const verticalCollision = playerBottom >= platformTop - tolerance && 
                                             playerBottom <= platformTop + tolerance * 2;
                    const isAbovePlatform = collisionY < platformBottom - 5;
                    // Only consider falling if velocity is positive (actually moving down)
                    // This prevents the player from being stuck on ground immediately after jumping
                    const isFalling = player.velY > 0;
                    
                    // ðŸ”½ DOWN JUMP CHECK - Skip collision if player just dropped through this platform
                    const justDroppedThrough = game.keys['downJumpPressed'] && player.lastPlatform === platform;
                    
                    // Reset down jump flag if player successfully dropped through a platform
                    if (game.keys['downJumpPressed'] && player.velY > 0 && player.y > (player.lastPlatform ? player.lastPlatform.y + 50 : 0)) {
                        game.keys['downJumpPressed'] = false;
                    }
                    
                    // ðŸŒŠ SWIMMING CHECK - Skip collision if player is swimming up in water
                    // BUT allow landing on platforms above water level even when in water
                    const isSwimmingUp = player.inWater && player.swimming && player.velY < 0;
                    const platformAboveWater = platform.y < game.waterLevel - 50; // Platform is clearly above water
                    const canLandOnPlatform = !isSwimmingUp || platformAboveWater; // Allow landing if platform is above water
                    
                    if (horizontalOverlap && verticalCollision && isAbovePlatform && isFalling && !justDroppedThrough && canLandOnPlatform) {
                        // ðŸŽ¯ Player landed on platform - snap to exact position
                        player.y = platform.y - player.collisionHeight - player.collisionOffsetY;
                        player.velY = 0;
                        player.onGround = true;
                        
                        // ðŸ“ Track last platform
                        player.lastPlatform = platform;
                        
                        // ðŸš€ Set moving platform state if this is a moving platform
                        if (platform.type === 'linear') {
                            player.onMovingPlatform = true;
                            player.platformStartTime = Date.now();
                        } else {
                            player.onMovingPlatform = false;
                        }
                        
                        // â˜ï¸ Start cloud disappearing timer when player steps on cloud
                        if (platform.type === 'cloud' && !platform.isDisappearing) {
                            platform.isDisappearing = true;
                            platform.cloudStartTime = Date.now();
                        }
                        
                        break; // Exit loop once we find a platform we're standing on
                    }
                }
            }

            // ðŸ§± BARRIER COLLISION DETECTION - Prevent going too far left
            // Optimize: Only check barriers near the player
            const barrierCheckRadius = 200;
            
            for (const platform of platforms) {
                if (platform.type === 'barrier') {
                    // Quick distance check
                    const platformCenterX = platform.x + platform.width / 2;
                    const platformCenterY = platform.y + platform.height / 2;
                    const distanceX = Math.abs(platformCenterX - playerCollisionX);
                    const distanceY = Math.abs(platformCenterY - playerCollisionY);
                    
                    if (distanceX > barrierCheckRadius || distanceY > barrierCheckRadius) {
                        continue;
                    }
                    
                    const collisionX = player.x + player.collisionOffsetX;
                    const collisionY = player.y + player.collisionOffsetY;
                    
                    const playerLeft = collisionX;
                    const playerRight = collisionX + player.collisionWidth;
                    const playerTop = collisionY;
                    const playerBottom = collisionY + player.collisionHeight;
                    
                    const barrierLeft = platform.x;
                    const barrierRight = platform.x + platform.width;
                    const barrierTop = platform.y;
                    const barrierBottom = platform.y + platform.height;
                    
                    // Check if player is colliding with barrier
                    if (playerRight > barrierLeft && playerLeft < barrierRight &&
                        playerBottom > barrierTop && playerTop < barrierBottom) {
                        
                        // Push player back to the right of the barrier
                        player.x = barrierRight - player.collisionOffsetX;
                        player.velX = Math.max(0, player.velX); // Stop leftward movement
                    }
                }
            }
            
            // ðŸ”‹ SEPARATE DOUBLE JUMP RECHARGE LOGIC - More reliable
            // This runs AFTER all collision detection is complete
            // ðŸ”‹ DOUBLE JUMP RECHARGE LOGIC
            if (player.onGround) {
                // Just landed (wasn't on ground before, now is)
                if (!wasOnGround && !player.canDoubleJump) {
                    player.canDoubleJump = true;
                    console.log('ðŸ”‹ Double jump recharged - just landed!');
                }
                // Still on ground and missing double jump (safety net)
                else if (!player.canDoubleJump) {
                    player.canDoubleJump = true;
                    console.log('ðŸ”‹ Double jump recharged - safety recharge while on ground');
                }
            }
            
            // Move collectibles and enemies with their platforms
            // IMPORTANT: This must run BEFORE enemy AI to keep enemies fixed to moving platforms
            platforms.forEach(platform => {
                if (platform.type === 'linear' && platform.deltaX !== undefined && platform.deltaY !== undefined) {
                    // Move enemies on this platform - use wider tolerance to catch all enemies
                    enemies.forEach(enemy => {
                        // Check if enemy is on this platform (wider Y tolerance for moving platforms)
                        const isOnPlatform = enemy.x >= platform.x - 10 && enemy.x <= platform.x + platform.width + 10 &&
                            enemy.y >= platform.y - enemy.height - 20 && enemy.y <= platform.y + 20;
                        
                        if (isOnPlatform) {
                            // Move enemy with platform
                            enemy.x += platform.deltaX;
                            enemy.y += platform.deltaY;
                            // Store reference to platform for enemy AI
                            enemy.currentPlatform = platform;
                            // Keep enemy properly positioned on platform
                            enemy.y = platform.y - enemy.height;
                        } else if (enemy.currentPlatform === platform) {
                            // Enemy was on this platform but fell off - clear reference
                            enemy.currentPlatform = null;
                        }
                    });
                    
                    // Move collectibles on this platform
                    fish.forEach(fish => {
                        if (!fish.collected && fish.x >= platform.x && fish.x <= platform.x + platform.width &&
                            fish.y >= platform.y - 80 && fish.y <= platform.y + 20) {
                            fish.x += platform.deltaX;
                            fish.y += platform.deltaY;
                        }
                    });
                    
                    coins.forEach(coin => {
                        if (!coin.collected && coin.x >= platform.x && coin.x <= platform.x + platform.width &&
                            coin.y >= platform.y - 80 && coin.y <= platform.y + 20) {
                            coin.x += platform.deltaX;
                            coin.y += platform.deltaY;
                        }
                    });
                    
                    health.forEach(h => {
                        if (!h.collected && h.x >= platform.x && h.x <= platform.x + platform.width &&
                            h.y >= platform.y - 80 && h.y <= platform.y + 20) {
                            h.x += platform.deltaX;
                            h.y += platform.deltaY;
                        }
                    });
                    
                    treasures.forEach(treasure => {
                        if (!treasure.collected && treasure.x >= platform.x && treasure.x <= platform.x + platform.width &&
                            treasure.y >= platform.y - 80 && treasure.y <= platform.y + 20) {
                            treasure.x += platform.deltaX;
                            treasure.y += platform.deltaY;
                        }
                    });
                    
                    jetpacks.forEach(jetpack => {
                        if (!jetpack.collected && jetpack.x >= platform.x && jetpack.x <= platform.x + platform.width &&
                            jetpack.y >= platform.y - 80 && jetpack.y <= platform.y + 20) {
                            jetpack.x += platform.deltaX;
                            jetpack.y += platform.deltaY;
                        }
                    });
                    
                    mushrooms.forEach(mushroom => {
                        if (!mushroom.collected && mushroom.x >= platform.x && mushroom.x <= platform.x + platform.width &&
                            mushroom.y >= platform.y - 80 && mushroom.y <= platform.y + 20) {
                            mushroom.x += platform.deltaX;
                            mushroom.y += platform.deltaY;
                        }
                    });
                    
                    // Move laser powerups on this platform
                    if (laserPowerups) {
                        laserPowerups.forEach(laser => {
                            if (!laser.collected && laser.x >= platform.x && laser.x <= platform.x + platform.width &&
                                laser.y >= platform.y - 80 && laser.y <= platform.y + 20) {
                                laser.x += platform.deltaX;
                                laser.y += platform.deltaY;
                            }
                        });
                    }
                    
                    // Move keys on this platform
                    keys.forEach(key => {
                        if (!key.collected && key.x >= platform.x && key.x <= platform.x + platform.width &&
                            key.y >= platform.y - 80 && key.y <= platform.y + 20) {
                            key.x += platform.deltaX;
                            key.y += platform.deltaY;
                        }
                    });
                    
                    // Move breakable tiles (crates) on this platform
                    breakables.forEach(breakable => {
                        if (!breakable.broken && breakable.x >= platform.x && breakable.x <= platform.x + platform.width &&
                            breakable.y >= platform.y - 80 && breakable.y <= platform.y + 20) {
                            breakable.x += platform.deltaX;
                            breakable.y += platform.deltaY;
                        }
                    });
                }
            });
            
            // Player is not on ground - reset moving platform state
            if (!player.onGround && player.onMovingPlatform) {
                player.onMovingPlatform = false;
                console.log('Player left moving platform - no longer on ground');
            }
            
            // Screen boundaries - check if player has fallen off the bottom of the world
            // All platforms are now solid, so use all platforms for world bottom calculation
            const worldBottom = Math.max(...platforms.map(p => p.y)) + 500; // 500 pixels below the lowest platform - reasonable death boundary
            const worldTop = Math.min(...platforms.map(p => p.y)) - 1000; // 1000 pixels above the highest platform - reasonable death boundary
            if (player.y < worldTop) {
                console.log('Player went above world! Player Y:', player.y, 'World top:', worldTop);
                console.log('Player lives before death:', game.lives);
                game.lives--;
                if (game.lives <= 0) {
                    game.gameOver = true;
                } else {
                    // Reset player position to last platform they were on
                    player.velX = 0;
                    player.velY = 0;
                    player.canDoubleJump = true;
                    player.onGround = true; // Ensure they start on ground
                    
                    if (game.activeCheckpoint) {
                        // Respawn at the last activated checkpoint
                        player.x = game.activeCheckpoint.platform.x + (game.activeCheckpoint.platform.width / 2) - (player.collisionWidth / 2);
                        player.y = game.activeCheckpoint.platform.y - player.collisionHeight - player.collisionOffsetY;
                        console.log('Respawning at checkpoint');
                    } else {
                        // Simple respawn - just use the first platform
                        console.log('Simple respawn to first platform');
                        
                        // Reset checkpoints when player dies
                        game.activeCheckpoint = null;
                        if (game.checkpointProgress[game.level]) {
                            delete game.checkpointProgress[game.level];
                        }
                        console.log('Checkpoints reset due to death');
                        
                        if (platforms.length > 0) {
                            const firstPlatform = platforms[0];
                            player.x = firstPlatform.x + 50; // Simple positioning
                            player.y = firstPlatform.y - player.collisionHeight - 10;
                            console.log('Respawning at first platform:', firstPlatform.x, firstPlatform.y);
                        } else {
                            // Emergency fallback
                            player.x = 240;
                            player.y = 1170;
                            console.log('Emergency fallback respawn');
                        }
                    }
                    
                    // Simple safety check
                    if (platforms.length > 0) {
                        const firstPlatform = platforms[0];
                        // Ensure player is above the platform
                        if (player.y + player.collisionHeight > firstPlatform.y) {
                            player.y = firstPlatform.y - player.collisionHeight - 10;
                        }
                        console.log('Simple safety check completed');
                    }
                }
            }
            
            if (player.y > worldBottom) {
                console.log('Player fell off world! Player Y:', player.y, 'World bottom:', worldBottom);
                console.log('Player lives before death:', game.lives);
                game.lives--;
                if (game.lives <= 0) {
                    game.gameOver = true;
                } else {
                    // Reset player position to last platform they were on
                    player.velX = 0;
                    player.velY = 0;
                    player.canDoubleJump = true;
                    player.onGround = true; // Ensure they start on ground
                    
                    if (game.activeCheckpoint) {
                        // Respawn at the last activated checkpoint
                        player.x = game.activeCheckpoint.platform.x + (game.activeCheckpoint.platform.width / 2) - (player.collisionWidth / 2);
                        player.y = game.activeCheckpoint.platform.y - player.collisionHeight - player.collisionOffsetY;
                        console.log('Respawning at checkpoint');
                    } else {
                    // Simple respawn - just use the first platform
                    console.log('Simple respawn to first platform');
                    
                    // Reset checkpoints when player dies
                    game.activeCheckpoint = null;
                    if (game.checkpointProgress[game.level]) {
                        delete game.checkpointProgress[game.level];
                    }
                    console.log('Checkpoints reset due to death');
                    
                    if (platforms.length > 0) {
                        const firstPlatform = platforms[0];
                        player.x = firstPlatform.x + 50; // Simple positioning
                        player.y = firstPlatform.y - player.collisionHeight - 10;
                        console.log('Respawning at first platform:', firstPlatform.x, firstPlatform.y);
                    } else {
                        // Emergency fallback
                        player.x = 240;
                        player.y = 1170;
                        console.log('Emergency fallback respawn');
                    }
                }
                    
                    // Simple safety check
                    if (platforms.length > 0) {
                        const firstPlatform = platforms[0];
                        // Ensure player is above the platform
                        if (player.y + player.collisionHeight > firstPlatform.y) {
                            player.y = firstPlatform.y - player.collisionHeight - 10;
                        }
                        console.log('Simple safety check completed');
                    }
                }
            }
            
            // Update camera - position it closer to player and add Y positioning
            game.camera.x = player.x - game.canvasWidth / 2.5; // Changed from /3 to /2.5 to be closer
            if (game.camera.x < 0) game.camera.x = 0;
            
            // Add Y camera positioning to follow player vertically
            game.camera.y = player.y - game.canvasHeight / 2;
            // Removed ALL limits to allow camera to follow player anywhere
            
            // Debug camera movement (only log occasionally to avoid spam)
            if (Math.random() < 0.01) { // 1% chance to log
                console.log('ðŸ“· Camera following player - Player Y:', player.y, 'Camera Y:', game.camera.y, 'Screen Y:', player.y - game.camera.y);
                if (game.camera.y < 0) {
                    console.log('ðŸš€ Camera is in negative Y territory - following player upward!');
                }
            }
            
            // ðŸ¤– Update AI Bot (performance optimized)
            if (game.aiBot.isVisible) {
                updateAiBot();
            }
            
            // Fish collection
            fish.forEach((f, index) => {
                if (!f.collected && checkCollision(player, { x: f.x - 19, y: f.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    f.collected = true;
                    game.score += 100;
                    game.sessionStats.fishCollected++;
                    game.sessionStats.totalScore += 100;
                    game.sessionStats.currentSessionFish++;
                    game.sessionStats.currentSessionScore += 100;
                    
                    // Update highest fish if current session is higher
                    if (game.sessionStats.currentSessionFish > game.sessionStats.highestFish) {
                        game.sessionStats.highestFish = game.sessionStats.currentSessionFish;
                    }
                    
                }
            });
            
            // Coin collection
            coins.forEach((c, index) => {
                if (!c.collected && checkCollision(player, { x: c.x - 14, y: c.y - 14, width: 29, height: 29 })) { // Scaled from 6, 12 (6*2.4=14.4, 12*2.4=28.8)
                    c.collected = true;
                    
                    // Apply wallet bonuses if connected
                    let coinMultiplier = 1;
                    let bonusCoins = 0;
                    // Wallet system disabled - no coin multipliers
                    
                    game.coins += coinMultiplier + bonusCoins;
                    // Don't add to marketplace coins yet - only on level completion
                    game.sessionStats.totalCoins += coinMultiplier + bonusCoins;
                    game.sessionStats.currentSessionCoins += coinMultiplier + bonusCoins;
                    
                    // Add score with XP and multiplier
                    addScoreWithXP(25 * coinMultiplier, 'Coin');
                    
                    // Update highest coins if current session is higher
                    if (game.sessionStats.currentSessionCoins > game.sessionStats.highestCoins) {
                        game.sessionStats.highestCoins = game.sessionStats.currentSessionCoins;
                    }
                    
                    // Don't save marketplace data when coins are collected - only on level completion
                    
                    // Check for coin-related achievements
                    if (game.sessionStats.totalCoins === 1) {
                        unlockAchievement('first_coin');
                    }
                    if (game.sessionStats.currentSessionCoins >= 10) {
                        unlockAchievement('ten_coins');
                    }
                    
                    // Check for score achievement
                    if (game.sessionStats.currentSessionScore >= 100) {
                        unlockAchievement('hundred_score');
                    }
                    
                    // Update collectibles counter
                    game.collectiblesCount.coinsCollected++;
                    updateCollectiblesCounter();
                    
                    // Check all achievements after coin collection
                    checkAllAchievements();
                }
            });
            
            // Health collection - more difficult to find health
            health.forEach((h, index) => {
                if (!h.collected && checkCollision(player, { x: h.x - 19, y: h.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    h.collected = true;
                    game.score += 25; // Reduced points from 50 to 25
                    game.sessionStats.healthCollected++;
                    game.sessionStats.healthPickups++;
                    game.sessionStats.totalScore += 25;
                    game.sessionStats.currentSessionHealth++;
                    game.sessionStats.currentSessionScore += 25;
                    
                    // Update highest health if current session is higher
                    if (game.sessionStats.currentSessionHealth > game.sessionStats.highestHealth) {
                        game.sessionStats.highestHealth = game.sessionStats.currentSessionHealth;
                    }
                    
                    
                    // Heal player and 60% chance to get a life
                    healPlayer(25); // Heal 25 health points
                    if (Math.random() < 0.6) {
                        game.lives = Math.min(game.lives + 1, game.maxLives);
                        console.log('Health collected! +1 life');
                    } else {
                        console.log('Health collected! No life this time...');
                    }
                }
            });
            
            // Heart collection (extra lives)
            hearts.forEach((h, index) => {
                if (!h.collected && checkCollision(player, { x: h.x - 19, y: h.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    h.collected = true;
                    game.score += 100; // Heart gives 100 points
                    game.sessionStats.totalScore += 100;
                    game.sessionStats.currentSessionScore += 100;
                    
                    
                    // Give player an extra life
                    game.lives = Math.min(game.lives + 1, game.maxLives);
                    addScreenShake(5);
                    console.log('â¤ï¸ Heart collected! +1 life. Total lives:', game.lives);
                    
                    // Create heart particles
                    for (let i = 0; i < 6; i++) {
                        game.particles.push({
                            x: h.x,
                            y: h.y,
                            velX: (Math.random() - 0.5) * 3,
                            velY: (Math.random() - 0.5) * 3,
                            life: 80,
                            decay: 1,
                            type: 'heart'
                        });
                    }
                }
            });
            
            // Armor collection
            armor.forEach((a, index) => {
                if (!a.collected && checkCollision(player, { x: a.x - 19, y: a.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    a.collected = true;
                    
                    let points = 50;
                    let armorAmount = 50;
                    let message = 'ðŸ›¡ï¸ Armor collected! +50 armor points';
                    
                    // Different rewards for different armor types
                    if (a.isHidden) {
                        points = 100; // Hidden armor gives more points
                        armorAmount = 75; // Hidden armor gives more protection
                        if (a.hiddenType === 'underwater') {
                            message = 'ðŸ›¡ï¸ Underwater armor collected! +75 armor points';
                        } else if (a.hiddenType === 'cloud') {
                            message = 'ðŸ›¡ï¸ Cloud armor collected! +75 armor points';
                        } else {
                            message = 'ðŸ›¡ï¸ Hidden armor collected! +75 armor points';
                        }
                    } else if (a.isBossArmor) {
                        points = 150; // Boss armor gives even more points
                        armorAmount = 100; // Boss armor gives maximum protection
                        message = 'ðŸ›¡ï¸ Boss armor collected! +100 armor points';
                    }
                    
                    game.score += points;
                    game.sessionStats.totalScore += points;
                    game.sessionStats.currentSessionScore += points;
                    
                    
                    // Add armor to player
                    addArmor(armorAmount);
                    console.log(message);
                    
                    // Special effects for hidden armor
                    if (a.isHidden) {
                        addScreenShake(3);
                        // Create sparkle particles
                        for (let i = 0; i < 8; i++) {
                            game.particles.push({
                                x: a.x,
                                y: a.y,
                                velX: (Math.random() - 0.5) * 4,
                                velY: (Math.random() - 0.5) * 4,
                                life: 60,
                                decay: 1,
                                type: 'sparkle'
                            });
                        }
                    }
                }
            });
            
            // Treasure collection
            treasures.forEach((t, index) => {
                if (!t.collected) {
                    // Check if player is near the treasure for interaction
                    const isNearTreasure = checkCollision(player, { x: t.x - 19, y: t.y - 19, width: 38, height: 38 });
                    
                    if (isNearTreasure) {
                        // Check if this is a golden chest that requires F key interaction
                        if (t.requiresKey && t.isGoldenChest) {
                            // Check if F key is pressed for golden chest interaction
                            if (game.keys['KeyF']) {
                                if (game.keyCount > 0) {
                                    // Player has a key, open the chest
                                    game.keyCount--;
                                    player.keys--;
                                    t.collected = true;
                                    game.score += t.value;
                                    game.sessionStats.treasuresCollected++;
                                    game.sessionStats.treasuresFound++;
                                    game.sessionStats.totalScore += t.value;
                                    game.sessionStats.currentSessionTreasures++;
                                    game.sessionStats.currentSessionScore += t.value;
                                    
                                    // Update highest treasures if current session is higher
                                    if (game.sessionStats.currentSessionTreasures > game.sessionStats.highestTreasures) {
                                        game.sessionStats.highestTreasures = game.sessionStats.currentSessionTreasures;
                                    }
                                    
                                    
                                    // Golden chest rewards
                                    game.coins += 50; // Extra bonus coins for golden chests
                                    game.lives = Math.min(game.lives + 2, game.maxLives); // Bonus 2 lives for golden chest
                                    
                                    // Update collectibles counter
                                    game.collectiblesCount.chestsCollected++;
                                    updateCollectiblesCounter();
                                    
                                    addScreenShake(5);
                                    console.log('ðŸ”‘ Golden chest opened with F key! +50 coins, +2 lives');
                                } else {
                                    // Player doesn't have a key
                                    console.log('ðŸ”‘ Golden chest requires a key! Find a key first.');
                                    addScreenShake(2);
                                }
                            }
                            // Don't collect automatically - wait for F key
                        } else {
                            // Regular treasure collection (automatic)
                    t.collected = true;
                    game.sessionStats.treasuresCollected++;
                    game.sessionStats.treasuresFound++;
                    game.sessionStats.currentSessionTreasures++;
                    
                    // Add score with XP and multiplier
                    addScoreWithXP(t.value, 'Treasure');
                    
                    // Update highest treasures if current session is higher
                    if (game.sessionStats.currentSessionTreasures > game.sessionStats.highestTreasures) {
                        game.sessionStats.highestTreasures = game.sessionStats.currentSessionTreasures;
                    }
                    
                    if (t.type === 'rareTreasure') {
                        game.coins += 25; // Extra bonus coins for rare treasures
                        game.lives = Math.min(game.lives + 1, game.maxLives); // Bonus life for rare treasure
                    } else {
                        game.coins += 10; // Regular bonus coins for normal treasures
                            }
                    
                    // Update collectibles counter
                    game.collectiblesCount.chestsCollected++;
                    updateCollectiblesCounter();
                        }
                    }
                }
            });
            
            // Jetpack collection
            jetpacks.forEach((j, index) => {
                if (!j.collected && checkCollision(player, { x: j.x - 19, y: j.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    j.collected = true;
                    game.score += 100;
                    game.sessionStats.totalScore += 100;
                    game.sessionStats.currentSessionScore += 100;
                    
                    
                    // Give player jetpack ability
                                                                    player.hasJetpack = true;
                        updateAbilitiesDisplay();
                        addScreenShake(3);
                    console.log('Jetpack collected! Press Shift to activate!');
                }
            });
            
            // Mushroom collection
            mushrooms.forEach((m, index) => {
                if (!m.collected && checkCollision(player, { x: m.x - 19, y: m.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    m.collected = true;
                    const mushroomValue = m.value || 1000; // Default to 1000 if value is missing
                    game.score += mushroomValue;
                    game.sessionStats.mushroomsCollected++;
                    game.sessionStats.mushroomsEaten++;
                    game.sessionStats.totalScore += mushroomValue;
                    game.sessionStats.currentSessionMushrooms++;
                    game.sessionStats.currentSessionScore += mushroomValue;
                    
                    // Update highest mushrooms if current session is higher
                    if (game.sessionStats.currentSessionMushrooms > game.sessionStats.highestMushrooms) {
                        game.sessionStats.highestMushrooms = game.sessionStats.currentSessionMushrooms;
                    }
                    
                    
                    // Activate giant mode
                    player.isGiant = true;
                    player.giantTime = Date.now();
                    player.invulnerable = true;
                    
                    // Increase player size for giant mode
                    player.width = 96; // Scaled from 40 (40*2.4=96)
                    player.height = 140; // Scaled from 58 (58*2.4=139.2)
                    player.collisionWidth = 96;
                    player.collisionHeight = 140;
                    
                    // Adjust player position to keep feet on the same platform
                    player.y -= 40; // Move player up to compensate for larger collision box
                
                    // Force player back onto platform after size change
                    // Find the platform the player is currently on
                    let currentPlatform = null;
                    for (const platform of platforms) {
                        if (platform.isVisible !== false) {
                            const collisionX = player.x + player.collisionOffsetX;
                            const collisionY = player.y + player.collisionOffsetY;
                            
                            if (collisionX + player.collisionWidth > platform.x && 
                                collisionX < platform.x + platform.width &&
                                collisionY + player.collisionHeight >= platform.y - 10 &&
                                collisionY + player.collisionHeight <= platform.y + 10) {
                                currentPlatform = platform;
                                break;
                            }
                        }
                    }
                    
                    if (currentPlatform) {
                        // Calculate the correct position for the giant player on the platform
                        const newY = currentPlatform.y - player.collisionHeight - player.collisionOffsetY;
                        player.y = newY;
                        player.velY = 0; // Stop any falling velocity
                        player.onGround = true;
                        player.canDoubleJump = true; // Reset double jump
                        console.log('Repositioned giant player on platform:', {
                            platformY: currentPlatform.y,
                            playerY: player.y,
                            collisionHeight: player.collisionHeight,
                            collisionOffsetY: player.collisionOffsetY
                        });
                    } else {
                        // If no platform found, just ensure player is on ground
                                        player.onGround = true;
                                        player.canDoubleJump = true;
                        console.log('Giant mode activated! No platform repositioning needed.');
                    }
                    
                    addScreenShake(5);
                    console.log('ðŸ„ Mushroom collected! Giant mode activated!');
                }
            });
            
            // Key collection
            keys.forEach((k, index) => {
                if (!k.collected && checkCollision(player, { x: k.x - 4, y: k.y - 12, width: 8, height: 24 })) { // Thinner collision box for keys
                    k.collected = true;
                    game.score += 200;
                    game.keyCount++;
                    player.keys++;
                    game.sessionStats.keysCollected++;
                    game.sessionStats.totalScore += 200;
                    game.sessionStats.currentSessionScore += 200;
                    
                    
                    // Update collectibles counter
                    updateCollectiblesCounter();
                    
                    addScreenShake(3);
                    console.log('ðŸ”‘ Key collected! Total keys:', game.keyCount);
                }
            });
            
            // ðŸ”« LASER COLLECTION CODE - ENHANCED COLLISION DETECTION
            function updateLaserCollection() {
                if (!laserPowerups || laserPowerups.length === 0) {
                    console.log('ðŸ”« No laser powerups to check for collection');
                    return;
                }
                
                laserPowerups.forEach((l, index) => {
                if (!l.collected) {
                        // Enhanced collision box - larger pickup area
                        const laserBounds = {
                            x: l.x - 30,
                            y: l.y - 30,
                            width: 60,
                            height: 60
                        };
                        
                        const playerBounds = {
                            x: player.x,
                            y: player.y,
                            width: player.width,
                            height: player.height
                        };
                        
                        // Debug collision detection
                        const collision = checkCollision(playerBounds, laserBounds);
                        
                        if (collision) {
                        l.collected = true;
                            game.score += 200;
                            game.sessionStats.totalScore += 200;
                            game.sessionStats.currentSessionScore += 200;
                        
                        
                        // Give player laser ability
                        player.hasLaser = true;
                        updateAbilitiesDisplay();
                        addScreenShake(5);
                            
                            console.log('ðŸ”« Laser collected! Press Space to shoot!');
                            console.log('ðŸ”« Player position:', player.x, player.y);
                            console.log('ðŸ”« Laser position:', l.x, l.y);
                            
                            return; // Exit early since we found a collision
                    }
                }
            });
            }
            
            // Call the enhanced collection function
            updateLaserCollection();
            
            // ðŸ”¥ FIREBALL COLLECTION CODE
            function updateFireballCollection() {
                if (!fireballPowerups || fireballPowerups.length === 0) {
                    return;
                }
                
                fireballPowerups.forEach((f, index) => {
                    if (!f.collected) {
                        // Enhanced collision box - larger pickup area
                        const fireballBounds = {
                            x: f.x - 30,
                            y: f.y - 30,
                            width: 60,
                            height: 60
                        };
                        
                        const playerBounds = {
                            x: player.x,
                            y: player.y,
                            width: player.width,
                            height: player.height
                        };
                        
                        const collision = checkCollision(playerBounds, fireballBounds);
                        
                        if (collision) {
                            f.collected = true;
                            game.score += 300;
                            game.sessionStats.totalScore += 300;
                            game.sessionStats.currentSessionScore += 300;
                            
                            
                            // Give player fireball ability
                                                                            player.hasFireball = true;
                        updateAbilitiesDisplay();
                        addScreenShake(5);
                            
                            console.log('ðŸ”¥ Fireball collected! Right-click to shoot bouncing fireballs!');
                            console.log('ðŸ”¥ Player hasFireball set to:', player.hasFireball);
                            console.log('ðŸ”¥ Player position:', player.x, player.y);
                            console.log('ðŸ”¥ Fireball position:', f.x, f.y);
                            
                            return; // Exit early since we found a collision
                        }
                    }
                });
            }
            
            // Call the fireball collection function
            updateFireballCollection();
            
            // Check if reached goal (only when player touches the flag!)
            if (game.goalX && game.goalY) {
                const playerRight = player.x + player.collisionWidth;
                const playerBottom = player.y + player.collisionHeight;
                
                // Goal flag triangular collision detection
                const flagCenterX = game.goalX + 180; // Center of platform
                const flagBaseY = game.goalY - 192; // Bottom of flag at platform level
                const flagTopY = game.goalY - 192 - 270; // Top of flag
                const flagWidth = 120; // Width of the flag
                
                // Define triangular flag bounds (triangle pointing right)
                const flagLeft = flagCenterX - flagWidth/2; // Left edge of flag
                const flagRight = flagCenterX + flagWidth/2; // Right edge of flag
                const flagTop = flagTopY; // Top point of flag
                const flagBottom = flagBaseY; // Bottom edge of flag
                
                // Check if player is within the rectangular bounds first (quick check)
                if (player.x < flagRight && playerRight > flagLeft && 
                    player.y < flagBottom && playerBottom > flagTop) {
                    
                    // More precise triangular collision detection
                    const playerCenterX = player.x + player.collisionWidth / 2;
                    const playerCenterY = player.y + player.collisionHeight / 2;
                    
                    // Check if player center is within the triangular flag area
                    const isInTriangle = checkTriangleCollision(
                        playerCenterX, playerCenterY,
                        flagLeft, flagBottom,  // Bottom left point
                        flagRight, flagBottom, // Bottom right point  
                        flagLeft, flagTop      // Top point (triangle pointing right)
                    );
                    
                    if (isInTriangle) {
                    
                    // Boss level check - prevent completion if boss is still alive
                    if (game.bossActive && game.currentBoss && game.currentBoss.health > 0) {
                        console.log('ðŸš« Cannot complete boss level - boss is still alive!');
                        // Don't set levelComplete = true, just return
                        return;
                    }
                    
                    game.levelComplete = true;
                    
                    // Calculate level completion bonus with XP system
                    const baseLevelBonus = 500;
                    const fishBonus = fish.filter(f => f.collected).length * 50;
                    const totalBaseBonus = baseLevelBonus + fishBonus;
                    
                    // Add score with XP and multiplier
                    addScoreWithXP(totalBaseBonus, 'Level Complete');
                    
                    // Add level completion XP bonus
                    const levelCompletionXP = player.rewards.levelCompletionBonus * game.level; // Higher levels = more XP
                    addXP(levelCompletionXP);
                    
                    console.log(`ðŸŽ‰ Level ${game.level} completed! +${levelCompletionXP} bonus XP`);
                game.sessionStats.currentSessionLevels++;
                
                // Update highest levels if current session is higher
                if (game.sessionStats.currentSessionLevels > game.sessionStats.highestLevels) {
                    game.sessionStats.highestLevels = game.sessionStats.currentSessionLevels;
                }
                
                // Update highest score if current session is higher
                if (game.sessionStats.currentSessionScore > game.sessionStats.highestScore) {
                    game.sessionStats.highestScore = game.sessionStats.currentSessionScore;
                    // Show owl high score celebration
                    showSituationalOwlMessage('highScore');
                }
                
                // Record level completion time
                const levelTime = Date.now() - game.sessionStats.levelStartTime;
                game.sessionStats.levelTimes.push({
                    level: game.level,
                    time: formatTime(levelTime)
                });
                game.sessionStats.levelsCompleted++;
                saveStats(true); // Save all stats only on level completion
                saveSessionStats(); // Save session stats
                
                // Save player progress (XP, level, etc.) when level is completed
                savePlayerProgress();
                
                // Check for level-related achievements
                if (game.sessionStats.levelsCompleted === 1) {
                    unlockAchievement('first_level');
                }
                if (game.sessionStats.levelsCompleted >= 5) {
                    unlockAchievement('five_levels');
                }
                
                // Check all achievements after level completion
                checkAllAchievements();
                
                // Reset secret chest state for next level
                game.secretChestsSpawned = false;
                game.secretChestConditions.coinsCollected = 0;
                game.secretChestConditions.treasuresCollected = 0;
                game.secretChestConditions.keysCollected = 0;
                
                // PERFORMANCE: Clear particles and arrays when level completes to prevent memory buildup
                game.particles = [];
                if (typeof playerLasers !== 'undefined') playerLasers.length = 0;
                if (typeof playerFireballs !== 'undefined') playerFireballs.length = 0;
                if (typeof lasers !== 'undefined') lasers.length = 0;
                if (typeof bossLasers !== 'undefined') bossLasers.length = 0;
                
                document.getElementById('levelCompleteName').textContent = `${currentLevel.name} Complete!`;
                document.getElementById('levelComplete').style.display = 'block';
                
                // Show owl celebration message
                showSituationalOwlMessage('levelComplete');
                    }
                }
            }
            
            // Update enemies - OPTIMIZED VERSION
            // Cache time once per frame instead of calling Date.now() for each enemy
            const currentTime = Date.now();
            const frameTime = currentTime * 0.003; // Cache for sin/cos calculations
            const frameTime001 = currentTime * 0.001; // For goldfish
            
            // Only update enemies that are on-screen or near player (within 600px)
            const updateRadius = 600; // Only update enemies within this distance
            
            enemies.forEach((enemy, enemyIndex) => {
                // PERFORMANCE: Skip enemies that are far off-screen
                const enemyScreenX = enemy.x - game.camera.x;
                const enemyScreenY = enemy.y - game.camera.y;
                const distanceToPlayer = Math.abs(enemy.x - player.x);
                const distanceToCamera = Math.sqrt(
                    Math.pow(enemyScreenX, 2) + Math.pow(enemyScreenY, 2)
                );
                
                // Skip enemy if too far from both player and camera
                if (distanceToPlayer > updateRadius && distanceToCamera > updateRadius) {
                    return; // Skip this enemy
                }
                
                // Enemy type-specific AI (simplified)
                if (enemy.type === 'eagle') {
                    // Simplified Eagle AI - removed complex retreat logic
                    const verticalDistance = Math.abs(enemy.y - player.y);
                    
                    // Only check targeting if near player
                    if (distanceToPlayer < 400 && verticalDistance < 200 && !enemy.targetPlayer) {
                        enemy.targetPlayer = true;
                        enemy.chaseStartTime = currentTime; // Use cached time
                    }

                    if (enemy.targetPlayer) {
                        const playerDirection = player.x > enemy.x ? 1 : -1;
                        enemy.direction = playerDirection;
                        enemy.x += enemy.velX * playerDirection;
                        
                        const targetHeight = player.y - 80;
                        const heightDiff = targetHeight - enemy.y;
                        if (Math.abs(heightDiff) > 10) {
                            enemy.y += heightDiff > 0 ? 3 : -3;
                        }
                        
                        // Simplified attack
                        if (distanceToPlayer < 200 && !enemy.isAttacking) {
                            enemy.isAttacking = true;
                            enemy.attackStartTime = currentTime;
                        }
                        
                        if (enemy.isAttacking) {
                            const attackTime = currentTime - enemy.attackStartTime;
                            if (attackTime < 1000) {
                                enemy.y += player.y > enemy.y ? 3 : -3;
                            } else {
                                enemy.isAttacking = false;
                            }
                        }
                        
                        // Simplified retreat check
                        const chaseTime = currentTime - enemy.chaseStartTime;
                        if (distanceToPlayer > 500 || chaseTime > 8000) {
                            enemy.targetPlayer = false;
                            enemy.isAttacking = false;
                        }
                    } else {
                        // Simple patrol - use cached frameTime
                        enemy.x += enemy.velX * enemy.direction;
                        const baseY = enemy.originalSpawnY || enemy.originalY || enemy.y;
                        enemy.y = baseY + Math.sin(frameTime + (enemy.sineOffset || 0)) * 15;
                        
                        if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                            enemy.direction *= -1;
                        }
                    }
                    
                } else if (enemy.type === 'shark') {
                    // Simplified Shark AI - removed complex dive/back-away states
                    const verticalDistance = Math.abs(enemy.y - player.y);
                    const waterSurface = game.waterLevel;
                    const patrolDepth = waterSurface + 200;
                    
                    // Only check targeting if near player and in water
                    if (distanceToPlayer < 400 && verticalDistance < 200 && !enemy.targetPlayer && player.inWater) {
                        enemy.targetPlayer = true;
                        enemy.followStartTime = currentTime;
                    }

                    if (enemy.targetPlayer) {
                        const playerDirection = player.x > enemy.x ? 1 : -1;
                        enemy.direction = playerDirection;
                        enemy.x += Math.abs(enemy.velX) * 1.5 * playerDirection;
                        
                        // Simplified depth following
                        const targetDepth = Math.max(waterSurface + 50, Math.min(waterSurface + 400, player.y + 50));
                        const depthDiff = targetDepth - enemy.y;
                        if (Math.abs(depthDiff) > 5) {
                            enemy.y += depthDiff > 0 ? 5 : -5;
                        }
                        
                        // Simplified retreat
                        const followTime = currentTime - enemy.followStartTime;
                        if (distanceToPlayer > 250 || followTime > 3000) {
                            enemy.targetPlayer = false;
                        }
                    } else {
                        // Simple patrol - use cached frameTime
                        enemy.x += enemy.velX * enemy.direction;
                        const baseY = enemy.originalY || patrolDepth;
                        enemy.y = baseY + Math.sin(frameTime + enemy.sineOffset) * 30;
                        
                        if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                            enemy.direction *= -1;
                        }
                    }
                    
                    if (enemy.y < waterSurface + 30) {
                        enemy.y = waterSurface + 30;
                    }
                    
                } else if (enemy.type === 'charger') {
                    // Charger AI - strictly on platforms, only charges when player is close on same platform
                    
                    // First, check if enemy already has a platform reference (from moving platform code)
                    let currentPlatform = enemy.currentPlatform || null;
                    
                    // If no platform reference, find which platform the charger is on
                    if (!currentPlatform) {
                        for (const platform of platforms) {
                            if (platform.isVisible === false) continue;
                            if (enemy.x >= platform.x && enemy.x <= platform.x + platform.width &&
                                enemy.y >= platform.y - enemy.height - 5 && enemy.y <= platform.y + 5) {
                                currentPlatform = platform;
                                enemy.currentPlatform = platform; // Store reference
                                // Keep charger on platform
                                enemy.y = platform.y - enemy.height;
                                break;
                            }
                        }
                    } else {
                        // Enemy is on a moving platform - verify it's still on it
                        if (enemy.x >= currentPlatform.x && enemy.x <= currentPlatform.x + currentPlatform.width &&
                            enemy.y >= currentPlatform.y - enemy.height - 5 && enemy.y <= currentPlatform.y + 5) {
                            // Still on platform - keep it fixed
                            enemy.y = currentPlatform.y - enemy.height;
                        } else {
                            // Fell off - clear reference and find new platform
                            enemy.currentPlatform = null;
                            currentPlatform = null;
                        }
                    }
                    
                    // If charger is not on a platform, try to find the closest one and move towards it
                    if (!currentPlatform) {
                        let closestPlatform = null;
                        let closestDistance = Infinity;
                        for (const platform of platforms) {
                            if (platform.isVisible === false) continue;
                            const distance = Math.abs(enemy.x - (platform.x + platform.width / 2));
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestPlatform = platform;
                            }
                        }
                        if (closestPlatform && closestDistance < 200) {
                            // Move towards closest platform
                            if (enemy.x < closestPlatform.x + closestPlatform.width / 2) {
                                enemy.direction = 1;
                            } else {
                                enemy.direction = -1;
                            }
                            enemy.x += enemy.velX * enemy.direction;
                            // Snap to platform if close enough
                            if (enemy.x >= closestPlatform.x && enemy.x <= closestPlatform.x + closestPlatform.width) {
                                enemy.y = closestPlatform.y - enemy.height;
                                currentPlatform = closestPlatform;
                            }
                        }
                    }
                    
                    // Only proceed if charger is on a platform
                    if (currentPlatform) {
                        // Check if player is on the same platform and close enough to charge
                        const playerOnSamePlatform = player.x >= currentPlatform.x && 
                                                    player.x <= currentPlatform.x + currentPlatform.width &&
                                                    Math.abs(player.y - currentPlatform.y) < 150;
                        const canSeePlayer = distanceToPlayer < 300 && 
                                           Math.abs(enemy.y - player.y) < 100 && 
                                           playerOnSamePlatform;
                        
                        if (canSeePlayer && !enemy.isCharging && currentTime - (enemy.lastChargeTime || 0) > enemy.chargeCooldown) {
                            enemy.isCharging = true;
                            enemy.chargeStartTime = currentTime;
                            enemy.chargeDirection = player.x > enemy.x ? 1 : -1;
                        }
                        
                        if (enemy.isCharging) {
                            const chargeProgress = (currentTime - enemy.chargeStartTime) / enemy.chargeWindup;
                            
                            // Check if charger would fall off platform during charge
                            const nextX = enemy.x + (chargeProgress < 1 ? 
                                enemy.velX * 0.3 * enemy.chargeDirection : 
                                enemy.chargeSpeed * enemy.chargeDirection);
                            const wouldFallOff = nextX < currentPlatform.x || nextX > currentPlatform.x + currentPlatform.width;
                            
                            if (wouldFallOff) {
                                // Stop charging if about to fall off
                                enemy.isCharging = false;
                                enemy.lastChargeTime = currentTime;
                                enemy.direction *= -1; // Turn around
                            } else {
                                if (chargeProgress < 1) {
                                    // Windup phase
                                    enemy.x += enemy.velX * 0.3 * enemy.chargeDirection;
                                } else {
                                    // Charge phase
                                    enemy.x += enemy.chargeSpeed * enemy.chargeDirection;
                                    
                                    // Stop charging if reached edge or player is too far
                                    if (enemy.x <= currentPlatform.x || enemy.x >= currentPlatform.x + currentPlatform.width ||
                                        distanceToPlayer > 400 || !playerOnSamePlatform) {
                                        enemy.isCharging = false;
                                        enemy.lastChargeTime = currentTime;
                                    }
                                }
                            }
                            
                            // Keep charger on platform during charge
                            enemy.y = currentPlatform.y - enemy.height;
                        } else {
                            // Normal patrol movement
                            enemy.x += enemy.velX * enemy.direction;
                            
                            // Turn around at platform edges
                            if (enemy.x <= currentPlatform.x || enemy.x >= currentPlatform.x + currentPlatform.width) {
                                enemy.direction *= -1;
                                // Clamp to platform bounds
                                enemy.x = Math.max(currentPlatform.x, Math.min(currentPlatform.x + currentPlatform.width, enemy.x));
                            }
                            
                            // Keep charger on platform
                            enemy.y = currentPlatform.y - enemy.height;
                        }
                    }
                    
                } else if (enemy.type === 'goldfish') {
                    // Simplified Goldfish AI - use cached frameTime001
                    enemy.x += 0.8 * enemy.direction;
                    enemy.y += Math.sin(frameTime001 + enemy.x * 0.01) * 0.3;
                    
                    if (enemy.y < game.waterLevel + 50) enemy.y = game.waterLevel + 50;
                    if (enemy.y > game.waterLevel + 400) enemy.y = game.waterLevel + 400;
                    
                    if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                        enemy.direction *= -1;
                    }
                    
                    if (Math.random() < 0.003) {
                        enemy.direction *= -1;
                    }
                    
                } else if (enemy.type === 'gator' || enemy.type === 'wizgator') {
                    // Simplified Gator/Wizgator AI
                    const playerInWater = player.inWater;
                    const playerInLava = game.bossActive && player.y > game.waterLevel;
                    
                    if (distanceToPlayer < enemy.chaseRange && (playerInWater || playerInLava) && !enemy.isChasing) {
                        enemy.isChasing = true;
                        enemy.chaseStartTime = currentTime;
                    }
                    
                    if (enemy.isChasing) {
                        const playerDirection = player.x > enemy.x ? 1 : -1;
                        enemy.direction = playerDirection;
                        enemy.x += enemy.chaseSpeed * playerDirection;
                        enemy.y = game.waterLevel - enemy.height + 20;
                        
                        const chaseTime = currentTime - enemy.chaseStartTime;
                        if (chaseTime > enemy.chaseDuration || distanceToPlayer > enemy.chaseRange * 1.5) {
                            enemy.isChasing = false;
                            enemy.chaseStartTime = 0;
                        }
                    } else {
                        enemy.x += enemy.velX * enemy.patrolDirection;
                        enemy.y = game.waterLevel - enemy.height + 20;
                        
                        const patrolRange = 200;
                        if (Math.abs(enemy.x - enemy.originalX) > patrolRange) {
                            enemy.patrolDirection *= -1;
                        }
                        
                        if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                            enemy.patrolDirection *= -1;
                        }
                    }
                    
                    // Wizgator shooting (only if near player)
                    if (enemy.type === 'wizgator' && enemy.canShoot && distanceToPlayer < 400 && 
                        currentTime - (enemy.lastShot || 0) > enemy.shotCooldown) {
                        const mouthX = enemy.x + (enemy.direction === 1 ? enemy.width - 10 : 10);
                        const mouthY = enemy.y + enemy.height / 2;
                        const dx = player.x - enemy.x;
                        const dy = player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        lasers.push({
                            x: mouthX,
                            y: mouthY,
                            velX: (dx / distance) * 5,
                            velY: (dy / distance) * 5,
                            width: 32,
                            height: 32,
                            active: true,
                            color: '#FF6600',
                            type: 'fireball'
                        });
                        
                        enemy.lastShot = currentTime;
                    }
                    
                } else {
                    // Basic enemy AI (crabs) - must stay on platforms, including moving ones
                    // Check if enemy already has a platform reference (from moving platform code)
                    let currentPlatform = enemy.currentPlatform || null;
                    
                    // If no platform reference, find which platform the enemy is on
                    if (!currentPlatform) {
                        for (const platform of platforms) {
                            if (platform.isVisible === false) continue;
                            if (enemy.x >= platform.x && enemy.x <= platform.x + platform.width &&
                                enemy.y >= platform.y - enemy.height - 5 && enemy.y <= platform.y + 5) {
                                currentPlatform = platform;
                                enemy.currentPlatform = platform; // Store reference
                                enemy.y = platform.y - enemy.height;
                                break;
                            }
                        }
                    } else {
                        // Enemy is on a moving platform - verify it's still on it
                        if (enemy.x >= currentPlatform.x && enemy.x <= currentPlatform.x + currentPlatform.width &&
                            enemy.y >= currentPlatform.y - enemy.height - 5 && enemy.y <= currentPlatform.y + 5) {
                            // Still on platform - keep it fixed
                            enemy.y = currentPlatform.y - enemy.height;
                        } else {
                            // Fell off - clear reference and find new platform
                            enemy.currentPlatform = null;
                            currentPlatform = null;
                            // Try to find a new platform
                            for (const platform of platforms) {
                                if (platform.isVisible === false) continue;
                                if (enemy.x >= platform.x && enemy.x <= platform.x + platform.width &&
                                    enemy.y >= platform.y - enemy.height - 5 && enemy.y <= platform.y + 5) {
                                    currentPlatform = platform;
                                    enemy.currentPlatform = platform;
                                    enemy.y = platform.y - enemy.height;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Only move if on a platform
                    if (currentPlatform) {
                        enemy.x += enemy.velX * enemy.direction;
                        
                        // Turn around at platform edges
                        if (enemy.x <= currentPlatform.x || enemy.x >= currentPlatform.x + currentPlatform.width) {
                            enemy.direction *= -1;
                            // Clamp to platform bounds
                            enemy.x = Math.max(currentPlatform.x, Math.min(currentPlatform.x + currentPlatform.width, enemy.x));
                        }
                        
                        // Keep enemy on platform (especially important for moving platforms)
                        enemy.y = currentPlatform.y - enemy.height;
                    }
                }
                
                // Shooting logic for level 5+ crabs (only if near player)
                if (enemy.canShoot && enemy.type === 'crab' && distanceToPlayer < 400 &&
                    currentTime - (enemy.lastShot || 0) > enemy.shotCooldown) {
                    const leftClawX = enemy.x + (enemy.direction === 1 ? 29 : -10);
                    const rightClawX = enemy.x + (enemy.direction === 1 ? 38 : -19);
                    const clawY = enemy.y + 5;
                    
                    lasers.push({
                        x: leftClawX,
                        y: clawY,
                        velX: enemy.direction * 7,
                        velY: 0,
                        width: 19,
                        height: 5,
                        active: true
                    });
                    
                    lasers.push({
                        x: rightClawX,
                        y: clawY,
                        velX: enemy.direction * 7,
                        velY: 0,
                        width: 19,
                        height: 5,
                        active: true
                    });
                    
                    enemy.lastShot = currentTime;
                }
                
                // Shooting logic for level 5+ goldfish (only if near player)
                if (enemy.canShoot && enemy.type === 'goldfish' && distanceToPlayer < 400 &&
                    currentTime - (enemy.lastShot || 0) > enemy.shotCooldown) {
                    const mouthX = enemy.x + (enemy.direction === 1 ? enemy.width - 5 : 5);
                    const mouthY = enemy.y + enemy.height / 2;
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    lasers.push({
                        x: mouthX,
                        y: mouthY,
                        velX: (dx / distance) * 5,
                        velY: (dy / distance) * 5,
                        width: 16,
                        height: 6,
                        active: true,
                        color: '#FFD700'
                    });
                    
                    enemy.lastShot = currentTime;
                }
                
                // Enemy collision with player - use player's collision box for more accurate detection
                const playerCollisionX = player.x + player.collisionOffsetX;
                const playerCollisionY = player.y + player.collisionOffsetY;
                
                // Check collision using enemy's collision box (smaller than sprite)
                const enemyCollisionX = enemy.x + (enemy.collisionOffsetX || 0);
                const enemyCollisionY = enemy.y + (enemy.collisionOffsetY || 0);
                const enemyCollisionWidth = enemy.collisionWidth || enemy.width;
                const enemyCollisionHeight = enemy.collisionHeight || enemy.height;
                
                if (playerCollisionX < enemyCollisionX + enemyCollisionWidth &&
                    playerCollisionX + player.collisionWidth > enemyCollisionX &&
                    playerCollisionY < enemyCollisionY + enemyCollisionHeight &&
                    playerCollisionY + player.collisionHeight > enemyCollisionY) {
                    
                    // MUCH MORE LENIENT conditions for "jump on head" - should work at all times
                    const isFalling = player.velY > 0;
                    const feetNearEnemyTop = playerCollisionY + player.collisionHeight >= enemyCollisionY - 10 && 
                                           playerCollisionY + player.collisionHeight <= enemyCollisionY + 10;
                    const isAboveEnemy = playerCollisionY < enemyCollisionY + enemyCollisionHeight * 0.5; // Much more lenient
                    const horizontalOverlap = Math.min(playerCollisionX + player.collisionWidth, enemyCollisionX + enemyCollisionWidth) - 
                                            Math.max(playerCollisionX, enemyCollisionX);
                    const isCenteredOnEnemy = horizontalOverlap > enemyCollisionWidth * 0.2; // Much more lenient centering
                    
                    if (isFalling && feetNearEnemyTop && isAboveEnemy && isCenteredOnEnemy) {
                        // Jump on head - bounce back up (ALWAYS works, even during invulnerability)
                        enemies.splice(enemyIndex, 1);
                        game.score += 200;
                        
                        // Track specific enemy types
                        switch (enemy.type) {
                            case 'crab':
                        game.sessionStats.crabsDefeated++;
                        game.sessionStats.currentSessionCrabs++;
                                break;
                            case 'eagle':
                                game.sessionStats.eaglesDefeated++;
                                break;
                            case 'gator':
                                game.sessionStats.gatorsDefeated++;
                                break;
                            case 'shark':
                                game.sessionStats.sharksDefeated++;
                                break;
                            default:
                                game.sessionStats.crabsDefeated++; // Default to crab for unknown types
                                game.sessionStats.currentSessionCrabs++;
                        }
                        
                        game.sessionStats.totalScore += 200;
                        game.sessionStats.currentSessionScore += 200;
                        
                        // Update highest crabs if current session is higher
                        if (game.sessionStats.currentSessionCrabs > game.sessionStats.highestCrabs) {
                            game.sessionStats.highestCrabs = game.sessionStats.currentSessionCrabs;
                        }
                        
                        player.velY = -player.jumpPower * 0.4; // Slightly stronger bounce
                        addScreenShake(8);
                        addFreezeFrame(80);
                        game.particles.push(...createParticle(enemy.x + enemy.width/2, enemy.y + enemy.height, 'stomp'));
                        console.log('Enemy stomped! Bounce!'); // Debug message
                    } else {
                        // Any other collision = damage (only if not invulnerable)
                        if (!player.invulnerable) {
                            takeDamage(25); // Use new health system
                            player.x = enemy.x - 120; // Scaled from 50 (50*2.4=120)
                            player.velY = 0; // No bounce - just horizontal knockback
                        } else if (player.isGiant) {
                            // Mushroom power-up: knock over enemies by running into them
                            enemies.splice(enemyIndex, 1);
                            game.score += 200;
                            
                            // Track specific enemy types
                            switch (enemy.type) {
                                case 'crab':
                            game.sessionStats.crabsDefeated++;
                            game.sessionStats.currentSessionCrabs++;
                                    break;
                                case 'eagle':
                                    game.sessionStats.eaglesDefeated++;
                                    break;
                                case 'gator':
                                    game.sessionStats.gatorsDefeated++;
                                    break;
                                case 'shark':
                                    game.sessionStats.sharksDefeated++;
                                    break;
                                default:
                                    game.sessionStats.crabsDefeated++; // Default to crab for unknown types
                                    game.sessionStats.currentSessionCrabs++;
                            }
                            
                            game.sessionStats.totalScore += 200;
                            game.sessionStats.currentSessionScore += 200;
                            
                            // Update highest crabs if current session is higher
                            if (game.sessionStats.currentSessionCrabs > game.sessionStats.highestCrabs) {
                                game.sessionStats.highestCrabs = game.sessionStats.currentSessionCrabs;
                            }
                            
                            console.log('Mushroom power-up! Enemy knocked over!');
                        }
                    }
                }
            });
            
            // Checkpoint collision and activation
            checkpoints.forEach((checkpoint, index) => {
                if (!checkpoint.activated && checkCollision(player, checkpoint)) {
                    checkpoint.activated = true;
                    game.activeCheckpoint = checkpoint;
                    
                    // Store checkpoint progress for this level
                    if (!game.checkpointProgress[game.level]) {
                        game.checkpointProgress[game.level] = [];
                    }
                    game.checkpointProgress[game.level].push(index);
                    
                    console.log('Checkpoint activated!');
                }
            });
            
            // Breakable tile collision
            breakables.forEach((tile, index) => {
                if (!tile.broken && checkCollision(player, tile)) {
                    // Check if player is falling (stomping)
                    if (player.velY > 0 && player.y < tile.y) {
                        tile.health--;
                        addScreenShake(5);
                        addFreezeFrame(50);
                        
                        // Create stomp particles
                        game.particles.push(...createParticle(tile.x + tile.width/2, tile.y + tile.height, 'stomp'));
                        
                        if (tile.health <= 0) {
                            tile.broken = true;
                            console.log('Breakable tile destroyed!');
                            
                            // Give reward based on tile type
                            if (tile.reward) {
                                switch (tile.reward) {
                                    case 'mushroom':
                                        // Create mushroom at tile location
                                        mushrooms.push({
                                            x: tile.x + tile.width/2,
                                            y: tile.y + tile.height,
                                            collected: false,
                                            type: 'mushroom',
                                            value: 1000 // 1000 points for mushroom
                                        });
                                        console.log('Mushroom reward from breakable tile!');
                                        break;
                                    case 'health':
                                        // Create health pickup at tile location
                                        health.push({
                                            x: tile.x + tile.width/2,
                                            y: tile.y + tile.height,
                                            collected: false,
                                            type: 'health'
                                        });
                                        console.log('Health reward from breakable tile!');
                                        break;

                                }
                                
                                // Create reward particles
                                game.particles.push(...createParticle(tile.x + tile.width/2, tile.y + tile.height, 'reward'));
                            }
                            
                            // Check if this reveals a secret room
                            secretRooms.forEach(room => {
                                if (!room.discovered && 
                                    Math.abs(tile.x - room.x) < 300 && 
                                    Math.abs(tile.y - room.y) < 200) {
                                    room.discovered = true;
                                    console.log('Secret room discovered!');
                                }
                            });
                        }
                    }
                }
            });
            
            // Update boss
            if (game.currentBoss && game.bossActive) {
                const boss = game.currentBoss;
                console.log('ðŸ”« BOSS UPDATE - State:', boss.state, 'Health:', boss.health, '/', boss.maxHealth);
                boss.stateTimer += 16; // Assuming 60 FPS
                
                        // Debug boss health every 2 seconds
        if (boss.stateTimer % 2000 < 16) {
            const healthPercentage = (boss.health / boss.maxHealth * 100).toFixed(1);
            console.log('ðŸ‘‘ Boss health:', boss.health, '/', boss.maxHealth, '(', healthPercentage + '%)', 'State:', boss.state, 'Timer:', boss.stateTimer);
        }
                
                // Boss AI
                const distanceToPlayer = Math.abs(boss.x - player.x);
                
                // State machine
                switch (boss.state) {

                        
                    
                        

                        
                            case 'shoot':
            // Shoot 8 lasers in 360 degrees every 2 seconds
            if (boss.stateTimer % 2000 < 16) {
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI * 2) / 8; // 8 directions
                    const speed = 6;
                    const laser = {
                        x: boss.x + boss.width / 2,
                        y: boss.y + boss.height / 2,
                        velX: Math.cos(angle) * speed,
                        velY: Math.sin(angle) * speed,
                        width: 30,
                        height: 6,
                        color: '#FF0000',
                        active: true,
                        angle: angle // ðŸŽ¯ STORE THE ANGLE for proper rotation
                    };
                    bossLasers.push(laser);
                }
                console.log('ðŸ”« 8 lasers created in 360 degrees! Total:', bossLasers.length);
            }
                        

                        break;
                }
                
                // Physics
                boss.velY += 0.8; // Gravity
                boss.x += boss.velX;
                boss.y += boss.velY;
                
                // Ground collision
                boss.isGrounded = false;
                for (const platform of platforms) {
                    if (platform.type === 'disappearing' && !platform.isVisible) continue;
                    
                    if (boss.x < platform.x + platform.width && boss.x + boss.width > platform.x &&
                        boss.y + boss.height >= platform.y && boss.y < platform.y + platform.height) {
                        boss.y = platform.y - boss.height;
                        boss.velY = 0;
                        boss.isGrounded = true;
                        break;
                    }
                }
                
                // Spawn adds
                boss.addSpawnTimer += 16;
                if (boss.addSpawnTimer > boss.addSpawnCooldown) {
                    boss.adds.push({
                        x: boss.x + Math.random() * boss.width,
                        y: boss.y - 50,
                        width: 40,
                        height: 32,
                        velX: (Math.random() - 0.5) * 4,
                        velY: 0,
                        direction: Math.random() < 0.5 ? 1 : -1
                    });
                    boss.addSpawnTimer = 0;
                }
                
                // Update adds
                boss.adds.forEach((add, index) => {
                    add.x += add.velX;
                    add.velY += 0.8;
                    add.y += add.velY;
                    
                    // Ground collision for adds
                    for (const platform of platforms) {
                        if (platform.type === 'disappearing' && !platform.isVisible) continue;
                        
                        if (add.x < platform.x + platform.width && add.x + add.width > platform.x &&
                            add.y + add.height >= platform.y && add.y < platform.y + platform.height) {
                            add.y = platform.y - add.height;
                            add.velY = 0;
                            break;
                        }
                    }
                    
                    // Remove adds that fall off screen
                    if (add.y > game.camera.y + game.canvasHeight + 100) {
                        boss.adds.splice(index, 1);
                    }
                });
                
                // Boss collision with player
                const playerCollisionX = player.x + player.collisionOffsetX;
                const playerCollisionY = player.y + player.collisionOffsetY;
                
                if (playerCollisionX < boss.x + boss.width &&
                    playerCollisionX + player.collisionWidth > boss.x &&
                    playerCollisionY < boss.y + boss.height &&
                    playerCollisionY + player.collisionHeight > boss.y) {
                    
                    // Check if player is stomping boss
                    const isFalling = player.velY > 0;
                    const feetNearBossTop = playerCollisionY + player.collisionHeight >= boss.y - 10 && 
                                           playerCollisionY + player.collisionHeight <= boss.y + 10;
                    const isAboveBoss = playerCollisionY < boss.y + boss.height * 0.5;
                    
                    if (isFalling && feetNearBossTop && isAboveBoss) {
                        // Stomp boss
                        boss.health -= 20;
                        player.velY = -player.jumpPower * 0.6;
                        console.log('Boss stomped! Health:', boss.health);
                        
                        if (boss.health <= 0) {
                            // Don't set bossActive to false yet - keep lava until level changes
                            // game.bossActive = false; // REMOVED - keep lava active
                            game.currentBoss = null;
                            game.score += 1000;
                            game.sessionStats.bossesDefeated++;
                            game.sessionStats.currentSessionBosses++;
                            game.sessionStats.totalScore += 1000;
                            game.sessionStats.currentSessionScore += 1000;
                            
                            console.log('Boss defeated by stomp! Lava remains until level change.');
                        }
                                            } else if (!player.damageInvulnerable) {
                            // Player takes damage
                            game.lives--;
                            if (game.lives <= 0) {
                                game.gameOver = true;
                            } else {
                                player.damageInvulnerable = true;
                                player.invulnerableTime = Date.now();
                            }
                    }
                }
                
                // Boss adds collision
                boss.adds.forEach((add, addIndex) => {
                    if (playerCollisionX < add.x + add.width &&
                        playerCollisionX + player.collisionWidth > add.x &&
                        playerCollisionY < add.y + add.height &&
                        playerCollisionY + player.collisionHeight > add.y) {
                        
                        // Check if stomping add
                        const isFalling = player.velY > 0;
                        const feetNearAddTop = playerCollisionY + player.collisionHeight >= add.y - 10 && 
                                               playerCollisionY + player.collisionHeight <= add.y + 10;
                        const isAboveAdd = playerCollisionY < add.y + add.height * 0.5;
                        
                        if (isFalling && feetNearAddTop && isAboveAdd) {
                            // Stomp add
                            boss.adds.splice(addIndex, 1);
                            player.velY = -player.jumpPower * 0.4;
                            game.score += 100;
                        } else if (!player.damageInvulnerable) {
                            // Player takes damage
                            takeDamage(25); // Use new health system
                        }
                    }
                });
            }
            
            // Update particles (optimized: reverse loop to avoid index issues, limit particles)
            // Limit particles to prevent performance issues
            const MAX_PARTICLES = 100; // Reduced from 200 to 100 for better performance
            if (game.particles.length > MAX_PARTICLES) {
                game.particles = game.particles.slice(-MAX_PARTICLES);
            }
            
            // Reverse loop to avoid index shifting issues when removing particles
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const particle = game.particles[i];
                particle.x += particle.velX;
                particle.y += particle.velY;
                particle.velY += 0.3; // Gravity
                particle.life -= particle.decay;
                
                // Remove particles that are off-screen and dead (more aggressive cleanup for performance)
                if (particle.life <= 0 || 
                    particle.x < game.camera.x - 100 || 
                    particle.x > game.camera.x + game.canvasWidth + 100 ||
                    particle.y < game.camera.y - 100 || 
                    particle.y > game.camera.y + game.canvasHeight + 100) {
                    game.particles.splice(i, 1);
                }
            }
            
            // Update screen shake
            if (game.screenShake > 0) {
                game.screenShake *= 0.9;
                if (game.screenShake < 0.1) game.screenShake = 0;
            }
            
            // Update freeze frame
            if (game.freezeFrame > 0) {
                game.freezeFrame -= 16; // Assuming 60 FPS
            }
            
            // Update lasers
            lasers.forEach((laser, laserIndex) => {
                laser.x += laser.velX;
                laser.y += laser.velY;
                
                // Remove lasers that go off screen
                if (laser.x < game.camera.x - 120 || laser.x > game.camera.x + canvas.width + 120) { // Scaled from 50 (50*2.4=120)
                    lasers.splice(laserIndex, 1);
                    return;
                }
                
                // Laser collision with player
                if (!player.damageInvulnerable && checkCollision(player, laser)) {
                    console.log('Laser hit player! No bounce applied...'); // Debug
                    takeDamage(25); // Use new health system
                    player.x -= 120; // Scaled from 50 (50*2.4=120)
                    player.velY = 0; // No bounce - just horizontal knockback
                    console.log('No bounce - velY set to 0'); // Debug
                    lasers.splice(laserIndex, 1);
                }
                
                // Laser collision with platforms
                for (const platform of platforms) {
                    if (checkCollision(laser, platform)) {
                        lasers.splice(laserIndex, 1);
                        break;
                    }
                }
            });
            
            // Update boss lasers
            bossLasers.forEach((laser, laserIndex) => {
                laser.x += laser.velX;
                laser.y += laser.velY;
                
                // Remove boss lasers that go off screen
                if (laser.x < game.camera.x - 200 || laser.x > game.camera.x + canvas.width + 200 ||
                    laser.y < game.camera.y - 200 || laser.y > game.camera.y + canvas.height + 200) {
                    bossLasers.splice(laserIndex, 1);
                    return;
                }
                
                // Boss laser collision with player
                if (!player.damageInvulnerable && checkCollision(player, laser)) {
                    console.log('ðŸ”« Boss laser hit player!');
                    takeDamage(25); // Use new health system
                    player.x -= 120;
                    player.velY = 0;
                    bossLasers.splice(laserIndex, 1);
                }
                
                // Boss lasers pass through platforms (no collision detection)
                // This allows boss lasers to travel through the environment
            });
            
            // Check for new life every 10000 points
            const lifeThreshold = Math.floor(game.score / 10000);
            if (lifeThreshold > game.lastLifeScore) {
                game.lives = Math.min(game.lives + (lifeThreshold - game.lastLifeScore), game.maxLives);
                game.lastLifeScore = lifeThreshold;
            }
            
            // Update UI
            document.getElementById('score').textContent = game.score;
            document.getElementById('coins').textContent = game.coins;
            document.getElementById('lives').textContent = game.lives;
            document.getElementById('xp').textContent = player.xp;
            
            // Update XP bar
            const xpBarFill = document.getElementById('xpBarFill');
            const xpText = document.getElementById('xpText');
            if (xpBarFill && xpText) {
                // Calculate current level XP and XP needed for next level based on new system
                let currentLevelXP, xpForNextLevel;
                
                if (player.level === 1) {
                    currentLevelXP = player.xp;
                    xpForNextLevel = 1000;
                } else if (player.level === 2) {
                    currentLevelXP = player.xp - 1000;
                    xpForNextLevel = 1500;
                } else if (player.level === 3) {
                    currentLevelXP = player.xp - 2500;
                    xpForNextLevel = 2000;
                } else if (player.level === 4) {
                    currentLevelXP = player.xp - 4500;
                    xpForNextLevel = 2500;
                } else if (player.level === 5) {
                    currentLevelXP = player.xp - 7000;
                    xpForNextLevel = 3000;
                } else if (player.level === 6) {
                    currentLevelXP = player.xp - 10000;
                    xpForNextLevel = 3500;
                } else if (player.level === 7) {
                    currentLevelXP = player.xp - 13500;
                    xpForNextLevel = 4000;
                } else if (player.level === 8) {
                    currentLevelXP = player.xp - 17500;
                    xpForNextLevel = 4500;
                } else if (player.level === 9) {
                    currentLevelXP = player.xp - 22000;
                    xpForNextLevel = 5000;
                } else if (player.level === 10) {
                    currentLevelXP = player.xp - 27000;
                    xpForNextLevel = 5500;
                } else {
                    // Level 10+: 1000 XP per level
                    const level10Plus = player.level - 10;
                    const baseXP = 32500 + (level10Plus * 1000);
                    currentLevelXP = player.xp - baseXP;
                    xpForNextLevel = 1000;
                }
                
                const xpPercentage = (currentLevelXP / xpForNextLevel) * 100;
                
                xpBarFill.style.width = xpPercentage + '%';
                xpText.innerHTML = `Level ${player.level} <span id="xpProgress">(${currentLevelXP}/${xpForNextLevel} XP)</span>`;
            }
            
            // Update XP display
            document.getElementById('xp').textContent = player.xp;
            // Keys are now updated in updateCollectiblesCounter()
            
            // Update health bar
            updateHealthBar();
            
            // Update armor bar
            updateArmorBar();
            
            // Update collectibles counter (includes keys)
            updateCollectiblesCounter();
            
            // Update giant mode indicator
            const giantIndicator = document.getElementById('giantIndicator');
            if (giantIndicator) {
                if (player.isGiant) {
                    const remainingTime = Math.max(0, Math.ceil((player.giantDuration - (Date.now() - player.giantTime)) / 1000));
                    giantIndicator.textContent = `ðŸ„ GIANT MODE: ${remainingTime}s`;
                    giantIndicator.style.display = 'block';
                } else {
                    giantIndicator.style.display = 'none';
                }
            }
        }
        
        // Render game
        function draw() {
            // Safety check: ensure canvas is ready before drawing
            if (!isCanvasReady()) {
                console.error('âŒ Canvas not ready in draw() function');
                return;
            }
            
            const isMobile = game.isMobile || window.innerWidth < 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Clear and draw background
            drawBackground();
            
            // Draw top boundary warning (skip on mobile for performance)
            if (!isMobile) {
                drawTopBoundary();
            }
            
            // Water will be drawn as overlay at the end
            
            // Debug: Draw collision boxes if Shift key is held
            const showCollisionBoxes = game.keys['ShiftLeft'] || game.keys['ShiftRight'];
            
            // Draw platforms in correct order (bottom to top) so green grass is visible
            // Cloud platforms are drawn last to appear on top
            // Cache platform filtering and sorting (only recalculate if platforms changed)
            if (!game._cachedPlatforms || game._platformsCacheFrame !== game.frameCount) {
                const regularPlatforms = platforms.filter(p => p.type !== 'cloud');
                const cloudPlatforms = platforms.filter(p => p.type === 'cloud');
                
                // Sort regular platforms by Y position (bottom first) - cache this
                game._cachedRegularPlatforms = [...regularPlatforms].sort((a, b) => a.y - b.y);
                game._cachedCloudPlatforms = cloudPlatforms;
                game._platformsCacheFrame = game.frameCount;
            }
            
            // Draw cached platforms
            game._cachedRegularPlatforms.forEach(drawPlatform);
            game._cachedCloudPlatforms.forEach(drawPlatform);
            
            // Draw goal
            drawGoal();
            
            // Draw fish
            fish.forEach(f => {
                if (!f.collected) {
                    const x = f.x - game.camera.x;
                    const y = f.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawFish(x, y);
                    }
                }
            });
            
            // Draw coins
            coins.forEach(c => {
                if (!c.collected) {
                    const x = c.x - game.camera.x;
                    const y = c.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawCoin(x, y);
                    }
                }
            });
            
            // Draw health pickups
            health.forEach(h => {
                if (!h.collected) {
                    const x = h.x - game.camera.x;
                    const y = h.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawHealth(x, y);
                    }
                }
            });
            
            // Draw heart pickups (extra lives)
            hearts.forEach(h => {
                if (!h.collected) {
                    const x = h.x - game.camera.x;
                    const y = h.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawHeart(x, y);
                    }
                }
            });
            
            // Draw armor pickups
            armor.forEach(a => {
                if (!a.collected) {
                    const x = a.x - game.camera.x;
                    const y = a.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawArmor(x, y, a);
                    }
                }
            });
            
            // Draw jetpacks
            jetpacks.forEach(j => {
                if (!j.collected) {
                    const x = j.x - game.camera.x;
                    const y = j.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawJetpack(x, y);
                    }
                }
            });
            
            // Draw treasures
            treasures.forEach(t => {
                if (!t.collected) {
                    const x = t.x - game.camera.x;
                    const y = t.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        if (t.isSecret) {
                            // Draw secret chest with special effects
                            drawSecretChest(x, y, t);
                        } else if (t.type === 'rareTreasure') {
                            drawRareTreasure(x, y, t.requiresKey);
                        } else {
                            drawTreasure(x, y);
                        }
                        
                        // Draw treasure hit effect
                        if (t.hitEffect && Date.now() - t.hitTime < 1000) {
                            ctx.save();
                            const time = Date.now() * 0.01;
                            const glowIntensity = Math.sin(time * 5) * 0.3 + 0.7;
                            
                            // Treasure hit glow effect
                            ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 50, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Treasure hit text
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('TREASURE HIT!', x, y - 40);
                            ctx.restore();
                        }
                    }
                }
            });
            
            // Draw mushrooms
            mushrooms.forEach(m => {
                if (!m.collected) {
                    const x = m.x - game.camera.x;
                    const y = m.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawMushroom(x, y);
                    }
                }
            });
            
            // Draw keys
            keys.forEach(k => {
                if (!k.collected) {
                    const x = k.x - game.camera.x;
                    const y = k.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawKey(x, y);
                    }
                }
            });
            
            // ðŸ”« LASER DRAWING CODE - ENHANCED RENDERING
            function drawLasers() {
                if (!laserPowerups || laserPowerups.length === 0) {
                    console.log('ðŸ”« No laser powerups to draw');
                    return;
                }
                
                // Removed console.log to prevent spam
                
                laserPowerups.forEach((l, index) => {
                    if (!l.collected) {
                        const screenX = l.x - game.camera.x;
                        const screenY = l.y - game.camera.y;
                        
                        // Wider visibility range
                        if (screenX > -100 && screenX < game.canvasWidth + 100 && 
                            screenY > -100 && screenY < game.canvasHeight + 100) {
                            
                            // Removed console.log for performance
                            drawLaser(screenX, screenY);
                        }
                    }
                });
            }
            
            // Call the enhanced drawing function
            drawLasers();
            
            // ðŸ”¥ Draw fireball powerups
            if (fireballPowerups && fireballPowerups.length > 0) {
                fireballPowerups.forEach((f, index) => {
                    if (!f.collected) {
                        const screenX = f.x - game.camera.x;
                        const screenY = f.y - game.camera.y;
                        
                        // Wider visibility range
                        if (screenX > -100 && screenX < game.canvasWidth + 100 && 
                            screenY > -100 && screenY < game.canvasHeight + 100) {
                            
                            // Draw fireball powerup
                            ctx.save();
                            ctx.translate(screenX, screenY);
                            
                            const time = Date.now() * 0.01;
                            const pulseIntensity = Math.sin(time * 6) * 0.3 + 0.7;
                            
                            // ðŸ”¥ OUTER GLOW (animated) - Draw behind the asset
                            ctx.fillStyle = `rgba(255, 69, 0, ${0.6 * pulseIntensity})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, 35, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // ðŸŒŸ FIRE PARTICLES - Draw behind the asset
                            ctx.fillStyle = '#FFAA00';
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2 + time * 3;
                                const radius = 30 + Math.sin(time * 4 + i) * 5;
                                const particleX = Math.cos(angle) * radius;
                                const particleY = Math.sin(angle) * radius;
                                const particleSize = Math.random() * 3 + 1;
                                ctx.beginPath();
                                ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            // Draw fireball asset if available
                            if (gameAssets.fireball && gameAssets.fireball.complete) {
                                const fireballWidth = gameAssets.fireball.width * 0.6; // Scale down slightly
                                const fireballHeight = gameAssets.fireball.height * 0.6;
                                ctx.drawImage(gameAssets.fireball, -fireballWidth/2, -fireballHeight/2, fireballWidth, fireballHeight);
                            } else {
                                // Fallback to custom fireball drawing
                                // ðŸ”¥ FIREBALL POWERUP CORE
                                ctx.fillStyle = '#FF4500';
                                ctx.beginPath();
                                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // âš¡ INNER GLOW
                                ctx.fillStyle = '#FFFFFF';
                                ctx.beginPath();
                                ctx.arc(0, 0, 10, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            // ðŸ”¥ FLOATING EFFECT - Draw on top
                            const floatOffset = Math.sin(time * 2) * 3;
                            ctx.fillStyle = 'rgba(255, 69, 0, 0.3)';
                            ctx.beginPath();
                            ctx.arc(0, floatOffset + 5, 20, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // âš¡ SPARKLE EFFECT - Draw on top
                            ctx.fillStyle = '#FFFFFF';
                            for (let i = 0; i < 4; i++) {
                                const angle = (i * Math.PI / 2) + time * 2;
                                const sparkleX = Math.cos(angle) * 25;
                                const sparkleY = Math.sin(angle) * 25;
                                ctx.beginPath();
                                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            ctx.restore();
                        }
                    }
                });
            }
            
            // Draw enemies
            if (enemies.length > 0) {
                // Removed console.log to prevent spam
            }
            enemies.forEach(enemy => {
                // Removed console.log for performance
                // Draw based on enemy type
                if (enemy.type === 'eagle') {
                    drawEagle(enemy);
                } else if (enemy.type === 'charger') {
                    drawCharger(enemy);
                } else if (enemy.type === 'goldfish') {
                    drawGoldfish(enemy);
                } else if (enemy.type === 'gator') {
                    drawGator(enemy);
                } else if (enemy.type === 'wizgator') {
                    drawWizgator(enemy);
                } else if (enemy.type === 'shark') {
                    drawShark(enemy);
                } else {
                    drawCrab(enemy);
                }
                

            });
            
            // ðŸ”« Draw enemy lasers
            lasers.forEach(laser => {
                const laserScreenX = laser.x - game.camera.x;
                const laserScreenY = laser.y - game.camera.y;
                
                // Only draw if on screen
                if (laserScreenX > -50 && laserScreenX < game.canvasWidth + 50 && 
                    laserScreenY > -50 && laserScreenY < game.canvasHeight + 50) {
                    
                    ctx.save();
                    ctx.translate(laserScreenX + laser.width/2, laserScreenY + laser.height/2);
                    
                    // Calculate rotation from velocity
                    const rotation = Math.atan2(laser.velY, laser.velX);
                    ctx.rotate(rotation);
                    
                    // Laser glow effect
                    const glowColor = laser.color || '#FF0000';
                    ctx.fillStyle = glowColor.replace(')', ', 0.3)').replace('rgb', 'rgba');
                    ctx.fillRect(-laser.width/2 - 3, -laser.height/2 - 3, laser.width + 6, laser.height + 6);
                    
                    // Main laser beam
                    ctx.fillStyle = laser.color || '#FF0000';
                    ctx.fillRect(-laser.width/2, -laser.height/2, laser.width, laser.height);
                    
                                         // Laser core (brighter center)
                     ctx.fillStyle = laser.color === '#FFD700' ? '#FFFF00' : '#FFFFFF';
                     ctx.fillRect(-laser.width/2 + 2, -laser.height/2 + 1, laser.width - 4, laser.height - 2);
                     
                     // Laser tip glow
                     ctx.fillStyle = '#FFFFFF';
                     ctx.fillRect(laser.width/2 - 3, -laser.height/2, 6, laser.height);
                     
                     // Fireball effects
                     if (laser.type === 'fireball') {
                         // Fireball glow effect
                         const time = Date.now() * 0.01;
                         const glowIntensity = Math.sin(time) * 0.3 + 0.7;
                         
                         // Outer fire glow
                         ctx.fillStyle = `rgba(255, 102, 0, ${glowIntensity * 0.4})`;
                         ctx.beginPath();
                         ctx.arc(0, 0, laser.width + 12, 0, Math.PI * 2); // Increased from +8
                         ctx.fill();
                         
                         // Inner fire glow
                         ctx.fillStyle = `rgba(255, 165, 0, ${glowIntensity * 0.6})`;
                         ctx.beginPath();
                         ctx.arc(0, 0, laser.width + 8, 0, Math.PI * 2); // Increased from +4
                         ctx.fill();
                         
                         // Fireball core
                         ctx.fillStyle = '#FF6600';
                         ctx.beginPath();
                         ctx.arc(0, 0, laser.width/2, 0, Math.PI * 2);
                         ctx.fill();
                         
                         // Fireball center
                         ctx.fillStyle = '#FFFF00';
                         ctx.beginPath();
                         ctx.arc(0, 0, laser.width/3, 0, Math.PI * 2); // Increased from /4
                         ctx.fill();
                     }
                    
                    ctx.restore();
                }
            });
            
            // Draw checkpoints
            checkpoints.forEach(checkpoint => {
                drawCheckpoint(checkpoint);
            });
            
            // Draw breakable tiles
            breakables.forEach(tile => {
                drawBreakableTile(tile);
            });
            
            // Draw secret rooms
            secretRooms.forEach(room => {
                drawSecretRoom(room);
            });
            

            
            // Draw boss
            if (game.currentBoss && game.bossActive) {
                drawBoss(game.currentBoss);
            }
            
            // ðŸ”¥ FIXED BOSS LASER DRAWING SYSTEM
            bossLasers.forEach(laser => {
                const laserScreenX = laser.x - game.camera.x;
                const laserScreenY = laser.y - game.camera.y;
                
                ctx.save();
                ctx.translate(laserScreenX + laser.width/2, laserScreenY + laser.height/2); // Translate to center
                
                // ðŸŽ¯ CORRECT ROTATION - Use stored angle or calculate from velocity
                let rotation = laser.angle || Math.atan2(laser.velY, laser.velX);
                ctx.rotate(rotation);
                
                // ðŸŒŸ LASER GLOW EFFECT (outer glow)
                ctx.fillStyle = `rgba(255, 0, 0, 0.3)`;
                ctx.fillRect(-laser.width/2 - 3, -laser.height/2 - 3, laser.width + 6, laser.height + 6);
                
                // ðŸ”¥ MAIN LASER BEAM (core)
                ctx.fillStyle = '#FF4444';
                ctx.fillRect(-laser.width/2, -laser.height/2, laser.width, laser.height);
                
                // âš¡ LASER CORE (bright center)
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(-laser.width/2 + 2, -laser.height/2 + 1, laser.width - 4, laser.height - 2);
                
                // âœ¨ LASER TIP GLOW (white hot tip)
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(laser.width/2 - 4, -laser.height/2, 6, laser.height);
                
                // ðŸŒŸ ENERGY PARTICLES (animated sparkles)
                ctx.fillStyle = '#FFAA00';
                for (let i = 0; i < 4; i++) {
                    const particleX = (Math.random() - 0.5) * laser.width;
                    const particleY = (Math.random() - 0.5) * laser.height;
                    const particleSize = Math.random() * 2 + 0.5;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // ðŸ”¥ TRAILING ENERGY (behind the laser)
                ctx.fillStyle = `rgba(255, 100, 0, 0.6)`;
                for (let i = 0; i < 3; i++) {
                    const trailX = -laser.width/2 - (i * 4);
                    const trailWidth = laser.width * (0.8 - i * 0.2);
                    const trailHeight = laser.height * (0.6 - i * 0.1);
                    ctx.fillRect(trailX, -trailHeight/2, trailWidth, trailHeight);
                }
                
                ctx.restore();
            });
            
            // Apply screen shake
            if (game.screenShake > 0) {
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * game.screenShake,
                    (Math.random() - 0.5) * game.screenShake
                );
            }
            
            // Draw particles
            drawParticles();
            
            // Draw player
            const playerScreenX = player.x - game.camera.x;
            const playerScreenY = player.y - game.camera.y;
            drawOtter(playerScreenX, playerScreenY);
            
            // ðŸ¤– Draw AI Bot (performance optimized)
            if (game.aiBot.isVisible) {
                drawAiBot();
            }
            
            // ðŸŽ¯ Show crosshair on mouse when laser is active
            if (player.hasLaser && game.mouseX !== undefined && game.mouseY !== undefined) {
                ctx.save();
                ctx.strokeStyle = player.laserColors[player.currentLaserColor];
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.8;
                
                // Draw crosshair
                ctx.beginPath();
                ctx.moveTo(game.mouseX - 8, game.mouseY);
                ctx.lineTo(game.mouseX + 8, game.mouseY);
                ctx.moveTo(game.mouseX, game.mouseY - 8);
                ctx.lineTo(game.mouseX, game.mouseY + 8);
                ctx.stroke();
                
                // Draw small center dot
                ctx.fillStyle = player.laserColors[player.currentLaserColor];
                ctx.beginPath();
                ctx.arc(game.mouseX, game.mouseY, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
                         // ðŸ”¥ Show fireball crosshair when fireball is active
             if (player.hasFireball && game.mouseX !== undefined && game.mouseY !== undefined) {
                 ctx.save();
                 ctx.strokeStyle = player.fireballCooldown > 0 ? '#666666' : '#FF4500';
                 ctx.lineWidth = 2;
                 ctx.globalAlpha = player.fireballCooldown > 0 ? 0.3 : 0.8;
                 
                 // Draw fireball crosshair
                 ctx.beginPath();
                 ctx.moveTo(game.mouseX - 10, game.mouseY);
                 ctx.lineTo(game.mouseX + 10, game.mouseY);
                 ctx.moveTo(game.mouseX, game.mouseY - 10);
                 ctx.lineTo(game.mouseX, game.mouseY + 10);
                 ctx.stroke();
                 
                 // Draw fireball center dot
                 ctx.fillStyle = player.fireballCooldown > 0 ? '#666666' : '#FF4500';
                 ctx.beginPath();
                 ctx.arc(game.mouseX, game.mouseY, 3, 0, Math.PI * 2);
                 ctx.fill();
                 
                 // Removed on-screen 'FIREBALL' text indicator to avoid top-left label
                 
                 ctx.restore();
             }
            

            
            // ðŸ”‹ Draw charging indicator when laser is charging (only if laser charge ability is unlocked)
            if (player.hasLaser && player.isCharging && player.laserChargingLevel > 0) {
                ctx.save();
                
                // Calculate charge progress
                const currentTime = Date.now();
                const chargeDuration = currentTime - player.chargeStartTime;
                const chargeProgress = Math.min(1, chargeDuration / player.chargeTime);
                
                 // Calculate charge level
                 player.chargeLevel = Math.min(player.maxChargeLevel, Math.floor(chargeDuration / (player.chargeTime / player.maxChargeLevel)));
                 
                 // Flashing effect - faster when fully charged
                 const baseFlashSpeed = 0.005; // Base flash speed
                 const chargeSpeedMultiplier = 1 + (player.chargeLevel * 0.3); // Gets faster with charge level (adjusted for 5 levels)
                 const time = Date.now() * baseFlashSpeed * chargeSpeedMultiplier;
                 
                 // Flash intensity based on charge level
                 const flashIntensity = Math.sin(time * 20) * 0.5 + 0.5;
                 
                 // Apply flashing effect to the otter
                 ctx.globalAlpha = 0.3 + (flashIntensity * 0.7); // Flash between 30% and 100% opacity
                 
                 // Add glow effect around the otter
                 ctx.shadowColor = player.laserColors[player.currentLaserColor];
                 ctx.shadowBlur = 15 + (player.chargeLevel * 5); // Glow gets stronger with charge
                 
                 // Redraw the otter with flashing effect
                 drawOtter(playerScreenX, playerScreenY);
                 
                 // Reset shadow for other elements
                 ctx.shadowBlur = 0;
                 ctx.globalAlpha = 1.0;
                 
                                 // REMOVED: All text overlays for cleaner look
                
                ctx.restore();
            }
            
            // ðŸ”« Draw player lasers with enhanced visual effects
            playerLasers.forEach(laser => {
                const laserScreenX = laser.x - game.camera.x;
                const laserScreenY = laser.y - game.camera.y;
                
                ctx.save();
                // FIXED: Draw laser from its actual position, not centered
                ctx.translate(laserScreenX, laserScreenY);
                
                // Calculate rotation from velocity
                let rotation = Math.atan2(laser.velY, laser.velX);
                ctx.rotate(rotation);
                
                // Get charge level for enhanced effects
                const chargeLevel = laser.chargeLevel || 0;
                const time = Date.now() * 0.01;
                const pulseIntensity = Math.sin(time * 5) * 0.3 + 0.7;
                
                // REMOVED: Outer glow effects for cleaner look
                
                // ðŸ”¥ MAIN LASER BEAM (enhanced with charge effects)
                ctx.fillStyle = laser.color;
                ctx.fillRect(0, 0, laser.width, laser.height);
                
                // âš¡ LASER CORE (bright center, scales with charge)
                const coreWidth = Math.max(2, laser.width - (chargeLevel * 2));
                const coreHeight = Math.max(2, laser.height - (chargeLevel * 1));
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(2, 1, coreWidth, coreHeight);
                
                // âœ¨ LASER TIP GLOW (enhanced white hot tip)
                const tipGlowSize = 6 + (chargeLevel * 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(laser.width - 2, -1, tipGlowSize, laser.height + 2);
                
                // ðŸŒŸ ENERGY PARTICLES (more particles for higher charge)
                const particleCount = 3 + (chargeLevel * 2);
                ctx.fillStyle = laser.color;
                for (let i = 0; i < particleCount; i++) {
                    const particleX = Math.random() * laser.width;
                    const particleY = Math.random() * laser.height;
                    const particleSize = Math.random() * 2 + 0.5;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // ðŸ”¥ TRAILING ENERGY (behind the laser, scales with charge)
                ctx.fillStyle = `${laser.color}60`; // 40% opacity
                for (let i = 0; i < 3 + chargeLevel; i++) {
                    const trailX = -(i * 4);
                    const trailWidth = laser.width * (0.8 - i * 0.1);
                    const trailHeight = laser.height * (0.6 - i * 0.1);
                    ctx.fillRect(trailX, 0, trailWidth, trailHeight);
                }
                
                // âš¡ CHARGE EFFECTS (special effects for charged lasers)
                if (chargeLevel > 0) {
                    // Lightning bolts around the laser
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.6 * pulseIntensity;
                    
                    for (let i = 0; i < chargeLevel; i++) {
                        const boltX = Math.random() * laser.width;
                        const boltY = Math.random() * laser.height;
                        ctx.beginPath();
                        ctx.moveTo(boltX, boltY);
                        ctx.lineTo(boltX + (Math.random() - 0.5) * 20, boltY + (Math.random() - 0.5) * 20);
                        ctx.stroke();
                    }
                    
                    // REMOVED: Energy rings for cleaner look
                    
                    // REMOVED: Explosion radius indicator and particles for cleaner look
                    

                }
                
                ctx.restore();
            });
            
            // ðŸ”¥ Draw player fireballs
            playerFireballs.forEach(fireball => {
                const fireballScreenX = fireball.x - game.camera.x;
                const fireballScreenY = fireball.y - game.camera.y;
                
                ctx.save();
                ctx.translate(fireballScreenX, fireballScreenY);
                
                // Calculate rotation from velocity
                let rotation = Math.atan2(fireball.velY, fireball.velX);
                ctx.rotate(rotation);
                
                const time = Date.now() * 0.01;
                const pulseIntensity = Math.sin(time * 8) * 0.3 + 0.7;
                
                // ðŸ”¥ FIREBALL CORE (bright orange center)
                ctx.fillStyle = '#FF4500';
                ctx.beginPath();
                ctx.arc(0, 0, fireball.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // âš¡ FIREBALL INNER GLOW (white hot center)
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(0, 0, fireball.width / 4, 0, Math.PI * 2);
                ctx.fill();
                
                // ðŸ”¥ FIREBALL OUTER GLOW (animated orange glow)
                ctx.fillStyle = `rgba(255, 69, 0, ${0.6 * pulseIntensity})`;
                ctx.beginPath();
                ctx.arc(0, 0, fireball.width / 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // ðŸŒŸ FIRE PARTICLES (animated sparkles)
                ctx.fillStyle = '#FFAA00';
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + time * 2;
                    const radius = fireball.width / 2 + Math.sin(time * 3 + i) * 3;
                    const particleX = Math.cos(angle) * radius;
                    const particleY = Math.sin(angle) * radius;
                    const particleSize = Math.random() * 2 + 1;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // ðŸ”¥ TRAILING FIRE (behind the fireball)
                ctx.fillStyle = 'rgba(255, 69, 0, 0.4)';
                for (let i = 0; i < 4; i++) {
                    const trailX = -(i * 6);
                    const trailRadius = (fireball.width / 2) * (0.8 - i * 0.15);
                    ctx.beginPath();
                    ctx.arc(trailX, 0, trailRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                

                
                ctx.restore();
            });
            
            // Restore screen shake
            if (game.screenShake > 0) {
                ctx.restore();
            }
            



            

            

            
            // Show giant mode activation effect
            if (game.giantModeActivated && Date.now() - game.giantModeTime < 2000) {
                ctx.save();
                const time = Date.now() * 0.01;
                const glowIntensity = Math.sin(time * 3) * 0.3 + 0.7;
                
                // Giant mode glow effect
                ctx.fillStyle = `rgba(255, 255, 0, ${glowIntensity * 0.3})`;
                ctx.beginPath();
                ctx.arc(playerScreenX + player.width/2, playerScreenY + player.height/2, 100, 0, Math.PI * 2);
                ctx.fill();
                
                // Giant mode text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GIANT MODE ACTIVATED!', playerScreenX + player.width/2, playerScreenY + player.height/2 - 120);
                ctx.restore();
            }
            
            // Show jetpack flames only when button is pressed
            if (player.jetpackActive && (game.keys['ShiftLeft'] || game.keys['ShiftRight'])) {
                ctx.save();
                const time = Date.now() * 0.01;
                const flameIntensity = Math.sin(time) * 0.3 + 0.7;
                
                // Scale flames based on giant mode
                const flameScale = player.isGiant ? 2.0 : 1.0;
                const flameWidth = 4 * flameScale; // Reduced from 10 to 4 (tail-sized)
                const flameHeight = 8 * flameScale; // Reduced from 20 to 8 (tail-sized)
                const innerFlameWidth = 2 * flameScale; // Reduced from 5 to 2
                const innerFlameHeight = 6 * flameScale; // Reduced from 15 to 6
                
                // Vertical flame dimensions (unchanged)
                const verticalFlameWidth = 10 * flameScale;
                const verticalFlameHeight = 20 * flameScale;
                const verticalInnerFlameWidth = 5 * flameScale;
                const verticalInnerFlameHeight = 15 * flameScale;
                
                if (player.inWater) {
                    // Water jetpack flames - horizontal from rear end
                    const flameX = playerScreenX + (player.direction === 1 ? -10 : player.width + 10);
                    const flameY = playerScreenY + player.height/2;
                    
                    // Jetpack flames (outer) - horizontal
                ctx.fillStyle = `rgba(255, 100, 0, ${flameIntensity})`;
                ctx.beginPath();
                    ctx.moveTo(flameX, flameY - flameWidth);
                    ctx.lineTo(flameX + (player.direction === 1 ? -flameHeight : flameHeight), flameY - flameWidth/2);
                    ctx.lineTo(flameX + (player.direction === 1 ? -flameHeight * 0.75 : flameHeight * 0.75), flameY);
                    ctx.lineTo(flameX + (player.direction === 1 ? -flameHeight : flameHeight), flameY + flameWidth/2);
                    ctx.lineTo(flameX, flameY + flameWidth);
                ctx.closePath();
                ctx.fill();
                
                    // Inner flame (brighter) - horizontal
                ctx.fillStyle = `rgba(255, 255, 0, ${flameIntensity * 0.8})`;
                ctx.beginPath();
                    ctx.moveTo(flameX, flameY - innerFlameWidth);
                    ctx.lineTo(flameX + (player.direction === 1 ? -innerFlameHeight : innerFlameHeight), flameY - innerFlameWidth/2);
                    ctx.lineTo(flameX + (player.direction === 1 ? -innerFlameHeight * 0.75 : innerFlameHeight * 0.75), flameY);
                    ctx.lineTo(flameX + (player.direction === 1 ? -innerFlameHeight : innerFlameHeight), flameY + innerFlameWidth/2);
                    ctx.lineTo(flameX, flameY + innerFlameWidth);
                ctx.closePath();
                ctx.fill();
                
                    // Additional flame particles for more dynamic effect - horizontal
                    ctx.fillStyle = `rgba(255, 200, 0, ${flameIntensity * 0.6})`;
                    for (let i = 0; i < 6; i++) {
                        const particleX = flameX + (player.direction === 1 ? -Math.random() * flameHeight : Math.random() * flameHeight);
                        const particleY = flameY + (Math.random() - 0.5) * flameWidth * 2;
                        const particleSize = Math.random() * 3 * flameScale + 1;
                ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                ctx.fill();
                    }
                } else {
                    // Land jetpack flames - vertical downward
                    // Calculate visual height for giant mode
                    const visualHeight = player.isGiant ? player.height * 1.5 : player.height;
                    
                    // Jetpack flames (outer)
                    ctx.fillStyle = `rgba(255, 100, 0, ${flameIntensity})`;
                    ctx.beginPath();
                    ctx.moveTo(playerScreenX + player.width/2 - verticalFlameWidth, playerScreenY + visualHeight);
                    ctx.lineTo(playerScreenX + player.width/2 - verticalFlameWidth/2, playerScreenY + visualHeight + verticalFlameHeight);
                    ctx.lineTo(playerScreenX + player.width/2, playerScreenY + visualHeight + verticalFlameHeight * 0.75);
                    ctx.lineTo(playerScreenX + player.width/2 + verticalFlameWidth/2, playerScreenY + visualHeight + verticalFlameHeight);
                    ctx.lineTo(playerScreenX + player.width/2 + verticalFlameWidth, playerScreenY + visualHeight);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner flame (brighter)
                    ctx.fillStyle = `rgba(255, 255, 0, ${flameIntensity * 0.8})`;
                ctx.beginPath();
                    ctx.moveTo(playerScreenX + player.width/2 - verticalInnerFlameWidth, playerScreenY + visualHeight);
                    ctx.lineTo(playerScreenX + player.width/2 - verticalInnerFlameWidth/2, playerScreenY + visualHeight + verticalInnerFlameHeight);
                    ctx.lineTo(playerScreenX + player.width/2, playerScreenY + visualHeight + verticalInnerFlameHeight * 0.75);
                    ctx.lineTo(playerScreenX + player.width/2 + verticalInnerFlameWidth/2, playerScreenY + visualHeight + verticalInnerFlameHeight);
                    ctx.lineTo(playerScreenX + player.width/2 + verticalInnerFlameWidth, playerScreenY + visualHeight);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Additional flame particles for more dynamic effect
                    ctx.fillStyle = `rgba(255, 200, 0, ${flameIntensity * 0.6})`;
                    for (let i = 0; i < 6; i++) {
                        const particleX = playerScreenX + player.width/2 + (Math.random() - 0.5) * verticalFlameWidth * 2;
                        const particleY = playerScreenY + visualHeight + Math.random() * verticalFlameHeight;
                        const particleSize = Math.random() * 3 * flameScale + 1;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }
            

            

            

            
            // Game over screen
            if (game.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px Orbitron, Arial Black, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 50);
                
                ctx.font = 'bold 24px Orbitron, Arial Black, sans-serif';
                ctx.fillText('Final Score: ' + game.score, canvas.width/2, canvas.height/2);
                ctx.fillText('Reached Level: ' + game.level, canvas.width/2, canvas.height/2 + 30);
                
                ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 50);
                
                if (game.keys['KeyR']) {
                    // Reset game
                    game.score = 0;
                    game.coins = 0;
                    game.lives = 3;
                    game.level = 1;
                    game.lastLifeScore = 0;
                    game.gameOver = false;
                    game.keyCount = 0; // Reset key count on game restart
                    
                    // Reset boss state
                    game.bossActive = false;
                    game.currentBoss = null;
                    
                    // Reset player state completely
                    player.x = 240;
                    player.y = 1200;
                    player.velX = 0;
                    player.velY = 0;
                    player.onGround = true;
                    player.canDoubleJump = true;
                    player.direction = 1;
                    player.health = player.maxHealth; // Reset health to full
                    player.armor = 0; // Reset armor to 0
                    player.invulnerable = false;
                    player.invulnerableTime = 0;
                    player.damageInvulnerable = false;
                    player.isGiant = false;
                    player.giantTime = 0;
                    player.canDash = false;
                    player.dashCooldown = 0;
                    player.dashDuration = 0;

                    player.lastPlatform = null;
                    player.onMovingPlatform = false;
                    
                    // Reset lava state
                    player.inLava = false;
                    player.lavaSinkTime = 0;
                    player.lavaDamageTime = 0;
                    player.lavaInvulnerable = false;
                    
                    loadLevel(1);
                    document.getElementById('level').textContent = 1;
                    document.getElementById('levelComplete').style.display = 'none';
                    console.log('Game restarted');
                }
            }
            
            // Draw water overlay as top layer (after everything else)
            drawWater();
        }
        
        function drawBoss(boss) {
            const x = boss.x - game.camera.x;
            const y = boss.y - game.camera.y;
            
            if (x > -200 && x < game.canvasWidth + 200) {
                if (gameAssets.useCustomAssets && gameAssets.kingcrab) {
                    // Draw custom kingcrab sprite for boss
                    ctx.save();
                    ctx.translate(x + boss.width/2, y + boss.height/2);
                    ctx.scale(boss.direction, 1);
                    ctx.drawImage(gameAssets.kingcrab, -boss.width/2, -boss.height/2, boss.width, boss.height);
                    
                    // State indicator on top of sprite
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(boss.state.toUpperCase(), 0, -boss.height/2 - 10);
                    
                    ctx.restore();
                } else {
                    // Draw default boss (fallback)
                    ctx.save();
                    ctx.translate(x + boss.width/2, y + boss.height/2);
                    ctx.scale(boss.direction, 1);
                    
                    // Boss body
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(-boss.width/2, -boss.height/2, boss.width, boss.height);
                    
                    // Boss shell
                    ctx.fillStyle = '#FF4444';
                    ctx.fillRect(-boss.width/2 + 10, -boss.height/2 + 10, boss.width - 20, boss.height - 20);
                    
                    // Boss eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-boss.width/4, -boss.height/3, 8, 0, Math.PI * 2);
                    ctx.arc(boss.width/4, -boss.height/3, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(-boss.width/4, -boss.height/3, 4, 0, Math.PI * 2);
                    ctx.arc(boss.width/4, -boss.height/3, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Boss claws
                    ctx.fillStyle = '#CC3333';
                    ctx.fillRect(-boss.width/2 - 15, -boss.height/2 + 20, 15, 20);
                    ctx.fillRect(boss.width/2, -boss.height/2 + 20, 15, 20);
                    
                    // State indicator
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(boss.state.toUpperCase(), 0, -boss.height/2 - 10);
                    
                    ctx.restore();
                }
                
                // Health bar
                const barWidth = 200;
                const barHeight = 20;
                const barX = x + (boss.width - barWidth) / 2;
                const barY = y - 30;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(barX, barY, (boss.health / boss.maxHealth) * barWidth, barHeight);
                
                // Draw adds
                boss.adds.forEach(add => {
                    const addX = add.x - game.camera.x;
                    const addY = add.y - game.camera.y;
                    
                    if (addX > -40 && addX < game.canvasWidth + 40) {
                        ctx.fillStyle = '#FF6666';
                        ctx.fillRect(addX, addY, add.width, add.height);
                    }
                });
            }
        }
        
        function drawBreakableTile(tile) {
            if (tile.broken) return;
            
            const x = tile.x - game.camera.x;
            const y = tile.y - game.camera.y;
            
            if (x > -50 && x < game.canvasWidth + 50) {
                ctx.save();
                
                // Determine which crate image to use based on health
                let crateImage = null;
                if (gameAssets.useCustomAssets) {
                    if (tile.health === 3) {
                        crateImage = gameAssets.crate; // Full health - intact crate
                    } else if (tile.health === 2) {
                        crateImage = gameAssets.crate1; // Damaged - first damage state
                    } else if (tile.health === 1) {
                        crateImage = gameAssets.crate2; // Heavily damaged - second damage state
                    }
                }
                
                if (crateImage && crateImage.complete) {
                    // Draw custom crate image
                    ctx.drawImage(crateImage, x, y, tile.width, tile.height);
                } else {
                    // Fallback to default drawn appearance
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x, y, tile.width, tile.height);
                
                    // Cracks based on damage level
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.beginPath();
                    
                    if (tile.health <= 2) {
                        // First crack
                ctx.moveTo(x + 10, y + 10);
                ctx.lineTo(x + 40, y + 30);
                    }
                    if (tile.health <= 1) {
                        // Second crack
                ctx.moveTo(x + 30, y + 15);
                ctx.lineTo(x + 15, y + 40);
                    }
                ctx.stroke();
                }
                
                // Health indicator
                for (let i = 0; i < tile.health; i++) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(x + 5 + i * 15, y - 10, 10, 5);
                }
                
                // Reward indicator (small icon above health bars)
                if (tile.reward) {
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    let rewardIcon = '?';
                    let rewardColor = '#FFD700';
                    
                    switch (tile.reward) {
                        case 'mushroom':
                            rewardIcon = 'ðŸ„';
                            rewardColor = '#FF00FF';
                            break;
                        case 'health':
                            rewardIcon = 'â¤ï¸';
                            rewardColor = '#FF0000';
                            break;
                        case 'treasure':
                            rewardIcon = 'ðŸ’Ž';
                            rewardColor = '#FFD700';
                            break;
                    }
                    
                    ctx.fillStyle = rewardColor;
                    ctx.fillText(rewardIcon, x + tile.width/2, y - 20);
                }
                
                ctx.restore();
            }
        }
        
        function drawSecretRoom(room) {
            if (!room.discovered) return;
            
            const x = room.x - game.camera.x;
            const y = room.y - game.camera.y;
            
            if (x > -300 && x < game.canvasWidth + 300) {
                ctx.save();
                
                // Secret room background
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fillRect(x, y, room.width, room.height);
                
                // Glowing border
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(x, y, room.width, room.height);
                ctx.setLineDash([]);
                
                // Treasure indicator
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(room.contains === 'treasure' ? 'ðŸ’Ž' : 'ðŸ„', x + room.width/2, y + room.height/2);
                
                ctx.restore();
            }
        }
        
        function drawTopBoundary() {
            // Calculate world top boundary (1000 pixels above the highest platform)
            const worldTop = Math.min(...platforms.map(p => p.y)) - 1000;
            
            // Only draw if the boundary is visible on screen
            const boundaryScreenY = worldTop - game.camera.y;
            if (boundaryScreenY > -100 && boundaryScreenY < game.canvasHeight + 100) {
                ctx.save();
                
                // Create warning boundary effect
                const time = Date.now() * 0.005;
                const pulseIntensity = Math.sin(time) * 0.3 + 0.7;
                
                // Draw warning boundary line
                ctx.strokeStyle = `rgba(255, 0, 0, ${pulseIntensity * 0.8})`;
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 5]);
                ctx.lineDashOffset = time * 20; // Animated dash movement
                ctx.beginPath();
                ctx.moveTo(0, boundaryScreenY);
                ctx.lineTo(game.canvasWidth, boundaryScreenY);
                ctx.stroke();
                
                // Draw warning triangles
                ctx.fillStyle = `rgba(255, 0, 0, ${pulseIntensity * 0.6})`;
                for (let i = 0; i < game.canvasWidth; i += 40) {
                    ctx.beginPath();
                    ctx.moveTo(i, boundaryScreenY - 15);
                    ctx.lineTo(i + 10, boundaryScreenY);
                    ctx.lineTo(i - 10, boundaryScreenY);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Draw warning text
                ctx.fillStyle = `rgba(255, 0, 0, ${pulseIntensity * 0.9})`;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('WARNING: TOP BOUNDARY', game.canvasWidth / 2, boundaryScreenY - 25);
                
                ctx.restore();
            }
        }
        
        function drawParticles() {
            game.particles.forEach(particle => {
                const x = particle.x - game.camera.x;
                const y = particle.y - game.camera.y;
                
                if (x > -10 && x < game.canvasWidth + 10 && y > -10 && y < game.canvasHeight + 10) {
                    ctx.save();
                    ctx.globalAlpha = particle.life;
                    
                    if (particle.type === 'sparkle') {
                        // Sparkle effect for hidden armor
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add sparkle glow
                        ctx.fillStyle = `rgba(255, 255, 255, ${particle.life * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (particle.type === 'heart') {
                        // Heart particle effect for heart collection
                        ctx.fillStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.moveTo(x, y + 3);
                        ctx.bezierCurveTo(x - 4, y - 2, x - 4, y - 6, x, y - 6);
                        ctx.bezierCurveTo(x + 4, y - 6, x + 4, y - 2, x, y + 3);
                        ctx.fill();
                        
                        // Heart glow
                        ctx.strokeStyle = '#FF4444';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, y + 3);
                        ctx.bezierCurveTo(x - 4, y - 2, x - 4, y - 6, x, y - 6);
                        ctx.bezierCurveTo(x + 4, y - 6, x + 4, y - 2, x, y + 3);
                        ctx.stroke();
                    } else {
                        // Regular particles
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            });
        }
        
        const cutsceneTexts = [
            "Welcome to the Otter Kingdom, young adventurer!",
            "You are a brave otter on a quest to save your homeland.",
            "The evil crabs have stolen the sacred mushrooms and scattered them across the land.",
            "You must journey through dangerous levels, defeat enemies, and collect treasures.",
            "Along the way, you'll discover secret rooms and unlock powerful abilities.",
            "Every 5 levels, you'll face a mighty boss - Captain Claws himself!",
            "Use your platforming skills, collect power-ups, and become the hero the otters need!",
            "Good luck, brave otter! The kingdom's fate rests in your paws!"
        ];
        
        function startGame() {
            // Give 50,000 coins for marketplace testing
            if (!game.sessionStats) {
                game.sessionStats = {
                    // Current Game Session Stats
                    totalScore: 0,
                    levelsCompleted: 0,
                    totalCoins: 0,
                    crabsDefeated: 0,
                    eaglesDefeated: 0,
                    gatorsDefeated: 0,
                    sharksDefeated: 0,
                    bossesDefeated: 0,
                    fishCollected: 0,
                    healthCollected: 0,
                    treasuresCollected: 0,
                    mushroomsCollected: 0,
                    keysCollected: 0,
                    treasuresFound: 0,
                    healthPickups: 0,
                    mushroomsEaten: 0,
                    jetpacksUsed: 0,
                    lasersUsed: 0,
                    fireballsShot: 0,
                    fireballsHit: 0,
                    underwaterTime: 0,
                    jetpackTime: 0,
                    laserTime: 0,
                    damageTaken: 0,
                    jumpsMade: 0,
                    perfectLevels: 0,
                    speedRunLevels: 0,
                    noDamageLevels: 0,
                    noJumpLevels: 0,
                    noPowerupLevels: 0,
                    
                    // All-Time Stats (Persistent)
                    allTimeScore: 0,
                    allTimeLevels: 0,
                    allTimeCoins: 0,
                    allTimeEnemies: 0,
                    allTimeBosses: 0,
                    allTimeFish: 0,
                    allTimeHealth: 0,
                    allTimeTreasures: 0,
                    allTimeMushrooms: 0,
                    allTimeJetpacks: 0,
                    allTimeLasers: 0,
                    allTimeFireballs: 0,
                    allTimeUnderwater: 0,
                    allTimeJetpackTime: 0,
                    allTimeLaserTime: 0,
                    allTimeDamage: 0,
                    allTimeJumps: 0,
                    allTimePerfectLevels: 0,
                    allTimeSpeedRuns: 0,
                    allTimeNoDamage: 0,
                    allTimeNoJumps: 0,
                    allTimeNoPowerups: 0,
                    allTimeKeys: 0,
                    
                    // Session Records
                    levelTimes: [],
                    levelStartTime: Date.now(),
                    highestScore: 0,
                    highestLevels: 0,
                    highestCoins: 0,
                    highestCrabs: 0,
                    highestBosses: 0,
                    highestFish: 0,
                    highestHealth: 0,
                    highestTreasures: 0,
                    highestMushrooms: 0,
                    currentSessionScore: 0,
                    currentSessionLevels: 0,
                    currentSessionCoins: 0,
                    currentSessionCrabs: 0,
                    currentSessionBosses: 0,
                    currentSessionFish: 0,
                    currentSessionHealth: 0,
                    currentSessionTreasures: 0,
                    currentSessionMushrooms: 0
                };
            }
            
            // Load saved session stats
            loadSessionStats();
            
            // Reset only session coins (keep marketplace coins)
            game.sessionStats.currentSessionCoins = 0;
            game.coins = 0;
            // Don't reset marketplace.coins - preserve coins from completed levels
            console.log('ðŸ†• Starting fresh session, keeping marketplace coins:', game.marketplace.coins);
            
            // Clear any existing saved game state when starting new game
            localStorage.removeItem('otterBrosGameState');
            console.log('ðŸ—‘ï¸ Cleared saved game state for new game');
            
            // Reset game level to 1 for fresh start
            game.level = 1;
            game.score = 0;
            game.lives = 3;
            game.gameState = 'menu';
            console.log('ðŸ”„ Reset game to level 1 for fresh start');
            
            // Update continue button visibility after clearing
            updateContinueButtonVisibility();
            
            // Save to localStorage
            saveMarketplaceData(); // Save marketplace data
            updateLeaderboard(); // Update the leaderboard display
            updateMarketplace(); // Update marketplace display
            // Don't check achievements on game start - only check when making progress
            
            // Initialize collectibles counter
            game.collectiblesCount.coinsCollected = 0;
            
            // Reset secret chest state for new level
            game.secretChestsSpawned = false;
            game.secretChestConditions.coinsCollected = 0;
            game.secretChestConditions.treasuresCollected = 0;
            game.secretChestConditions.keysCollected = 0;
            game.collectiblesCount.chestsCollected = 0;
            game.collectiblesCount.goldenChestsCollected = 0;
            updateCollectiblesCounter();
            
            // Reset player progress for new game (don't load saved progress)
            resetPlayerProgress();
            
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('cutscenePanel').style.display = 'flex';
            game.cutsceneActive = true;
            game.cutsceneIndex = 0;
            displayCutsceneText();
        }
        
        function displayCutsceneText() {
            if (game.cutsceneIndex < cutsceneTexts.length) {
                const text = cutsceneTexts[game.cutsceneIndex];
                const textElement = document.getElementById('cutsceneText');
                
                // Clear any existing text and intervals
                textElement.textContent = '';
                if (game.typewriterInterval) {
                    clearInterval(game.typewriterInterval);
                }
                
                console.log('Displaying cutscene text:', text); // Debug log
                
                // Option 1: Character by character typing (current)
                let charIndex = 0;
                game.typewriterInterval = setInterval(() => {
                    if (charIndex < text.length) {
                        textElement.textContent += text[charIndex];
                        charIndex++;
                    } else {
                        clearInterval(game.typewriterInterval);
                        game.typewriterInterval = null;
                        setTimeout(() => {
                            game.cutsceneIndex++;
                            if (game.cutsceneIndex < cutsceneTexts.length) {
                                displayCutsceneText();
                            } else {
                                endCutscene();
                            }
                        }, 2000);
                    }
                }, 50);
            }
        }
        
        function endCutscene() {
            document.getElementById('cutscenePanel').style.display = 'none';
            game.cutsceneActive = false;
            game.storyMode = true;
            game.gameState = 'playing';
            
            // Load the current level and update UI
            loadLevel(game.level);
            document.getElementById('level').textContent = game.level;
            
            // Show pause button and settings button, hide title screen buttons
            document.getElementById('pauseBtn').style.display = 'inline-block';
            document.getElementById('settingsBtn').style.display = 'inline-block';
            document.getElementById('profileBtn').style.display = 'none';
            document.getElementById('marketplaceBtn').style.display = 'none';
            document.getElementById('startGameBtn').style.display = 'none';
            
            // Enable abilities for the player
            // Dash removed - no longer needed
            
            console.log('Story mode activated! Abilities unlocked! Level loaded:', game.level);
        }
        
        function skipCutscene() {
            if (game.typewriterInterval) {
                clearInterval(game.typewriterInterval);
                game.typewriterInterval = null;
            }
            endCutscene();
        }
        
        function returnToStart() {
            // Reset game state but preserve current level
            game.score = 0;
            game.lives = 3;
            // Don't reset game.level - preserve current level
            game.coins = 0;
            game.gameOver = false;
            game.levelComplete = false;
            game.levelTransition = false;
            game.lastLifeScore = 0;
            game.camera = { x: 0, y: 0 };
            // Reset checkpoint progress for current level only
            if (game.checkpointProgress[game.level]) {
                delete game.checkpointProgress[game.level];
            }
            game.activeCheckpoint = null;
            game.currentBoss = null;
            game.bossActive = false;
            game.secrets = [];
            game.secretRooms = [];
            game.particles = [];
            game.screenShake = 0;
            game.freezeFrame = 0;
            game.storyMode = false;
            game.cutsceneActive = false;
            game.cutsceneIndex = 0;
            game.gameState = 'menu';
            if (game.typewriterInterval) {
                clearInterval(game.typewriterInterval);
                game.typewriterInterval = null;
            }
            
            // Reset player state
            player.x = 240;
            player.y = 1200;
            player.velX = 0;
            player.velY = 0;
            player.onGround = true;
            player.canDoubleJump = true;
            player.direction = 1;
            player.invulnerable = false;
            player.invulnerableTime = 0;
            player.giant = false;
            player.giantTime = 0;

            // Reset jetpack
            player.hasJetpack = false;
            player.jetpackActive = false;
            player.jetpackTime = 0;
            player.lastPlatform = null;
            
            // Hide all panels
            document.getElementById('leaderboardPanel').style.display = 'none';
            document.getElementById('instructionsPanel').style.display = 'none';

            document.getElementById('cutscenePanel').style.display = 'none';
            
            // Show title screen
            document.getElementById('titleScreen').style.display = 'flex';
            
            // Hide pause button and settings button, show title screen buttons
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('settingsBtn').style.display = 'none';
            document.getElementById('profileBtn').style.display = 'inline-block';
            document.getElementById('marketplaceBtn').style.display = 'inline-block';
            document.getElementById('startGameBtn').style.display = 'inline-block';
            
            // Check for saved game and show continue button if available
            updateContinueButtonVisibility();
            
            // Reset UI displays
            document.getElementById('score').textContent = '0';
            document.getElementById('coins').textContent = '0';
            document.getElementById('level').textContent = game.level; // Show current level, not 1
            document.getElementById('lives').textContent = '3';
            document.getElementById('giantIndicator').style.display = 'none';
            
            // Reset XP display with proper span structure
            const xpText = document.getElementById('xpText');
            const xpBarFill = document.getElementById('xpBarFill');
            if (xpText) {
                xpText.innerHTML = `Level 1 <span id="xpProgress">(0/1000 XP)</span>`;
            }
            if (xpBarFill) {
                xpBarFill.style.width = '0%';
            }
            
            // Regenerate level
            generateLevel();
            
            console.log('Returned to start screen');
        }
        
        // Health Bar Functions
        function updateHealthBar() {
            const healthBarFill = document.getElementById('healthBarFill');
            const healthText = document.getElementById('healthText');
            
            if (healthBarFill && healthText) {
                const healthPercentage = (player.health / player.maxHealth) * 100;
                healthBarFill.style.width = healthPercentage + '%';
                healthText.textContent = `Health: ${Math.round(healthPercentage)}%`;
                
                // Update health bar color based on health level
                healthBarFill.classList.remove('medium', 'low');
                if (healthPercentage <= 30) {
                    healthBarFill.classList.add('low');
                } else if (healthPercentage <= 60) {
                    healthBarFill.classList.add('medium');
                }
            }
        }
        
        function takeDamage(damageAmount = 25) {
            if (player.invulnerable || player.damageInvulnerable) {
                return; // Player is invulnerable
            }
            
            // Wallet defense bonuses removed
            // Wallet system disabled - no defense multipliers
            
            // Apply armor boost if player has the ability
            if (player.hasArmorBoost && player.armorLevel > 0) {
                const armorBoostPercent = player.armorLevel * 25; // 25%, 50%, or 75%
                const damageReduction = damageAmount * (armorBoostPercent / 100);
                damageAmount = Math.max(1, damageAmount - damageReduction); // Minimum 1 damage
                console.log(`ðŸ›¡ï¸ Armor boost reduced damage by ${armorBoostPercent}%! Damage: ${damageAmount + damageReduction} â†’ ${damageAmount}`);
            }
            
            // Armor absorbs damage first
            if (player.armor > 0) {
                const armorAbsorbed = Math.min(player.armor, damageAmount);
                player.armor -= armorAbsorbed;
                damageAmount -= armorAbsorbed;
                updateArmorBar();
                console.log('ðŸ›¡ï¸ Armor absorbed', armorAbsorbed, 'damage! Armor remaining:', player.armor);
            }
            
            // Remaining damage goes to health
            if (damageAmount > 0) {
                player.health = Math.max(0, player.health - damageAmount);
                game.sessionStats.damageTaken += damageAmount;
                updateHealthBar();
                console.log('ðŸ’” Player took', damageAmount, 'damage to health! Health remaining:', player.health);
            }
            
            // Activate damage invulnerability
            player.damageInvulnerable = true;
            player.invulnerableTime = Date.now();
            
            // If health reaches 0, lose a life and reset health
            if (player.health <= 0) {
                game.lives--;
                player.health = player.maxHealth; // Reset health to full
                updateHealthBar();
                
                // Update lives display
                const livesElement = document.getElementById('lives');
                if (livesElement) {
                    livesElement.textContent = game.lives;
                }
                
                console.log('ðŸ’” Player took damage! Health: 0, Lives remaining:', game.lives);
                
                if (game.lives <= 0) {
                    console.log('ðŸ’” GAME OVER! No lives remaining.');
                    game.gameOver = true;
                    saveGameState(); // Save game state when game over
                }
            }
        }
        
        function healPlayer(healAmount = 25) {
            player.health = Math.min(player.maxHealth, player.health + healAmount);
            updateHealthBar();
            console.log('â¤ï¸ Player healed! Health:', player.health);
        }
        
        // Armor Bar Functions
        function updateArmorBar() {
            const armorBarFill = document.getElementById('armorBarFill');
            const armorText = document.getElementById('armorText');
            
            if (armorBarFill && armorText) {
                const armorPercentage = (player.armor / player.maxArmor) * 100;
                armorBarFill.style.width = armorPercentage + '%';
                armorText.textContent = `Armor: ${Math.round(armorPercentage)}%`;
            }
        }
        
        function addArmor(armorAmount = 25) {
            player.armor = Math.min(player.maxArmor, player.armor + armorAmount);
            updateArmorBar();
            console.log('ðŸ›¡ï¸ Armor added! Armor:', player.armor);
        }
        
                // Abilities Display Functions
        function updateAbilitiesDisplay() {
            const laserAbility = document.getElementById('laserAbility');
            const fireballAbility = document.getElementById('fireballAbility');
            const jetpackAbility = document.getElementById('jetpackAbility');
            
            if (laserAbility) {
                if (player.hasLaser) {
                    laserAbility.classList.remove('inactive');
                    laserAbility.classList.add('active');
                } else {
                    laserAbility.classList.remove('active');
                    laserAbility.classList.add('inactive');
                }
            }
            
            if (fireballAbility) {
                if (player.hasFireball) {
                    fireballAbility.classList.remove('inactive');
                    fireballAbility.classList.add('active');
                } else {
                    fireballAbility.classList.remove('active');
                    fireballAbility.classList.add('inactive');
                }
            }
            
            if (jetpackAbility) {
                if (player.hasJetpack) {
                    jetpackAbility.classList.remove('inactive');
                    jetpackAbility.classList.add('active');
                } else {
                    jetpackAbility.classList.remove('active');
                    jetpackAbility.classList.add('inactive');
                }
            }
        }
        
        function removeArmor(armorAmount = 25) {
            player.armor = Math.max(0, player.armor - armorAmount);
            updateArmorBar();
            console.log('ðŸ›¡ï¸ Armor damaged! Armor remaining:', player.armor);
        }
        
        // Game loop
        // Mobile frame rate limiting
        let lastFrameTime = 0;
        const mobileFrameInterval = 1000 / 30; // 30 FPS on mobile for better performance
        
        function gameLoop(timestamp) {
            const isMobile = game.isMobile || window.innerWidth < 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Frame rate limiting for mobile
            if (isMobile) {
                const elapsed = timestamp - lastFrameTime;
                if (elapsed < mobileFrameInterval) {
                    requestAnimationFrame(gameLoop);
                    return;
                }
                lastFrameTime = timestamp - (elapsed % mobileFrameInterval);
            }
            
            game.frameCount = (game.frameCount || 0) + 1;
            
            // Only run game logic when actually playing
            if (game.gameState === 'playing') {
                update();
                updateTimeStats();
                
                // Check secret chest conditions and update abilities display periodically
                // Less frequent on mobile
                const checkInterval = isMobile ? 90 : 60;
                if (game.frameCount % checkInterval === 0) {
                    checkSecretChestConditions(); // Check for secret chest conditions
                    updateAbilitiesDisplay(); // Update abilities display
                }
                
                // Show random owl messages periodically (every 600 frames = ~10 seconds at 60fps)
                // Less frequent on mobile
                const messageInterval = isMobile ? 900 : 600;
                if (game.frameCount % messageInterval === 0 && Math.random() < 0.3) { // 30% chance every 10 seconds
                    showRandomOwlMessage();
                }
                
                draw();
            } else {
                // When not playing, just draw the menu/background
                drawMenu();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Simple menu drawing function
        function drawMenu() {
            // Safety check: ensure canvas context is available
            if (!ctx) {
                console.error('âŒ Canvas context not available in drawMenu');
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, game.canvasWidth, game.canvasHeight);
            
            // Draw a simple background or just leave it clear
            // This prevents the game from drawing enemies and other game elements when in menu
        }
        
        function updateTimeStats() {
            const currentTime = Date.now();
            const deltaTime = 16; // Approximate frame time
            
            // Track underwater time
            if (player.inWater) {
                game.sessionStats.underwaterTime += deltaTime;
            }
            
            // Track jetpack time
            if (player.jetpackActive) {
                game.sessionStats.jetpackTime += deltaTime;
            }
            
            // Track laser time (when laser is being used)
            if (player.hasLaser && (player.isCharging || player.laserCooldown > 0)) {
                game.sessionStats.laserTime += deltaTime;
            }
        }
        
        // Asset management functions
        function toggleAssetPanel() {
            const panel = document.getElementById('assetPanel');
            const isVisible = panel.style.display === 'block';
            
            panel.style.display = isVisible ? 'none' : 'block';
        }
        
        function toggleInstructions() {
            const panel = document.getElementById('instructionsPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }
        

        
        // Get current skin image based on equipped skin
        function getCurrentSkinImage() {
            const currentSkin = marketplaceItems.skins.find(skin => skin.id === game.marketplace.currentSkin);
            if (currentSkin && currentSkin.image) {
                return currentSkin.image;
            }
            return 'public/oggg.png'; // Default skin
        }
        
        // Get current swimming asset based on equipped skin
        function getCurrentSwimmingAsset() {
            const currentSkin = marketplaceItems.skins.find(skin => skin.id === game.marketplace.currentSkin);
            if (!currentSkin) {
                return gameAssets.swimmingOtter; // Default swimming otter
            }
            
            switch (currentSkin.id) {
                case 'red_plumber':
                    return gameAssets.redPlumberSwimming || gameAssets.swimmingOtter;
                case 'green_plumber':
                    return gameAssets.greenPlumberSwimming || gameAssets.swimmingOtter;
                case 'yellow_plumber':
                    return gameAssets.yellowPlumberSwimming || gameAssets.swimmingOtter;
                case 'purple_plumber':
                    return gameAssets.purplePlumberSwimming || gameAssets.swimmingOtter;
                case 'snow_plumber':
                    return gameAssets.snowPlumberSwimming || gameAssets.swimmingOtter;
                default:
                    return gameAssets.swimmingOtter; // Default swimming otter
            }
        }
        
        // Sign In Modal Functions
        function showSignInModal() {
            const modal = document.getElementById('signInModal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }
        
        function hideSignInModal() {
            const modal = document.getElementById('signInModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function toggleMarketplace() {
            console.log('ðŸ›’ Marketplace button clicked!');
            const panel = document.getElementById('marketplacePanel');
            console.log('Panel found:', panel);
            const isVisible = panel.style.display === 'block';
            console.log('Is visible:', isVisible);
            
            if (!isVisible) {
                console.log('Updating marketplace...');
                updateMarketplace();
            }
            
            panel.style.display = isVisible ? 'none' : 'block';
            console.log('Panel display set to:', panel.style.display);
        }
        
        function updateMarketplace() {
            console.log('ðŸ›’ Updating marketplace...');
            console.log('Marketplace coins:', game.marketplace.coins);
            
            // Update coins display
            const coinsElement = document.getElementById('marketplaceCoins');
            console.log('Coins element found:', coinsElement);
            if (coinsElement) {
                coinsElement.textContent = game.marketplace.coins;
            }
            
            // Update hats grid
            updateHatsGrid();
            
            // Update skins grid
            updateSkinsGrid();
            
            // Update abilities grid
            updateAbilitiesGrid();
        }
        
        function updateHatsGrid() {
            console.log('ðŸ¦‰ Updating hats grid...');
            const grid = document.getElementById('hatsGrid');
            console.log('Hats grid element found:', grid);
            if (!grid) {
                console.error('Hats grid element not found!');
                return;
            }
            
            if (!marketplaceItems || !marketplaceItems.hats) {
                console.error('Marketplace items not defined!');
                return;
            }
            
            grid.innerHTML = '';
            console.log('Marketplace hats:', marketplaceItems.hats);
            
            marketplaceItems.hats.forEach(hat => {
                const hatElement = document.createElement('div');
                hatElement.className = `marketplace-item ${hat.owned ? 'owned' : 'unowned'}`;
                hatElement.style.cssText = `
                    background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(26,26,46,0.6));
                    border: 2px solid ${hat.owned ? 'rgba(76,175,80,0.6)' : 'rgba(255,215,0,0.4)'};
                    border-radius: 20px;
                    padding: 25px;
                    text-align: center;
                    cursor: pointer;
                    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                    position: relative;
                    overflow: hidden;
                    backdrop-filter: blur(10px);
                    ${hat.equipped ? 'box-shadow: 0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3);' : 'box-shadow: 0 4px 15px rgba(0,0,0,0.2);'}
                `;
                
                // Add hover effects
                hatElement.addEventListener('mouseenter', () => {
                    hatElement.style.transform = 'translateY(-8px) scale(1.02)';
                    hatElement.style.boxShadow = hat.equipped ? 
                        '0 0 40px rgba(76,175,80,0.8), 0 12px 35px rgba(0,0,0,0.4)' : 
                        '0 8px 25px rgba(0,0,0,0.4), 0 0 20px rgba(255,215,0,0.3)';
                });
                
                hatElement.addEventListener('mouseleave', () => {
                    hatElement.style.transform = 'translateY(0) scale(1)';
                    hatElement.style.boxShadow = hat.equipped ? 
                        '0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3)' : 
                        '0 4px 15px rgba(0,0,0,0.2)';
                });
                
                // Add dark overlay for unowned items
                if (!hat.owned) {
                    const darkOverlay = document.createElement('div');
                    darkOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.6);
                        pointer-events: none;
                        z-index: 1;
                        border-radius: 18px;
                    `;
                    hatElement.appendChild(darkOverlay);
                }
                
                const contentDiv = document.createElement('div');
                contentDiv.style.cssText = `
                    position: relative;
                    z-index: 2;
                `;
                
                contentDiv.innerHTML = `
                    <div style="margin-bottom: 20px; text-align: center; position: relative;">
                        <div style="width: 80px; height: 80px; margin: 0 auto; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border-radius: 15px; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255,255,255,0.1);">
                            <img src="${hat.image}" alt="${hat.name}" style="width: 60px; height: 60px; object-fit: contain; filter: ${hat.owned ? 'none' : 'brightness(0.3) grayscale(0.5)'}; border-radius: 8px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display: none; font-size: 40px; filter: ${hat.owned ? 'none' : 'brightness(0.3)'};">ðŸ¦‰</div>
                    </div>
                        ${hat.equipped ? '<div style="position: absolute; top: -5px; right: -5px; background: #4CAF50; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">âœ“</div>' : ''}
                    </div>
                    <div style="font-size: 18px; margin-bottom: 10px; filter: ${hat.owned ? 'none' : 'brightness(0.4)'}; color: ${hat.owned ? '#FFD700' : '#999'}; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">${hat.name}</div>
                    <div style="font-size: 13px; color: ${hat.owned ? '#00FFFF' : '#666'}; margin-bottom: 20px; line-height: 1.4; opacity: 0.9;">${hat.description}</div>
                    <div style="font-size: 16px; color: ${hat.owned ? '#4CAF50' : '#FFD700'}; margin-bottom: 20px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                        ${hat.owned ? 'âœ“ OWNED' : `${hat.price} ðŸª™`}
                    </div>
                    ${hat.owned ? 
                        `<button onclick="equipHat('${hat.id}')" style="background: ${hat.equipped ? 'linear-gradient(135deg, #4CAF50, #45a049)' : 'linear-gradient(135deg, #2196F3, #1976D2)'}; color: white; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            ${hat.equipped ? 'âœ“ EQUIPPED' : 'EQUIP'}
                        </button>` :
                        `<button onclick="buyHat('${hat.id}')" style="background: ${game.marketplace.coins >= hat.price ? 'linear-gradient(135deg, #FFD700, #FFA500)' : 'linear-gradient(135deg, #666666, #444444)'}; color: ${game.marketplace.coins >= hat.price ? '#000' : '#999'}; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            ${game.marketplace.coins >= hat.price ? 'ðŸ›’ BUY' : 'âŒ NOT ENOUGH COINS'}
                        </button>`
                    }
                `;
                
                hatElement.appendChild(contentDiv);
                grid.appendChild(hatElement);
            });
        }
        
        function updateSkinsGrid() {
            console.log('ðŸ¦¦ Updating skins grid...');
            const grid = document.getElementById('skinsGrid');
            console.log('Skins grid element found:', grid);
            if (!grid) {
                console.error('Skins grid element not found!');
                return;
            }
            
            if (!marketplaceItems || !marketplaceItems.skins) {
                console.error('Marketplace items not defined!');
                return;
            }
            
            grid.innerHTML = '';
            console.log('Marketplace skins:', marketplaceItems.skins);
            
            marketplaceItems.skins.forEach(skin => {
                const skinElement = document.createElement('div');
                skinElement.className = `marketplace-item ${skin.owned ? 'owned' : 'unowned'}`;
                skinElement.style.cssText = `
                    background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(26,26,46,0.6));
                    border: 2px solid ${skin.owned ? 'rgba(76,175,80,0.6)' : 'rgba(255,215,0,0.4)'};
                    border-radius: 20px;
                    padding: 25px;
                    text-align: center;
                    cursor: pointer;
                    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                    position: relative;
                    overflow: hidden;
                    backdrop-filter: blur(10px);
                    ${skin.equipped ? 'box-shadow: 0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3);' : 'box-shadow: 0 4px 15px rgba(0,0,0,0.2);'}
                `;
                
                // Add hover effects
                skinElement.addEventListener('mouseenter', () => {
                    skinElement.style.transform = 'translateY(-8px) scale(1.02)';
                    skinElement.style.boxShadow = skin.equipped ? 
                        '0 0 40px rgba(76,175,80,0.8), 0 12px 35px rgba(0,0,0,0.4)' : 
                        '0 8px 25px rgba(0,0,0,0.4), 0 0 20px rgba(255,215,0,0.3)';
                });
                
                skinElement.addEventListener('mouseleave', () => {
                    skinElement.style.transform = 'translateY(0) scale(1)';
                    skinElement.style.boxShadow = skin.equipped ? 
                        '0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3)' : 
                        '0 4px 15px rgba(0,0,0,0.2)';
                });
                
                // Add dark overlay for unowned items
                if (!skin.owned) {
                    const darkOverlay = document.createElement('div');
                    darkOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.6);
                        pointer-events: none;
                        z-index: 1;
                        border-radius: 18px;
                    `;
                    skinElement.appendChild(darkOverlay);
                }
                
                const contentDiv = document.createElement('div');
                contentDiv.style.cssText = `
                    position: relative;
                    z-index: 2;
                `;
                
                contentDiv.innerHTML = `
                    <div style="margin-bottom: 20px; text-align: center; position: relative;">
                        <div style="width: 80px; height: 80px; margin: 0 auto; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border-radius: 15px; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255,255,255,0.1);">
                            <img src="${skin.image}" alt="${skin.name}" style="width: 60px; height: 60px; object-fit: contain; filter: ${skin.owned ? 'none' : 'brightness(0.3) grayscale(0.5)'}; border-radius: 8px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display: none; font-size: 40px; filter: ${skin.owned ? 'none' : 'brightness(0.3)'};">ðŸ¦¦</div>
                    </div>
                        ${skin.equipped ? '<div style="position: absolute; top: -5px; right: -5px; background: #4CAF50; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">âœ“</div>' : ''}
                    </div>
                    <div style="font-size: 18px; margin-bottom: 10px; filter: ${skin.owned ? 'none' : 'brightness(0.4)'}; color: ${skin.owned ? '#FFD700' : '#999'}; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">${skin.name}</div>
                    <div style="font-size: 13px; color: ${skin.owned ? '#00FFFF' : '#666'}; margin-bottom: 20px; line-height: 1.4; opacity: 0.9;">${skin.description}</div>
                    <div style="font-size: 16px; color: ${skin.owned ? '#4CAF50' : '#FFD700'}; margin-bottom: 20px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                        ${skin.owned ? 'âœ“ OWNED' : (skin.unlockType === 'achievement' ? 'ðŸ”’ ACHIEVEMENT' : `${skin.price} ðŸª™`)}
                    </div>
                    ${skin.owned ? 
                        `<button onclick="equipSkin('${skin.id}')" style="background: ${skin.equipped ? 'linear-gradient(135deg, #4CAF50, #45a049)' : 'linear-gradient(135deg, #2196F3, #1976D2)'}; color: white; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            ${skin.equipped ? 'âœ“ EQUIPPED' : 'EQUIP'}
                        </button>` :
                        (skin.unlockType === 'achievement' ? 
                            `<button style="background: linear-gradient(135deg, #666666, #444444); color: #999; border: none; padding: 12px 20px; border-radius: 12px; cursor: not-allowed; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                                ðŸ”’ LOCKED
                            </button>` :
                            `<button onclick="buySkin('${skin.id}')" style="background: ${game.marketplace.coins >= skin.price ? 'linear-gradient(135deg, #FFD700, #FFA500)' : 'linear-gradient(135deg, #666666, #444444)'}; color: ${game.marketplace.coins >= skin.price ? '#000' : '#999'}; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                                ${game.marketplace.coins >= skin.price ? 'ðŸ›’ BUY' : 'âŒ NOT ENOUGH COINS'}
                            </button>`
                        )
                    }
                `;
                
                skinElement.appendChild(contentDiv);
                grid.appendChild(skinElement);
            });
        }
        
        function updateAbilitiesGrid() {
            console.log('âš¡ Updating abilities grid...');
            const grid = document.getElementById('abilitiesGrid');
            console.log('Abilities grid element found:', grid);
            if (!grid) {
                console.error('Abilities grid element not found!');
                return;
            }
            
            if (!marketplaceItems || !marketplaceItems.abilities) {
                console.error('Marketplace abilities not defined!');
                return;
            }
            
            grid.innerHTML = '';
            console.log('Marketplace abilities:', marketplaceItems.abilities);
            
            marketplaceItems.abilities.forEach(ability => {
                const abilityElement = document.createElement('div');
                abilityElement.className = `marketplace-item ${ability.owned ? 'owned' : 'unowned'}`;
                abilityElement.style.cssText = `
                    background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(26,26,46,0.6));
                    border: 2px solid ${ability.owned ? 'rgba(76,175,80,0.6)' : 'rgba(255,107,53,0.4)'};
                    border-radius: 20px;
                    padding: 25px;
                    text-align: center;
                    cursor: pointer;
                    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                    position: relative;
                    overflow: hidden;
                    backdrop-filter: blur(10px);
                    ${ability.equipped ? 'box-shadow: 0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3);' : 'box-shadow: 0 4px 15px rgba(0,0,0,0.2);'}
                `;
                
                // Add hover effects
                abilityElement.addEventListener('mouseenter', () => {
                    abilityElement.style.transform = 'translateY(-8px) scale(1.02)';
                    abilityElement.style.boxShadow = ability.equipped ? 
                        '0 0 40px rgba(76,175,80,0.8), 0 12px 35px rgba(0,0,0,0.4)' : 
                        '0 8px 25px rgba(0,0,0,0.4), 0 0 20px rgba(255,107,53,0.3)';
                });
                
                abilityElement.addEventListener('mouseleave', () => {
                    abilityElement.style.transform = 'translateY(0) scale(1)';
                    abilityElement.style.boxShadow = ability.equipped ? 
                        '0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3)' : 
                        '0 4px 15px rgba(0,0,0,0.2)';
                });
                
                // Add dark overlay for unowned items
                if (!ability.owned) {
                    const darkOverlay = document.createElement('div');
                    darkOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.6);
                        pointer-events: none;
                        z-index: 1;
                        border-radius: 18px;
                    `;
                    abilityElement.appendChild(darkOverlay);
                }
                
                const contentDiv = document.createElement('div');
                contentDiv.style.cssText = `
                    position: relative;
                    z-index: 2;
                `;
                
                contentDiv.innerHTML = `
                    <div style="margin-bottom: 20px; text-align: center; position: relative;">
                        <div style="width: 80px; height: 80px; margin: 0 auto; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border-radius: 15px; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255,255,255,0.1);">
                            <img src="${ability.image}" alt="${ability.name}" style="width: 60px; height: 60px; object-fit: contain; filter: ${ability.owned ? 'none' : 'brightness(0.3) grayscale(0.5)'}; border-radius: 8px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display: none; font-size: 40px; filter: ${ability.owned ? 'none' : 'brightness(0.3)'};">âš¡</div>
                    </div>
                        ${ability.equipped ? '<div style="position: absolute; top: -5px; right: -5px; background: #4CAF50; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">âœ“</div>' : ''}
                    </div>
                    <div style="font-size: 18px; margin-bottom: 10px; filter: ${ability.owned ? 'none' : 'brightness(0.4)'}; color: ${ability.owned ? '#FFD700' : '#999'}; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">${ability.name}</div>
                    <div style="font-size: 13px; color: ${ability.owned ? '#00FFFF' : '#666'}; margin-bottom: 20px; line-height: 1.4; opacity: 0.9;">
                        ${ability.id === 'armor' && player.hasArmorBoost ? 
                            `Level ${player.armorLevel} (+${player.armorLevel * 25}% armor)` : 
                            ability.description}
                    </div>
                    <div style="font-size: 16px; color: ${ability.owned ? '#4CAF50' : '#FFD700'}; margin-bottom: 20px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                        ${ability.owned ? 'âœ“ OWNED' : `${ability.price} ðŸª™`}
                    </div>
                    ${ability.owned ? 
                        `<button onclick="equipAbility('${ability.id}')" style="background: ${ability.equipped ? 'linear-gradient(135deg, #4CAF50, #45a049)' : 'linear-gradient(135deg, #FF6B35, #F7931E)'}; color: white; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            ${ability.equipped ? 'âœ“ EQUIPPED' : 'EQUIP'}
                        </button>` :
                        `<button onclick="buyAbility('${ability.id}')" style="background: ${game.marketplace.coins >= ability.price ? 'linear-gradient(135deg, #FFD700, #FFA500)' : 'linear-gradient(135deg, #666666, #444444)'}; color: ${game.marketplace.coins >= ability.price ? '#000' : '#999'}; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            ${game.marketplace.coins >= ability.price ? 'ðŸ›’ BUY' : 'âŒ NOT ENOUGH COINS'}
                        </button>`
                    }
                `;
                
                abilityElement.appendChild(contentDiv);
                grid.appendChild(abilityElement);
            });
        }
        
        function switchMarketplaceTab(tab) {
            const hatsTab = document.getElementById('hatsTab');
            const skinsTab = document.getElementById('skinsTab');
            const abilitiesTab = document.getElementById('abilitiesTab');
            const hatsBtn = document.getElementById('hatsTabBtn');
            const skinsBtn = document.getElementById('skinsTabBtn');
            const abilitiesBtn = document.getElementById('abilitiesTabBtn');
            
            // Hide all tabs
            hatsTab.style.display = 'none';
            skinsTab.style.display = 'none';
            abilitiesTab.style.display = 'none';
            
            // Remove active class from all buttons and reset styles
            [hatsBtn, skinsBtn, abilitiesBtn].forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.3), rgba(0,0,0,0.1))';
                btn.style.color = '#999';
                btn.style.border = '2px solid rgba(255,255,255,0.1)';
            });
            
            if (tab === 'hats') {
                hatsTab.style.display = 'block';
                hatsBtn.classList.add('active');
                hatsBtn.style.background = 'linear-gradient(135deg, rgba(76,175,80,0.2), rgba(76,175,80,0.1))';
                hatsBtn.style.color = '#4CAF50';
                hatsBtn.style.border = '2px solid rgba(76,175,80,0.4)';
            } else if (tab === 'skins') {
                skinsTab.style.display = 'block';
                skinsBtn.classList.add('active');
                skinsBtn.style.background = 'linear-gradient(135deg, rgba(33,150,243,0.2), rgba(33,150,243,0.1))';
                skinsBtn.style.color = '#2196F3';
                skinsBtn.style.border = '2px solid rgba(33,150,243,0.4)';
            } else if (tab === 'abilities') {
                abilitiesTab.style.display = 'block';
                abilitiesBtn.classList.add('active');
                abilitiesBtn.style.background = 'linear-gradient(135deg, rgba(255,107,53,0.2), rgba(255,107,53,0.1))';
                abilitiesBtn.style.color = '#FF6B35';
                abilitiesBtn.style.border = '2px solid rgba(255,107,53,0.4)';
            }
        }
        
        function buyHat(hatId) {
            const hat = marketplaceItems.hats.find(h => h.id === hatId);
            if (hat && game.marketplace.coins >= hat.price) {
                game.marketplace.coins -= hat.price;
                hat.owned = true;
                game.marketplace.ownedHats.push(hatId);
                updateMarketplace();
                saveMarketplaceData();
                
                // Check for marketplace achievements
                unlockAchievement('marketplace_shopper');
                
                // Check for hat collector achievement
                if (game.marketplace.ownedHats.length >= 4) { // 3 hats + 'none'
                    unlockAchievement('hat_collector');
                }
            }
        }
        
        function buySkin(skinId) {
            const skin = marketplaceItems.skins.find(s => s.id === skinId);
            if (skin && game.marketplace.coins >= skin.price) {
                game.marketplace.coins -= skin.price;
                skin.owned = true;
                game.marketplace.ownedSkins.push(skinId);
                updateMarketplace();
                saveMarketplaceData();
                
                // Check for marketplace achievements
                unlockAchievement('marketplace_shopper');
                
                // Check for skin collector achievement
                if (game.marketplace.ownedSkins.length >= 4) { // 3 skins + 'default'
                    unlockAchievement('skin_collector');
                }
            }
        }
        
        function equipHat(hatId) {
            // Unequip current hat
            marketplaceItems.hats.forEach(hat => hat.equipped = false);
            
            // Equip new hat
            const hat = marketplaceItems.hats.find(h => h.id === hatId);
            if (hat) {
                hat.equipped = true;
                game.marketplace.currentHat = hatId;
                game.aiBot.currentHat = hatId;
            }
            
            updateMarketplace();
            saveMarketplaceData();
        }
        
        function equipSkin(skinId) {
            // Unequip current skin
            marketplaceItems.skins.forEach(skin => skin.equipped = false);
            
            // Equip new skin
            const skin = marketplaceItems.skins.find(s => s.id === skinId);
            if (skin) {
                skin.equipped = true;
                game.marketplace.currentSkin = skinId;
            }
            
            updateMarketplace();
            saveMarketplaceData();
        }
        
        function buyAbility(abilityId) {
            const ability = marketplaceItems.abilities.find(a => a.id === abilityId);
            if (ability && game.marketplace.coins >= ability.price) {
                game.marketplace.coins -= ability.price;
                ability.owned = true;
                game.marketplace.ownedAbilities.push(abilityId);
                updateMarketplace();
                saveMarketplaceData();
                
                // Check for marketplace achievements
                unlockAchievement('marketplace_shopper');
            }
        }
        
        function equipAbility(abilityId) {
            const ability = marketplaceItems.abilities.find(a => a.id === abilityId);
            if (ability && ability.owned) {
                // Toggle ability (can equip multiple abilities)
                if (ability.equipped) {
                    ability.equipped = false;
                    game.marketplace.currentAbilities = game.marketplace.currentAbilities.filter(id => id !== abilityId);
                } else {
                    ability.equipped = true;
                    game.marketplace.currentAbilities.push(abilityId);
                }
                
                updateMarketplace();
                saveMarketplaceData();
            }
        }
        
        function saveGameState() {
            try {
                const gameState = {
                    level: game.level,
                    score: game.score,
                    lives: game.lives,
                    gameState: game.gameState,
                    playerHealth: player.health,
                    playerMaxHealth: player.maxHealth,
                    checkpointProgress: game.checkpointProgress,
                    timestamp: Date.now()
                };
                localStorage.setItem('otterBrosGameState', JSON.stringify(gameState));
                console.log('ðŸ’¾ Saved game state to local storage - Level:', game.level, 'Health:', player.health);
                
                // Update continue button visibility after saving
                updateContinueButtonVisibility();
            } catch (error) {
                console.error('âŒ Error saving game state:', error);
            }
        }
        
        function loadGameState() {
            try {
                const savedState = localStorage.getItem('otterBrosGameState');
                if (savedState) {
                    const gameState = JSON.parse(savedState);
                    
                    // Check if saved state is recent (within 24 hours)
                    const timeDiff = Date.now() - gameState.timestamp;
                    const maxAge = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
                    
                    if (timeDiff < maxAge) {
                        game.level = gameState.level || 1;
                        game.score = gameState.score || 0;
                        game.lives = gameState.lives || 3;
                        game.gameState = gameState.gameState || 'menu';
                        game.savedPlayerHealth = gameState.playerHealth || player.maxHealth;
                        game.savedPlayerMaxHealth = gameState.playerMaxHealth || 100;
                        game.checkpointProgress = gameState.checkpointProgress || {};
                        
                        console.log('ðŸ“Š Loaded game state from local storage - Level:', game.level, 'Health:', game.savedPlayerHealth);
                        return true;
                    } else {
                        console.log('â° Saved game state is too old, starting fresh');
                        localStorage.removeItem('otterBrosGameState');
                        return false;
                    }
                }
                return false;
            } catch (error) {
                console.error('âŒ Error loading game state:', error);
                return false;
            }
        }
        
        function hasSavedGame() {
            try {
                const savedState = localStorage.getItem('otterBrosGameState');
                if (savedState) {
                    const gameState = JSON.parse(savedState);
                    const timeDiff = Date.now() - gameState.timestamp;
                    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                    return timeDiff < maxAge;
                }
                return false;
            } catch (error) {
                return false;
            }
        }
        
        function updateContinueButtonVisibility() {
            const continueBtn = document.getElementById('continueGameBtn');
            if (continueBtn) {
                if (hasSavedGame()) {
                    continueBtn.style.display = 'inline-block';
                    console.log('ðŸŽ® Saved game found - showing continue button');
                } else {
                    continueBtn.style.display = 'none';
                    console.log('ðŸ†• No saved game found - hiding continue button');
                }
            }
        }
        
        function continueGame() {
            console.log('ðŸŽ® Continuing saved game...');
            
            if (loadGameState()) {
                // Reset session-specific stats for continued game
                loadStats(); // Reset all session stats to 0
                game.coins = 0; // Reset current session coins to 0
                
                // Hide title screen
                document.getElementById('titleScreen').style.display = 'none';
                
                // Hide title screen buttons
                document.getElementById('profileBtn').style.display = 'none';
                document.getElementById('marketplaceBtn').style.display = 'none';
                document.getElementById('startGameBtn').style.display = 'none';
                document.getElementById('continueGameBtn').style.display = 'none';
                
                // Show game UI
                document.getElementById('pauseBtn').style.display = 'inline-block';
                document.getElementById('settingsBtn').style.display = 'inline-block';
                
                // Set game state to playing
                game.gameState = 'playing';
                
                // Load the saved level
                loadLevel(game.level);
                document.getElementById('level').textContent = game.level;
                
                // Restore player state after level load
                player.health = game.savedPlayerHealth || player.maxHealth;
                player.maxHealth = game.savedPlayerMaxHealth || 100;
                
                // Update UI displays (show 0 coins for fresh session)
                document.getElementById('score').textContent = game.score;
                document.getElementById('coins').textContent = '0';
                document.getElementById('lives').textContent = game.lives;
                
                // Update health bar
                updateHealthBar();
                
                console.log('âœ… Continued game from level', game.level, 'with health:', player.health, 'and fresh session stats');
            } else {
                console.log('âŒ No valid saved game found');
                startGame(); // Fallback to starting new game
            }
        }
        
        function saveMarketplaceData() {
            try {
                const marketplaceData = {
                    coins: game.marketplace.coins,
                    ownedHats: game.marketplace.ownedHats,
                    ownedSkins: game.marketplace.ownedSkins,
                    ownedAbilities: game.marketplace.ownedAbilities,
                    currentHat: game.marketplace.currentHat,
                    currentSkin: game.marketplace.currentSkin,
                    currentAbilities: game.marketplace.currentAbilities,
                    timestamp: Date.now()
                };
                localStorage.setItem('otterBrosMarketplace', JSON.stringify(marketplaceData));
                console.log('ðŸ’¾ Saved marketplace data to local storage');
            } catch (error) {
                console.error('âŒ Error saving marketplace data:', error);
            }
        }
        
        function loadMarketplaceData() {
            console.log('ðŸ›’ Loading marketplace data...');
            
            try {
                const savedData = localStorage.getItem('otterBrosMarketplace');
                if (savedData) {
                    const marketplaceData = JSON.parse(savedData);
                    console.log('ðŸ’¾ Found saved marketplace data:', marketplaceData);
                    
                    // Load saved marketplace data
                    game.marketplace.coins = marketplaceData.coins || 0;
                    game.marketplace.ownedHats = marketplaceData.ownedHats || [];
                    game.marketplace.ownedSkins = marketplaceData.ownedSkins || [];
                    game.marketplace.ownedAbilities = marketplaceData.ownedAbilities || [];
                    game.marketplace.currentHat = marketplaceData.currentHat || null;
                    game.marketplace.currentSkin = marketplaceData.currentSkin || null;
                    game.marketplace.currentAbilities = marketplaceData.currentAbilities || [];
                    
                    console.log('âœ… Loaded marketplace data successfully');
                } else {
                    console.log('ðŸ†• No saved marketplace data found, starting fresh');
                    // Reset marketplace to fresh state
                    game.marketplace.coins = 0;
                    game.marketplace.ownedHats = [];
                    game.marketplace.ownedSkins = [];
                    game.marketplace.ownedAbilities = [];
                    game.marketplace.currentHat = null;
                    game.marketplace.currentSkin = null;
                    game.marketplace.currentAbilities = [];
                }
            } catch (error) {
                console.error('âŒ Error loading marketplace data:', error);
                // Reset marketplace to fresh state on error
                game.marketplace.coins = 0;
                game.marketplace.ownedHats = [];
                game.marketplace.ownedSkins = [];
                game.marketplace.ownedAbilities = [];
                game.marketplace.currentHat = null;
                game.marketplace.currentSkin = null;
                game.marketplace.currentAbilities = [];
            }
            
            // Reset all marketplace items but keep defaults
                marketplaceItems.hats.forEach(hat => {
                if (hat.id === 'none') {
                    hat.owned = true;
                    hat.equipped = true;
                } else {
                    hat.owned = false;
                    hat.equipped = false;
                }
                });
                
                marketplaceItems.skins.forEach(skin => {
                if (skin.id === 'default') {
                    skin.owned = true;
                    skin.equipped = true;
                } else {
                    skin.owned = false;
                    skin.equipped = false;
                }
                });
                
                marketplaceItems.abilities.forEach(ability => {
                ability.owned = false;
                ability.equipped = false;
                });
            
            console.log('ðŸ†• Fresh marketplace initialized');
        }
        
        function toggleProfile() {
            console.log('ðŸ‘¤ Profile button clicked!');
            const panel = document.getElementById('profilePanel');
            const isVisible = panel.style.display === 'block';
            
            if (!isVisible) {
                updateProfileDisplay();
                updateProfile();
            }
            
            panel.style.display = isVisible ? 'none' : 'block';
        }
        
        function updateProfile() {
            console.log('ðŸ‘¤ Updating profile...');
            
            // Update profile display (handles header updates)
            updateProfileDisplay();
            
            // Update main stats
            document.getElementById('profileTotalScore').textContent = game.sessionStats.totalScore || 0;
            document.getElementById('profileLevelsCompleted').textContent = game.sessionStats.levelsCompleted || 0;
            document.getElementById('profileTotalCoins').textContent = game.marketplace.coins || 0;
            document.getElementById('profileEnemiesDefeated').textContent = game.sessionStats.crabsDefeated || 0;
            document.getElementById('profileBossesDefeated').textContent = game.sessionStats.bossesDefeated || 0;
            
            // Update detailed stats
            document.getElementById('profileGamesPlayed').textContent = game.profile.gamesPlayed || 0;
            document.getElementById('profilePlayTime').textContent = formatPlayTime(game.profile.playTime || 0);
            document.getElementById('profileBestScore').textContent = game.profile.bestScore || 0;
            document.getElementById('profileCurrentLevel').textContent = game.level || 1;
            document.getElementById('profileTreasuresFound').textContent = game.sessionStats.treasuresFound || 0;
            document.getElementById('profileKeysCollected').textContent = game.sessionStats.keysCollected || 0;
            document.getElementById('profileHealthPickups').textContent = game.sessionStats.healthPickups || 0;
            document.getElementById('profileMushroomsEaten').textContent = game.sessionStats.mushroomsEaten || 0;
            document.getElementById('profileLaserLevel').textContent = player.laserChargingLevel || 1;
            document.getElementById('profileMaxCharge').textContent = player.maxChargeLevel || 5;
            
            // Update enemy defeat breakdown
            document.getElementById('profileCrabsDefeated').textContent = game.sessionStats.crabsDefeated || 0;
            document.getElementById('profileEaglesDefeated').textContent = game.sessionStats.eaglesDefeated || 0;
            document.getElementById('profileGatorsDefeated').textContent = game.sessionStats.gatorsDefeated || 0;
            document.getElementById('profileSharksDefeated').textContent = game.sessionStats.sharksDefeated || 0;
            
            // Update XP Progress Bar
            updateProfileXPBar();
            
            // Update recent achievements
            updateRecentAchievements();
            
            // Update customization
            updateProfileCustomization();
            
            // Update achievements list
            updateAchievementsList();
            
            // Update wallet profile if wallet tab is active
            const walletTab = document.getElementById('walletTab');
            if (walletTab && walletTab.style.display !== 'none') {
                updateWalletProfile();
            }
            
            // Save session stats after updating profile
            saveSessionStats();
        }
        
        function updateProfileXPBar() {
            // Get current XP and level data
            const currentXP = player.xp || 0;
            const currentLevel = player.level || 1;
            
            // Calculate XP requirements using the same logic as the main game
            let xpForNextLevel = 0;
            let currentLevelXP = 0;
            
            if (currentLevel === 1) {
                xpForNextLevel = 1000;
                currentLevelXP = currentXP;
            } else if (currentLevel === 2) {
                xpForNextLevel = 1500; // 2500 - 1000
                currentLevelXP = currentXP - 1000;
            } else if (currentLevel === 3) {
                xpForNextLevel = 2000; // 4500 - 2500
                currentLevelXP = currentXP - 2500;
            } else if (currentLevel === 4) {
                xpForNextLevel = 2500; // 7000 - 4500
                currentLevelXP = currentXP - 4500;
            } else if (currentLevel === 5) {
                xpForNextLevel = 3000; // 10000 - 7000
                currentLevelXP = currentXP - 7000;
            } else if (currentLevel === 6) {
                xpForNextLevel = 3500; // 13500 - 10000
                currentLevelXP = currentXP - 10000;
            } else if (currentLevel === 7) {
                xpForNextLevel = 4000; // 17500 - 13500
                currentLevelXP = currentXP - 13500;
            } else if (currentLevel === 8) {
                xpForNextLevel = 4500; // 22000 - 17500
                currentLevelXP = currentXP - 17500;
            } else if (currentLevel === 9) {
                xpForNextLevel = 5000; // 27000 - 22000
                currentLevelXP = currentXP - 22000;
            } else if (currentLevel === 10) {
                xpForNextLevel = 5500; // 32500 - 27000
                currentLevelXP = currentXP - 27000;
            } else {
                // Level 10+: 1000 XP per level
                const level10Plus = currentLevel - 10;
                const baseXP = 32500 + (level10Plus * 1000);
                xpForNextLevel = 1000;
                currentLevelXP = currentXP - baseXP;
            }
            
            // Ensure currentLevelXP doesn't go negative
            currentLevelXP = Math.max(0, currentLevelXP);
            
            // Calculate progress percentage
            const progressPercentage = Math.min(100, Math.max(0, (currentLevelXP / xpForNextLevel) * 100));
            
            // Update profile XP elements
            const profilePlayerLevel = document.getElementById('profilePlayerLevel');
            const profileXpBarFill = document.getElementById('profileXpBarFill');
            const profileXpText = document.getElementById('profileXpText');
            const profileTotalXP = document.getElementById('profileTotalXP');
            const profileXpToNext = document.getElementById('profileXpToNext');
            const profileXpProgress = document.getElementById('profileXpProgress');
            
            if (profilePlayerLevel) profilePlayerLevel.textContent = currentLevel;
            if (profileXpBarFill) profileXpBarFill.style.width = `${progressPercentage}%`;
            if (profileXpText) profileXpText.textContent = `${currentLevelXP.toLocaleString()} / ${xpForNextLevel.toLocaleString()} XP`;
            if (profileTotalXP) profileTotalXP.textContent = currentXP.toLocaleString();
            if (profileXpToNext) profileXpToNext.textContent = Math.max(0, (xpForNextLevel - currentLevelXP)).toLocaleString();
            if (profileXpProgress) profileXpProgress.textContent = `${Math.round(progressPercentage)}%`;
            
            console.log(`ðŸ“Š Profile XP Updated: Level ${currentLevel}, XP: ${currentXP}, Current Level XP: ${currentLevelXP}, XP for Next: ${xpForNextLevel}, Progress: ${progressPercentage.toFixed(1)}%`);
        }
        
        // Wallet functions removed for performance
        function updateWalletProfile() {
            // Wallet system completely disabled - function does nothing
            console.log('âš ï¸ Wallet system has been removed');
            return;
            console.log('ðŸ”— Updating wallet profile...');
            
            if (!otterWallet) {
                console.log('âš ï¸ No wallet available for profile update');
                return;
            }
            
            // Check if profile elements exist
            const connectedStatus = document.getElementById('walletConnectedStatus');
            const disconnectedStatus = document.getElementById('walletDisconnectedStatus');
            const walletAddressDisplay = document.getElementById('walletAddressDisplay');
            
            console.log('ðŸ” Profile elements found:', {
                connectedStatus: !!connectedStatus,
                disconnectedStatus: !!disconnectedStatus,
                walletAddressDisplay: !!walletAddressDisplay
            });
            
            if (!connectedStatus || !disconnectedStatus || !walletAddressDisplay) {
                console.error('âŒ Profile elements not found - profile may not be open');
                return;
            }
            
            // Wallet system disabled - no wallet state
            // console.log('ðŸ“Š Wallet system disabled');
            
            // Update wallet connection status - always show disconnected
            if (false) { // Wallet system disabled
                connectedStatus.style.display = 'block';
                disconnectedStatus.style.display = 'none';
                if (false) { // Wallet system disabled
                    // walletAddressDisplay.textContent = '';
                }
            } else {
                connectedStatus.style.display = 'none';
                disconnectedStatus.style.display = 'block';
            }
            
            // Update NFT collection stats
            const totalNFTs = 0; // Wallet system disabled
            const stakedNFTs = 0; // Wallet system disabled
            const legendaryNFTs = 0; // Wallet system disabled
            const epicNFTs = 0; // Wallet system disabled
            
            document.getElementById('profileTotalNFTs').textContent = totalNFTs;
            document.getElementById('profileStakedNFTs').textContent = stakedNFTs;
            document.getElementById('profileLegendaryNFTs').textContent = legendaryNFTs;
            document.getElementById('profileEpicNFTs').textContent = epicNFTs;
            
            // Update staking rewards
            let totalEarned = 0; // Wallet system disabled
            let avgMultiplier = 1.0;
            let stakingTime = 0;
            
            if (stakedNFTs > 0) {
                const totalMultiplier = 0; // Wallet system disabled
                avgMultiplier = totalMultiplier / stakedNFTs;
                
                // Calculate total staking time
                // Wallet staking disabled
                [].forEach(nft => {
                    const stakingTime = 0; // Wallet system disabled
                    totalEarned += Math.floor(stakingTime / (1000 * 60 * 60) * nft.multiplier * 10 / 24);
                });
                
                // Get average staking time
                const stakingTimes = []; // Wallet system disabled
                if (stakingTimes.length > 0) {
                    const avgStakingTime = stakingTimes.reduce((sum, time) => sum + (Date.now() - time), 0) / stakingTimes.length;
                    stakingTime = Math.floor(avgStakingTime / (1000 * 60 * 60));
                }
            }
            
            document.getElementById('profileFishEarned').textContent = Math.floor(totalEarned);
            document.getElementById('profileStakingRate').textContent = `${Math.round(avgMultiplier * 10)}/day`;
            document.getElementById('profileAvgMultiplier').textContent = `${avgMultiplier.toFixed(1)}x`;
            document.getElementById('profileStakingTime').textContent = `${stakingTime}h`;
            
            // Update game multipliers - wallet disabled, use defaults
            const multipliers = { speed: 1.0, points: 1.0, damage: 1.0, defense: 1.0, luck: 1.0 };
            document.getElementById('profileSpeedMultiplier').textContent = `${multipliers.speed.toFixed(1)}x`;
            document.getElementById('profilePointsMultiplier').textContent = `${multipliers.points.toFixed(1)}x`;
            document.getElementById('profileDamageMultiplier').textContent = `${multipliers.damage.toFixed(1)}x`;
            document.getElementById('profileDefenseMultiplier').textContent = `${multipliers.defense.toFixed(1)}x`;
            document.getElementById('profileLuckMultiplier').textContent = `${multipliers.luck.toFixed(1)}x`;
            
            // Update active traits
            updateActiveTraitsDisplay();
            
            // Update NFT gallery
            updateNFTGallery();
            
            // Wallet system disabled - no manual load button
            if (false) { // Wallet system disabled
                // Add load NFTs button to the profile
                const profileActions = document.getElementById('profileActions');
                if (profileActions) {
                    // Check if button already exists
                    if (!document.getElementById('loadNFTsBtn')) {
                        const loadNFTsBtn = document.createElement('button');
                        loadNFTsBtn.id = 'loadNFTsBtn';
                        loadNFTsBtn.textContent = 'ðŸ”„ Load Saved NFTs';
                        loadNFTsBtn.style.cssText = `
                            background: linear-gradient(135deg, #00FFFF, #0080FF);
                            color: white;
                            border: none;
                            padding: 10px 15px;
                            border-radius: 10px;
                            cursor: pointer;
                            font-weight: bold;
                            margin: 5px;
                            transition: all 0.3s ease;
                        `;
                        
                        loadNFTsBtn.addEventListener('click', () => {
                            console.log('ðŸ”„ Manual NFT load requested...');
                            // Wallet loading disabled
                            const loaded = false; // Wallet system disabled
                                if (false) { // Wallet system disabled
                                // Wallet system removed
                                updateWalletProfile(); // Refresh the profile display
                                console.log('âœ… Manual NFT load successful!');
                            } else {
                                console.log('âš ï¸ No saved NFTs found');
                            }
                        });
                        
                        profileActions.appendChild(loadNFTsBtn);
                    }
                }
            }
        }
        
        function updateActiveTraitsDisplay() {
            const container = document.getElementById('profileActiveTraits');
            container.innerHTML = '';
            
            // Wallet system disabled - always show no traits
            const noTraitsDiv = document.createElement('div');
            noTraitsDiv.style.cssText = 'text-align: center; padding: 20px; color: #888; font-style: italic;';
            noTraitsDiv.textContent = 'Wallet system has been removed';
            container.appendChild(noTraitsDiv);
            return;
            
            // const activeTraits = []; // Wallet system disabled
            // All code below is unreachable due to return above
            /*
            if (activeTraits.length === 0) {
                const noTraitsDiv = document.createElement('div');
                noTraitsDiv.style.cssText = 'text-align: center; padding: 20px; color: #888; font-style: italic;';
                noTraitsDiv.textContent = 'No active traits found';
                container.appendChild(noTraitsDiv);
                return;
            }
            
            activeTraits.forEach(trait => {
                const traitDiv = document.createElement('div');
                traitDiv.style.cssText = 'background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center;';
                
                const perk = null; // Wallet system disabled
                const multiplier = 1.0; // Wallet system disabled
                
                traitDiv.innerHTML = `
                    <div style="font-size: 18px; margin-bottom: 8px;">${getTraitIcon(trait)}</div>
                    <div style="font-size: 14px; font-weight: bold; color: #FF6B35; margin-bottom: 5px;">${trait}</div>
                    <div style="font-size: 12px; color: #00FFFF; margin-bottom: 5px;">${multiplier.toFixed(1)}x Multiplier</div>
                    ${perk ? `<div style="font-size: 11px; color: #FFD700; opacity: 0.8;">${perk.description}</div>` : ''}
                `;
                
                container.appendChild(traitDiv);
            });
            */
        }
        
        function updateNFTGallery() {
            console.log('ðŸ–¼ï¸ Updating NFT gallery...');
            console.log('ðŸ” otterWallet exists:', !!otterWallet);
            // Wallet logging disabled
            // console.log('ðŸ” Wallet system disabled');
            
            const container = document.getElementById('profileNFTGallery');
            if (!container) {
                console.error('âŒ NFT gallery container not found');
                return;
            }
            container.innerHTML = '';
            
            // Wallet system disabled - always show no NFTs message
            const noNFTsDiv = document.createElement('div');
            noNFTsDiv.style.cssText = 'text-align: center; padding: 20px; color: #888; font-style: italic;';
            noNFTsDiv.textContent = 'Wallet system has been removed';
            container.appendChild(noNFTsDiv);
            return;
            
            // Wallet NFT gallery disabled
            /*
            [].forEach(nft => { // Wallet system disabled
                const nftCard = document.createElement('div');
                nftCard.style.cssText = 'background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; position: relative;';
                
                const isStaked = false; // Wallet system disabled
                const rarityColor = getRarityColor(nft.rarity);
                
                nftCard.innerHTML = `
                    <img src="${nft.image}" alt="${nft.name}" style="width: 100px; height: 100px; object-fit: contain; margin-bottom: 8px; border-radius: 8px;">
                    <div style="font-size: 14px; font-weight: bold; color: #FFD700; margin-bottom: 5px;">${nft.name}</div>
                    <div style="font-size: 12px; color: ${rarityColor}; margin-bottom: 5px; text-transform: capitalize;">${nft.rarity}</div>
                    <div style="font-size: 11px; color: #00FFFF; margin-bottom: 8px;">${nft.multiplier.toFixed(1)}x Multiplier</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 8px;">${nft.traits.join(', ')}</div>
                    ${isStaked ? '<div style="position: absolute; top: 5px; right: 5px; background: #4CAF50; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px;">â­ Staked</div>' : ''}
                `;
                
                container.appendChild(nftCard);
            });
            */
        }
        
        function getTraitIcon(trait) {
            const icons = {
                'Plumber-v5': 'ðŸ‘‘',
                'Plumber-v3': 'âš¡',
                'Plumber-v4': 'ðŸƒ',
                'Plumber-v2': 'ðŸ€',
                'Plumber': 'ðŸ› ï¸',
                'Overalls V3': 'ðŸ—ï¸',
                'Overalls V2': 'ðŸ”¨',
                'Pirate Hat': 'ðŸ´â€â˜ ï¸',
                'Crown': 'ðŸ‘‘',
                'Wizard Hat': 'ðŸ§™â€â™‚ï¸',
                'Golden Fur': 'âœ¨',
                'Laser Eyes': 'ðŸ‘ï¸',
                'Diamond Teeth': 'ðŸ’Ž',
                'Sunglasses': 'ðŸ˜Ž',
                'Rainbow Fur': 'ðŸŒˆ',
                'Baseball Cap': 'ðŸ§¢',
                'Beanie': 'ðŸŽ©'
            };
            return icons[trait] || 'ðŸŽ®';
        }
        
        function getRarityColor(rarity) {
            const colors = {
                'legendary': '#FFD700',
                'epic': '#FF6B35',
                'rare': '#00FFFF',
                'common': '#888'
            };
            return colors[rarity] || '#888';
        }
        
        // Wallet functions removed for performance
        function connectWalletFromProfile() {
            alert('Wallet/Staking system has been removed for performance optimization.');
        }

        function disconnectWalletFromProfile() {
            // Wallet system disabled
        }

        function refreshMetadata() {
            console.log('ðŸŒ Wallet system disabled - metadata refresh not available');
            // Wallet system completely disabled
            return;
        }

        // Wallet functions removed for performance
        function checkNFTs() {
            alert('Wallet/Staking system has been removed for performance optimization.');
            return;
            console.log('ðŸ” Checking NFTs...');
            console.log('ðŸ” otterWallet exists:', !!otterWallet);
            console.log('ðŸ” otterWallet.isConnected:', otterWallet?.isConnected);
            
            if (otterWallet && otterWallet.isConnected) {
                console.log('ðŸ‘¤ Current wallet address:', otterWallet.account);
                console.log('ðŸ“Š Current NFTs:', otterWallet.userNFTs.length);
                
                // Show detailed NFT information
                console.log('ðŸ¦¦ NFT Details:');
                if (otterWallet.userNFTs.length > 0) {
                    otterWallet.userNFTs.forEach((nft, index) => {
                        console.log(`  ${index + 1}. Token #${nft.tokenId}: ${nft.name}`);
                        console.log(`     Traits: ${nft.traits.join(', ')}`);
                        console.log(`     Rarity: ${nft.rarity}`);
                        console.log(`     Multiplier: ${nft.multiplier}x`);
                    });
                } else {
                    console.log('  No NFTs found in wallet');
                }
                
                // Update the profile display
                try {
                    updateWalletProfile();
                    console.log('âœ… NFT check completed');
                } catch (error) {
                    console.error('âŒ Error updating profile:', error);
                }
            } else {
                console.log('âš ï¸ Wallet not connected, cannot check NFTs');
                if (!otterWallet) {
                    console.error('âŒ OtterWallet not initialized');
                } else if (!otterWallet.isConnected) {
                    console.log('ðŸ’¡ Try connecting your wallet first');
                }
            }
        }

        function scanAllOtterfulOtters() {
            console.log('ðŸ” Scanning all 2222 Otterful Otters...');
            console.log('ðŸ” otterWallet exists:', !!otterWallet);
            console.log('ðŸ” otterWallet.isConnected:', otterWallet?.isConnected);
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            // Show user that scan is starting
            alert('ðŸ¦¦ Starting full scan of all 2222 Otterful Otters...\n\nThis may take 2-3 minutes due to RPC rate limiting.\n\nWatch the console for progress updates!');
            
            // This will trigger a full scan of all 2222 tokens
            otterWallet.loadNFTs().then(() => {
                console.log('âœ… Full scan completed');
                console.log(`ðŸ“Š Found ${otterWallet.userNFTs.length} NFTs`);
                try {
                    updateWalletProfile();
                    alert(`âœ… Scan completed!\n\nFound ${otterWallet.userNFTs.length} NFTs in your wallet.`);
                } catch (error) {
                    console.error('âŒ Error updating profile after scan:', error);
                    alert('âš ï¸ Scan completed but failed to update profile display.');
                }
            }).catch(error => {
                console.error('âŒ Full scan failed:', error);
                alert('âŒ Scan failed. Check console for details and try again.');
            });
        }

        // Test function to verify buttons are working
        function testProfileButton() {
            console.log('ðŸ§ª Profile button test - this function is working!');
            alert('Profile button test - this function is working!');
        }

        function showNFTLoadingNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #2196F3, #1976D2);
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                z-index: 10000;
                font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
                font-size: 14px;
                max-width: 300px;
                animation: slideInRight 0.5s ease-out;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px;">ðŸ”„ Loading NFTs...</div>
                <div style="font-size: 12px;">Your NFTs are being loaded in the background while you play!</div>
            `;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, 3000);
        }

        function showNFTLoadedNotification(nftCount) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #4CAF50, #45a049);
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                z-index: 10000;
                font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
                font-size: 14px;
                max-width: 300px;
                animation: slideInRight 0.5s ease-out;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px;">âœ… NFTs Loaded!</div>
                <div style="font-size: 12px;">Found ${nftCount} NFTs - bonuses applied!</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, 4000);
        }

        // Function to check if profile is accessible
        function checkProfileAccess() {
            console.log('ðŸ” Checking profile access...');
            const profileElements = [
                'walletConnectedStatus',
                'walletDisconnectedStatus', 
                'walletAddressDisplay',
                'profileTotalNFTs',
                'profileStakedNFTs'
            ];
            
            const results = {};
            profileElements.forEach(id => {
                const element = document.getElementById(id);
                results[id] = !!element;
                console.log(`  ${id}: ${!!element}`);
            });
            
            const allFound = Object.values(results).every(found => found);
            console.log(`âœ… Profile accessible: ${allFound}`);
            
            if (!allFound) {
                console.log('âš ï¸ Some profile elements not found - profile may not be open');
                alert('Profile elements not found. Make sure the Profile â†’ Wallet tab is open!');
            }
            
            return allFound;
        }

        // Function to manually test NFT loading
        function testNFTLoading() {
            console.log('ðŸ§ª Testing NFT loading...');
            console.log('ðŸ” otterWallet exists:', !!otterWallet);
            console.log('ðŸ” otterWallet.isConnected:', otterWallet?.isConnected);
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                alert('Please connect your wallet first!');
                return;
            }
            
            console.log('ðŸ‘¤ Wallet address:', otterWallet.account);
            console.log('ðŸ“Š Current NFTs:', otterWallet.userNFTs.length);
            console.log('ðŸ¦¦ Current NFT data:', otterWallet.userNFTs);
            
            // Test balance
            otterWallet.getTokenBalance().then(balance => {
                console.log('ðŸ’° Token balance:', balance);
                
                if (balance > 0) {
                    console.log('âœ… Balance found, testing token scanning...');
                    // Test scanning first 10 tokens
                    testTokenScanning(10);
                } else {
                    console.log('âš ï¸ No tokens found in balance');
                    alert('No tokens found in wallet balance. This might be a contract issue.');
                }
            }).catch(error => {
                console.error('âŒ Error getting balance:', error);
                alert('Error getting token balance: ' + error.message);
            });
        }

        // Function to test token scanning
        async function testTokenScanning(maxTokens = 10) {
            console.log(`ðŸ§ª Testing token scanning (first ${maxTokens} tokens)...`);
            
            for (let i = 0; i < maxTokens; i++) {
                try {
                    const owner = await otterWallet.getTokenOwner(i);
                    console.log(`Token ${i}: ${owner}`);
                    
                    if (owner && owner.toLowerCase() === otterWallet.account.toLowerCase()) {
                        console.log(`âœ… Found owned token: ${i}`);
                        alert(`Found owned token: ${i}!`);
                        return;
                    }
                } catch (error) {
                    console.log(`âŒ Error checking token ${i}:`, error.message);
                }
                
                // Small delay to prevent RPC overload
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            console.log('âš ï¸ No owned tokens found in first', maxTokens, 'tokens');
            alert(`No owned tokens found in first ${maxTokens} tokens. Your NFTs might be in higher token IDs.`);
        }

        // Function to test local metadata system
        async function testLocalMetadata() {
            console.log('ðŸ§ª Testing local metadata system...');
            
            // Test if metadata files are accessible at all
            console.log('ðŸ” Testing metadata file accessibility...');
            const testUrls = [
                './metadata/1499.json',
                '/metadata/1499.json',
                'metadata/1499.json'
            ];
            
            for (const url of testUrls) {
                try {
                    console.log(`ðŸ“„ Testing URL: ${url}`);
                    const response = await fetch(url);
                    console.log(`ðŸ“„ Response for ${url}:`, response.status, response.statusText);
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`âœ… Successfully loaded from ${url}:`, data);
                    } else {
                        console.log(`âŒ Failed to load from ${url}:`, response.status, response.statusText);
                    }
                } catch (error) {
                    console.log(`âŒ Error testing ${url}:`, error.message);
                }
            }
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                alert('Please connect your wallet first!');
                return;
            }
            
            // Test loading a few local metadata files
            const testTokens = [1499, 1000, 500, 1];
            
            for (const tokenId of testTokens) {
                try {
                    console.log(`ðŸ§ª Testing local metadata for token ${tokenId}...`);
                    const metadata = await otterWallet.getLocalTokenMetadata(tokenId);
                    console.log(`âœ… Token ${tokenId} metadata:`, metadata);
                    
                    if (metadata && metadata.attributes) {
                        console.log(`ðŸŽ¨ Token ${tokenId} traits:`, metadata.attributes);
                    }
                } catch (error) {
                    console.error(`âŒ Error testing token ${tokenId}:`, error);
                }
            }
            
            alert('Local metadata test completed! Check console for results.');
        }

        // Function to test local NFT loading without blockchain
        async function testLocalNFTLoading() {
            console.log('ðŸ§ª Testing local NFT loading without blockchain...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                alert('Please connect your wallet first!');
                return;
            }
            
            console.log('ðŸ”„ Testing local NFT loading system...');
            
            // Test the local loading system directly
            try {
                await otterWallet.loadUserNFTsWithMetadata(4);
                console.log('âœ… Local NFT loading completed!');
                console.log('ðŸ“Š Loaded NFTs:', otterWallet.userNFTs);
                
                if (otterWallet.userNFTs.length > 0) {
                    alert(`âœ… Successfully loaded ${otterWallet.userNFTs.length} NFTs using local metadata!\n\nCheck console for details.`);
                    updateWalletProfile();
                } else {
                    alert('âš ï¸ No NFTs loaded. Check console for details.');
                }
            } catch (error) {
                console.error('âŒ Error in local NFT loading:', error);
                alert('âŒ Error loading NFTs. Check console for details.');
            }
        }

        // Function to enable blockchain scanning (for advanced users)
        async function enableBlockchainScanning() {
            console.log('ðŸ”— Enabling blockchain scanning...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                alert('Please connect your wallet first!');
                return;
            }
            
            const confirmed = confirm('âš ï¸ WARNING: This will scan the blockchain for your owned NFTs.\n\nThis may cause RPC errors and take a long time.\n\nAre you sure you want to continue?');
            
            if (!confirmed) {
                console.log('âŒ Blockchain scanning cancelled by user');
                return;
            }
            
            console.log('ðŸ” Starting blockchain scan for owned NFTs...');
            
            try {
                // Temporarily enable blockchain scanning
                const originalGetOwnedTokenIds = otterWallet.getOwnedTokenIds;
                
                otterWallet.getOwnedTokenIds = async function() {
                    console.log('ðŸ” BLOCKCHAIN SCANNING ENABLED - Scanning for owned tokens...');
                    
                    const tokenIds = [];
                    const TOTAL_OTTERS = 2222;
                    const BATCH_SIZE = 100; // Smaller batches to reduce errors
                    
                    for (let i = 0; i < TOTAL_OTTERS; i += BATCH_SIZE) {
                        const endToken = Math.min(i + BATCH_SIZE, TOTAL_OTTERS);
                        console.log(`ðŸ“¦ Scanning tokens ${i}-${endToken - 1}...`);
                        
                        for (let j = i; j < endToken; j++) {
                            try {
                                const owner = await this.getTokenOwner(j);
                                if (owner && owner.toLowerCase() === this.account.toLowerCase()) {
                                    console.log(`âœ… Found owned token: ${j}`);
                                    tokenIds.push(j);
                                }
                                
                                // Add delay every 10 calls
                                if ((j - i) % 10 === 0 && (j - i) > 0) {
                                    await new Promise(resolve => setTimeout(resolve, 1000));
                                }
                            } catch (error) {
                                console.log(`âŒ Error checking token ${j}:`, error.message);
                                // Continue scanning even if some tokens fail
                            }
                        }
                        
                        // Pause between batches
                        if (endToken < TOTAL_OTTERS) {
                            console.log('â³ Pausing between batches...');
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        }
                    }
                    
                    console.log('ðŸ“Š Blockchain scan completed. Found tokens:', tokenIds);
                    return tokenIds;
                };
                
                // Load NFTs with blockchain scanning
                await otterWallet.loadUserNFTsWithMetadata(4);
                
                // Restore original function
                otterWallet.getOwnedTokenIds = originalGetOwnedTokenIds;
                
                console.log('âœ… Blockchain scanning completed!');
                console.log('ðŸ“Š Loaded NFTs:', otterWallet.userNFTs);
                
                if (otterWallet.userNFTs.length > 0) {
                    alert(`âœ… Successfully loaded ${otterWallet.userNFTs.length} NFTs from blockchain!\n\nCheck console for details.`);
                    updateWalletProfile();
                } else {
                    alert('âš ï¸ No NFTs found in blockchain scan. Check console for details.');
                }
            } catch (error) {
                console.error('âŒ Error in blockchain scanning:', error);
                alert('âŒ Error during blockchain scan. Check console for details.');
            }
        }

        // Function to stake all NFTs (simulated for now)
        // Wallet functions removed for performance
        async function stakeAllNFTs() {
            alert('Wallet/Staking system has been removed for performance optimization.');
            return;
            console.log('ðŸ”’ Staking all NFTs (simulated)...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                alert('Please connect your wallet first!');
                return;
            }
            
            if (otterWallet.userNFTs.length === 0) {
                alert('No NFTs available to stake!');
                return;
            }
            
            const confirmed = confirm(`ðŸ”’ STAKE ALL NFTS?\n\nThis will stake ${otterWallet.userNFTs.length} NFTs (simulated).\n\nNFTs will earn $FISH rewards but cannot be traded while staked.\n\nAre you sure you want to continue?`);
            
            if (!confirmed) {
                console.log('âŒ Staking cancelled by user');
                return;
            }
            
            console.log('ðŸ”’ Starting simulated staking...');
            
            try {
                const tokenIds = otterWallet.userNFTs.map(nft => nft.tokenId);
                const stakedCount = otterWallet.simulateStakeMultiple(tokenIds);
                
                console.log('âœ… All NFTs staked successfully!');
                alert(`âœ… Successfully staked ${stakedCount} NFTs!\n\nYour NFTs are now earning $FISH rewards.`);
                updateWalletProfile();
                
            } catch (error) {
                console.error('âŒ Error staking NFTs:', error);
                alert(`âŒ Error staking NFTs: ${error.message}`);
            }
        }

        // Function to claim all staking rewards
        // Wallet functions removed for performance
        async function claimAllRewards() {
            alert('Wallet/Staking system has been removed for performance optimization.');
            return;
            console.log('ðŸ’° Claiming all staking rewards...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                alert('Please connect your wallet first!');
                return;
            }
            
            if (otterWallet.stakedNFTs.length === 0) {
                alert('No staked NFTs found!');
                return;
            }
            
            const confirmed = confirm(`ðŸ’° CLAIM REWARDS?\n\nThis will claim all accumulated $FISH rewards from staking.\n\nâš ï¸ WARNING: This requires a staking contract to be deployed!\n\nAre you sure you want to continue?`);
            
            if (!confirmed) {
                console.log('âŒ Claim cancelled by user');
                return;
            }
            
            console.log('ðŸ’° Claiming staking rewards...');
            
            try {
                await otterWallet.claimRewards();
                console.log('âœ… Rewards claimed successfully!');
                alert('âœ… Rewards claimed successfully!\n\nCheck your wallet for transaction confirmation.');
                updateWalletProfile();
                
            } catch (error) {
                console.error('âŒ Error claiming rewards:', error);
                alert(`âŒ Error claiming rewards: ${error.message}`);
            }
        }

        // Function to convert in-game coins to $FISH
        // Wallet functions removed for performance
        function convertCoinsToFish() {
            alert('Wallet/Staking system has been removed for performance optimization.');
            return;
            console.log('ðŸª™ CONVERTING COINS TO $FISH - Starting...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                otterWallet.showMessage('Please connect your wallet first!', 'error');
                return;
            }
            
            // Get current game coins from the game state
            const currentCoins = game.sessionStats.totalCoins || 0;
            
            if (currentCoins <= 0) {
                otterWallet.showMessage('No coins to convert! Play the game to earn coins.', 'warning');
                console.log('âš ï¸ No coins available for conversion');
                return;
            }
            
            // Calculate conversion rate (5 coins = 1 $FISH for demo)
            const conversionRate = 0.2; // 1/5 = 0.2
            const fishToReceive = Math.floor(currentCoins * conversionRate);
            
            const confirmed = confirm(`ðŸª™ CONVERT COINS TO $FISH?\n\nYou have ${currentCoins} coins to convert.\n\nConversion Rate: 5 Coins = 1 $FISH\n\nYou will receive: ${fishToReceive} $FISH\n\nâš ï¸ WARNING: This is simulated - no real blockchain transaction!\n\nAre you sure you want to continue?`);
            
            if (!confirmed) {
                console.log('âŒ Conversion cancelled by user');
                return;
            }
            
            console.log(`ðŸª™ Converting ${currentCoins} coins to ${fishToReceive} $FISH...`);
            otterWallet.showMessage(`Converting ${currentCoins} coins to ${fishToReceive} $FISH...`, 'info');
            
            // Simulated conversion
            game.sessionStats.totalCoins = 0; // Reset coins
            otterWallet.fishCoins += fishToReceive; // Add $FISH to wallet
            
            // Save the updated data
            otterWallet.saveNFTsToStorage();
            
            otterWallet.showMessage(`Successfully converted ${currentCoins} coins to ${fishToReceive} $FISH! (Simulated)`, 'success');
            console.log(`âœ… Converted ${currentCoins} coins to ${fishToReceive} $FISH (simulated)`);
            
            // Update the UI to reflect the changes
            updateWalletProfile();
        }

        // Function to unstake all NFTs (easy unlock button - simulated)
        // Wallet functions removed for performance
        async function unstakeAllNFTs() {
            alert('Wallet/Staking system has been removed for performance optimization.');
            return;
            console.log('ðŸ”“ Unstaking all NFTs (simulated)...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                alert('Please connect your wallet first!');
                return;
            }
            
            if (otterWallet.stakedNFTs.length === 0) {
                alert('No staked NFTs found!');
                return;
            }
            
            const confirmed = confirm(`ðŸ”“ UNSTAKE ALL NFTS?\n\nThis will return ${otterWallet.stakedNFTs.length} NFTs from staking to your wallet.\n\nYour NFTs will no longer earn $FISH rewards but can be traded again.\n\nAre you sure you want to continue?`);
            
            if (!confirmed) {
                console.log('âŒ Unstaking cancelled by user');
                return;
            }
            
            console.log('ðŸ”“ Starting simulated unstaking...');
            
            try {
                const unstakedCount = otterWallet.simulateUnstakeAll();
                
                console.log('âœ… All NFTs unstaked successfully!');
                alert(`âœ… Successfully unstaked ${unstakedCount} NFTs!\n\nYour NFTs are now back in your wallet and can be traded.`);
                updateWalletProfile();
                
            } catch (error) {
                console.error('âŒ Error unstaking NFTs:', error);
                alert(`âŒ Error unstaking NFTs: ${error.message}`);
            }
        }

        // Function to scan for your real owned NFTs
        async function scanForMyNFTs() {
            console.log('ðŸ” Scanning for your real owned NFTs...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                alert('Please connect your wallet first!');
                return;
            }
            
            const confirmed = confirm(`ðŸ” SCAN FOR YOUR NFTS?\n\nThis will scan the blockchain for NFTs owned by your wallet address.\n\nThis may take a few minutes and may cause some RPC errors.\n\nAre you sure you want to continue?`);
            
            if (!confirmed) {
                console.log('âŒ NFT scanning cancelled by user');
                return;
            }
            
            console.log('ðŸ” Starting blockchain scan for your NFTs...');
            
            try {
                // Clear existing NFTs
                otterWallet.userNFTs = [];
                otterWallet.stakedNFTs = [];
                otterWallet.stakingStartTimes = {};
                
                // Get your real owned token IDs
                const tokenIds = await otterWallet.getOwnedTokenIds();
                console.log('âœ… Found your owned token IDs:', tokenIds);
                
                if (tokenIds.length === 0) {
                    alert('âŒ No NFTs found in your wallet!\n\nMake sure you are connected to the correct wallet and network (ApeChain).');
                    return;
                }
                
                // Load metadata for your real NFTs
                await otterWallet.loadUserNFTsWithMetadata(tokenIds.length);
                
                console.log('âœ… NFT scanning completed!');
                console.log('ðŸ“Š Your NFTs:', otterWallet.userNFTs);
                
                alert(`âœ… Successfully found ${otterWallet.userNFTs.length} NFTs in your wallet!\n\nCheck the wallet section to see your NFTs.`);
                updateWalletProfile();
                
            } catch (error) {
                console.error('âŒ Error scanning for NFTs:', error);
                alert(`âŒ Error scanning for NFTs: ${error.message}`);
            }
        }

        // Function to select specific NFTs to stake
        // Wallet functions removed for performance
        function selectNFTsToStake() {
            alert('Wallet/Staking system has been removed for performance optimization.');
            return;
            console.log('ðŸŽ¯ Opening NFT selection interface...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                alert('Please connect your wallet first!');
                return;
            }
            
            console.log('ðŸ“‹ Current userNFTs:', otterWallet.userNFTs);
            console.log('ðŸ“Š Total NFTs in wallet:', otterWallet.userNFTs.length);
            
            if (otterWallet.userNFTs.length === 0) {
                alert('No NFTs available to stake!');
                return;
            }
            
            // Create NFT selection modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: linear-gradient(135deg, #1a1a2e, #16213e);
                border: 3px solid #FFD700;
                border-radius: 20px;
                padding: 30px;
                max-width: 800px;
                max-height: 80vh;
                overflow-y: auto;
                color: white;
                font-family: 'SuperMario', 'Orbitron', sans-serif;
            `;
            
            modalContent.innerHTML = `
                <h2 style="text-align: center; color: #FFD700; margin-bottom: 20px;">ðŸŽ¯ Select NFTs to Stake</h2>
                <p style="text-align: center; margin-bottom: 20px; color: #ccc;">
                    Choose which NFTs you want to stake. Staked NFTs will earn $FISH rewards but cannot be traded.
                </p>
                <div id="nftSelectionGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                </div>
                <div style="text-align: center;">
                    <button id="stakeSelectedBtn" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 15px 30px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; margin-right: 10px;">ðŸ”’ Stake Selected</button>
                    <button id="cancelSelectionBtn" style="background: linear-gradient(135deg, #F44336, #D32F2F); color: white; border: none; padding: 15px 30px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold;">âŒ Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Populate NFT grid
            const nftGrid = modalContent.querySelector('#nftSelectionGrid');
            const selectedNFTs = new Set();
            
            otterWallet.userNFTs.forEach(nft => {
                console.log(`ðŸŽ¨ Creating card for NFT:`, nft);
                
                const nftCard = document.createElement('div');
                nftCard.style.cssText = `
                    background: linear-gradient(135deg, #2a2a4e, #1a1a3e);
                    border: 2px solid #FFD700;
                    border-radius: 15px;
                    padding: 15px;
                    text-align: center;
                    cursor: pointer;
                    transition: all 0.3s ease;
                `;
                
                nftCard.innerHTML = `
                    <div style="font-size: 18px; font-weight: bold; color: #FFD700; margin-bottom: 10px;">
                        ${nft.name}
                    </div>
                    <div style="font-size: 14px; color: #ccc; margin-bottom: 10px;">
                        ID: ${nft.tokenId}
                    </div>
                    <div style="font-size: 12px; color: #aaa; margin-bottom: 10px;">
                        Multiplier: ${nft.multiplier}x
                    </div>
                    <div style="font-size: 12px; color: #aaa;">
                        ${nft.traits.slice(0, 2).join(', ')}
                    </div>
                `;
                
                nftCard.addEventListener('click', () => {
                    if (selectedNFTs.has(nft.tokenId)) {
                        selectedNFTs.delete(nft.tokenId);
                        nftCard.style.border = '2px solid #FFD700';
                        nftCard.style.background = 'linear-gradient(135deg, #2a2a4e, #1a1a3e)';
                    } else {
                        selectedNFTs.add(nft.tokenId);
                        nftCard.style.border = '2px solid #4CAF50';
                        nftCard.style.background = 'linear-gradient(135deg, #2a4e2a, #1a3e1a)';
                    }
                });
                
                nftGrid.appendChild(nftCard);
            });
            
            // Handle stake selected button
            modalContent.querySelector('#stakeSelectedBtn').addEventListener('click', async () => {
                if (selectedNFTs.size === 0) {
                    alert('Please select at least one NFT to stake!');
                    return;
                }
                
                const confirmed = confirm(`ðŸ”’ STAKE ${selectedNFTs.size} NFTS?\n\nThis will stake the selected NFTs (simulated).\n\nNFTs will earn $FISH rewards but cannot be traded while staked.\n\nAre you sure you want to continue?`);
                
                if (!confirmed) return;
                
                try {
                    const tokenIds = Array.from(selectedNFTs);
                    const stakedCount = otterWallet.simulateStakeMultiple(tokenIds);
                    
                    alert(`âœ… Successfully staked ${stakedCount} NFTs!\n\nYour NFTs are now earning $FISH rewards.`);
                    document.body.removeChild(modal);
                    updateWalletProfile();
                    
                } catch (error) {
                    console.error('âŒ Error staking selected NFTs:', error);
                    alert(`âŒ Error staking NFTs: ${error.message}`);
                }
            });
            
            // Handle cancel button
            modalContent.querySelector('#cancelSelectionBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        }

        // Function to scan specific range
        async function scanTokenRange(startToken, endToken) {
            console.log(`ðŸ” Scanning token range ${startToken}-${endToken}...`);
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                alert('Please connect your wallet first!');
                return;
            }
            
            const tokenIds = [];
            let errorCount = 0;
            
            for (let i = startToken; i <= endToken; i++) {
                try {
                    // Add delay every 25 calls
                    if ((i - startToken) % 25 === 0 && (i - startToken) > 0) {
                        console.log(`â³ Pausing for 500ms...`);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    
                    const owner = await otterWallet.getTokenOwner(i);
                    if (owner && owner.toLowerCase() === otterWallet.account.toLowerCase()) {
                        console.log(`âœ… Found owned token: ${i}`);
                        tokenIds.push(i);
                    }
                    
                    // Show progress every 50 tokens
                    if ((i - startToken) % 50 === 0) {
                        const progress = Math.round(((i - startToken) / (endToken - startToken)) * 100);
                        console.log(`ðŸ“Š Progress: ${progress}% (token ${i})`);
                    }
                    
                } catch (error) {
                    console.log(`âŒ Error checking token ${i}:`, error.message);
                    errorCount++;
                    
                    if (errorCount > 5) {
                        console.log('âš ï¸ Too many errors, stopping scan');
                        break;
                    }
                }
            }
            
            console.log(`ðŸ“Š Found ${tokenIds.length} tokens in range ${startToken}-${endToken}:`, tokenIds);
            
            if (tokenIds.length > 0) {
                alert(`Found ${tokenIds.length} NFTs in range ${startToken}-${endToken}!\n\nToken IDs: ${tokenIds.join(', ')}`);
            } else {
                alert(`No NFTs found in range ${startToken}-${endToken}`);
            }
            
            return tokenIds;
        }
        
        function loadNFTsManually() {
            console.log('ðŸ¦¦ MANUAL NFT LOADING - Starting...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            console.log('ðŸ‘¤ Wallet address:', otterWallet.account);
            console.log('ðŸ”— Network:', window.ethereum.chainId);
            
            // Use the same function as automatic loading for consistency
            console.log('ðŸ” Starting manual NFT loading...');
            otterWallet.showMessage('Scanning blockchain for your NFTs...', 'info');
            
            // Don't clear existing NFTs - just add to them
            console.log('ðŸ“‹ Current NFTs before loading:', otterWallet.userNFTs.length);
            
            // Use manual loading that doesn't clear existing NFTs
            otterWallet.loadNFTsManuallyOnly().then(() => {
                console.log('âœ… Manual NFT loading completed');
                console.log('ðŸ“Š NFTs found:', otterWallet.userNFTs.length);
                console.log('ðŸ“‹ NFT details:', otterWallet.userNFTs);
                
                if (otterWallet.userNFTs.length > 0) {
                    otterWallet.showMessage(`Found ${otterWallet.userNFTs.length} NFTs!`, 'success');
                } else {
                    otterWallet.showMessage('No NFTs found in this wallet', 'warning');
                }
                
                updateWalletProfile();
            }).catch(error => {
                console.error('âŒ Manual NFT loading failed:', error);
                otterWallet.showMessage(`Error loading NFTs: ${error.message}`, 'error');
            });
        }

        function checkSpecificToken() {
            console.log('ðŸ” MANUAL TOKEN CHECK - Starting...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            // Create a simple modal for token input
            const tokenId = prompt('Enter the Token ID you want to check (e.g., 1234):');
            
            if (!tokenId || isNaN(tokenId)) {
                console.log('âŒ Invalid token ID entered');
                return;
            }
            
            const tokenIdNum = parseInt(tokenId);
            console.log(`ðŸ” Checking token #${tokenIdNum}...`);
            console.log(`ðŸ” Input validation: tokenId="${tokenId}", tokenIdNum=${tokenIdNum}, type=${typeof tokenIdNum}`);
            
            // Check ownership first
            otterWallet.getTokenOwner(tokenIdNum).then(owner => {
                console.log(`ðŸ‘¤ Token #${tokenIdNum} owner:`, owner);
                console.log(`ðŸ‘¤ Your address:`, otterWallet.account);
                
                if (owner && owner.toLowerCase() === otterWallet.account.toLowerCase()) {
                    console.log(`âœ… YOU OWN TOKEN #${tokenIdNum}!`);
                    otterWallet.showMessage(`You own Token #${tokenIdNum}!`, 'success');
                    
                    // Load this specific token
                    console.log(`ðŸ¦¦ About to call loadSpecificToken(${tokenIdNum})...`);
                    const result = loadSpecificToken(tokenIdNum);
                    console.log(`ðŸ¦¦ loadSpecificToken returned:`, result);
                    return result;
                } else {
                    console.log(`âŒ You don't own Token #${tokenIdNum}`);
                    otterWallet.showMessage(`You don't own Token #${tokenIdNum}`, 'warning');
                    return null;
                }
            }).catch(error => {
                console.error(`âŒ Error checking token #${tokenIdNum}:`, error);
                otterWallet.showMessage(`Error checking token: ${error.message}`, 'error');
            });
        }

        async function loadSpecificToken(tokenId) {
            console.log(`ðŸ¦¦ Loading specific token #${tokenId}...`);
            console.log(`ðŸ¦¦ Input validation: tokenId=${tokenId}, type=${typeof tokenId}`);
            console.log(`ðŸ“‹ Current NFTs before loading:`, otterWallet.userNFTs.map(n => n.tokenId));
            
            // Check if token is already loaded
            const existingIndex = otterWallet.userNFTs.findIndex(nft => nft.tokenId === tokenId);
            if (existingIndex !== -1) {
                console.log(`âš ï¸ Token #${tokenId} already loaded`);
                otterWallet.showMessage(`Token #${tokenId} already in gallery!`, 'info');
                return otterWallet.userNFTs[existingIndex];
            }
            
            try {
                // Load real metadata from blockchain/IPFS (same as automatic loading)
                console.log(`ðŸ“„ Loading real metadata for token #${tokenId}...`);
                const metadata = await otterWallet.getRealNFTMetadata(tokenId);
                
                if (metadata) {
                    console.log(`âœ… Loaded real metadata for token ${tokenId}:`, metadata);
                    
                    // Extract traits from the actual metadata
                    const traits = otterWallet.extractTraitsFromMetadata(metadata);
                    
                    // Create NFT object with real metadata
                    console.log(`ðŸŽ¨ Creating NFT object for token #${tokenId}...`);
                    const nft = {
                        tokenId: tokenId,
                        name: metadata.name || `Otterful Otter #${tokenId}`,
                        traits: traits,
                        multiplier: otterWallet.calculateMultiplier(traits),
                        perks: otterWallet.calculatePerks(traits),
                        rarity: otterWallet.calculateRarity(traits),
                        image: otterWallet.processImageUrl(metadata.image, tokenId),
                        description: metadata.description || `Otterful Otter #${tokenId}`,
                        rawMetadata: metadata // Store for debugging
                    };
                    
                    console.log(`ðŸŽ¨ Created NFT object:`, nft);
                    console.log(`ðŸŽ¨ NFT tokenId verification: ${nft.tokenId} === ${tokenId}? ${nft.tokenId === tokenId}`);
                    
                    // Add to userNFTs array (don't replace, add to existing)
                    otterWallet.userNFTs.push(nft);
                    
                    console.log(`âœ… Added token #${tokenId} to wallet:`, nft);
                    console.log(`ðŸ“Š Total NFTs in gallery: ${otterWallet.userNFTs.length}`);
                    console.log(`ðŸ“‹ All NFTs after adding:`, otterWallet.userNFTs.map(n => n.tokenId));
                    otterWallet.showMessage(`Added Token #${tokenId} to gallery! (Total: ${otterWallet.userNFTs.length})`, 'success');
                    
                    // Save to local storage
                    otterWallet.saveNFTsToStorage();
                    
                    // Update the UI
                    updateWalletProfile();
                    
                    return nft;
                } else {
                    console.log(`âŒ No metadata found for token ${tokenId}`);
                    otterWallet.showMessage(`No metadata found for Token #${tokenId}`, 'warning');
                    return null;
                }
            } catch (error) {
                console.error(`âŒ Error loading metadata for token ${tokenId}:`, error);
                otterWallet.showMessage(`Error loading Token #${tokenId}: ${error.message}`, 'error');
                return null;
            }
        }

        function generateTraitsForToken(tokenId) {
            // Generate traits based on token ID (same logic as before)
            const traits = [];
            
            // Hat trait based on token ID
            if (tokenId <= 10) {
                traits.push('Hat-Stealth-v2');
            } else if (tokenId <= 50) {
                traits.push('Hat-Plumber-v5');
            } else if (tokenId <= 150) {
                traits.push('Hat-Plumber-v3');
            } else if (tokenId <= 500) {
                traits.push('Hat-Pirate');
            } else {
                traits.push('Hat-Baseball');
            }
            
            // Fur trait
            const furMod = tokenId % 5;
            switch (furMod) {
                case 0: traits.push('Fur-Golden'); break;
                case 1: traits.push('Fur-Rainbow'); break;
                case 2: traits.push('Fur-Green'); break;
                case 3: traits.push('Fur-Blue'); break;
                default: traits.push('Fur-Brown'); break;
            }
            
            // Eyes trait
            const eyesMod = tokenId % 4;
            switch (eyesMod) {
                case 0: traits.push('Eyes-Laser'); break;
                case 1: traits.push('Eyes-Diamond'); break;
                case 2: traits.push('Eyes-Yellow-Scanner'); break;
                default: traits.push('Eyes-Sunglasses'); break;
            }
            
            // Base trait
            if (tokenId <= 20) {
                traits.push('Base-Stealth');
            } else {
                traits.push('Base-Normal');
            }
            
            console.log(`ðŸŽ¨ Generated traits for token ${tokenId}:`, traits);
            return traits;
        }

        function calculateMultiplierForTraits(traits) {
            let multiplier = 1.0;
            
            traits.forEach(trait => {
                if (trait.includes('Stealth-v2')) multiplier += 1.5;
                else if (trait.includes('Plumber-v5')) multiplier += 1.3;
                else if (trait.includes('Plumber-v3')) multiplier += 1.0;
                else if (trait.includes('Golden')) multiplier += 0.5;
                else if (trait.includes('Rainbow')) multiplier += 0.4;
                else if (trait.includes('Laser')) multiplier += 0.3;
                else if (trait.includes('Diamond')) multiplier += 0.3;
                else if (trait.includes('Pirate')) multiplier += 0.2;
            });
            
            return Math.round(multiplier * 10) / 10; // Round to 1 decimal
        }

        function calculatePerksForTraits(traits) {
            const perks = [];
            
            traits.forEach(trait => {
                if (trait.includes('Stealth-v2')) perks.push('Stealth Mode');
                else if (trait.includes('Plumber-v5')) perks.push('Super Plumber');
                else if (trait.includes('Laser')) perks.push('Laser Vision');
                else if (trait.includes('Diamond')) perks.push('Diamond Hard');
                else if (trait.includes('Golden')) perks.push('Golden Touch');
            });
            
            return perks;
        }

        function calculateRarityForTraits(traits) {
            let rarityScore = 0;
            
            traits.forEach(trait => {
                if (trait.includes('Stealth-v2')) rarityScore += 5;
                else if (trait.includes('Plumber-v5')) rarityScore += 4;
                else if (trait.includes('Plumber-v3')) rarityScore += 3;
                else if (trait.includes('Golden')) rarityScore += 2;
                else if (trait.includes('Rainbow')) rarityScore += 2;
                else if (trait.includes('Laser')) rarityScore += 2;
                else if (trait.includes('Diamond')) rarityScore += 2;
                else if (trait.includes('Pirate')) rarityScore += 1;
            });
            
            if (rarityScore >= 8) return 'legendary';
            else if (rarityScore >= 5) return 'epic';
            else if (rarityScore >= 3) return 'rare';
            else return 'common';
        }

        function loadMultipleTokens() {
            console.log('ðŸ“¦ LOADING MULTIPLE TOKENS - Starting...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            // Create a simple modal for multiple token input
            const tokenIds = prompt('Enter Token IDs separated by commas (e.g., 1234, 5678, 9999):');
            
            if (!tokenIds) {
                console.log('âŒ No token IDs entered');
                return;
            }
            
            const tokenIdArray = tokenIds.split(',').map(id => id.trim()).filter(id => !isNaN(id));
            
            if (tokenIdArray.length === 0) {
                console.log('âŒ No valid token IDs found');
                return;
            }
            
            console.log(`ðŸ“¦ Loading ${tokenIdArray.length} tokens:`, tokenIdArray);
            
            let loadedCount = 0;
            let ownedCount = 0;
            
            // Process each token sequentially to avoid race conditions
            const processTokens = async () => {
                for (let i = 0; i < tokenIdArray.length; i++) {
                    const tokenId = tokenIdArray[i];
                    try {
                        const tokenIdNum = parseInt(tokenId);
                        console.log(`ðŸ” Checking token #${tokenIdNum} (${i + 1}/${tokenIdArray.length})...`);
                        
                        const owner = await otterWallet.getTokenOwner(tokenIdNum);
                        
                        if (owner && owner.toLowerCase() === otterWallet.account.toLowerCase()) {
                            console.log(`âœ… You own token #${tokenIdNum}`);
                            ownedCount++;
                            
                            // Load the token (now async)
                            const nft = await loadSpecificToken(tokenIdNum);
                            if (nft) loadedCount++;
                            
                            console.log(`âœ… Successfully processed token #${tokenIdNum}`);
                        } else {
                            console.log(`âŒ You don't own token #${tokenIdNum}`);
                        }
                        
                        // Small delay between tokens to be nice to servers
                        if (i < tokenIdArray.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    } catch (error) {
                        console.error(`âŒ Error checking token #${tokenId}:`, error);
                    }
                }
                
                console.log('ðŸ“¦ Multiple token loading completed');
                console.log(`ðŸ“Š Results: ${ownedCount} owned, ${loadedCount} loaded`);
                
                otterWallet.showMessage(`Loaded ${loadedCount} NFTs! (${ownedCount} owned out of ${tokenIdArray.length} checked)`, 'success');
                
                // Update the UI
                updateWalletProfile();
            };
            
            processTokens().catch(error => {
                console.error('âŒ Multiple token loading failed:', error);
                otterWallet.showMessage(`Error loading tokens: ${error.message}`, 'error');
            });
        }

        function clearInvalidNFTs() {
            console.log('ðŸ§¹ CLEARING INVALID NFTS - Starting...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            console.log('ðŸ“‹ Current NFTs before clearing:', otterWallet.userNFTs);
            
            // Filter out invalid NFTs (those without proper tokenId or with placeholder data)
            const validNFTs = otterWallet.userNFTs.filter(nft => {
                // Check if NFT has valid tokenId
                if (!nft.tokenId || isNaN(nft.tokenId)) {
                    console.log(`âŒ Removing invalid NFT (no tokenId):`, nft);
                    return false;
                }
                
                // Check if NFT has valid name
                if (!nft.name || nft.name.includes('placeholder') || nft.name.includes('test')) {
                    console.log(`âŒ Removing invalid NFT (bad name):`, nft);
                    return false;
                }
                
                // Check if tokenId is reasonable (1-2222 for Otterful Otters)
                if (nft.tokenId < 1 || nft.tokenId > 2222) {
                    console.log(`âŒ Removing invalid NFT (tokenId out of range):`, nft);
                    return false;
                }
                
                // SPECIFICALLY REMOVE TOKEN #102 (the problematic one)
                if (nft.tokenId === 102) {
                    console.log(`âŒ Removing suspicious token #102:`, nft);
                    return false;
                }
                
                return true;
            });
            
            const removedCount = otterWallet.userNFTs.length - validNFTs.length;
            otterWallet.userNFTs = validNFTs;
            
            console.log('âœ… Valid NFTs after clearing:', otterWallet.userNFTs);
            console.log(`ðŸ§¹ Removed ${removedCount} invalid NFTs`);
            
            otterWallet.showMessage(`Cleared ${removedCount} invalid NFTs! (${validNFTs.length} valid NFTs remaining)`, 'success');
            
            // Update the UI
            updateWalletProfile();
        }

        function resetNFTGallery() {
            console.log('ðŸ”„ RESETTING NFT GALLERY - Starting...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            const confirmed = confirm('ðŸ”„ RESET NFT GALLERY?\n\nThis will completely clear all NFTs from your gallery.\n\nYou can then reload only the NFTs you actually own.\n\nAre you sure you want to continue?');
            
            if (!confirmed) {
                console.log('âŒ Reset cancelled by user');
                return;
            }
            
            console.log('ðŸ“‹ Current NFTs before reset:', otterWallet.userNFTs);
            const previousCount = otterWallet.userNFTs.length;
            
            // Completely reset the NFT array
            otterWallet.userNFTs = [];
            
            console.log('âœ… NFT gallery reset complete');
            console.log(`ðŸ§¹ Removed ${previousCount} NFTs from gallery`);
            
            otterWallet.showMessage(`Gallery reset! Removed ${previousCount} NFTs. Use "Check Token" to load your real NFTs.`, 'success');
            
            // Update the UI
            updateWalletProfile();
        }

        function debugToken102Issue() {
            console.log('ðŸ” DEBUGGING TOKEN #102 ISSUE - Starting...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            console.log('ðŸ“‹ Current NFTs in gallery:', otterWallet.userNFTs);
            console.log('ðŸ“‹ Token IDs in gallery:', otterWallet.userNFTs.map(n => n.tokenId));
            
            // Check if token #102 exists
            const token102 = otterWallet.userNFTs.find(n => n.tokenId === 102);
            if (token102) {
                console.log('âŒ TOKEN #102 FOUND IN GALLERY:', token102);
                console.log('âŒ This token should not be here!');
            } else {
                console.log('âœ… Token #102 not found in gallery (good!)');
            }
            
            // Check for any suspicious tokens
            const suspiciousTokens = otterWallet.userNFTs.filter(n => 
                !n.tokenId || 
                isNaN(n.tokenId) || 
                n.tokenId < 1 || 
                n.tokenId > 2222 ||
                n.tokenId === 102
            );
            
            if (suspiciousTokens.length > 0) {
                console.log('âš ï¸ SUSPICIOUS TOKENS FOUND:', suspiciousTokens);
            } else {
                console.log('âœ… No suspicious tokens found');
            }
            
            // Check if any functions are being called that might add token #102
            console.log('ðŸ” Checking for potential sources of token #102...');
            
            // Test if getLocalTokenMetadata is being called
            console.log('ðŸ” Testing getLocalTokenMetadata function...');
            otterWallet.getLocalTokenMetadata(102).then(metadata => {
                console.log('âš ï¸ getLocalTokenMetadata(102) returned:', metadata);
                if (metadata) {
                    console.log('âŒ This might be the source of token #102!');
                }
            }).catch(error => {
                console.log('âœ… getLocalTokenMetadata(102) failed (good!):', error.message);
            });
            
            otterWallet.showMessage('Debug complete! Check console for results.', 'info');
        }

        function scanAll2222Tokens() {
            console.log('ðŸ” SCANNING ALL 2222 TOKENS - Starting...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            const confirmed = confirm('ðŸ” SCAN ALL 2222 TOKENS?\n\nThis will scan all 2222 Otterful Otters tokens for ownership.\n\nâš ï¸ WARNING: This may take 5-10 minutes and could cause RPC errors.\n\nAre you sure you want to continue?');
            
            if (!confirmed) {
                console.log('âŒ Full scan cancelled by user');
                return;
            }
            
            console.log('ðŸ‘¤ Wallet address:', otterWallet.account);
            console.log('ðŸ”— Network:', window.ethereum.chainId);
            
            // Show progress message
            otterWallet.showMessage('Starting full scan of all 2222 tokens... This may take 5-10 minutes.', 'info');
            
            // Use the improved scanning function with full range
            otterWallet.scanTokenRangeImproved(1, 2222).then((ownedTokens) => {
                console.log('âœ… Full scan completed!');
                console.log('ðŸ“Š Found tokens:', ownedTokens);
                
                if (ownedTokens.length > 0) {
                    // Load metadata for found tokens
                    otterWallet.loadUserNFTsWithMetadataImproved(ownedTokens.length).then(() => {
                        console.log('âœ… Metadata loading completed');
                        otterWallet.showMessage(`Full scan complete! Found ${ownedTokens.length} NFTs.`, 'success');
                        updateWalletProfile();
                    }).catch(error => {
                        console.error('âŒ Error loading metadata:', error);
                        otterWallet.showMessage(`Found ${ownedTokens.length} NFTs but metadata loading failed.`, 'warning');
                    });
                } else {
                    otterWallet.showMessage('Full scan complete! No NFTs found in this wallet.', 'info');
                }
                
            }).catch(error => {
                console.error('âŒ Full scan failed:', error);
                otterWallet.showMessage(`Full scan failed: ${error.message}`, 'error');
            });
        }

        function forceRefreshNFTs() {
            console.log('ðŸ”„ FORCE REFRESH NFTS - Starting...');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            // Completely clear the NFT array
            console.log('ðŸ§¹ Clearing all NFTs from memory...');
            otterWallet.userNFTs = [];
            otterWallet.stakedNFTs = [];
            
            // Clear any cached data
            console.log('ðŸ§¹ Clearing any cached data...');
            
            // Force a fresh blockchain scan
            console.log('ðŸ” Starting fresh blockchain scan...');
            otterWallet.showMessage('Force refreshing NFTs from blockchain...', 'info');
            
            // Use the improved loading function
            otterWallet.loadUserNFTsWithMetadataImproved(0).then(() => {
                console.log('âœ… Force refresh completed!');
                console.log('ðŸ“Š Current NFTs:', otterWallet.userNFTs);
                
                if (otterWallet.userNFTs.length > 0) {
                    otterWallet.showMessage(`Force refresh complete! Found ${otterWallet.userNFTs.length} real NFTs.`, 'success');
                } else {
                    otterWallet.showMessage('Force refresh complete! No NFTs found in this wallet.', 'info');
                }
                
                updateWalletProfile();
            }).catch(error => {
                console.error('âŒ Force refresh failed:', error);
                otterWallet.showMessage(`Force refresh failed: ${error.message}`, 'error');
            });
        }

        function refreshWalletData() {
            console.log('ðŸ”„ Refreshing wallet data...');
            console.log('ðŸ” otterWallet exists:', !!otterWallet);
            console.log('ðŸ” otterWallet.isConnected:', otterWallet?.isConnected);
            console.log('ðŸ” window.ethereum exists:', !!window.ethereum);
            
            if (otterWallet && otterWallet.isConnected) {
                console.log('ðŸ‘¤ Current wallet address:', otterWallet.account);
                console.log('ðŸ”— Current network:', window.ethereum.chainId);
                
                // First try to get balance to see if we have any NFTs
                otterWallet.getTokenBalance().then(balance => {
                    console.log('ðŸ“Š Token balance:', balance);
                    
                    if (balance > 0) {
                        console.log('ðŸŽ‰ Found NFTs in wallet! Loading metadata...');
                        return otterWallet.loadUserNFTsWithMetadata(balance);
                    } else {
                        console.log('âš ï¸ No NFTs found in wallet balance');
                        // Still try to load NFTs in case balance check fails
                        return otterWallet.loadUserNFTsWithMetadata(0);
                    }
                }).then(() => {
                    updateWalletProfile();
                    console.log('âœ… Wallet data refreshed');
                    console.log('ðŸ“Š Total NFTs loaded:', otterWallet.userNFTs.length);
                    console.log('ðŸ“‹ NFT details:', otterWallet.userNFTs);
                }).catch(error => {
                    console.error('âŒ Failed to refresh wallet data:', error);
                });
            } else {
                console.log('âš ï¸ Wallet not connected, cannot refresh');
                if (!otterWallet) {
                    console.error('âŒ OtterWallet not initialized');
                } else if (!otterWallet.isConnected) {
                    console.log('ðŸ’¡ Try connecting your wallet first');
                }
            }
        }
        
        function testContractConnection() {
            console.log('ðŸ§ª Testing contract connection...');
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            console.log('ðŸ”— Testing basic wallet connection...');
            console.log('ðŸ‘¤ Account:', otterWallet.account);
            console.log('ðŸ”— Provider:', otterWallet.provider);
            console.log('ðŸ“‹ Contract:', otterWallet.contractAddress);
            
            // Test network first
            window.ethereum.request({method: 'eth_chainId'}).then(chainId => {
                console.log('ðŸŒ Current chain ID:', chainId);
                console.log('ðŸŽ¯ Expected chain ID:', otterWallet.apeChainId);
                console.log('âœ… Network match:', chainId === otterWallet.apeChainId);
                
                // Test basic contract calls
                return otterWallet.getTokenBalance();
            }).then(balance => {
                console.log('âœ… Balance test passed:', balance);
                
                if (balance > 0) {
                    console.log('ðŸŽ‰ You have NFTs! Loading them...');
                    return otterWallet.loadUserNFTsWithMetadata(balance);
                } else {
                    console.log('âš ï¸ No NFTs found in wallet');
                    return Promise.resolve();
                }
            }).then(() => {
                console.log('âœ… NFT loading test completed');
                console.log('ðŸ“Š User NFTs:', otterWallet.userNFTs);
            }).catch(error => {
                console.error('âŒ Contract test failed:', error);
                console.log('ðŸ” Error details:', error.message);
                console.log('ðŸ” Error code:', error.code);
            });
        }

        function testMetadataFetching() {
            console.log('ðŸŒ Testing metadata fetching...');
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            // Test metadata fetching for a specific token
            const testTokenId = 1; // Test with token ID 1
            console.log(`ðŸ§ª Testing metadata for token #${testTokenId}...`);
            
            otterWallet.getTokenMetadata(testTokenId).then(metadata => {
                console.log('âœ… Metadata test result:', metadata);
                if (metadata && metadata.attributes) {
                    console.log('ðŸŽ¨ Attributes found:', metadata.attributes.length);
                    metadata.attributes.forEach(attr => {
                        console.log(`  - ${attr.trait_type}: ${attr.value}`);
                    });
                } else {
                    console.log('âš ï¸ No attributes found in metadata');
                }
            }).catch(error => {
                console.error('âŒ Metadata test failed:', error);
            });
        }
        
        function updateRecentAchievements() {
            const container = document.getElementById('profileRecentAchievements');
            container.innerHTML = '';
            
            game.profile.recentAchievements.slice(-3).forEach(achievement => {
                const div = document.createElement('div');
                div.style.cssText = 'margin-bottom: 8px; padding: 8px; background: rgba(255,215,0,0.1); border-radius: 8px; border-left: 3px solid #FFD700;';
                div.textContent = achievement;
                container.appendChild(div);
            });
        }
        
        function updateProfileCustomization() {
            // Update currently equipped items
            updateCurrentlyEquipped();
            
            // Update inventory
            updateInventoryDisplay();
            
            // Update quick equip dropdowns
            updateQuickEquipDropdowns();
        }
        
        function updateCurrentlyEquipped() {
            // Update current skin
            const currentSkin = marketplaceItems.skins.find(skin => skin.id === game.marketplace.currentSkin);
            if (currentSkin) {
                document.getElementById('profileSkinName').textContent = currentSkin.name;
                document.getElementById('profileSkinDescription').textContent = currentSkin.description;
                // Update skin image based on current skin
                const skinImage = document.getElementById('profileSkinImage');
                if (currentSkin.id === 'default') {
                    skinImage.src = 'public/oggg.png';
                } else {
                    skinImage.src = currentSkin.image || 'public/oggg.png';
                }
            }
            
            // Update current hat
            const currentHat = marketplaceItems.hats.find(hat => hat.id === game.marketplace.currentHat);
            if (currentHat) {
                document.getElementById('profileHatName').textContent = currentHat.name;
                document.getElementById('profileHatDescription').textContent = currentHat.description;
                // Update hat image
                const hatImage = document.getElementById('profileHatImage');
                if (currentHat.id === 'none') {
                    hatImage.innerHTML = '';
                    hatImage.style.background = 'rgba(0,0,0,0.1)';
                    hatImage.style.backgroundImage = 'url(public/owl.png)';
                    hatImage.style.backgroundSize = 'contain';
                    hatImage.style.backgroundPosition = 'center';
                    hatImage.style.backgroundRepeat = 'no-repeat';
                } else {
                    hatImage.innerHTML = '';
                    hatImage.style.background = 'rgba(0,0,0,0.1)';
                    hatImage.style.backgroundImage = `url(${currentHat.image})`;
                    hatImage.style.backgroundSize = 'contain';
                    hatImage.style.backgroundPosition = 'center';
                    hatImage.style.backgroundRepeat = 'no-repeat';
                }
            }
            
            // Update current abilities
            const abilitiesContainer = document.getElementById('profileCurrentAbilities');
            if (abilitiesContainer) {
                abilitiesContainer.innerHTML = '';
                
                if (game.marketplace.currentAbilities.length === 0) {
                    abilitiesContainer.innerHTML = '<div style="text-align: center; color: #888; font-style: italic; padding: 20px;">No abilities equipped</div>';
                } else {
                    game.marketplace.currentAbilities.forEach(abilityId => {
                        const ability = marketplaceItems.abilities.find(a => a.id === abilityId);
                        if (ability) {
                            const abilityDiv = document.createElement('div');
                            abilityDiv.style.cssText = `
                                background: rgba(76,175,80,0.2);
                                border: 2px solid #4CAF50;
                                border-radius: 15px;
                                padding: 15px;
                                text-align: center;
                                margin-bottom: 10px;
                            `;
                            
                            let abilityLevel = '';
                            if (abilityId === 'armor' && player.hasArmorBoost) {
                                abilityLevel = `Level ${player.armorLevel} (+${player.armorLevel * 25}% armor)`;
                            } else if (abilityId === 'laser' && player.hasLaser) {
                                abilityLevel = `Level ${player.laserChargingLevel}`;
                            }
                            
                            abilityDiv.innerHTML = `
                                <img src="${ability.image}" alt="${ability.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; margin-bottom: 8px; background: rgba(0,0,0,0.1);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div style="display: none; font-size: 24px; margin: 8px 0;">âš¡</div>
                                <div style="font-size: 12px; font-weight: bold; color: #4CAF50; margin-bottom: 3px;">${ability.name}</div>
                                <div style="font-size: 10px; color: #00FFFF; margin-bottom: 6px;">${ability.description}</div>
                                ${abilityLevel ? `<div style="font-size: 9px; color: #FFD700; margin-bottom: 6px;">${abilityLevel}</div>` : ''}
                                <div style="font-size: 9px; color: #4CAF50; font-weight: bold;">âœ“ EQUIPPED</div>
                            `;
                            
                            abilitiesContainer.appendChild(abilityDiv);
                        }
                    });
                }
            }
        }
        
        function updateInventoryDisplay() {
            // Update skins inventory
            const skinsContainer = document.getElementById('profileSkinsInventory');
            skinsContainer.innerHTML = '';
            
            marketplaceItems.skins.forEach(skin => {
                const skinDiv = document.createElement('div');
                
                if (skin.owned) {
                    // Owned skin styling
                    skinDiv.style.cssText = `
                        background: ${skin.equipped ? 'rgba(76,175,80,0.2)' : 'rgba(100,100,100,0.1)'};
                        border: 2px solid ${skin.equipped ? '#4CAF50' : '#666666'};
                        border-radius: 15px;
                        padding: 15px;
                        text-align: center;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    `;
                    
                    skinDiv.onclick = () => quickEquipSkin(skin.id);
                    
                    skinDiv.innerHTML = `
                        <img src="${skin.image}" alt="${skin.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; margin-bottom: 8px; background: rgba(0,0,0,0.1);">
                        <div style="font-size: 12px; font-weight: bold; color: ${skin.equipped ? '#4CAF50' : '#FFFFFF'}; margin-bottom: 3px;">${skin.name}</div>
                        <div style="font-size: 10px; color: #00FFFF; margin-bottom: 6px;">${skin.description}</div>
                        ${skin.equipped ? '<div style="font-size: 9px; color: #4CAF50; font-weight: bold;">âœ“ EQUIPPED</div>' : '<div style="font-size: 9px; color: #FFD700;">Click to equip</div>'}
                    `;
                } else {
                    // Locked skin styling
                    skinDiv.style.cssText = `
                        background: rgba(0,0,0,0.3);
                        border: 2px solid #666666;
                        border-radius: 15px;
                        padding: 15px;
                        text-align: center;
                        transition: all 0.3s ease;
                        position: relative;
                        opacity: 0.6;
                    `;
                    
                    // Add dark overlay for locked skins
                    const darkOverlay = document.createElement('div');
                    darkOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.5);
                        border-radius: 13px;
                        pointer-events: none;
                        z-index: 1;
                    `;
                    skinDiv.appendChild(darkOverlay);
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.style.cssText = `
                        position: relative;
                        z-index: 2;
                    `;
                    
                    let unlockText = '';
                    if (skin.unlockType === 'achievement') {
                        unlockText = 'ðŸ”’ ACHIEVEMENT';
                    } else if (skin.unlockType === 'purchase') {
                        unlockText = `${skin.price} ðŸª™`;
                    }
                    
                    contentDiv.innerHTML = `
                        <img src="${skin.image}" alt="${skin.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; margin-bottom: 8px; background: rgba(0,0,0,0.1); filter: brightness(0.4) grayscale(0.3);">
                        <div style="font-size: 12px; font-weight: bold; color: #666666; margin-bottom: 3px;">${skin.name}</div>
                        <div style="font-size: 10px; color: #888888; margin-bottom: 6px;">${skin.description}</div>
                        <div style="font-size: 9px; color: #FFD700; margin-bottom: 8px;">${unlockText}</div>
                        <div style="font-size: 9px; color: #FF4444; font-weight: bold;">ðŸ”’ LOCKED</div>
                        ${skin.unlockType === 'purchase' ? 
                            `<button onclick="event.stopPropagation(); openMarketplaceForSkin('${skin.id}')" style="background: #666666; color: white; border: none; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 9px; min-width: 50px; margin-top: 8px;">
                                BUY
                            </button>` : 
                            `<div style="font-size: 9px; color: #888888; margin-top: 8px;">Complete achievement to unlock</div>`
                        }
                    `;
                    
                    skinDiv.appendChild(contentDiv);
                }
                
                skinsContainer.appendChild(skinDiv);
            });
            
            // Update hats inventory
            const hatsContainer = document.getElementById('profileHatsInventory');
            hatsContainer.innerHTML = '';
            
            marketplaceItems.hats.forEach(hat => {
                if (hat.owned) {
                    const hatDiv = document.createElement('div');
                    hatDiv.style.cssText = `
                        background: ${hat.equipped ? 'rgba(76,175,80,0.2)' : 'rgba(100,100,100,0.1)'};
                        border: 2px solid ${hat.equipped ? '#4CAF50' : '#666666'};
                        border-radius: 15px;
                        padding: 15px;
                        text-align: center;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    `;
                    
                    hatDiv.onclick = () => quickEquipHat(hat.id);
                    
                    const hatImage = hat.id === 'none' ? `<img src="public/owl.png" alt="${hat.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; background: rgba(0,0,0,0.1);">` : `<img src="${hat.image}" alt="${hat.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; background: rgba(0,0,0,0.1);">`;
                    
                    hatDiv.innerHTML = `
                        <div style="width: 32px; height: 32px; margin: 0 auto 8px; display: flex; align-items: center; justify-content: center;">${hatImage}</div>
                        <div style="font-size: 12px; font-weight: bold; color: ${hat.equipped ? '#4CAF50' : '#FFFFFF'}; margin-bottom: 3px;">${hat.name}</div>
                        <div style="font-size: 10px; color: #00FFFF; margin-bottom: 6px;">${hat.description}</div>
                        ${hat.equipped ? '<div style="font-size: 9px; color: #4CAF50; font-weight: bold;">âœ“ EQUIPPED</div>' : '<div style="font-size: 9px; color: #FFD700;">Click to equip</div>'}
                    `;
                    
                    hatsContainer.appendChild(hatDiv);
                } else {
                    // Locked hat styling
                    const hatDiv = document.createElement('div');
                    hatDiv.style.cssText = `
                        background: rgba(0,0,0,0.3);
                        border: 2px solid #666666;
                        border-radius: 15px;
                        padding: 15px;
                        text-align: center;
                        transition: all 0.3s ease;
                        position: relative;
                        opacity: 0.6;
                    `;
                    
                    // Add dark overlay for locked hats
                    const darkOverlay = document.createElement('div');
                    darkOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.5);
                        border-radius: 13px;
                        pointer-events: none;
                        z-index: 1;
                    `;
                    hatDiv.appendChild(darkOverlay);
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.style.cssText = `
                        position: relative;
                        z-index: 2;
                    `;
                    
                    const hatImage = hat.id === 'none' ? `<img src="public/owl.png" alt="${hat.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; background: rgba(0,0,0,0.1); filter: brightness(0.4) grayscale(0.3);">` : `<img src="${hat.image}" alt="${hat.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; background: rgba(0,0,0,0.1); filter: brightness(0.4) grayscale(0.3);">`;
                    
                    let unlockText = '';
                    if (hat.unlockType === 'achievement') {
                        unlockText = 'ðŸ”’ ACHIEVEMENT';
                    } else if (hat.unlockType === 'purchase') {
                        unlockText = `${hat.price} ðŸª™`;
                    }
                    
                    contentDiv.innerHTML = `
                        <div style="width: 32px; height: 32px; margin: 0 auto 8px; display: flex; align-items: center; justify-content: center;">${hatImage}</div>
                        <div style="font-size: 12px; font-weight: bold; color: #666666; margin-bottom: 3px;">${hat.name}</div>
                        <div style="font-size: 10px; color: #888888; margin-bottom: 6px;">${hat.description}</div>
                        <div style="font-size: 9px; color: #FFD700; margin-bottom: 8px;">${unlockText}</div>
                        <div style="font-size: 9px; color: #FF4444; font-weight: bold;">ðŸ”’ LOCKED</div>
                        ${hat.unlockType === 'purchase' ? 
                            `<button onclick="event.stopPropagation(); openMarketplaceForHat('${hat.id}')" style="background: #666666; color: white; border: none; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 9px; min-width: 50px; margin-top: 8px;">
                                BUY
                            </button>` : 
                            `<div style="font-size: 9px; color: #888888; margin-top: 8px;">Complete achievement to unlock</div>`
                        }
                    `;
                    
                    hatDiv.appendChild(contentDiv);
                    hatsContainer.appendChild(hatDiv);
                }
            });
            
            // Update abilities inventory
            const abilitiesContainer = document.getElementById('profileAbilitiesInventory');
            if (abilitiesContainer) {
                abilitiesContainer.innerHTML = '';
                
                marketplaceItems.abilities.forEach(ability => {
                    const abilityDiv = document.createElement('div');
                    
                    if (ability.owned) {
                        // Owned ability styling
                        abilityDiv.style.cssText = `
                            background: ${ability.equipped ? 'rgba(76,175,80,0.2)' : 'rgba(100,100,100,0.1)'};
                            border: 2px solid ${ability.equipped ? '#4CAF50' : '#FF6B35'};
                            border-radius: 15px;
                            padding: 15px;
                            text-align: center;
                            transition: all 0.3s ease;
                        `;
                        
                        // Get current ability status
                        let abilityStatus = '';
                        let abilityLevel = '';
                        
                        if (ability.id === 'armor' && player.hasArmorBoost) {
                            abilityLevel = `Level ${player.armorLevel} (+${player.armorLevel * 25}% armor)`;
                        } else if (ability.id === 'laser' && player.hasLaser) {
                            abilityLevel = `Level ${player.laserChargingLevel}`;
                        }
                        
                        if (ability.equipped) {
                            abilityStatus = `<div style="font-size: 9px; color: #4CAF50; font-weight: bold; margin-bottom: 8px;">âœ“ EQUIPPED</div>`;
                        } else {
                            abilityStatus = `<div style="font-size: 9px; color: #FFD700; margin-bottom: 8px;">Click to equip</div>`;
                        }
                        
                        abilityDiv.innerHTML = `
                            <img src="${ability.image}" alt="${ability.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; margin-bottom: 8px; background: rgba(0,0,0,0.1);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display: none; font-size: 24px; margin: 8px 0;">âš¡</div>
                            <div style="font-size: 12px; font-weight: bold; color: ${ability.equipped ? '#4CAF50' : '#FFFFFF'}; margin-bottom: 3px;">${ability.name}</div>
                            <div style="font-size: 10px; color: #00FFFF; margin-bottom: 6px;">${ability.description}</div>
                            ${abilityLevel ? `<div style="font-size: 9px; color: #FFD700; margin-bottom: 6px;">${abilityLevel}</div>` : ''}
                            ${abilityStatus}
                            <div style="display: flex; gap: 8px; justify-content: center;">
                                <button onclick="event.stopPropagation(); quickEquipAbility('${ability.id}')" style="background: ${ability.equipped ? '#4CAF50' : '#FF6B35'}; color: white; border: none; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 9px; min-width: 50px;">
                                    ${ability.equipped ? 'EQUIPPED' : 'EQUIP'}
                                </button>
                                <button onclick="event.stopPropagation(); toggleAbility('${ability.id}')" style="background: ${ability.equipped ? '#FF4444' : '#666666'}; color: white; border: none; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 9px; min-width: 50px;">
                                    ${ability.equipped ? 'DISABLE' : 'ENABLE'}
                                </button>
                            </div>
                        `;
                    } else {
                        // Locked ability styling
                        abilityDiv.style.cssText = `
                            background: rgba(0,0,0,0.3);
                            border: 2px solid #666666;
                            border-radius: 15px;
                            padding: 15px;
                            text-align: center;
                            transition: all 0.3s ease;
                            position: relative;
                            opacity: 0.6;
                        `;
                        
                        // Add dark overlay for locked abilities
                        const darkOverlay = document.createElement('div');
                        darkOverlay.style.cssText = `
                            position: absolute;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(0,0,0,0.5);
                            border-radius: 13px;
                            pointer-events: none;
                            z-index: 1;
                        `;
                        abilityDiv.appendChild(darkOverlay);
                        
                        const contentDiv = document.createElement('div');
                        contentDiv.style.cssText = `
                            position: relative;
                            z-index: 2;
                        `;
                        
                        contentDiv.innerHTML = `
                            <img src="${ability.image}" alt="${ability.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; margin-bottom: 8px; background: rgba(0,0,0,0.1); filter: brightness(0.4) grayscale(0.3);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display: none; font-size: 24px; margin: 8px 0; filter: brightness(0.4);">âš¡</div>
                            <div style="font-size: 12px; font-weight: bold; color: #666666; margin-bottom: 3px;">${ability.name}</div>
                            <div style="font-size: 10px; color: #888888; margin-bottom: 6px;">${ability.description}</div>
                            <div style="font-size: 9px; color: #FFD700; margin-bottom: 8px;">${ability.price} ðŸª™</div>
                            <div style="font-size: 9px; color: #FF4444; font-weight: bold;">ðŸ”’ LOCKED</div>
                            <button onclick="event.stopPropagation(); openMarketplaceForAbility('${ability.id}')" style="background: #666666; color: white; border: none; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 9px; min-width: 50px; margin-top: 8px;">
                                BUY
                            </button>
                        `;
                        
                        abilityDiv.appendChild(contentDiv);
                    }
                    
                    abilitiesContainer.appendChild(abilityDiv);
                });
            }
        }
        
        function updateQuickEquipDropdowns() {
            // Update skin dropdown
            const skinSelect = document.getElementById('quickEquipSkin');
            skinSelect.innerHTML = '<option value="">Select a skin...</option>';
            
            marketplaceItems.skins.forEach(skin => {
                if (skin.owned) {
                    const option = document.createElement('option');
                    option.value = skin.id;
                    option.textContent = skin.name;
                    if (skin.equipped) {
                        option.textContent += ' (Equipped)';
                    }
                    skinSelect.appendChild(option);
                }
            });
            
            // Update hat dropdown
            const hatSelect = document.getElementById('quickEquipHat');
            hatSelect.innerHTML = '<option value="">Select a hat...</option>';
            
            marketplaceItems.hats.forEach(hat => {
                if (hat.owned) {
                    const option = document.createElement('option');
                    option.value = hat.id;
                    option.textContent = hat.name;
                    if (hat.equipped) {
                        option.textContent += ' (Equipped)';
                    }
                    hatSelect.appendChild(option);
                }
            });
        }
        
        function quickEquipSkin(skinId) {
            if (!skinId) return;
            
            const skin = marketplaceItems.skins.find(s => s.id === skinId);
            if (skin && skin.owned) {
                // Unequip current skin
                marketplaceItems.skins.forEach(s => s.equipped = false);
                
                // Equip new skin
                skin.equipped = true;
                game.marketplace.currentSkin = skinId;
                
                // Save and update
                saveMarketplaceData();
                updateProfileCustomization();
                updateMarketplace();
                
                console.log(`ðŸ¦¦ Equipped skin: ${skin.name}`);
            }
        }
        
        function quickEquipHat(hatId) {
            if (!hatId) return;
            
            const hat = marketplaceItems.hats.find(h => h.id === hatId);
            if (hat && hat.owned) {
                // Unequip current hat
                marketplaceItems.hats.forEach(h => h.equipped = false);
                
                // Equip new hat
                hat.equipped = true;
                game.marketplace.currentHat = hatId;
                
                // Save and update
                saveMarketplaceData();
                updateProfileCustomization();
                updateMarketplace();
                
                console.log(`ðŸ¦‰ Equipped hat: ${hat.name}`);
            }
        }
        
        function quickEquipAbility(abilityId) {
            if (!abilityId) return;
            
            const ability = marketplaceItems.abilities.find(a => a.id === abilityId);
            if (ability && ability.owned) {
                // Toggle ability (can equip multiple abilities)
                if (ability.equipped) {
                    ability.equipped = false;
                    game.marketplace.currentAbilities = game.marketplace.currentAbilities.filter(id => id !== abilityId);
                } else {
                    ability.equipped = true;
                    game.marketplace.currentAbilities.push(abilityId);
                }
                
                // Save and update
                saveMarketplaceData();
                updateProfileCustomization();
                updateMarketplace();
                
                console.log(`âš¡ ${ability.equipped ? 'Equipped' : 'Unequipped'} ability: ${ability.name}`);
            }
        }
        
        function toggleAbility(abilityId) {
            if (!abilityId) return;
            
            const ability = marketplaceItems.abilities.find(a => a.id === abilityId);
            if (!ability || !ability.owned) return;
            
            if (ability.equipped) {
                // Disable the ability
                ability.equipped = false;
                game.marketplace.currentAbilities = game.marketplace.currentAbilities.filter(id => id !== abilityId);
                
                // Reset player ability status
                if (abilityId === 'jetpack') {
                    player.hasJetpack = false;
                } else if (abilityId === 'laser') {
                    player.hasLaser = false;
                } else if (abilityId === 'fireball') {
                    player.hasFireball = false;
                } else if (abilityId === 'armor') {
                    player.hasArmorBoost = false;
                    player.armorLevel = 0;
                }
                
                console.log(`âš¡ Disabled ability: ${ability.name}`);
            } else {
                // Enable the ability
                ability.equipped = true;
                if (!game.marketplace.currentAbilities.includes(abilityId)) {
                    game.marketplace.currentAbilities.push(abilityId);
                }
                
                // Set player ability status
                if (abilityId === 'jetpack') {
                    player.hasJetpack = true;
                } else if (abilityId === 'laser') {
                    player.hasLaser = true;
                } else if (abilityId === 'fireball') {
                    player.hasFireball = true;
                } else if (abilityId === 'armor') {
                    player.hasArmorBoost = true;
                    player.armorLevel = 1; // Start at level 1
                }
                
                console.log(`âš¡ Enabled ability: ${ability.name}`);
            }
            
            // Save marketplace data
            saveMarketplaceData();
            
            // Update display
            updateProfileCustomization();
            updateMarketplace();
        }
        
        function openMarketplaceForAbility(abilityId) {
            // Close profile panel
            document.getElementById('profilePanel').style.display = 'none';
            
            // Open marketplace panel
            document.getElementById('marketplacePanel').style.display = 'block';
            
            // Switch to abilities tab
            switchMarketplaceTab('abilities');
            
            console.log(`ðŸ›’ Opening marketplace for ability: ${abilityId}`);
        }
        
        function openMarketplaceForSkin(skinId) {
            // Close profile panel
            document.getElementById('profilePanel').style.display = 'none';
            
            // Open marketplace panel
            document.getElementById('marketplacePanel').style.display = 'block';
            
            // Switch to skins tab
            switchMarketplaceTab('skins');
            
            console.log(`ðŸ›’ Opening marketplace for skin: ${skinId}`);
        }
        
        function openMarketplaceForHat(hatId) {
            // Close profile panel
            document.getElementById('profilePanel').style.display = 'none';
            
            // Open marketplace panel
            document.getElementById('marketplacePanel').style.display = 'block';
            
            // Switch to hats tab
            switchMarketplaceTab('hats');
            
            console.log(`ðŸ›’ Opening marketplace for hat: ${hatId}`);
        }
        
        function updateAchievementsList() {
            const container = document.getElementById('profileAchievementsList');
            container.innerHTML = '';
            
            achievements.forEach(achievement => {
                const div = document.createElement('div');
                const isUnlocked = achievement.unlocked;
                const xpReward = achievement.xpReward || 0;
                
                div.style.cssText = `
                    background: ${isUnlocked ? 'linear-gradient(135deg, rgba(76,175,80,0.15), rgba(76,175,80,0.05))' : 'linear-gradient(135deg, rgba(100,100,100,0.15), rgba(100,100,100,0.05))'};
                    border: 2px solid ${isUnlocked ? '#4CAF50' : '#666666'};
                    border-radius: 15px;
                    padding: 20px;
                    text-align: center;
                    opacity: ${isUnlocked ? '1' : '0.7'};
                    transition: transform 0.2s, box-shadow 0.2s;
                    cursor: pointer;
                    position: relative;
                    overflow: hidden;
                `;
                
                // Add hover effects
                div.onmouseover = function() {
                    this.style.transform = 'scale(1.05)';
                    this.style.boxShadow = `0 8px 25px ${isUnlocked ? 'rgba(76,175,80,0.3)' : 'rgba(100,100,100,0.3)'}`;
                };
                div.onmouseout = function() {
                    this.style.transform = 'scale(1)';
                    this.style.boxShadow = 'none';
                };
                
                div.innerHTML = `
                    <div style="font-size: 36px; margin-bottom: 12px; filter: ${isUnlocked ? 'drop-shadow(0 0 8px rgba(76,175,80,0.5))' : 'grayscale(100%)'};">
                        ${achievement.icon}
                    </div>
                    <div style="font-size: 16px; font-weight: bold; color: ${isUnlocked ? '#4CAF50' : '#999999'}; margin-bottom: 8px; text-shadow: ${isUnlocked ? '0 0 8px rgba(76,175,80,0.5)' : 'none'};">
                        ${achievement.name}
                    </div>
                    <div style="font-size: 12px; color: #00FFFF; margin-bottom: 10px; line-height: 1.4;">
                        ${achievement.description}
                    </div>
                    ${isUnlocked ? 
                        `<div style="font-size: 11px; color: #4CAF50; margin-top: 8px; font-weight: bold; text-shadow: 0 0 5px rgba(76,175,80,0.5);">
                            âœ“ UNLOCKED â€¢ +${xpReward} XP
                        </div>` : 
                        `<div style="font-size: 11px; color: #666; margin-top: 8px; font-style: italic;">
                            ðŸ”’ LOCKED â€¢ +${xpReward} XP
                        </div>`
                    }
                    ${achievement.hidden ? '<div style="position: absolute; top: 10px; right: 10px; font-size: 12px; color: #FFD700;">ðŸ”</div>' : ''}
                `;
                
                container.appendChild(div);
            });
        }
        
        function switchProfileTab(tab) {
            const statsTab = document.getElementById('statsTab');
            const achievementsTab = document.getElementById('achievementsTab');
            const customizationTab = document.getElementById('customizationTab');
            const walletTab = document.getElementById('walletTab');
            const statsBtn = document.getElementById('statsTabBtn');
            const achievementsBtn = document.getElementById('achievementsTabBtn');
            const customizationBtn = document.getElementById('customizationTabBtn');
            const walletBtn = document.getElementById('walletTabBtn');
            
            // Hide all tabs
            statsTab.style.display = 'none';
            achievementsTab.style.display = 'none';
            customizationTab.style.display = 'none';
            walletTab.style.display = 'none';
            
            // Remove active class from all buttons
            statsBtn.classList.remove('active');
            achievementsBtn.classList.remove('active');
            customizationBtn.classList.remove('active');
            walletBtn.classList.remove('active');
            
            // Show selected tab and activate button
            if (tab === 'stats') {
                statsTab.style.display = 'block';
                statsBtn.classList.add('active');
            } else if (tab === 'achievements') {
                achievementsTab.style.display = 'block';
                achievementsBtn.classList.add('active');
            } else if (tab === 'customization') {
                customizationTab.style.display = 'block';
                customizationBtn.classList.add('active');
            } else if (tab === 'wallet') {
                // Wallet tab disabled - show message instead
                if (walletTab) walletTab.style.display = 'block';
                if (walletBtn) walletBtn.classList.add('active');
                // updateWalletProfile(); // Removed - wallet system disabled
            }
        }
        
        function unlockAchievement(achievementId) {
            const achievement = achievements.find(a => a.id === achievementId);
            if (achievement && !achievement.unlocked) {
                achievement.unlocked = true;
                
                // Initialize arrays if they don't exist
                if (!game.profile.achievements) {
                    game.profile.achievements = [];
                }
                if (!game.profile.recentAchievements) {
                    game.profile.recentAchievements = [];
                }
                
                game.profile.achievements.push(achievementId);
                game.profile.recentAchievements.push(`ðŸ† ${achievement.name} - ${achievement.description}`);
                
                // Keep only last 10 recent achievements
                if (game.profile.recentAchievements.length > 10) {
                    game.profile.recentAchievements = game.profile.recentAchievements.slice(-10);
                }
                
                // Award XP for achievement completion
                if (achievement.xpReward) {
                    addXP(achievement.xpReward);
                    showXPRewardNotification(achievement.xpReward, achievement.name);
                }
                
                console.log(`ðŸ† Achievement unlocked: ${achievement.name} (+${achievement.xpReward || 0} XP)`);
                saveProfileData();
                
                // Show achievement popup
                showAchievementPopup(achievement);
                
                // Show owl achievement celebration
                showSituationalOwlMessage('achievement');
                
                // Check for skin unlocks based on this achievement
                checkSkinUnlocks(achievementId);
            }
        }
        
        function showXPRewardNotification(xpAmount, achievementName) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute;
                top: 80px;
                left: 20px;
                background: linear-gradient(135deg, #00FFFF, #0080FF);
                color: white;
                padding: 8px 15px;
                border-radius: 8px;
                font-size: 12px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 4px 15px rgba(0,255,255,0.4);
                animation: achievementSlideIn 0.5s ease-out;
                max-width: 200px;
                font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 14px; margin-bottom: 2px;">â­ ${achievementName}</div>
                <div style="font-size: 10px; opacity: 0.9;">+${xpAmount} XP</div>
            `;
            
            // Position relative to the score/coins area
            const scoreElement = document.getElementById('score');
            if (scoreElement && scoreElement.parentElement) {
                scoreElement.parentElement.style.position = 'relative';
                scoreElement.parentElement.appendChild(notification);
            } else {
            document.body.appendChild(notification);
            }
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'achievementSlideOut 0.5s ease-in';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                    }, 500);
                }
            }, 2500);
        }
        
        function showAchievementPopup(achievement) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(255,215,0,0.95), rgba(255,165,0,0.95));
                color: #000;
                padding: 25px 30px;
                border-radius: 20px;
                font-size: 16px;
                font-weight: bold;
                text-align: center;
                z-index: 10001;
                box-shadow: 0 10px 30px rgba(255,215,0,0.6);
                animation: achievementPopupSlideIn 0.6s ease-out;
                max-width: 350px;
                font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
                border: 3px solid #FFD700;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 15px;">ðŸ†</div>
                <div style="font-size: 20px; margin-bottom: 10px; color: #8B0000; text-shadow: 0 0 10px rgba(139,0,0,0.3);">ACHIEVEMENT UNLOCKED!</div>
                <div style="font-size: 18px; margin-bottom: 8px; color: #000080;">${achievement.icon} ${achievement.name}</div>
                <div style="font-size: 14px; margin-bottom: 15px; color: #333; opacity: 0.9;">${achievement.description}</div>
                <div style="font-size: 16px; color: #006400; font-weight: bold;">+${achievement.xpReward || 0} XP</div>
            `;
            
            document.body.appendChild(notification);
            
            // Add sound effect (if available)
            if (game.sounds && game.sounds.achievement) {
                game.sounds.achievement.play().catch(e => console.log('Audio play failed:', e));
            }
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'achievementPopupSlideOut 0.5s ease-in';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 500);
                }
            }, 4000);
        }
        
        function checkSkinUnlocks(achievementId) {
            marketplaceItems.skins.forEach(skin => {
                if (skin.unlockType === 'achievement' && skin.achievementId === achievementId && !skin.owned) {
                    skin.owned = true;
                    game.marketplace.ownedSkins.push(skin.id);
                    saveMarketplaceData();
                    
                    // Show skin unlock notification
                    showSkinUnlockNotification(skin);
                    
                    console.log(`ðŸŽ¨ Skin unlocked: ${skin.name} via achievement ${achievementId}`);
                }
            });
        }
        
        function showSkinUnlockNotification(skin) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FF6B35, #FFD700);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(255,107,53,0.4);
                animation: levelUpPulse 3s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">ðŸŽ¨</div>
                <div>SKIN UNLOCKED!</div>
                <div style="font-size: 16px; margin-top: 5px;">${skin.name}</div>
                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">${skin.description}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        function checkAllAchievements() {
            // Prevent multiple achievement checks in quick succession
            if (game.lastAchievementCheck && Date.now() - game.lastAchievementCheck < 1000) {
                return; // Skip if checked within last second
            }
            game.lastAchievementCheck = Date.now();
            
            // Basic achievements
            if (!achievements.find(a => a.id === 'first_game').unlocked) {
                unlockAchievement('first_game');
            }
            
            // Coin achievements (use all-time stats)
            const totalCoins = game.sessionStats.allTimeCoins || 0;
            if (totalCoins >= 1 && !achievements.find(a => a.id === 'first_coin').unlocked) {
                unlockAchievement('first_coin');
            }
            if (totalCoins >= 10 && !achievements.find(a => a.id === 'ten_coins').unlocked) {
                unlockAchievement('ten_coins');
            }
            if (totalCoins >= 50 && !achievements.find(a => a.id === 'fifty_coins').unlocked) {
                unlockAchievement('fifty_coins');
            }
            if (totalCoins >= 100 && !achievements.find(a => a.id === 'hundred_coins').unlocked) {
                unlockAchievement('hundred_coins');
            }
            if (totalCoins >= 200 && !achievements.find(a => a.id === 'two_hundred_coins').unlocked) {
                unlockAchievement('two_hundred_coins');
            }
            
            // Level achievements (use all-time stats)
            const levelsCompleted = game.sessionStats.allTimeLevels || 0;
            if (levelsCompleted >= 1 && !achievements.find(a => a.id === 'first_level').unlocked) {
                unlockAchievement('first_level');
            }
            if (levelsCompleted >= 5 && !achievements.find(a => a.id === 'five_levels').unlocked) {
                unlockAchievement('five_levels');
            }
            if (levelsCompleted >= 10 && !achievements.find(a => a.id === 'ten_levels').unlocked) {
                unlockAchievement('ten_levels');
            }
            if (levelsCompleted >= 20 && !achievements.find(a => a.id === 'twenty_levels').unlocked) {
                unlockAchievement('twenty_levels');
            }
            if (levelsCompleted >= 50 && !achievements.find(a => a.id === 'fifty_levels').unlocked) {
                unlockAchievement('fifty_levels');
            }
            if (levelsCompleted >= 100 && !achievements.find(a => a.id === 'hundred_levels').unlocked) {
                unlockAchievement('hundred_levels');
            }
            
            // Score achievements (use all-time stats)
            const currentScore = game.sessionStats.allTimeScore || 0;
            if (currentScore >= 100 && !achievements.find(a => a.id === 'hundred_score').unlocked) {
                unlockAchievement('hundred_score');
            }
            if (currentScore >= 1000 && !achievements.find(a => a.id === 'thousand_score').unlocked) {
                unlockAchievement('thousand_score');
            }
            if (currentScore >= 10000 && !achievements.find(a => a.id === 'ten_thousand_score').unlocked) {
                unlockAchievement('ten_thousand_score');
            }
            if (currentScore >= 100000 && !achievements.find(a => a.id === 'hundred_thousand_score').unlocked) {
                unlockAchievement('hundred_thousand_score');
            }
            if (currentScore >= 1000000 && !achievements.find(a => a.id === 'million_score').unlocked) {
                unlockAchievement('million_score');
            }
            
            // Enemy achievements (use all-time stats)
            const enemiesDefeated = game.sessionStats.allTimeEnemies || 0;
            if (enemiesDefeated >= 1 && !achievements.find(a => a.id === 'first_enemy').unlocked) {
                unlockAchievement('first_enemy');
            }
            if (enemiesDefeated >= 20 && !achievements.find(a => a.id === 'twenty_enemies').unlocked) {
                unlockAchievement('twenty_enemies');
            }
            if (enemiesDefeated >= 50 && !achievements.find(a => a.id === 'fifty_enemies').unlocked) {
                unlockAchievement('fifty_enemies');
            }
            if (enemiesDefeated >= 100 && !achievements.find(a => a.id === 'hundred_enemies').unlocked) {
                unlockAchievement('hundred_enemies');
            }
            if (enemiesDefeated >= 1000 && !achievements.find(a => a.id === 'thousand_enemies').unlocked) {
                unlockAchievement('thousand_enemies');
            }
            
            // Boss achievements (use all-time stats)
            const bossesDefeated = game.sessionStats.allTimeBosses || 0;
            if (bossesDefeated >= 1 && !achievements.find(a => a.id === 'boss_defeater').unlocked) {
                unlockAchievement('boss_defeater');
            }
            if (bossesDefeated >= 5 && !achievements.find(a => a.id === 'five_bosses').unlocked) {
                unlockAchievement('five_bosses');
            }
            if (bossesDefeated >= 10 && !achievements.find(a => a.id === 'ten_bosses').unlocked) {
                unlockAchievement('ten_bosses');
            }
            if (bossesDefeated >= 20 && !achievements.find(a => a.id === 'twenty_bosses').unlocked) {
                unlockAchievement('twenty_bosses');
            }
            if (bossesDefeated >= 50 && !achievements.find(a => a.id === 'fifty_bosses').unlocked) {
                unlockAchievement('fifty_bosses');
            }
            
            // Collection achievements (use all-time stats)
            const totalItems = (game.sessionStats.allTimeFish || 0) + (game.sessionStats.allTimeHealth || 0) + (game.sessionStats.allTimeTreasures || 0) + (game.sessionStats.allTimeMushrooms || 0);
            if (totalItems >= 100 && !achievements.find(a => a.id === 'collector').unlocked) {
                unlockAchievement('collector');
            }
            if (totalItems >= 500 && !achievements.find(a => a.id === 'master_collector').unlocked) {
                unlockAchievement('master_collector');
            }
            if (totalItems >= 1000 && !achievements.find(a => a.id === 'collector_god').unlocked) {
                unlockAchievement('collector_god');
            }
            
            // Marketplace achievements
            const ownedHats = marketplaceItems.hats.filter(hat => hat.owned).length;
            const ownedSkins = marketplaceItems.skins.filter(skin => skin.owned).length;
            
            if (ownedHats >= 3 && !achievements.find(a => a.id === 'hat_collector').unlocked) {
                unlockAchievement('hat_collector');
            }
            if (ownedHats >= marketplaceItems.hats.length && !achievements.find(a => a.id === 'all_hats').unlocked) {
                unlockAchievement('all_hats');
            }
            if (ownedSkins >= 3 && !achievements.find(a => a.id === 'skin_collector').unlocked) {
                unlockAchievement('skin_collector');
            }
            if (ownedSkins >= marketplaceItems.skins.length && !achievements.find(a => a.id === 'all_skins').unlocked) {
                unlockAchievement('all_skins');
            }
            
            // Hidden achievements (random checks)
            checkHiddenAchievements();
            
            // Time-based achievements
            checkTimeBasedAchievements();
            
            // New gameplay achievements
            checkNewGameplayAchievements();
        }
        
        function checkNewGameplayAchievements() {
            // Fireball achievements (use all-time stats)
            if ((game.sessionStats.allTimeFireballs || 0) >= 10 && !achievements.find(a => a.id === 'fireball_master').unlocked) {
                unlockAchievement('fireball_master');
            }
            
            // All-time stats achievements
            if (game.sessionStats.allTimeUnderwater >= 600000 && !achievements.find(a => a.id === 'underwater_explorer_master').unlocked) { // 10 minutes
                unlockAchievement('underwater_explorer_master');
            }
            
            if (game.sessionStats.allTimeJetpackTime >= 300000 && !achievements.find(a => a.id === 'jetpack_explorer').unlocked) { // 5 minutes
                unlockAchievement('jetpack_explorer');
            }
            
            if (game.sessionStats.allTimeLasers >= 25 && !achievements.find(a => a.id === 'laser_expert').unlocked) {
                unlockAchievement('laser_expert');
            }
            
            if (game.sessionStats.allTimeTreasures >= 50 && !achievements.find(a => a.id === 'treasure_hunter').unlocked) {
                unlockAchievement('treasure_hunter');
            }
            
            if (game.sessionStats.allTimeHealth >= 100 && !achievements.find(a => a.id === 'health_master').unlocked) {
                unlockAchievement('health_master');
            }
            
            if (game.sessionStats.allTimeMushrooms >= 50 && !achievements.find(a => a.id === 'mushroom_master').unlocked) {
                unlockAchievement('mushroom_master');
            }
            
            if (game.sessionStats.allTimeKeys >= 25 && !achievements.find(a => a.id === 'key_collector').unlocked) {
                unlockAchievement('key_collector');
            }
            
            if (game.sessionStats.allTimeFish >= 100 && !achievements.find(a => a.id === 'fish_collector').unlocked) {
                unlockAchievement('fish_collector');
            }
            
            if (game.sessionStats.allTimeJumps >= 500 && !achievements.find(a => a.id === 'jump_master').unlocked) {
                unlockAchievement('jump_master');
            }
            
            // Total enemies defeated (for skin unlock)
            const totalEnemiesDefeated = game.sessionStats.allTimeEnemies;
            if (totalEnemiesDefeated >= 50 && !achievements.find(a => a.id === 'defeat_50_enemies').unlocked) {
                unlockAchievement('defeat_50_enemies');
            }
            
            // Total coins collected (for skin unlock)
            if (game.sessionStats.allTimeCoins >= 100 && !achievements.find(a => a.id === 'collect_100_coins').unlocked) {
                unlockAchievement('collect_100_coins');
            }
            
            // Total levels completed (for skin unlock)
            if (game.sessionStats.allTimeLevels >= 10 && !achievements.find(a => a.id === 'complete_10_levels').unlocked) {
                unlockAchievement('complete_10_levels');
            }
            
            // Total bosses defeated (for skin unlock)
            if (game.sessionStats.allTimeBosses >= 5 && !achievements.find(a => a.id === 'defeat_5_bosses').unlocked) {
                unlockAchievement('defeat_5_bosses');
            }
            
            // Player level (for skin unlock)
            if (player.level >= 20 && !achievements.find(a => a.id === 'reach_level_20').unlocked) {
                unlockAchievement('reach_level_20');
            }
        }
        
        function checkHiddenAchievements() {
            // Lucky 777
            if (game.score === 777 && !achievements.find(a => a.id === 'lucky_777').unlocked) {
                unlockAchievement('lucky_777');
            }
            
            // Unlucky 13
            const totalItems = (game.sessionStats.allTimeFish || 0) + (game.sessionStats.allTimeHealth || 0) + (game.sessionStats.allTimeTreasures || 0) + (game.sessionStats.allTimeMushrooms || 0);
            if (totalItems === 13 && !achievements.find(a => a.id === 'collector_13').unlocked) {
                unlockAchievement('collector_13');
            }
            
            // Devil Hunter 666
            const enemiesDefeated = game.sessionStats.allTimeEnemies || 0;
            if (enemiesDefeated === 666 && !achievements.find(a => a.id === 'enemy_666').unlocked) {
                unlockAchievement('enemy_666');
            }
            
            // Answer to Everything 42
            if (game.sessionStats.allTimeCoins === 42 && !achievements.find(a => a.id === 'coin_42').unlocked) {
                unlockAchievement('coin_42');
            }
            
            // Nice Level 69
            if (game.level === 69 && !achievements.find(a => a.id === 'level_69').unlocked) {
                unlockAchievement('level_69');
            }
            
            // Random Master (5 hidden achievements)
            const hiddenAchievements = achievements.filter(a => a.hidden && a.unlocked);
            if (hiddenAchievements.length >= 5 && !achievements.find(a => a.id === 'random_master').unlocked) {
                unlockAchievement('random_master');
            }
        }
        
        function checkTimeBasedAchievements() {
            const now = new Date();
            const hour = now.getHours();
            const month = now.getMonth() + 1;
            const day = now.getDay(); // 0 = Sunday, 6 = Saturday
            
            // Midnight Gamer
            if (hour === 0 && !achievements.find(a => a.id === 'midnight_gamer').unlocked) {
                unlockAchievement('midnight_gamer');
            }
            
            // Early Bird
            if (hour === 6 && !achievements.find(a => a.id === 'early_bird').unlocked) {
                unlockAchievement('early_bird');
            }
            
            // Weekend Warrior
            if ((day === 0 || day === 6) && !achievements.find(a => a.id === 'weekend_warrior').unlocked) {
                unlockAchievement('weekend_warrior');
            }
            
            // Seasonal achievements
            if (month === 12 && !achievements.find(a => a.id === 'christmas_player').unlocked) {
                unlockAchievement('christmas_player');
            }
            if (month === 10 && !achievements.find(a => a.id === 'halloween_player').unlocked) {
                unlockAchievement('halloween_player');
            }
            if (month >= 6 && month <= 8 && !achievements.find(a => a.id === 'summer_player').unlocked) {
                unlockAchievement('summer_player');
            }
            if (month >= 3 && month <= 5 && !achievements.find(a => a.id === 'spring_player').unlocked) {
                unlockAchievement('spring_player');
            }
        }
        
        function saveProfileData() {
            localStorage.setItem('otterBrosProfile', JSON.stringify({
                playerName: game.profile.playerName,
                profilePicture: game.profile.profilePicture,
                level: game.profile.level,
                experience: game.profile.experience,
                achievements: game.profile.achievements,
                recentAchievements: game.profile.recentAchievements,
                playTime: game.profile.playTime,
                gamesPlayed: game.profile.gamesPlayed,
                bestScore: game.profile.bestScore,
                favoriteLevel: game.profile.favoriteLevel
            }));
        }
        
        function saveSessionStats() {
            localStorage.setItem('otterBrosSessionStats', JSON.stringify(game.sessionStats));
        }
        
        function loadSessionStats() {
            const savedStats = localStorage.getItem('otterBrosSessionStats');
            if (savedStats) {
                try {
                    const stats = JSON.parse(savedStats);
                    console.log('ðŸ“Š Loading saved session stats:', stats);
                    
                    // Merge saved stats with current session stats
                    Object.assign(game.sessionStats, stats);
                } catch (error) {
                    console.error('âŒ Error loading session stats:', error);
                }
            } else {
                console.log('ðŸ“Š No saved session stats found, starting fresh');
            }
        }
        
        function loadProfileData() {
            const savedData = localStorage.getItem('otterBrosProfile');
            
            if (savedData) {
                try {
                    const profile = JSON.parse(savedData);
                    console.log('ðŸ‘¤ Loading saved profile data:', profile);
                    
                    // Load profile data
                    game.profile = {
                        gamesPlayed: profile.gamesPlayed || 0,
                        playTime: profile.playTime || 0,
                        bestScore: profile.bestScore || 0,
                        achievements: profile.achievements || [],
                        recentAchievements: profile.recentAchievements || [],
                        playerName: profile.playerName || 'Otter Player',
                        profilePicture: profile.profilePicture || null,
                        level: profile.level || 1,
                        experience: profile.experience || 0
                    };
                    
                    // Mark achievements as unlocked based on saved data
                    achievements.forEach(achievement => {
                        achievement.unlocked = game.profile.achievements.includes(achievement.id);
                    });
                    
                    console.log('ðŸ† Loaded achievement state:', game.profile.achievements);
                } catch (error) {
                    console.error('âŒ Error loading profile data:', error);
                    // Fallback to fresh profile
                    resetToFreshProfile();
                }
            } else {
                console.log('ðŸ‘¤ No saved profile found, starting fresh');
                resetToFreshProfile();
            }
            
            // Ensure real-time achievement tracking is enabled
            game.achievementTrackingEnabled = true;
            
            // Update profile display
            updateProfileDisplay();
        }
        
        function resetToFreshProfile() {
            // Reset profile to fresh state
            game.profile = {
                gamesPlayed: 0,
                playTime: 0,
                bestScore: 0,
                achievements: [],
                recentAchievements: [],
                playerName: 'Otter Player',
                profilePicture: null,
                level: 1,
                experience: 0
            };
            
            // Reset all achievements to locked
                achievements.forEach(achievement => {
                achievement.unlocked = false;
            });
        }
        
        // Profile editing functions
        function editProfilePicture() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const profileImage = document.getElementById('profileOtterImage');
                        profileImage.src = e.target.result;
                        game.profile.profilePicture = e.target.result;
                        saveProfileData();
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }
        
        function editPlayerName() {
            const currentName = game.profile.playerName || 'Otter Player';
            const newName = prompt('Enter your new player name:', currentName);
            
            if (newName && newName.trim() !== '') {
                game.profile.playerName = newName.trim();
                updateProfileDisplay();
                saveProfileData();
            }
        }
        
        function updateProfileDisplay() {
            // Update profile picture
            const profileImage = document.getElementById('profileOtterImage');
            if (game.profile.profilePicture) {
                profileImage.src = game.profile.profilePicture;
            }
            
            // Update player name
            const playerName = document.getElementById('profilePlayerName');
            playerName.textContent = game.profile.playerName || 'Otter Player';
            
            // Update coins
            const profileCoins = document.getElementById('profileCoins');
            profileCoins.textContent = game.marketplace.coins || 0;
        }
        
        function formatPlayTime(minutes) {
            if (minutes < 60) {
                return `${minutes} min`;
            } else {
                const hours = Math.floor(minutes / 60);
                const remainingMinutes = minutes % 60;
                return `${hours}h ${remainingMinutes}m`;
            }
        }
        
        // Home Screen Particle Effects
        function initHomeScreenParticles() {
            const particleContainer = document.getElementById('particleContainer');
            if (!particleContainer) return;
            
            const particles = [];
            const particleCount = 20;
            
            // Create particles
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.style.cssText = `
                    position: absolute;
                    width: 4px;
                    height: 4px;
                    background: radial-gradient(circle, #FFD700, transparent);
                    border-radius: 50%;
                    pointer-events: none;
                    animation: particleFloat ${5 + Math.random() * 5}s linear infinite;
                    animation-delay: ${Math.random() * 5}s;
                    opacity: ${0.3 + Math.random() * 0.4};
                `;
                
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                
                particleContainer.appendChild(particle);
                particles.push(particle);
            }
            
            // Add particle animation CSS
            if (!document.querySelector('#particleAnimationCSS')) {
                const style = document.createElement('style');
                style.id = 'particleAnimationCSS';
                style.textContent = `
                    @keyframes particleFloat {
                        0% {
                            transform: translateY(100vh) translateX(0px) rotate(0deg);
                            opacity: 0;
                        }
                        10% {
                            opacity: 1;
                        }
                        90% {
                            opacity: 1;
                        }
                        100% {
                            transform: translateY(-100px) translateX(${Math.random() * 200 - 100}px) rotate(360deg);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Enhanced button click effects
        function addButtonClickEffect(button) {
            const ripple = document.createElement('div');
            ripple.style.cssText = `
                position: absolute;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.6);
                transform: scale(0);
                animation: ripple 0.6s linear;
                pointer-events: none;
            `;
            
            const rect = button.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            const x = event.clientX - rect.left - size / 2;
            const y = event.clientY - rect.top - size / 2;
            
            ripple.style.width = ripple.style.height = size + 'px';
            ripple.style.left = x + 'px';
            ripple.style.top = y + 'px';
            
            button.appendChild(ripple);
            
            setTimeout(() => {
                ripple.remove();
            }, 600);
        }
        
        // Add ripple animation CSS
        if (!document.querySelector('#rippleAnimationCSS')) {
            const style = document.createElement('style');
            style.id = 'rippleAnimationCSS';
            style.textContent = `
                @keyframes ripple {
                    to {
                        transform: scale(4);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Dynamic background effect
        function addDynamicBackground() {
            const titleScreen = document.getElementById('titleScreen');
            if (!titleScreen) return;
            
            // Create gradient overlay
            const gradientOverlay = document.createElement('div');
            gradientOverlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(45deg, 
                    rgba(255,215,0,0.1) 0%, 
                    rgba(0,255,255,0.1) 25%, 
                    rgba(255,215,0,0.1) 50%, 
                    rgba(0,255,255,0.1) 75%, 
                    rgba(255,215,0,0.1) 100%);
                background-size: 400% 400%;
                animation: gradientShift 8s ease-in-out infinite;
                pointer-events: none;
                z-index: 1;
            `;
            
            titleScreen.appendChild(gradientOverlay);
            
            // Add gradient animation CSS
            if (!document.querySelector('#gradientAnimationCSS')) {
                const style = document.createElement('style');
                style.id = 'gradientAnimationCSS';
                style.textContent = `
                    @keyframes gradientShift {
                        0%, 100% { background-position: 0% 50%; }
                        50% { background-position: 100% 50%; }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        

        
        function toggleLeaderboard() {
            const panel = document.getElementById('leaderboardPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                updateLeaderboard();
            } else {
                panel.style.display = 'none';
            }
        }
        
        function saveStats(saveAllStats = false) {
            // Only save stats if explicitly requested (level completion)
            if (saveAllStats && game.sessionStats) {
                game.sessionStats.allTimeScore += game.sessionStats.totalScore;
                game.sessionStats.allTimeLevels += game.sessionStats.levelsCompleted;
                game.sessionStats.allTimeCoins += game.sessionStats.totalCoins;
                game.sessionStats.allTimeEnemies += (game.sessionStats.crabsDefeated + game.sessionStats.eaglesDefeated + game.sessionStats.gatorsDefeated + game.sessionStats.sharksDefeated);
                game.sessionStats.allTimeBosses += game.sessionStats.bossesDefeated;
                game.sessionStats.allTimeFish += game.sessionStats.fishCollected;
                game.sessionStats.allTimeHealth += game.sessionStats.healthCollected;
                game.sessionStats.allTimeTreasures += game.sessionStats.treasuresCollected;
                game.sessionStats.allTimeMushrooms += game.sessionStats.mushroomsCollected;
                game.sessionStats.allTimeJetpacks += game.sessionStats.jetpacksUsed;
                game.sessionStats.allTimeLasers += game.sessionStats.lasersUsed;
                game.sessionStats.allTimeFireballs += game.sessionStats.fireballsShot;
                game.sessionStats.allTimeUnderwater += game.sessionStats.underwaterTime;
                game.sessionStats.allTimeJetpackTime += game.sessionStats.jetpackTime;
                game.sessionStats.allTimeLaserTime += game.sessionStats.laserTime;
                game.sessionStats.allTimeDamage += game.sessionStats.damageTaken;
                game.sessionStats.allTimeJumps += game.sessionStats.jumpsMade;
                game.sessionStats.allTimePerfectLevels += game.sessionStats.perfectLevels;
                game.sessionStats.allTimeSpeedRuns += game.sessionStats.speedRunLevels;
                game.sessionStats.allTimeNoDamage += game.sessionStats.noDamageLevels;
                game.sessionStats.allTimeNoJumps += game.sessionStats.noJumpLevels;
                game.sessionStats.allTimeNoPowerups += game.sessionStats.noPowerupLevels;
                game.sessionStats.allTimeKeys += game.sessionStats.keysCollected;
                
                // Add session coins to marketplace coins only on level completion
                game.marketplace.coins += game.sessionStats.currentSessionCoins;
                
                localStorage.setItem('otterBrosStats', JSON.stringify(game.sessionStats));
                saveMarketplaceData(); // Save marketplace data with new coins
                saveGameState(); // Save current game state
            }
        }
        
        function loadStats() {
            // Load saved stats from localStorage
            const savedStats = localStorage.getItem('otterBrosStats');
            if (savedStats) {
                const loadedStats = JSON.parse(savedStats);
                
                // Reset session-specific fields for new session
                game.sessionStats = {
                    // All-time stats (persistent)
                    allTimeScore: loadedStats.allTimeScore || 0,
                    allTimeLevels: loadedStats.allTimeLevels || 0,
                    allTimeCoins: loadedStats.allTimeCoins || 0,
                    allTimeEnemies: loadedStats.allTimeEnemies || 0,
                    allTimeBosses: loadedStats.allTimeBosses || 0,
                    allTimeFish: loadedStats.allTimeFish || 0,
                    allTimeHealth: loadedStats.allTimeHealth || 0,
                    allTimeTreasures: loadedStats.allTimeTreasures || 0,
                    allTimeMushrooms: loadedStats.allTimeMushrooms || 0,
                    allTimeJetpacks: loadedStats.allTimeJetpacks || 0,
                    allTimeLasers: loadedStats.allTimeLasers || 0,
                    allTimeFireballs: loadedStats.allTimeFireballs || 0,
                    allTimeUnderwater: loadedStats.allTimeUnderwater || 0,
                    allTimeJetpackTime: loadedStats.allTimeJetpackTime || 0,
                    allTimeLaserTime: loadedStats.allTimeLaserTime || 0,
                    allTimeDamage: loadedStats.allTimeDamage || 0,
                    allTimeJumps: loadedStats.allTimeJumps || 0,
                    allTimePerfectLevels: loadedStats.allTimePerfectLevels || 0,
                    allTimeSpeedRuns: loadedStats.allTimeSpeedRuns || 0,
                    allTimeNoDamage: loadedStats.allTimeNoDamage || 0,
                    allTimeNoJumps: loadedStats.allTimeNoJumps || 0,
                    allTimeNoPowerups: loadedStats.allTimeNoPowerups || 0,
                    allTimeKeys: loadedStats.allTimeKeys || 0,
                    
                    // Session records (best single session)
                    highestScore: loadedStats.highestScore || 0,
                    highestLevels: loadedStats.highestLevels || 0,
                    highestCoins: loadedStats.highestCoins || 0,
                    highestCrabs: loadedStats.highestCrabs || 0,
                    highestFish: loadedStats.highestFish || 0,
                    highestHealth: loadedStats.highestHealth || 0,
                    highestTreasures: loadedStats.highestTreasures || 0,
                    highestMushrooms: loadedStats.highestMushrooms || 0,
                    levelTimes: loadedStats.levelTimes || [],
                    
                    // Current session stats (reset to 0 for new session)
                    totalScore: 0,
                    levelsCompleted: 0,
                    totalCoins: 0,
                    crabsDefeated: 0,
                    eaglesDefeated: 0,
                    gatorsDefeated: 0,
                    sharksDefeated: 0,
                    bossesDefeated: 0,
                    treasuresFound: 0,
                    keysCollected: 0,
                    healthPickups: 0,
                    mushroomsEaten: 0,
                    currentSessionScore: 0,
                    levelStartTime: Date.now(),
                    fishCollected: 0,
                    healthCollected: 0,
                    treasuresCollected: 0,
                    mushroomsCollected: 0,
                    currentSessionLevels: 0,
                    currentSessionCoins: 0,
                    currentSessionCrabs: 0,
                    currentSessionBosses: 0,
                    currentSessionFish: 0,
                    currentSessionHealth: 0,
                    currentSessionTreasures: 0,
                    currentSessionMushrooms: 0,
                    jetpacksUsed: 0,
                    lasersUsed: 0,
                    fireballsShot: 0,
                    fireballsHit: 0,
                    underwaterTime: 0,
                    jetpackTime: 0,
                    laserTime: 0,
                    damageTaken: 0,
                    jumpsMade: 0,
                    perfectLevels: 0,
                    speedRunLevels: 0,
                    noDamageLevels: 0,
                    noJumpLevels: 0,
                    noPowerupLevels: 0
                };
                console.log('ðŸ“Š Loaded saved stats from localStorage and reset session stats');
            } else {
                // Initialize fresh stats if none exist
                game.sessionStats = {
                    // All-time stats (persistent)
                    allTimeScore: 0,
                    allTimeLevels: 0,
                    allTimeCoins: 0,
                    allTimeEnemies: 0,
                    allTimeBosses: 0,
                    allTimeFish: 0,
                    allTimeHealth: 0,
                    allTimeTreasures: 0,
                    allTimeMushrooms: 0,
                    allTimeJetpacks: 0,
                    allTimeLasers: 0,
                    allTimeFireballs: 0,
                    allTimeUnderwater: 0,
                    allTimeJetpackTime: 0,
                    allTimeLaserTime: 0,
                    allTimeDamage: 0,
                    allTimeJumps: 0,
                    allTimePerfectLevels: 0,
                    allTimeSpeedRuns: 0,
                    allTimeNoDamage: 0,
                    allTimeNoJumps: 0,
                    allTimeNoPowerups: 0,
                    allTimeKeys: 0,
                    
                    // Session records (best single session)
                    highestScore: 0,
                    highestLevels: 0,
                    highestCoins: 0,
                    highestCrabs: 0,
                    highestFish: 0,
                    highestHealth: 0,
                    highestTreasures: 0,
                    highestMushrooms: 0,
                    levelTimes: [],
                    
                    // Current session stats (reset to 0 for new session)
                    totalScore: 0,
                    levelsCompleted: 0,
                    totalCoins: 0,
                    crabsDefeated: 0,
                    eaglesDefeated: 0,
                    gatorsDefeated: 0,
                    sharksDefeated: 0,
                    bossesDefeated: 0,
                    treasuresFound: 0,
                    keysCollected: 0,
                    healthPickups: 0,
                    mushroomsEaten: 0,
                    currentSessionScore: 0,
                    levelStartTime: Date.now(),
                    fishCollected: 0,
                    healthCollected: 0,
                    treasuresCollected: 0,
                    mushroomsCollected: 0,
                    currentSessionLevels: 0,
                    currentSessionCoins: 0,
                    currentSessionCrabs: 0,
                    currentSessionBosses: 0,
                    currentSessionFish: 0,
                    currentSessionHealth: 0,
                    currentSessionTreasures: 0,
                    currentSessionMushrooms: 0,
                    jetpacksUsed: 0,
                    lasersUsed: 0,
                    fireballsShot: 0,
                    fireballsHit: 0,
                    underwaterTime: 0,
                    jetpackTime: 0,
                    laserTime: 0,
                    damageTaken: 0,
                    jumpsMade: 0,
                    perfectLevels: 0,
                    speedRunLevels: 0,
                    noDamageLevels: 0,
                    noJumpLevels: 0,
                    noPowerupLevels: 0
                };
                console.log('ðŸ†• No saved stats found - starting fresh');
            }
        }
        
        function resetStats() {
            if (confirm('Are you sure you want to reset all saved stats? This cannot be undone.')) {
                localStorage.removeItem('otterBrosStats');
                game.sessionStats = {
                    // Cumulative stats (total across all sessions)
                    totalScore: 0,
                    levelsCompleted: 0,
                    totalCoins: 0,
                    crabsDefeated: 0,
                    fishCollected: 0,
                    healthCollected: 0,
                    treasuresCollected: 0,
                    mushroomsCollected: 0,
                    levelTimes: [],
                    levelStartTime: Date.now(),
                    // Highest scores (best single session)
                    highestScore: 0,
                    highestLevels: 0,
                    highestCoins: 0,
                    highestCrabs: 0,
                    highestFish: 0,
                    highestHealth: 0,
                    highestTreasures: 0,
                    highestMushrooms: 0,
                    // Current session tracking
                    currentSessionScore: 0,
                    currentSessionLevels: 0,
                    currentSessionCoins: 0,
                    currentSessionCrabs: 0,
                    currentSessionFish: 0,
                    currentSessionHealth: 0,
                    currentSessionTreasures: 0,
                    currentSessionMushrooms: 0
                };
                updateLeaderboard();
            }
        }
        
        function updateLeaderboard() {
            // Update all-time stats
            document.getElementById('totalScore').textContent = game.sessionStats.totalScore;
            document.getElementById('totalLevels').textContent = game.sessionStats.levelsCompleted;
            document.getElementById('totalCoins').textContent = game.sessionStats.totalCoins;
            document.getElementById('totalCrabs').textContent = game.sessionStats.crabsDefeated;
            document.getElementById('totalBosses').textContent = game.sessionStats.bossesDefeated;
            document.getElementById('totalFish').textContent = game.sessionStats.fishCollected;
            document.getElementById('totalHealth').textContent = game.sessionStats.healthCollected;
            document.getElementById('totalTreasures').textContent = game.sessionStats.treasuresCollected;
            document.getElementById('totalMushrooms').textContent = game.sessionStats.mushroomsCollected;
            
            // Update highest scores
            document.getElementById('highestScore').textContent = game.sessionStats.highestScore;
            document.getElementById('highestLevels').textContent = game.sessionStats.highestLevels;
            document.getElementById('highestCoins').textContent = game.sessionStats.highestCoins;
            document.getElementById('highestCrabs').textContent = game.sessionStats.highestCrabs;
            document.getElementById('highestFish').textContent = game.sessionStats.highestFish;
            document.getElementById('highestHealth').textContent = game.sessionStats.highestHealth;
            document.getElementById('highestTreasures').textContent = game.sessionStats.highestTreasures;
            document.getElementById('highestMushrooms').textContent = game.sessionStats.highestMushrooms;
            
            // Update current session stats
            document.getElementById('sessionScore').textContent = game.sessionStats.currentSessionScore;
            document.getElementById('sessionLevels').textContent = game.sessionStats.currentSessionLevels;
            document.getElementById('sessionCoins').textContent = game.sessionStats.currentSessionCoins;
            document.getElementById('sessionCrabs').textContent = game.sessionStats.currentSessionCrabs;
            document.getElementById('sessionBosses').textContent = game.sessionStats.currentSessionBosses;
            document.getElementById('sessionFish').textContent = game.sessionStats.currentSessionFish;
            document.getElementById('sessionHealth').textContent = game.sessionStats.currentSessionHealth;
            document.getElementById('sessionTreasures').textContent = game.sessionStats.currentSessionTreasures;
            document.getElementById('sessionMushrooms').textContent = game.sessionStats.currentSessionMushrooms;
            
            // Load global leaderboard
            loadGlobalLeaderboard();
            
            // Update recent achievements
            updateRecentAchievements();
            
            // Update level times
            const levelTimesDiv = document.getElementById('levelTimes');
            if (game.sessionStats.levelTimes.length === 0) {
                levelTimesDiv.innerHTML = '<div style="text-align: center; color: #888; font-style: italic;">No levels completed yet</div>';
            } else {
                levelTimesDiv.innerHTML = game.sessionStats.levelTimes.map(time => 
                    `<div style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid rgba(255,215,0,0.3);">
                        <span>Level ${time.level}</span>
                        <span style="color: #00FFFF;">${time.time}</span>
                    </div>`
                ).join('');
            }
        }
        
        function updateRecentAchievements() {
            const container = document.getElementById('recentAchievements');
            container.innerHTML = '';
            
            // Get unlocked achievements
            const unlockedAchievements = achievements.filter(achievement => achievement.unlocked);
            
            if (unlockedAchievements.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 20px; color: #888; font-style: italic; background: rgba(100,100,100,0.1); border-radius: 15px;">
                        <div style="font-size: 48px; margin-bottom: 10px;">ðŸ†</div>
                        <div style="font-size: 16px; color: #00FFFF;">No achievements unlocked yet</div>
                        <div style="font-size: 12px; margin-top: 5px;">Keep playing to earn badges!</div>
                    </div>
                `;
                return;
            }
            
            // Show the 4 most recent achievements
            const recentAchievements = unlockedAchievements.slice(-4);
            
            recentAchievements.forEach(achievement => {
                const achievementDiv = document.createElement('div');
                achievementDiv.style.cssText = `
                    background: rgba(76,175,80,0.1);
                    border: 2px solid #4CAF50;
                    border-radius: 15px;
                    padding: 15px;
                    text-align: center;
                    transition: all 0.3s ease;
                `;
                
                achievementDiv.innerHTML = `
                    <div style="font-size: 32px; margin-bottom: 10px;">${achievement.icon}</div>
                    <div style="font-size: 14px; font-weight: bold; color: #4CAF50; margin-bottom: 5px;">${achievement.name}</div>
                    <div style="font-size: 11px; color: #00FFFF; line-height: 1.3;">${achievement.description}</div>
                    <div style="font-size: 10px; color: #4CAF50; margin-top: 8px; font-weight: bold;">âœ“ UNLOCKED</div>
                `;
                
                container.appendChild(achievementDiv);
            });
            
            // If there are more than 4 achievements, show a count
            if (unlockedAchievements.length > 4) {
                const moreDiv = document.createElement('div');
                moreDiv.style.cssText = `
                    grid-column: 1 / -1;
                    text-align: center;
                    padding: 10px;
                    background: rgba(255,215,0,0.1);
                    border: 2px solid #FFD700;
                    border-radius: 15px;
                    color: #FFD700;
                    font-weight: bold;
                `;
                moreDiv.textContent = `+${unlockedAchievements.length - 4} more achievements unlocked!`;
                container.appendChild(moreDiv);
            }
        }
        
        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        function clearAsset(type) {
            // Clear the specific asset
            gameAssets[type] = null;
            
            // Clear cached pattern for background
            if (type === 'background') {
                gameAssets.backgroundPattern = null;
            }
            
            // Clear the preview
            const preview = document.getElementById(type + 'Preview');
            if (preview) {
                preview.innerHTML = '<span style="color: #FFD700;">No asset loaded</span>';
            }
            
            // Clear the file input
            const input = document.getElementById(type + 'Sprite');
            if (input) {
                input.value = '';
            }
            
            // Check if any assets are still loaded
            const hasAnyAssets = Object.keys(gameAssets).some(key => 
                key !== 'useCustomAssets' && gameAssets[key] !== null
            );
            
            if (!hasAnyAssets) {
                gameAssets.useCustomAssets = false;
            }
        }
        
        function loadAsset(type, input) {
            const file = input.files[0];
            if (!file) return;
            
            // Clear the previous asset and preview first
            if (gameAssets[type]) {
                gameAssets[type] = null;
            }
            // Clear cached pattern for background
            if (type === 'background') {
                gameAssets.backgroundPattern = null;
            }
            const preview = document.getElementById(type + 'Preview');
            if (preview) {
                preview.innerHTML = '<span>Loading...</span>';
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Ensure the old image is completely replaced
                    gameAssets[type] = img;
                    gameAssets.useCustomAssets = true;
                    
                    // For background images, create the pattern immediately to avoid performance issues
                    if (type === 'background') {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0);
                        gameAssets.backgroundPattern = tempCtx.createPattern(tempCanvas, 'repeat');
                    }
                    
                    updateAssetPreview(type, img);
                };
                img.onerror = function() {
                    // Handle loading errors
                    if (preview) {
                        preview.innerHTML = '<span style="color: red;">Error loading image</span>';
                    }
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                if (preview) {
                    preview.innerHTML = '<span style="color: red;">Error reading file</span>';
                }
            };
            reader.readAsDataURL(file);
        }
        
        function updateAssetPreview(type, img) {
            const preview = document.getElementById(type + 'Preview');
            if (preview) {
                // Completely clear the preview first
                preview.innerHTML = '';
                
                // Create new preview image
                const previewImg = document.createElement('img');
                previewImg.style.maxWidth = '100px';
                previewImg.style.maxHeight = '100px';
                previewImg.style.border = '2px solid #FFD700';
                previewImg.style.borderRadius = '5px';
                previewImg.style.margin = '5px';
                
                // Set the source after creating the element to ensure proper loading
                previewImg.onload = function() {
                    // Image loaded successfully
                };
                previewImg.onerror = function() {
                    preview.innerHTML = '<span style="color: red;">Preview failed to load</span>';
                };
                previewImg.src = img.src;
                preview.appendChild(previewImg);
            }
        }
        
        function resetToDefault() {
            // Clear all assets
            gameAssets.player = null;
            gameAssets.enemy = null;
            gameAssets.coin = null;
            gameAssets.health = null;
            gameAssets.heart = null;
            gameAssets.treasure = null;
            gameAssets.rareTreasure = null;
            gameAssets.mushroom = null;
            gameAssets.fish = null;
            gameAssets.background = null;
            gameAssets.backgroundPattern = null; // Clear cached pattern
            gameAssets.platform = null;
                                        gameAssets.crate = null;
            gameAssets.crate1 = null;
            gameAssets.crate2 = null;
            gameAssets.key = null;
            gameAssets.wizgator = null;
            gameAssets.shark = null;
            gameAssets.shark1 = null;
            gameAssets.useCustomAssets = false;
            
            // Clear all previews
            const previews = document.querySelectorAll('.preview');
            previews.forEach(preview => {
                preview.innerHTML = '<span style="color: #FFD700;">No asset loaded</span>';
            });
            
            // Clear file inputs
            const inputs = document.querySelectorAll('input[type="file"]');
            inputs.forEach(input => {
                input.value = '';
                // Trigger change event to ensure UI updates
                input.dispatchEvent(new Event('change'));
            });
        }
        
        function exportAssetConfig() {
            const config = {
                useCustomAssets: gameAssets.useCustomAssets,
                assets: {}
            };
            
            // Convert images to base64 for export
            Object.keys(gameAssets).forEach(key => {
                if (key !== 'useCustomAssets' && gameAssets[key]) {
                    const canvas = document.createElement('canvas');
                    canvas.width = gameAssets[key].width;
                    canvas.height = gameAssets[key].height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(gameAssets[key], 0, 0);
                    config.assets[key] = canvas.toDataURL();
                }
            });
            
            const dataStr = JSON.stringify(config, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'game-assets-config.json';
            link.click();
            
            URL.revokeObjectURL(url);
        }
        
        function importAssetConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const config = JSON.parse(e.target.result);
                        gameAssets.useCustomAssets = config.useCustomAssets;
                        
                        Object.keys(config.assets).forEach(key => {
                            const img = new Image();
                            img.onload = function() {
                                gameAssets[key] = img;
                                updateAssetPreview(key, img);
                            };
                            img.src = config.assets[key];
                        });
                    } catch (error) {
                        alert('Error loading asset configuration: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // ðŸ”« DEBUGGING HELPER - Add this to check laser status
        function debugLasers() {
            console.log('ðŸ”« === LASER DEBUG INFO ===');
            console.log('ðŸ”« Laser powerups array exists:', typeof laserPowerups !== 'undefined');
            console.log('ðŸ”« Laser powerups count:', laserPowerups ? laserPowerups.length : 'N/A');
            
            if (laserPowerups && laserPowerups.length > 0) {
                laserPowerups.forEach((l, i) => {
                    console.log(`ðŸ”« Laser powerup ${i}:`, {
                        x: l.x,
                        y: l.y,
                        collected: l.collected,
                        screenX: l.x - (game.camera ? game.camera.x : 0),
                        screenY: l.y - (game.camera ? game.camera.y : 0)
                    });
                });
            }
            
            console.log('ðŸ”« Player position:', player ? {x: player.x, y: player.y} : 'N/A');
            console.log('ðŸ”« Camera position:', game.camera ? {x: game.camera.x, y: game.camera.y} : 'N/A');
            console.log('ðŸ”« ========================');
        }
        
        // ðŸ”« INITIALIZATION CHECK - Add this to your level generation
        function initializeLevelWithLasers(platforms, levelNum) {
            console.log('ðŸ”« Initializing level', levelNum, 'with laser powerups');
            
            // Make sure laserPowerups array exists globally
            if (typeof laserPowerups === 'undefined') {
                console.error('ðŸ”« ERROR: laserPowerups array is not defined globally!');
                window.laserPowerups = []; // Create it if missing
            }
            
            // Generate laser powerups for this level
            const newLaserPowerups = generateRandomLasers(platforms, levelNum);
            
            // Replace existing laser powerups
            laserPowerups.length = 0; // Clear existing
            laserPowerups.push(...newLaserPowerups); // Add new ones
            
            console.log('ðŸ”« Level initialized with', laserPowerups.length, 'laser powerups');
            
            return laserPowerups;
        }
        
        // Start the game with error handling
        try {
            console.log('ðŸŽ® Starting game...');
            gameLoop();
            console.log('ðŸŽ® Game loop started successfully');
            
            // Initialize health bar
            setTimeout(() => {
                updateHealthBar();
                console.log('â¤ï¸ Health bar initialized');
            }, 100);
            
            // Initialize armor bar
            setTimeout(() => {
                updateArmorBar();
                console.log('ðŸ›¡ï¸ Armor bar initialized');
            }, 150);
        } catch (error) {
            console.error('âŒ Error starting game:', error);
            alert('Game failed to start: ' + error.message);
        }
        
        // Debug lasers on startup
        setTimeout(() => {
            try {
                debugLasers();
            } catch (error) {
                console.error('âŒ Error in debugLasers:', error);
            }
        }, 1000);
        
        // ðŸŒ Global Leaderboard System
        let globalLeaderboardData = {
            scores: [],
            coins: [],
            levels: [],
            bosses: []
        };
        let currentLeaderboardTab = 'score';
        let leaderboardUpdateInterval = null;
        
        // Mock global leaderboard data (in a real app, this would come from a server)
        function generateMockLeaderboardData() {
            const mockPlayers = [
                'OtterMaster', 'RiverRunner', 'SwimChamp', 'AquaHero', 'WaterWizard',
                'StreamSurfer', 'CreekKing', 'PondPrince', 'LakeLegend', 'OceanOtter',
                'WaveWarrior', 'TideTamer', 'SplashStar', 'DiveDynamo', 'FloatFighter'
            ];
            
            return {
                scores: mockPlayers.map((name, index) => ({
                    name: name,
                    score: Math.floor(Math.random() * 50000) + 10000,
                    rank: index + 1,
                    timestamp: Date.now() - Math.random() * 86400000 // Random time in last 24 hours
                })).sort((a, b) => b.score - a.score).map((player, index) => ({...player, rank: index + 1})),
                
                coins: mockPlayers.map((name, index) => ({
                    name: name,
                    coins: Math.floor(Math.random() * 2000) + 500,
                    rank: index + 1,
                    timestamp: Date.now() - Math.random() * 86400000
                })).sort((a, b) => b.coins - a.coins).map((player, index) => ({...player, rank: index + 1})),
                
                levels: mockPlayers.map((name, index) => ({
                    name: name,
                    levels: Math.floor(Math.random() * 50) + 10,
                    rank: index + 1,
                    timestamp: Date.now() - Math.random() * 86400000
                })).sort((a, b) => b.levels - a.levels).map((player, index) => ({...player, rank: index + 1})),
                
                bosses: mockPlayers.map((name, index) => ({
                    name: name,
                    bosses: Math.floor(Math.random() * 20) + 5,
                    rank: index + 1,
                    timestamp: Date.now() - Math.random() * 86400000
                })).sort((a, b) => b.bosses - a.bosses).map((player, index) => ({...player, rank: index + 1}))
            };
        }
        
        function loadGlobalLeaderboard() {
            console.log('ðŸŒ Loading global leaderboard...');
            
            // Simulate API call delay
            setTimeout(() => {
                globalLeaderboardData = generateMockLeaderboardData();
                updateGlobalLeaderboardDisplay();
                updateLeaderboardStatus();
                
                // Start real-time updates
                if (!leaderboardUpdateInterval) {
                    leaderboardUpdateInterval = setInterval(() => {
                        updateGlobalLeaderboardData();
                    }, 30000); // Update every 30 seconds
                }
            }, 500);
        }
        
        function refreshGlobalLeaderboard() {
            console.log('ðŸ”„ Refreshing global leaderboard...');
            const refreshBtn = document.getElementById('refreshLeaderboardBtn');
            refreshBtn.textContent = 'â³ Loading...';
            refreshBtn.disabled = true;
            
            // Simulate refresh delay
            setTimeout(() => {
                globalLeaderboardData = generateMockLeaderboardData();
                updateGlobalLeaderboardDisplay();
                updateLeaderboardStatus();
                
                refreshBtn.textContent = 'ðŸ”„ Refresh';
                refreshBtn.disabled = false;
            }, 1000);
        }
        
        function updateGlobalLeaderboardData() {
            // Simulate real-time updates by randomly updating some scores
            const updateChance = 0.3; // 30% chance to update each player
            
            globalLeaderboardData.scores.forEach(player => {
                if (Math.random() < updateChance) {
                    player.score += Math.floor(Math.random() * 1000);
                    player.timestamp = Date.now();
                }
            });
            
            globalLeaderboardData.coins.forEach(player => {
                if (Math.random() < updateChance) {
                    player.coins += Math.floor(Math.random() * 50);
                    player.timestamp = Date.now();
                }
            });
            
            globalLeaderboardData.levels.forEach(player => {
                if (Math.random() < updateChance) {
                    player.levels += Math.floor(Math.random() * 2);
                    player.timestamp = Date.now();
                }
            });
            
            globalLeaderboardData.bosses.forEach(player => {
                if (Math.random() < updateChance) {
                    player.bosses += Math.floor(Math.random() * 1);
                    player.timestamp = Date.now();
                }
            });
            
            // Re-sort and re-rank
            globalLeaderboardData.scores.sort((a, b) => b.score - a.score).forEach((player, index) => player.rank = index + 1);
            globalLeaderboardData.coins.sort((a, b) => b.coins - a.coins).forEach((player, index) => player.rank = index + 1);
            globalLeaderboardData.levels.sort((a, b) => b.levels - a.levels).forEach((player, index) => player.rank = index + 1);
            globalLeaderboardData.bosses.sort((a, b) => b.bosses - a.bosses).forEach((player, index) => player.rank = index + 1);
            
            updateGlobalLeaderboardDisplay();
            updateLeaderboardStatus();
        }
        
        function updateGlobalLeaderboardDisplay() {
            const content = document.getElementById('globalLeaderboardContent');
            const data = globalLeaderboardData[currentLeaderboardTab];
            
            if (!data || data.length === 0) {
                content.innerHTML = '<div style="text-align: center; color: #FFD700; font-size: 18px; margin: 20px 0;">No data available</div>';
                return;
            }
            
            let html = '<div style="max-height: 300px; overflow-y: auto;">';
            
            data.slice(0, 10).forEach((player, index) => {
                const isCurrentPlayer = player.name === (game.profile.playerName || 'Otter Player');
                const rankColor = index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#FFD700';
                const bgColor = isCurrentPlayer ? 'rgba(255,215,0,0.2)' : 'rgba(0,0,0,0.3)';
                const borderColor = isCurrentPlayer ? '#FFD700' : 'transparent';
                
                html += `
                    <div style="display: flex; align-items: center; padding: 10px; margin: 5px 0; background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 10px; ${isCurrentPlayer ? 'box-shadow: 0 0 10px rgba(255,215,0,0.5);' : ''}">
                        <div style="width: 40px; text-align: center; font-weight: bold; color: ${rankColor}; font-size: 18px;">
                            ${player.rank === 1 ? 'ðŸ¥‡' : player.rank === 2 ? 'ðŸ¥ˆ' : player.rank === 3 ? 'ðŸ¥‰' : `#${player.rank}`}
                        </div>
                        <div style="flex: 1; margin-left: 15px;">
                            <div style="font-weight: bold; color: ${isCurrentPlayer ? '#FFD700' : '#FFFFFF'}; font-size: 16px;">
                                ${player.name} ${isCurrentPlayer ? '(You)' : ''}
                            </div>
                            <div style="font-size: 12px; color: #00FFFF;">
                                ${currentLeaderboardTab === 'score' ? `${player.score.toLocaleString()} points` : 
                                  currentLeaderboardTab === 'coins' ? `${player.coins.toLocaleString()} coins` : 
                                  `${player.levels} levels`}
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #666;">
                            ${formatTimeAgo(player.timestamp)}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            content.innerHTML = html;
        }
        
        function switchLeaderboardTab(tab) {
            currentLeaderboardTab = tab;
            
            // Update tab button styles
            document.getElementById('scoreTabBtn').style.background = tab === 'score' ? '#FFD700' : 'rgba(255,215,0,0.3)';
            document.getElementById('scoreTabBtn').style.color = tab === 'score' ? 'black' : '#FFD700';
            document.getElementById('coinsTabBtn').style.background = tab === 'coins' ? '#FFD700' : 'rgba(255,215,0,0.3)';
            document.getElementById('coinsTabBtn').style.color = tab === 'coins' ? 'black' : '#FFD700';
            document.getElementById('levelsTabBtn').style.background = tab === 'levels' ? '#FFD700' : 'rgba(255,215,0,0.3)';
            document.getElementById('levelsTabBtn').style.color = tab === 'levels' ? 'black' : '#FFD700';
            document.getElementById('bossesTabBtn').style.background = tab === 'bosses' ? '#FFD700' : 'rgba(255,215,0,0.3)';
            document.getElementById('bossesTabBtn').style.color = tab === 'bosses' ? 'black' : '#FFD700';
            
            updateGlobalLeaderboardDisplay();
        }
        
        function updateLeaderboardStatus() {
            const status = document.getElementById('leaderboardStatus');
            const now = new Date();
            status.textContent = `Last updated: ${now.toLocaleTimeString()}`;
        }
        
        function formatTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (minutes < 1) return 'Just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return `${days}d ago`;
        }
        
        // Submit player score to global leaderboard (simulated)
        function submitToGlobalLeaderboard() {
            const playerName = game.profile.playerName || 'Otter Player';
            const playerScore = game.sessionStats.totalScore;
            const playerCoins = game.sessionStats.totalCoins;
            const playerLevels = game.sessionStats.levelsCompleted;
            
            console.log('ðŸŒ Submitting to global leaderboard:', {
                name: playerName,
                score: playerScore,
                coins: playerCoins,
                levels: playerLevels
            });
            
            // In a real implementation, this would send data to a server
            // For now, we'll just log it and update the mock data
            setTimeout(() => {
                // Simulate score submission
                console.log('âœ… Score submitted successfully!');
            }, 1000);
        }
        
        // Pause Menu Functions
        
        // Toggle pause menu
        function togglePauseMenu() {
            const pauseMenu = document.getElementById('pauseMenu');
            if (pauseMenu.style.display === 'none' || pauseMenu.style.display === '') {
                pauseMenu.style.display = 'block';
                game.gameState = 'paused';
                updatePauseMenuStats();
                populatePauseCustomization();
                setupPauseEventListeners();
                // Hide pause button and settings button when menu is open
                document.getElementById('pauseBtn').style.display = 'none';
                document.getElementById('settingsBtn').style.display = 'none';
                saveGameState(); // Save game state when pausing
            } else {
                pauseMenu.style.display = 'none';
                game.gameState = 'playing';
                // Show pause button and settings button when menu is closed
                if (game.gameState === 'playing') {
                    document.getElementById('pauseBtn').style.display = 'inline-block';
                    document.getElementById('settingsBtn').style.display = 'inline-block';
                }
            }
        }
        
        // Switch pause menu tabs
        function switchPauseTab(tab) {
            const instructionsTab = document.getElementById('pauseInstructionsTab');
            const settingsTab = document.getElementById('pauseSettingsTab');
            const customizationTab = document.getElementById('pauseCustomizationTab');
            const actionsTab = document.getElementById('pauseActionsTab');
            
            const instructionsBtn = document.getElementById('pauseInstructionsTabBtn');
            const settingsBtn = document.getElementById('pauseSettingsTabBtn');
            const customizationBtn = document.getElementById('pauseCustomizationTabBtn');
            const actionsBtn = document.getElementById('pauseActionsTabBtn');
            
            // Hide all tabs
            instructionsTab.style.display = 'none';
            settingsTab.style.display = 'none';
            customizationTab.style.display = 'none';
            actionsTab.style.display = 'none';
            
            // Remove active class from all buttons and reset styles
            [instructionsBtn, settingsBtn, customizationBtn, actionsBtn].forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.3), rgba(0,0,0,0.1))';
                btn.style.color = '#999';
                btn.style.border = '2px solid rgba(255,255,255,0.1)';
            });
            
            if (tab === 'instructions') {
                instructionsTab.style.display = 'block';
                instructionsBtn.classList.add('active');
                instructionsBtn.style.background = 'linear-gradient(135deg, rgba(76,175,80,0.2), rgba(76,175,80,0.1))';
                instructionsBtn.style.color = '#4CAF50';
                instructionsBtn.style.border = '2px solid rgba(76,175,80,0.4)';
            } else if (tab === 'settings') {
                settingsTab.style.display = 'block';
                settingsBtn.classList.add('active');
                settingsBtn.style.background = 'linear-gradient(135deg, rgba(33,150,243,0.2), rgba(33,150,243,0.1))';
                settingsBtn.style.color = '#2196F3';
                settingsBtn.style.border = '2px solid rgba(33,150,243,0.4)';
            } else if (tab === 'customization') {
                customizationTab.style.display = 'block';
                customizationBtn.classList.add('active');
                customizationBtn.style.background = 'linear-gradient(135deg, rgba(255,107,53,0.2), rgba(255,107,53,0.1))';
                customizationBtn.style.color = '#FF6B35';
                customizationBtn.style.border = '2px solid rgba(255,107,53,0.4)';
            } else if (tab === 'actions') {
                actionsTab.style.display = 'block';
                actionsBtn.classList.add('active');
                actionsBtn.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,215,0,0.1))';
                actionsBtn.style.color = '#FFD700';
                actionsBtn.style.border = '2px solid rgba(255,215,0,0.4)';
            }
        }
        
        // Update pause menu statistics
        function updatePauseMenuStats() {
            document.getElementById('pauseScore').textContent = game.score;
            document.getElementById('pauseCoins').textContent = game.coins;
            document.getElementById('pauseHealth').textContent = player.health;
            document.getElementById('pauseLevel').textContent = player.level;
        }
        
        // Populate pause menu customization options
        function populatePauseCustomization() {
            // Populate otter skins
            const otterSkinsContainer = document.getElementById('pauseOtterSkins');
            otterSkinsContainer.innerHTML = '';
            
            if (marketplaceItems && marketplaceItems.skins) {
                marketplaceItems.skins.forEach(skin => {
                    if (skin.owned) {
                        const skinElement = document.createElement('div');
                        skinElement.style.cssText = `
                            background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(26,26,46,0.6));
                            border: 2px solid ${skin.equipped ? 'rgba(76,175,80,0.6)' : 'rgba(255,215,0,0.4)'};
                            border-radius: 10px;
                            padding: 10px;
                            text-align: center;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            ${skin.equipped ? 'box-shadow: 0 0 15px rgba(76,175,80,0.6);' : ''}
                        `;
                        
                        skinElement.innerHTML = `
                            <img src="${skin.image}" alt="${skin.name}" style="width: 40px; height: 40px; object-fit: contain; border-radius: 5px;">
                            <div style="font-size: 10px; color: #FFD700; margin-top: 5px;">${skin.name}</div>
                            ${skin.equipped ? '<div style="color: #4CAF50; font-size: 8px;">âœ“</div>' : ''}
                        `;
                        
                        skinElement.onclick = () => equipSkin(skin.id);
                        otterSkinsContainer.appendChild(skinElement);
                    }
                });
            }
            
            // Populate owl hats
            const owlHatsContainer = document.getElementById('pauseOwlHats');
            owlHatsContainer.innerHTML = '';
            
            if (marketplaceItems && marketplaceItems.hats) {
                marketplaceItems.hats.forEach(hat => {
                    if (hat.owned) {
                        const hatElement = document.createElement('div');
                        hatElement.style.cssText = `
                            background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(26,26,46,0.6));
                            border: 2px solid ${hat.equipped ? 'rgba(76,175,80,0.6)' : 'rgba(255,215,0,0.4)'};
                            border-radius: 10px;
                            padding: 10px;
                            text-align: center;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            ${hat.equipped ? 'box-shadow: 0 0 15px rgba(76,175,80,0.6);' : ''}
                        `;
                        
                        hatElement.innerHTML = `
                            <img src="${hat.image}" alt="${hat.name}" style="width: 40px; height: 40px; object-fit: contain; border-radius: 5px;">
                            <div style="font-size: 10px; color: #FFD700; margin-top: 5px;">${hat.name}</div>
                            ${hat.equipped ? '<div style="color: #4CAF50; font-size: 8px;">âœ“</div>' : ''}
                        `;
                        
                        hatElement.onclick = () => equipHat(hat.id);
                        owlHatsContainer.appendChild(hatElement);
                    }
                });
            }
        }
        
        // Setup pause menu event listeners
        function setupPauseEventListeners() {
            // AI Owl Bot toggle
            const aiOwlToggle = document.getElementById('aiOwlToggle');
            const aiOwlStatus = document.getElementById('aiOwlStatus');
            
            aiOwlToggle.checked = aiOwlBotEnabled;
            aiOwlStatus.textContent = aiOwlBotEnabled ? 'ON' : 'OFF';
            aiOwlStatus.style.color = aiOwlBotEnabled ? '#4CAF50' : '#FF4444';
            
            aiOwlToggle.addEventListener('change', function() {
                aiOwlBotEnabled = this.checked;
                aiOwlStatus.textContent = aiOwlBotEnabled ? 'ON' : 'OFF';
                aiOwlStatus.style.color = aiOwlBotEnabled ? '#4CAF50' : '#FF4444';
                console.log('ðŸ¤– AI Owl Bot:', aiOwlBotEnabled ? 'Enabled' : 'Disabled');
            });
            
            // Settings sliders
            const sliders = [
                { id: 'screenShakeSlider', label: 'Screen Shake' },
                { id: 'particleEffectsSlider', label: 'Particle Effects' },
                { id: 'masterVolumeSlider', label: 'Master Volume' },
                { id: 'sfxVolumeSlider', label: 'SFX Volume' }
            ];
            
            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                if (element) {
                    const display = element.nextElementSibling;
                    if (display) {
                        element.addEventListener('input', function() {
                            display.textContent = this.value + '%';
                        });
                    }
                }
            });
        }
        
        // Pause menu action functions
        function resumeGame() {
            togglePauseMenu();
            game.gameState = 'playing';
        }
        
        function restartLevel() {
            if (confirm('Are you sure you want to restart the current level? All progress will be lost.')) {
                togglePauseMenu();
                // Reset current level without going back to title screen
                game.score = 0;
                game.coins = 0;
                game.lives = 3;
                game.gameOver = false;
                game.levelComplete = false;
                game.levelTransition = false;
                game.lastLifeScore = 0;
                game.camera = { x: 0, y: 0 };
                
                // Reset checkpoint progress for current level only
                if (game.checkpointProgress[game.level]) {
                    delete game.checkpointProgress[game.level];
                }
                game.activeCheckpoint = null;
                game.currentBoss = null;
                game.bossActive = false;
                game.secrets = [];
                game.secretRooms = [];
                game.particles = [];
                game.screenShake = 0;
                game.freezeFrame = 0;
                
                // Reset player state
                player.x = 240;
                player.y = 1200;
                player.velX = 0;
                player.velY = 0;
                player.onGround = true;
                player.canDoubleJump = true;
                player.direction = 1;
                player.invulnerable = false;
                player.invulnerableTime = 0;
                player.giant = false;
                player.giantTime = 0;
                player.health = player.maxHealth;
                player.armor = 0;

                // Reset jetpack
                player.hasJetpack = false;
                player.jetpackActive = false;
                player.jetpackTime = 0;
                player.lastPlatform = null;
                
                // Reset laser system for each level (but preserve laser charging level)
                player.hasLaser = false;
                player.laserActive = false;
                player.laserTime = 0;
                player.laserCooldown = 0;
                player.currentLaserColor = 0;
                player.isCharging = false;
                player.chargeStartTime = 0;
                player.chargeLevel = 0;
                
                // Reset fireball system for each level
                player.hasFireball = false;
                player.fireballCooldown = 0;
                
                // Check for equipped abilities from marketplace
                if (game.marketplace.currentAbilities && game.marketplace.currentAbilities.length > 0) {
                    game.marketplace.currentAbilities.forEach(abilityId => {
                        if (abilityId === 'jetpack') {
                            player.hasJetpack = true;
                        } else if (abilityId === 'laser') {
                            player.hasLaser = true;
                        } else if (abilityId === 'fireball') {
                            player.hasFireball = true;
                        } else if (abilityId === 'armor') {
                            player.hasArmorBoost = true;
                            player.armorLevel = 1;
                        }
                    });
                }
                
                playerLasers = [];
                bossLasers = [];
                playerFireballs = [];
                
                // Reset key count for each level
                game.keyCount = 0;
                player.keys = 0;
                
                // Regenerate level
                generateLevel(game.level);
                
                // Reset UI displays
                document.getElementById('score').textContent = '0';
                document.getElementById('coins').textContent = '0';
                document.getElementById('lives').textContent = '3';
                document.getElementById('giantIndicator').style.display = 'none';
                
                // Reset collectibles counter for new level
                game.collectiblesCount.coinsCollected = 0;
                game.collectiblesCount.chestsCollected = 0;
                game.collectiblesCount.goldenChestsCollected = 0;
                updateCollectiblesCounter();
                
                game.gameState = 'playing';
                console.log('Level restarted successfully');
            }
        }
        
        function returnToHome() {
            if (confirm('Are you sure you want to return to the main menu? All unsaved progress will be lost.')) {
                togglePauseMenu();
                returnToStart();
            }
        }
        
        function saveAndQuit() {
            savePlayerProgress();
            saveMarketplaceData();
            alert('Progress saved! Returning to main menu.');
            togglePauseMenu();
            returnToStart();
        }
        
        // Add keyboard event listener for pause menu
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && game.gameState === 'playing') {
                e.preventDefault();
                togglePauseMenu();
            }
        });

        // Asset Importer Functions
        let importedAssets = {
            otter: null,
            owl: null,
            enemies: [],
            backgrounds: [],
            platforms: [],
            collectibles: []
        };

        function importOtterCharacter() {
            const input = document.getElementById('otterCharacterInput');
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        importedAssets.otter = {
                            src: e.target.result,
                            name: file.name,
                            width: img.width,
                            height: img.height
                        };
                        showAssetImportNotification('Otter character imported successfully!', 'success');
                        console.log('ðŸ¦¦ Otter character imported:', file.name);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                showAssetImportNotification('Please select a file first!', 'error');
            }
        }

        function importOwlCompanion() {
            const input = document.getElementById('owlCompanionInput');
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        importedAssets.owl = {
                            src: e.target.result,
                            name: file.name,
                            width: img.width,
                            height: img.height
                        };
                        showAssetImportNotification('Owl companion imported successfully!', 'success');
                        console.log('ðŸ¦‰ Owl companion imported:', file.name);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                showAssetImportNotification('Please select a file first!', 'error');
            }
        }

        function importEnemySprites() {
            const input = document.getElementById('enemySpritesInput');
            const files = input.files;
            if (files.length > 0) {
                importedAssets.enemies = [];
                let loadedCount = 0;
                
                Array.from(files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            importedAssets.enemies.push({
                                src: e.target.result,
                                name: file.name,
                                width: img.width,
                                height: img.height,
                                type: `enemy_${index}`
                            });
                            loadedCount++;
                            
                            if (loadedCount === files.length) {
                                showAssetImportNotification(`${files.length} enemy sprites imported successfully!`, 'success');
                                console.log('ðŸ‘¹ Enemy sprites imported:', files.length, 'files');
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                showAssetImportNotification('Please select files first!', 'error');
            }
        }

        function importBackgrounds() {
            const input = document.getElementById('backgroundInput');
            const files = input.files;
            if (files.length > 0) {
                importedAssets.backgrounds = [];
                let loadedCount = 0;
                
                Array.from(files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            importedAssets.backgrounds.push({
                                src: e.target.result,
                                name: file.name,
                                width: img.width,
                                height: img.height,
                                type: `background_${index}`
                            });
                            loadedCount++;
                            
                            if (loadedCount === files.length) {
                                showAssetImportNotification(`${files.length} background images imported successfully!`, 'success');
                                console.log('ðŸŒ… Background images imported:', files.length, 'files');
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                showAssetImportNotification('Please select files first!', 'error');
            }
        }

        function importPlatforms() {
            const input = document.getElementById('platformInput');
            const files = input.files;
            if (files.length > 0) {
                importedAssets.platforms = [];
                let loadedCount = 0;
                
                Array.from(files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            importedAssets.platforms.push({
                                src: e.target.result,
                                name: file.name,
                                width: img.width,
                                height: img.height,
                                type: `platform_${index}`
                            });
                            loadedCount++;
                            
                            if (loadedCount === files.length) {
                                showAssetImportNotification(`${files.length} platform textures imported successfully!`, 'success');
                                console.log('ðŸ—ï¸ Platform textures imported:', files.length, 'files');
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                showAssetImportNotification('Please select files first!', 'error');
            }
        }

        function importCollectibles() {
            const input = document.getElementById('collectiblesInput');
            const files = input.files;
            if (files.length > 0) {
                importedAssets.collectibles = [];
                let loadedCount = 0;
                
                Array.from(files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            importedAssets.collectibles.push({
                                src: e.target.result,
                                name: file.name,
                                width: img.width,
                                height: img.height,
                                type: `collectible_${index}`
                            });
                            loadedCount++;
                            
                            if (loadedCount === files.length) {
                                showAssetImportNotification(`${files.length} collectibles imported successfully!`, 'success');
                                console.log('ðŸª™ Collectibles imported:', files.length, 'files');
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                showAssetImportNotification('Please select files first!', 'error');
            }
        }

        function previewImportedAssets() {
            const previewArea = document.getElementById('assetPreviewArea');
            const previewGrid = document.getElementById('assetPreviewGrid');
            
            if (previewArea.style.display === 'none') {
                previewArea.style.display = 'block';
                previewGrid.innerHTML = '';
                
                // Add all imported assets to preview
                const allAssets = [
                    ...(importedAssets.otter ? [importedAssets.otter] : []),
                    ...(importedAssets.owl ? [importedAssets.owl] : []),
                    ...importedAssets.enemies,
                    ...importedAssets.backgrounds,
                    ...importedAssets.platforms,
                    ...importedAssets.collectibles
                ];
                
                if (allAssets.length === 0) {
                    previewGrid.innerHTML = '<div style="text-align: center; color: #FFD700; grid-column: 1 / -1;">No assets imported yet</div>';
                    return;
                }
                
                allAssets.forEach(asset => {
                    const assetElement = document.createElement('div');
                    assetElement.style.cssText = `
                        background: rgba(255,215,0,0.1);
                        border: 2px solid rgba(255,215,0,0.3);
                        border-radius: 10px;
                        padding: 10px;
                        text-align: center;
                        transition: all 0.3s ease;
                    `;
                    
                    assetElement.innerHTML = `
                        <img src="${asset.src}" alt="${asset.name}" style="width: 60px; height: 60px; object-fit: contain; border-radius: 5px; margin-bottom: 5px;">
                        <div style="font-size: 10px; color: #FFD700; word-break: break-word;">${asset.name}</div>
                        <div style="font-size: 8px; color: #00FFFF;">${asset.width}x${asset.height}</div>
                    `;
                    
                    previewGrid.appendChild(assetElement);
                });
            } else {
                previewArea.style.display = 'none';
            }
        }

        function exportAssetPack() {
            const assetPack = {
                version: '1.0',
                timestamp: Date.now(),
                assets: importedAssets
            };
            
            const dataStr = JSON.stringify(assetPack, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `otter-bros-asset-pack-${Date.now()}.json`;
            link.click();
            
            showAssetImportNotification('Asset pack exported successfully!', 'success');
            console.log('ðŸ“¦ Asset pack exported');
        }

        function resetToDefaults() {
            if (confirm('Are you sure you want to reset all imported assets to defaults?')) {
                importedAssets = {
                    otter: null,
                    owl: null,
                    enemies: [],
                    backgrounds: [],
                    platforms: [],
                    collectibles: []
                };
                
                // Clear file inputs
                document.getElementById('otterCharacterInput').value = '';
                document.getElementById('owlCompanionInput').value = '';
                document.getElementById('enemySpritesInput').value = '';
                document.getElementById('backgroundInput').value = '';
                document.getElementById('platformInput').value = '';
                document.getElementById('collectiblesInput').value = '';
                
                // Hide preview area
                document.getElementById('assetPreviewArea').style.display = 'none';
                
                showAssetImportNotification('Assets reset to defaults!', 'success');
                console.log('ðŸ”„ Assets reset to defaults');
            }
        }

        function clearAllAssets() {
            if (confirm('Are you sure you want to clear all imported assets? This cannot be undone.')) {
                importedAssets = {
                    otter: null,
                    owl: null,
                    enemies: [],
                    backgrounds: [],
                    platforms: [],
                    collectibles: []
                };
                
                // Clear file inputs
                document.getElementById('otterCharacterInput').value = '';
                document.getElementById('owlCompanionInput').value = '';
                document.getElementById('enemySpritesInput').value = '';
                document.getElementById('backgroundInput').value = '';
                document.getElementById('platformInput').value = '';
                document.getElementById('collectiblesInput').value = '';
                
                // Hide preview area
                document.getElementById('assetPreviewArea').style.display = 'none';
                
                showAssetImportNotification('All assets cleared!', 'success');
                console.log('ðŸ—‘ï¸ All assets cleared');
            }
        }

        function showAssetImportNotification(message, type) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? 'linear-gradient(135deg, #4CAF50, #45a049)' : 'linear-gradient(135deg, #FF4444, #CC0000)'};
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                animation: slideIn 0.3s ease-out;
            `;
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Secret chest spawning system
        function checkSecretChestConditions() {
            // Check if conditions are met for secret chests
            const coinsCollected = game.collectiblesCount.coinsCollected;
            const treasuresCollected = game.sessionStats.treasuresCollected;
            const keysCollected = game.sessionStats.keysCollected;
            
            // Update tracking
            game.secretChestConditions.coinsCollected = coinsCollected;
            game.secretChestConditions.treasuresCollected = treasuresCollected;
            game.secretChestConditions.keysCollected = keysCollected;
            
            // Get total coins in current level - coins is a global array set in loadLevel
            const totalCoinsInLevel = (typeof coins !== 'undefined' && coins.length > 0) ? coins.length : 50; // Default to 50 if not available
            
            // Check if all coins on current level are collected (50 coins) and other conditions are met
            // Only spawn if chests haven't been spawned yet
            if (coinsCollected >= totalCoinsInLevel && treasuresCollected >= 11 && keysCollected >= 1 && !game.secretChestsSpawned) {
                spawnSecretChests();
                showAIOwlBotMessage("ðŸ¦‰ *whispers* Hoot hoot! I sense something special at the beginning of this level... maybe you should go back and check? *winks*");
            }
        }

        function spawnSecretChests() {
            console.log('ðŸŽ SECRET CHESTS SPAWNING!');
            game.secretChestsSpawned = true;
            
            // Get level boundaries from platforms (same logic as coins)
            const levelMinX = platforms.length > 0 ? Math.min(...platforms.map(p => p.x)) : 0;
            const levelMaxX = platforms.length > 0 ? Math.max(...platforms.map(p => p.x + p.width)) : 2000;
            
            // Find the spawn point (beginning of level) - use player starting position
            const spawnX = 240; // Player spawn position (from player.x)
            const spawnY = 1200; // Ground level (from player starting y)
            
            // Left boundary is 40px left of spawn (from game code: leftBoundaryX = 240 - 200 = 40)
            const leftBoundaryX = 40;
            const rightBoundaryX = levelMaxX;
            
            // Create 10 chests (reduced from 20) - place them in a tight, reachable group
            const chestCount = 10;
            const chestSpacing = 50; // Closer spacing for 10 chests
            const totalWidth = (chestCount - 1) * chestSpacing; // 9 spaces for 10 chests
            let startX = spawnX - totalWidth / 2; // Center the chests around spawn
            
            // Ensure startX is within reachable bounds (left boundary + margin)
            startX = Math.max(leftBoundaryX + 30, Math.min(rightBoundaryX - (totalWidth + 30), startX));
            
            // Find a platform near spawn to place chests on (more reliable than ground)
            const spawnPlatform = platforms.find(p => 
                p.x <= spawnX + 100 && 
                p.x + p.width >= spawnX - 100 && 
                p.y >= spawnY - 100 && 
                p.y <= spawnY + 100
            ) || platforms.find(p => p.x === 0 && p.y === 1320); // Fallback to starting platform
            
            const chestY = spawnPlatform ? spawnPlatform.y - 50 : spawnY - 50; // Above platform or ground
            
            for (let i = 0; i < chestCount; i++) {
                let chestX = startX + (i * chestSpacing);
                
                // Clamp chest X position to reachable boundaries
                chestX = Math.max(leftBoundaryX + 30, Math.min(rightBoundaryX - 30, chestX));
                
                // Ensure chest Y is within reasonable bounds
                const safeChestY = Math.max(0, Math.min(2500, chestY));
                
                const secretChest = {
                    x: chestX,
                    y: safeChestY,
                    width: 40,
                    height: 40,
                    collected: false,
                    type: 'chest',
                    isSecret: true,
                    value: 25, // Each chest gives 25 coins (regular chest value)
                    glowIntensity: 0,
                    glowSpeed: 0.05,
                    glowDirection: 1
                };
                
                treasures.push(secretChest);
            }
            
            console.log(`ðŸŽ Spawned ${chestCount} secret chests at spawn (${spawnX}, ${chestY}), boundaries: ${leftBoundaryX} to ${rightBoundaryX}`);
            
            // Show special notification
            showSecretChestNotification();
        }

        function showSecretChestNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FFD700, #FFA500);
                color: white;
                padding: 20px 30px;
                border-radius: 15px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 10px 30px rgba(255,215,0,0.6);
                animation: secretChestPulse 2s ease-in-out;
                font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 10px;">ðŸ“¦</div>
                <div>SECRET CHESTS DISCOVERED!</div>
                <div style="font-size: 14px; margin-top: 8px; opacity: 0.9;">20 Regular Chests have appeared!</div>
                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">Check the beginning of the level!</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 4000);
        }

        function showAIOwlBotMessage(message) {
            if (!aiOwlBotEnabled) return;
            
            // Set the message to display in the owl's speech bubble
            game.aiBot.currentTip = message;
            game.aiBot.tipTimer = 0;
            game.aiBot.lastTipTime = Date.now();
            
            // Clear the message after 6 seconds
            setTimeout(() => {
                if (game.aiBot.currentTip === message) {
                    game.aiBot.currentTip = '';
                    game.aiBot.tipTimer = 0;
                }
            }, 6000);
        }
        
        // AI Owl Bot Message System
        const owlMessages = {
            // Funny Jokes
            jokes: [
                "ðŸ¦‰ *chuckles* Why did the otter go to the doctor? Because it had a bad case of the 'otter' flu! *hoots with laughter*",
                "ðŸ¦‰ *winks* What do you call an otter that's good at math? A calcu-otter! *giggles*",
                "ðŸ¦‰ *whispers* Why don't otters like to play cards? Because they're afraid of getting otter-ly beaten! *hoots*",
                "ðŸ¦‰ *laughs* What's an otter's favorite type of music? Rock and otter! *bounces excitedly*",
                "ðŸ¦‰ *chuckles* Why did the otter bring a ladder to the pool? To reach the high dive! *hoots*",
                "ðŸ¦‰ *giggles* What do you call an otter that's always late? A procrasti-otter! *winks*",
                "ðŸ¦‰ *laughs* Why did the otter go to art school? To learn how to otter-draw! *bounces*",
                "ðŸ¦‰ *chuckles* What's an otter's favorite dance? The otter shuffle! *hoots with joy*",
                "ðŸ¦‰ *laughs* That was otterly hilarious! *hoots with amusement*",
                "ðŸ¦‰ *giggles* Your puns are ottstanding! *bounces around*",
                "ðŸ¦‰ *chuckles* This game is absolutely otterful! *spins excitedly*"
            ],
            
            // Important Tips
            tips: [
                "ðŸ¦‰ *wisely* Tip: Hold the laser button to charge for more powerful shots! *nods knowingly*",
                "ðŸ¦‰ *helpfully* Tip: Use the jetpack underwater for extra speed! *flaps wings*",
                "ðŸ¦‰ *advises* Tip: Collect coins to earn XP and level up faster! *points to coins*",
                "ðŸ¦‰ *suggests* Tip: Check underwater areas for hidden treasures! *looks down*",
                "ðŸ¦‰ *reminds* Tip: Use mushrooms to become giant and break through obstacles! *gestures up*",
                "ðŸ¦‰ *hints* Tip: Defeat enemies to earn points and unlock achievements! *flexes wings*",
                "ðŸ¦‰ *advises* Tip: Save your progress by completing levels! *nods seriously*",
                "ðŸ¦‰ *suggests* Tip: Try different owl hats for unique bonuses! *adjusts own hat*",
                "ðŸ¦‰ *hints* Tip: Look for secret areas behind waterfalls! *mysterious hoot*",
                "ðŸ¦‰ *advises* Tip: Use the double jump to reach higher platforms! *demonstrates*",
                "ðŸ¦‰ *wisely* Tip: Your gameplay is getting otterly impressive! *nods approvingly*",
                "ðŸ¦‰ *helpfully* Tip: That move was ottstanding! Keep it up! *flaps encouragingly*",
                "ðŸ¦‰ *advises* Tip: This level is going to be otterful fun! *bounces excitedly*"
            ],
            
            // Encouragement
            encouragement: [
                "ðŸ¦‰ *cheerfully* You're doing great! Keep up the otter-ific work! *hoots encouragingly*",
                "ðŸ¦‰ *proudly* Wow! You're really getting the hang of this! *puffs chest*",
                "ðŸ¦‰ *excitedly* Amazing progress! You're becoming a true otter master! *bounces*",
                "ðŸ¦‰ *supportively* Don't give up! Every otter was once a beginner! *nods wisely*",
                "ðŸ¦‰ *enthusiastically* You've got this! Show those enemies who's boss! *flexes wings*",
                "ðŸ¦‰ *cheerfully* Your skills are otterly amazing! *hoots with pride*",
                "ðŸ¦‰ *proudly* That was ottstanding gameplay! *puffs chest with pride*",
                "ðŸ¦‰ *excitedly* You're having an otterful adventure! *bounces with joy*",
                "ðŸ¦‰ *supportively* Your determination is otterly inspiring! *nods encouragingly*",
                "ðŸ¦‰ *enthusiastically* You're doing ottstanding work! *flexes wings proudly*"
            ],
            
            // Situational Messages
            situational: {
                lowHealth: "ðŸ¦‰ *worried* Oh no! Your health is low! Look for heart pickups! *frantically flaps*",
                manyEnemies: "ðŸ¦‰ *nervously* Lots of enemies ahead! Use your laser or fireball! *hides behind wing*",
                underwater: "ðŸ¦‰ *excitedly* Underwater exploration time! Don't forget to breathe! *holds breath*",
                highScore: "ðŸ¦‰ *impressed* Incredible score! You're on fire! *hoots with amazement*",
                levelComplete: "ðŸ¦‰ *celebrates* Level complete! You're unstoppable! *dances around*",
                achievement: "ðŸ¦‰ *proudly* Achievement unlocked! You're earning those feathers! *preens*",
                lowHealthOtterly: "ðŸ¦‰ *worried* Your health is otterly low! Find those hearts quickly! *frantically flaps*",
                manyEnemiesOtterly: "ðŸ¦‰ *nervously* That's an otterly dangerous situation! Use your weapons! *hides behind wing*",
                underwaterOtterly: "ðŸ¦‰ *excitedly* Time for some otterly amazing underwater exploration! *holds breath*",
                highScoreOtterly: "ðŸ¦‰ *impressed* That score is otterly incredible! You're ottstanding! *hoots with amazement*",
                levelCompleteOtterly: "ðŸ¦‰ *celebrates* Level complete! That was otterful! *dances around*",
                achievementOtterly: "ðŸ¦‰ *proudly* Achievement unlocked! Your progress is otterly impressive! *preens*"
            }
        };
        
        let lastOwlMessageTime = 0;
        const owlMessageCooldown = 30000; // 30 seconds between messages
        
        function showRandomOwlMessage(type = 'random') {
            if (!aiOwlBotEnabled) return;
            
            const now = Date.now();
            if (now - lastOwlMessageTime < owlMessageCooldown) return;
            
            let message = '';
            
            if (type === 'joke') {
                message = owlMessages.jokes[Math.floor(Math.random() * owlMessages.jokes.length)];
            } else if (type === 'tip') {
                message = owlMessages.tips[Math.floor(Math.random() * owlMessages.tips.length)];
            } else if (type === 'encouragement') {
                message = owlMessages.encouragement[Math.floor(Math.random() * owlMessages.encouragement.length)];
            } else {
                // Random type
                const types = ['jokes', 'tips', 'encouragement'];
                const randomType = types[Math.floor(Math.random() * types.length)];
                message = owlMessages[randomType][Math.floor(Math.random() * owlMessages[randomType].length)];
            }
            
            showAIOwlBotMessage(message);
            lastOwlMessageTime = now;
        }
        
        function showSituationalOwlMessage(situation) {
            if (!aiOwlBotEnabled) return;
            
            const now = Date.now();
            if (now - lastOwlMessageTime < owlMessageCooldown) return;
            
            // Sometimes use the otterly version for extra fun (30% chance)
            const useOtterly = Math.random() < 0.3;
            const situationKey = useOtterly ? situation + 'Otterly' : situation;
            
            const message = owlMessages.situational[situationKey] || owlMessages.situational[situation];
            if (message) {
                showAIOwlBotMessage(message);
                lastOwlMessageTime = now;
            }
        }

        // Setup button event listeners after DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Wait a bit to ensure all elements are fully loaded
            setTimeout(() => {
                const startBtn = document.getElementById('startGameBtn');
                const profileBtn = document.getElementById('profileBtn');
                const marketplaceBtn = document.getElementById('marketplaceBtn');
                const skipBtn = document.getElementById('skipCutsceneBtn');
                const continueBtn = document.getElementById('continueGameBtn');
                
                if (continueBtn) {
                    continueBtn.addEventListener('click', (event) => {
                        addButtonClickEffect(event.target);
                        console.log('ðŸŽ® Continue Game clicked!');
                        continueGame();
                    });
                    console.log('âœ… Continue Game button listener attached');
                }
                
                if (startBtn) {
                    startBtn.addEventListener('click', (event) => {
                        addButtonClickEffect(event.target);
                        
                        // Check if there's a saved game that can be continued
                        if (hasSavedGame()) {
                            const confirmed = confirm('âš ï¸ WARNING: You have a saved game that can be continued!\n\nThis will start a brand new game and overwrite your saved progress.\n\nAre you sure you want to continue?');
                            if (!confirmed) {
                                console.log('ðŸš« User cancelled starting new game due to existing save');
                                return;
                            }
                            console.log('âœ… User confirmed starting new game despite existing save');
                        }
                        
                        console.log('ðŸš€ Start Adventure clicked - starting game immediately!');
                        
                        // Start the game immediately
                        startGame();
                    });
                    console.log('âœ… Start Adventure button listener attached');
                } else {
                    console.error('âŒ startGameBtn not found!');
                }
                
                if (profileBtn) {
                    profileBtn.addEventListener('click', (event) => {
                        console.log('ðŸ‘¤ Profile button clicked via event listener!');
                        addButtonClickEffect(event.target);
                        toggleProfile();
                    });
                    console.log('âœ… Profile button listener attached');
                } else {
                    console.error('âŒ profileBtn not found!');
                }
                
                if (marketplaceBtn) {
                    marketplaceBtn.addEventListener('click', (event) => {
                        console.log('ðŸ›’ Marketplace button clicked via event listener!');
                        addButtonClickEffect(event.target);
                        toggleMarketplace();
                    });
                    console.log('âœ… Marketplace button listener attached');
                } else {
                    console.error('âŒ marketplaceBtn not found!');
                }
                
                if (skipBtn) {
                    skipBtn.addEventListener('click', skipCutscene);
                    console.log('âœ… Skip cutscene button listener attached');
                }
            }, 100);
        });

        // Add CSS animations for notifications
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
            @keyframes achievementSlideIn {
                from { transform: translateY(-20px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }
            @keyframes achievementSlideOut {
                from { transform: translateY(0); opacity: 1; }
                to { transform: translateY(-20px); opacity: 0; }
            }
            @keyframes secretChestPulse {
                0% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 10px 30px rgba(255,215,0,0.6); }
                50% { transform: translate(-50%, -50%) scale(1.1); box-shadow: 0 15px 40px rgba(255,215,0,0.8); }
                100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 10px 30px rgba(255,215,0,0.6); }
            }
            @keyframes owlMessageSlideIn {
                from { transform: translateX(-50%) translateY(50px); opacity: 0; }
                to { transform: translateX(-50%) translateY(0); opacity: 1; }
            }
            @keyframes owlMessageSlideOut {
                from { transform: translateX(-50%) translateY(0); opacity: 1; }
                to { transform: translateX(-50%) translateY(50px); opacity: 0; }
            }
            @keyframes achievementPopupSlideIn {
                from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }
            @keyframes achievementPopupSlideOut {
                from { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                to { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        function testMetadataFetching() {
            console.log('ðŸŒ Testing metadata fetching for your wallet...');
            console.log('ðŸ‘¤ Your wallet address:', '0x16E315e37cDEda413D22a6899FFF67A4B001D91B');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('âš ï¸ Wallet not connected');
                return;
            }
            
            // Test your specific wallet
            const testAddress = '0x16E315e37cDEda413D22a6899FFF67A4B001D91B';
            const contractAddress = '0x4e5913922b7ddf916c8d27d1016827f799687e66';
            
            console.log('ðŸ” Testing balance for your address...');
            const data = '0x70a08231' + testAddress.slice(2).padStart(64, '0');
            
            window.ethereum.request({
                method: 'eth_call',
                params: [{
                    to: contractAddress,
                    data: data
                }, 'latest']
            }).then(result => {
                const balance = parseInt(result, 16);
                console.log('ðŸ’° Your balance:', balance);
                
                if (balance > 0) {
                    console.log('ðŸŽ‰ Found NFTs! Now checking token 0...');
                    // Check token 0 specifically
                    const ownerData = '0x6352211e' + '0'.padStart(64, '0');
                    return window.ethereum.request({
                        method: 'eth_call',
                        params: [{
                            to: contractAddress,
                            data: ownerData
                        }, 'latest']
                    });
                } else {
                    console.log('âš ï¸ No NFTs found');
                }
            }).then(result => {
                if (result) {
                    const owner = '0x' + result.slice(26);
                    console.log('ðŸ‘¤ Token 0 owner:', owner);
                    console.log('âœ… Matches your wallet:', owner.toLowerCase() === testAddress.toLowerCase());
                }
            }).catch(error => {
                console.error('âŒ Error testing metadata:', error);
            });
        }

        // Console commands for debugging:
        // otterWallet.debugLocalStorage()
        // otterWallet.manualLoadNFTs() 
        // otterWallet.testNFTDisplay()  // Test NFT display system
        // otterWallet.debugNFTDisplayIssue()  // NEW: Comprehensive debug
        // otterWallet.forceShowNFTs()  // NEW: Force show NFTs in profile tab
        // otterWallet.testLocalStoragePersistence()  // NEW: Test localStorage persistence
        // otterWallet.forceSaveTestData()  // NEW: Force save test data
        // otterWallet.clearLocalStorage()  // NEW: Clear localStorage completely
        // otterWallet.forceReset()  // NEW: Force reset everything
        // otterWallet.nuclearClear()  // NEW: Nuclear clear and reload
        // otterWallet.simulateStakeNFT('1001')
        // otterWallet.simulateUnstakeAll()

        // AUTO-CLEAR DEMO NFTS ON STARTUP
        console.log('ðŸ§¹ AUTO-CLEARING DEMO NFTS ON STARTUP...');
        
        // Check if there are demo NFTs in localStorage and clear them
        const stored = localStorage.getItem('otterWalletNFTs');
        if (stored) {
            try {
                const data = JSON.parse(stored);
                const hasDemoNFTs = data.userNFTs && data.userNFTs.some(nft => 
                    nft.tokenId === '1001' || nft.tokenId === '1002' || nft.tokenId === '1003' ||
                    nft.name && nft.name.includes('Otter #1001') || nft.name && nft.name.includes('Otter #1002') || nft.name && nft.name.includes('Otter #1003')
                );
                
                if (hasDemoNFTs) {
                    console.log('ðŸ—‘ï¸ FOUND DEMO NFTS - CLEARING THEM!');
                    localStorage.clear();
                    console.log('âœ… DEMO NFTS CLEARED!');
                } else {
                    console.log('âœ… No demo NFTs found in localStorage');
                }
            } catch (error) {
                console.log('âŒ Error checking localStorage, clearing anyway');
                localStorage.clear();
            }
        }
        
        console.log('âœ… localStorage system loaded - data will persist across page refreshes');

    </script>
</body>
</html>



