<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollie the Otter - 2D Platformer</title>
    <style>
            @keyframes levelUpPulse {
                0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }
            
            @keyframes laserUpgradePulse {
                0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }
            
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            position: relative;
            overflow: hidden;
        }
        
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
            animation: backgroundShift 10s ease-in-out infinite;
        }
        
        @keyframes backgroundShift {
            0%, 100% { transform: translateX(0) translateY(0); }
            25% { transform: translateX(-10px) translateY(-10px); }
            50% { transform: translateX(10px) translateY(-5px); }
            75% { transform: translateX(-5px) translateY(10px); }
        }
        
        @font-face {
            font-family: 'SuperMario';
            src: url('public/SuperMario256.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            border: 6px solid #FFD700;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 0 30px rgba(255,215,0,0.3);
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            padding: 10px;
            animation: glow 3s ease-in-out infinite alternate;
            overflow: hidden;
            min-height: 400px;
            min-width: 600px;
        }
        
        #gameCanvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
        }
        
        @keyframes glow {
            from { box-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 0 30px rgba(255,215,0,0.3); }
            to { box-shadow: 0 15px 35px rgba(0,0,0,0.4), 0 0 50px rgba(255,215,0,0.6); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .score-row {
                flex-direction: column;
                gap: 4px;
            }
            
            .score-item {
                font-size: 12px;
                padding: 6px 10px;
            }
            
            .game-title {
                font-size: 16px;
                padding: 8px 12px;
            }
            
            .corner-display {
                font-size: 12px;
                padding: 8px 12px;
            }
            
            #ui {
                max-width: 95vw;
                padding: 12px;
            }
            
            #leaderboardPanel {
                max-width: 95vw;
                max-height: 90vh;
                padding: 15px;
            }
        }
        
        /* Ultra-wide screen adjustments */
        @media (min-width: 2560px) {
            .corner-display {
                font-size: 18px;
                padding: 15px 25px;
            }
            
            .game-title {
                font-size: 28px;
                padding: 15px 30px;
            }
            
            .score-item {
                font-size: 16px;
                padding: 10px 16px;
            }
        }
        
        canvas {
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 0.5vh;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: clamp(10px, 1.2vw, 14px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8);
            z-index: 10;
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: clamp(6px, 1vw, 12px);
            border-radius: 10px;
            border: 2px solid #FFD700;
            box-shadow: 0 6px 15px rgba(0,0,0,0.6), inset 0 0 15px rgba(255,215,0,0.15), 0 0 20px rgba(255,215,0,0.5), 0 0 30px rgba(255,215,0,0.3);
            backdrop-filter: blur(15px);
            overflow: visible;
            animation: scoreGlow 2s ease-in-out infinite alternate;
            max-width: 75vw;
        }
        
        @keyframes scoreGlow {
            from { 
                box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 25px rgba(255,215,0,0.15), 0 0 30px rgba(255,215,0,0.5), 0 0 50px rgba(255,215,0,0.3);
                border-color: #FFD700;
            }
            to { 
                box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 25px rgba(255,215,0,0.25), 0 0 40px rgba(255,215,0,0.8), 0 0 70px rgba(255,215,0,0.5);
                border-color: #FFA500;
            }
        }
        
        .game-title {
            font-size: clamp(12px, 2.5vw, 20px);
            font-weight: 900;
            text-align: center;
            margin-bottom: clamp(4px, 0.5vh, 8px);
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9), 0 0 20px rgba(255,215,0,0.8);
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: clamp(4px, 1vw, 8px) clamp(10px, 2vw, 16px);
            border-radius: 12px;
            border: 2px solid #FFD700;
            box-shadow: 0 6px 15px rgba(0,0,0,0.6), inset 0 0 15px rgba(255,215,0,0.15), 0 0 20px rgba(255,215,0,0.5), 0 0 30px rgba(255,215,0,0.3);
            backdrop-filter: blur(15px);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { 
                box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 25px rgba(255,215,0,0.15), 0 0 30px rgba(255,215,0,0.5), 0 0 50px rgba(255,215,0,0.3);
                border-color: #FFD700;
            }
            to { 
                box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 25px rgba(255,215,0,0.25), 0 0 40px rgba(255,215,0,0.8), 0 0 70px rgba(255,215,0,0.5);
                border-color: #FFA500;
            }
        }
        
        .corner-display {
            position: fixed;
            top: 1vh;
            color: #FFD700;
            font-size: clamp(12px, 1.5vw, 18px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8);
            z-index: 10;
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(26,26,46,0.95));
            padding: clamp(8px, 1.2vw, 16px) clamp(12px, 2vw, 20px);
            border-radius: 15px;
            border: 2px solid #FFD700;
            box-shadow: 0 8px 20px rgba(0,0,0,0.7), inset 0 0 20px rgba(255,215,0,0.2), 0 0 25px rgba(255,215,0,0.6), 0 0 40px rgba(255,215,0,0.4);
            backdrop-filter: blur(15px);
            animation: cornerGlow 2s ease-in-out infinite alternate, cornerFloat 4s ease-in-out infinite;
            transition: all 0.3s ease;
        }
        
        .corner-display:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 40px rgba(0,0,0,0.8), inset 0 0 30px rgba(255,215,0,0.3), 0 0 40px rgba(255,215,0,0.8), 0 0 60px rgba(255,215,0,0.6);
            animation: cornerGlow 2s ease-in-out infinite alternate, cornerHover 0.3s ease-in-out;
        }
        
        @keyframes cornerFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }
        
        @keyframes cornerHover {
            0% { transform: translateY(-3px) scale(1.05); }
            50% { transform: translateY(-5px) scale(1.08); }
            100% { transform: translateY(-3px) scale(1.05); }
        }
        
        .top-left {
            left: 8vw;
        }
        
        .top-right {
            right: 8vw;
        }
        
        /* Collectibles Counter Styles */
        #collectiblesCounter {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 120px;
        }
        
        .counter-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,165,0,0.1));
            border-radius: 8px;
            border-left: 3px solid #FFD700;
            transition: all 0.3s ease;
            animation: counterItemPulse 3s ease-in-out infinite;
        }
        
        .counter-item:hover {
            background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,165,0,0.2));
            transform: translateX(-3px) scale(1.05);
            box-shadow: 0 4px 15px rgba(255,215,0,0.4);
            animation: counterItemHover 0.3s ease-in-out;
        }
        
        @keyframes counterItemPulse {
            0%, 100% { transform: translateX(0px); }
            50% { transform: translateX(-1px); }
        }
        
        @keyframes counterItemHover {
            0% { transform: translateX(-3px) scale(1.05); }
            50% { transform: translateX(-5px) scale(1.08); }
            100% { transform: translateX(-3px) scale(1.05); }
        }
        
        .counter-icon {
            font-size: 18px;
            filter: drop-shadow(0 0 8px rgba(255,215,0,0.7));
            animation: iconGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes iconGlow {
            from { filter: drop-shadow(0 0 8px rgba(255,215,0,0.7)); }
            to { filter: drop-shadow(0 0 12px rgba(255,215,0,0.9)) drop-shadow(0 0 20px rgba(255,215,0,0.5)); }
        }
        
        .counter-label {
            font-size: 11px;
            color: #FFD700;
            font-weight: bold;
            min-width: 45px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .counter-value {
            font-size: 13px;
            color: #00FFFF;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0,255,255,0.7), 1px 1px 2px rgba(0,0,0,0.8);
            min-width: 30px;
            text-align: right;
            animation: valueShine 3s ease-in-out infinite;
        }
        
        @keyframes valueShine {
            0%, 100% { text-shadow: 0 0 8px rgba(0,255,255,0.7), 1px 1px 2px rgba(0,0,0,0.8); }
            50% { text-shadow: 0 0 15px rgba(0,255,255,0.9), 0 0 25px rgba(0,255,255,0.6), 1px 1px 2px rgba(0,0,0,0.8); }
        }
        
        /* Counter animation for when values change */
        .counter-value.updated {
            animation: counterPulse 0.5s ease-in-out;
        }
        
        @keyframes counterPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #FFFF00; }
            100% { transform: scale(1); }
        }
        
        @keyframes cornerGlow {
            from { 
                box-shadow: 0 8px 25px rgba(0,0,0,0.6), inset 0 0 20px rgba(255,215,0,0.15), 0 0 25px rgba(255,215,0,0.5), 0 0 40px rgba(255,215,0,0.3);
                border-color: #FFD700;
            }
            to { 
                box-shadow: 0 8px 25px rgba(0,0,0,0.6), inset 0 0 20px rgba(255,215,0,0.25), 0 0 35px rgba(255,215,0,0.8), 0 0 60px rgba(255,215,0,0.5);
                border-color: #FFA500;
            }
        }
        
        .score-row {
            display: flex;
            gap: clamp(3px, 0.5vw, 6px);
            justify-content: center;
            align-items: center;
            margin-bottom: clamp(3px, 0.5vh, 6px);
            flex-wrap: wrap;
        }
        
        .score-item {
            margin: 0;
            padding: clamp(2px, 0.5vw, 4px) clamp(6px, 1vw, 10px);
            border-radius: 6px;
            background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05));
            border-left: 2px solid #FFD700;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            white-space: nowrap;
            font-size: clamp(8px, 1.2vw, 12px);
        }
        
        .score-item {
            color: #FFD700 !important;
            font-weight: bold !important;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8) !important;
        }
        
        /* Ensure the labels (text before spans) are yellow */
        .score-item:not(:has(span)) {
            color: #FFD700 !important;
        }
        
        /* Target the text content directly */
        .score-item {
            color: #FFD700 !important;
        }
        
        /* Style for the labels */
        .score-item .label {
            color: #FFD700 !important;
            font-weight: bold !important;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8) !important;
        }
        
        .score-item span {
            color: #00FFFF;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0,255,255,0.7), 1px 1px 2px rgba(0,0,0,0.8);
            animation: valueShine 3s ease-in-out infinite;
        }
        
        #ui div {
            margin: 2px 0;
            padding: 4px 8px;
            border-radius: 6px;
            background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05));
            border-left: 2px solid #FFD700;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .score-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,215,0,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .score-item:hover {
            background: linear-gradient(135deg, rgba(255,215,0,0.25), rgba(255,215,0,0.1));
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 5px 15px rgba(255,215,0,0.3);
        }
        
        /* Prevent score-item hover effects from affecting XP bar */
        .score-item:hover .xp-bar-container {
            transform: none !important;
            background: none !important;
            box-shadow: none !important;
        }
        
        .score-item:hover::before {
            left: 100%;
        }
        
        #ui div::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,215,0,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        #ui div:hover {
            background: linear-gradient(135deg, rgba(255,215,0,0.25), rgba(255,215,0,0.1));
            transform: translateX(8px) scale(1.02);
            box-shadow: 0 5px 15px rgba(255,215,0,0.3);
        }
        
        #ui div:hover::before {
            left: 100%;
        }
        
        #controls {
            position: absolute;
            bottom: -130px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(26,26,46,0.95));
            color: #00FFFF;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            border: 3px solid #00FFFF;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5), 0 0 20px rgba(0,255,255,0.4);
            backdrop-filter: blur(10px);
            text-shadow: 0 0 10px #00FFFF;
            animation: glow 3s ease-in-out infinite alternate;
        }
        

        
        @keyframes controlsGlow {
            from { box-shadow: 0 8px 25px rgba(0,0,0,0.3), 0 0 20px rgba(255,215,0,0.5); }
            to { box-shadow: 0 8px 25px rgba(0,0,0,0.3), 0 0 30px rgba(255,215,0,0.8); }
        }
        
        #controls::before {
            content: '🎮';
            display: block;
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.95));
            color: #FFD700;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            font-size: 28px;
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            display: none;
            z-index: 20;
            border: 4px solid #FFD700;
            box-shadow: 0 0 40px rgba(255,215,0,0.7), inset 0 0 30px rgba(255,215,0,0.1);
            backdrop-filter: blur(15px);
            animation: levelCompleteGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes levelCompleteGlow {
            from { box-shadow: 0 0 40px rgba(255,215,0,0.7), inset 0 0 30px rgba(255,215,0,0.1); }
            to { box-shadow: 0 0 60px rgba(255,215,0,0.9), inset 0 0 40px rgba(255,215,0,0.2); }
        }
        
        #levelComplete .level-name {
            font-size: 20px;
            color: #FFD700;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255,215,0,0.8);
            font-weight: 900;
        }
        
        /* Asset Import Panel Styles */
        /* Enhanced Top UI Styles */
        .game-title {
            text-align: center;
            margin-bottom: 15px;
            animation: titleGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 10px #FFD700) drop-shadow(0 0 20px #FFA500); }
            to { filter: drop-shadow(0 0 15px #FFD700) drop-shadow(0 0 30px #FFA500) drop-shadow(0 0 40px #FF6B35); }
        }
        
        .score-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .score-item {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 165, 0, 0.8));
            color: #000;
            padding: 10px 15px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 14px;
            border: 2px solid #FFD700;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            animation: scoreItemPulse 2s ease-in-out infinite;
        }
        
        .score-item:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.5);
            animation: scoreItemHover 0.3s ease-in-out;
        }
        
        @keyframes scoreItemPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        @keyframes scoreItemHover {
            0% { transform: translateY(-3px) scale(1.05); }
            50% { transform: translateY(-5px) scale(1.08); }
            100% { transform: translateY(-3px) scale(1.05); }
        }
        
        /* Enhanced XP Bar Styles - COOL VERSION */
        .xp-bar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            animation: xpContainerFloat 4s ease-in-out infinite;
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(26,26,46,0.95));
            padding: 12px 16px;
            border-radius: 15px;
            border: 3px solid #00FFFF;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8), inset 0 0 25px rgba(0,255,255,0.2), 0 0 35px rgba(0,255,255,0.6), 0 0 60px rgba(0,255,255,0.4);
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
        }
        
        .xp-bar-container:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(0,0,0,0.9), inset 0 0 35px rgba(0,255,255,0.3), 0 0 50px rgba(0,255,255,0.8), 0 0 80px rgba(0,255,255,0.6);
        }
        
        @keyframes xpContainerFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }
        
        .xp-bar {
            width: 200px;
            height: 24px;
            background: linear-gradient(180deg, #1a1a2e, #16213e);
            border: 3px solid #00FFFF;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 8px 25px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,255,255,0.2), 0 0 30px rgba(0,255,255,0.6), 0 0 50px rgba(0,255,255,0.4);
            animation: xpBarGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes xpBarGlow {
            from { 
                box-shadow: 0 8px 25px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,255,255,0.2), 0 0 30px rgba(0,255,255,0.6), 0 0 50px rgba(0,255,255,0.4);
                border-color: #00FFFF;
            }
            to { 
                box-shadow: 0 8px 25px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,255,255,0.3), 0 0 40px rgba(0,255,255,0.8), 0 0 70px rgba(0,255,255,0.6);
                border-color: #87CEEB;
            }
        }
        
        .xp-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3), transparent);
            border-radius: 12px 12px 0 0;
            z-index: 1;
        }
        
        .xp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00FFFF, #0080FF, #0040FF, #0000FF, #8000FF, #FF00FF);
            background-size: 200% 100%;
            width: 0%;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 12px;
            position: relative;
            z-index: 2;
            animation: xpFillGlow 2s ease-in-out infinite alternate, xpFillMove 3s ease-in-out infinite;
        }
        
        @keyframes xpFillGlow {
            from { 
                box-shadow: inset 0 0 15px rgba(0,255,255,0.6), 0 0 20px rgba(0,255,255,0.4);
            }
            to { 
                box-shadow: inset 0 0 25px rgba(0,255,255,0.9), 0 0 35px rgba(0,255,255,0.7), 0 0 50px rgba(0,255,255,0.5);
            }
        }
        
        @keyframes xpFillMove {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .xp-text {
            font-size: clamp(12px, 1.4vw, 16px);
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8);
            animation: xpTextShine 3s ease-in-out infinite;
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: 8px 12px;
            border-radius: 10px;
            border: 2px solid #FFD700;
            box-shadow: 0 4px 15px rgba(0,0,0,0.7), inset 0 0 12px rgba(255,215,0,0.15), 0 0 20px rgba(255,215,0,0.5);
            backdrop-filter: blur(10px);
        }
        
        .xp-text span {
            color: #00FFFF;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0,255,255,0.8), 1px 1px 2px rgba(0,0,0,0.9);
            animation: valueShine 3s ease-in-out infinite;
        }
        
        @keyframes xpTextShine {
            0%, 100% { 
                text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8);
                box-shadow: 0 4px 15px rgba(0,0,0,0.7), inset 0 0 12px rgba(255,215,0,0.15), 0 0 20px rgba(255,215,0,0.5);
            }
            50% { 
                text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 25px rgba(255,215,0,0.9), 0 0 35px rgba(255,215,0,0.7);
                box-shadow: 0 4px 15px rgba(0,0,0,0.7), inset 0 0 12px rgba(255,215,0,0.25), 0 0 30px rgba(255,215,0,0.7), 0 0 45px rgba(255,215,0,0.4);
            }
        }
        
        /* Override score-item styling for XP bar */
        .score-item .xp-bar-container {
            background: none !important;
            padding: 0 !important;
            border: none !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            margin: 0 !important;
        }
        
        .score-item .xp-bar {
            background: linear-gradient(180deg, #1a1a2e, #16213e) !important;
            border: 3px solid #00FFFF !important;
            border-radius: 15px !important;
            box-shadow: 0 8px 25px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,255,255,0.2), 0 0 30px rgba(0,255,255,0.6), 0 0 50px rgba(0,255,255,0.4) !important;
            width: 200px !important;
            height: 24px !important;
            overflow: hidden !important;
            position: relative !important;
        }
        
        .score-item .xp-bar-fill {
            background: linear-gradient(90deg, #00FFFF, #0080FF, #0040FF, #0000FF, #8000FF, #FF00FF) !important;
            background-size: 200% 100% !important;
            border-radius: 12px !important;
            height: 100% !important;
            position: relative !important;
            z-index: 2 !important;
            animation: xpFillGlow 2s ease-in-out infinite alternate, xpFillMove 3s ease-in-out infinite !important;
        }
        
        .score-item .xp-text {
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95)) !important;
            border: 2px solid #FFD700 !important;
            border-radius: 10px !important;
            box-shadow: 0 4px 15px rgba(0,0,0,0.7), inset 0 0 12px rgba(255,215,0,0.15), 0 0 20px rgba(255,215,0,0.5) !important;
            backdrop-filter: blur(10px) !important;
            padding: 8px 12px !important;
            margin-top: 6px !important;
            font-size: clamp(12px, 1.4vw, 16px) !important;
            color: #FFD700 !important;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8) !important;
        }
        
        .score-item .xp-text span {
            color: #00FFFF !important;
            text-shadow: 0 0 10px rgba(0,255,255,0.8), 1px 1px 2px rgba(0,0,0,0.9) !important;
        }
        

        
        #assetPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-height: 80vh;
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.95));
            border: 4px solid #FFD700;
            border-radius: 20px;
            z-index: 1001;
            overflow-y: auto;
            backdrop-filter: blur(15px);
        }
        
        .asset-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 2px solid #FFD700;
            background: rgba(255,215,0,0.1);
        }
        
        .asset-header h3 {
            color: #FFD700;
            margin: 0;
            font-size: 24px;
        }
        
        .close-btn {
            background: #FF4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .close-btn:hover {
            background: #FF6666;
            transform: scale(1.1);
        }
        
        .asset-content {
            padding: 20px;
        }
        
        .asset-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255,215,0,0.05);
            border-radius: 10px;
            border-left: 3px solid #FFD700;
            transition: all 0.3s ease;
        }
        
        .asset-section:hover {
            background: rgba(255,215,0,0.1);
            transform: translateX(5px);
        }
        
        .asset-section h4 {
            color: #FFD700;
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        
        .asset-section input[type="file"] {
            display: block;
            margin: 5px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #FFD700;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }
        
        .asset-section input[type="file"]:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .preview {
            margin-top: 10px;
            min-height: 60px;
            background: rgba(0,0,0,0.3);
            border: 2px dashed #FFD700;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #FFD700;
            font-style: italic;
        }
        
        .preview img {
            max-width: 100%;
            max-height: 60px;
            border-radius: 3px;
        }
        
        .asset-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #FFD700;
        }
        
        .asset-controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-family: 'SuperMario', 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .reset-btn {
            background: #FF4444;
            color: white;
        }
        
        .export-btn {
            background: #4CAF50;
            color: white;
        }
        
        .import-btn {
            background: #2196F3;
            color: white;
        }
        
        .asset-controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        /* Health Bar Styles - Enhanced */
        .health-bar-container {
            position: fixed;
            bottom: 24px;
            right: 2vw;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 12px;
            animation: healthContainerFloat 4s ease-in-out infinite;
            transition: all 0.3s ease;
        }
        
        @keyframes healthContainerFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }
        
        .bar-group {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
            transition: all 0.3s ease;
        }
        
        .bar-group:hover {
            transform: scale(1.05);
        }
        
        .health-bar {
            width: 600px;
            height: 28px;
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(26,26,46,0.95));
            border: 3px solid #00FF00;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.8), inset 0 0 25px rgba(0,255,0,0.2), 0 0 30px rgba(0,255,0,0.6), 0 0 50px rgba(0,255,0,0.4);
            backdrop-filter: blur(15px);
            animation: healthBarGlow 2s ease-in-out infinite alternate;
            overflow: hidden;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .health-bar:hover {
            transform: scale(1.08);
            box-shadow: 0 15px 40px rgba(0,0,0,0.9), inset 0 0 35px rgba(0,255,0,0.3), 0 0 45px rgba(0,255,0,0.8), 0 0 70px rgba(0,255,0,0.6);
        }
        
        @keyframes healthBarGlow {
            from { 
                box-shadow: 0 10px 30px rgba(0,0,0,0.8), inset 0 0 25px rgba(0,255,0,0.2), 0 0 30px rgba(0,255,0,0.6), 0 0 50px rgba(0,255,0,0.4);
                border-color: #00FF00;
            }
            to { 
                box-shadow: 0 10px 30px rgba(0,0,0,0.8), inset 0 0 25px rgba(0,255,0,0.3), 0 0 40px rgba(0,255,0,0.8), 0 0 70px rgba(0,255,0,0.6);
                border-color: #32CD32;
            }
        }
        
        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00FF00, #66FF66, #99FF99, #CCFFCC);
            border-radius: 12px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
            animation: healthFillPulse 2s ease-in-out infinite;
        }
        
        @keyframes healthFillPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.9; }
        }
        
        .health-bar-fill.medium {
            background: linear-gradient(90deg, #FFFF00, #FFFF66, #FFFF99);
        }
        
        .health-bar-fill.low {
            background: linear-gradient(90deg, #FF4444, #FF6666, #FF8888);
        }
        
        .health-bar-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: healthShine 2s ease-in-out infinite;
        }
        
        @keyframes healthShine {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }
        
        .health-text {
            color: #00FF00;
            font-size: clamp(16px, 2vw, 24px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(0,255,0,0.8);
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: clamp(10px, 1.4vw, 14px) clamp(16px, 2.2vw, 24px);
            border-radius: 12px;
            border: 2px solid #00FF00;
            box-shadow: 0 6px 18px rgba(0,0,0,0.7), inset 0 0 15px rgba(0,255,0,0.15), 0 0 20px rgba(0,255,0,0.6);
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            animation: healthTextGlow 2s ease-in-out infinite alternate;
        }
        
        .health-text:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,255,0,0.25), 0 0 30px rgba(0,255,0,0.8);
        }
        
        @keyframes healthTextGlow {
            from { 
                box-shadow: 0 6px 18px rgba(0,0,0,0.7), inset 0 0 15px rgba(0,255,0,0.15), 0 0 20px rgba(0,255,0,0.6);
                border-color: #00FF00;
            }
            to { 
                box-shadow: 0 6px 18px rgba(0,0,0,0.7), inset 0 0 15px rgba(0,255,0,0.25), 0 0 25px rgba(0,255,0,0.8), 0 0 40px rgba(0,255,0,0.4);
                border-color: #32CD32;
            }
        }
        
        .armor-bar {
            width: 600px;
            height: 28px;
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            border: 3px solid #4169E1;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.8), inset 0 0 25px rgba(65,105,225,0.2), 0 0 30px rgba(65,105,225,0.6), 0 0 50px rgba(65,105,225,0.4);
            backdrop-filter: blur(15px);
            animation: armorGlow 2s ease-in-out infinite alternate;
            overflow: hidden;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .armor-bar:hover {
            transform: scale(1.08);
            box-shadow: 0 15px 40px rgba(0,0,0,0.9), inset 0 0 35px rgba(65,105,225,0.3), 0 0 45px rgba(65,105,225,0.8), 0 0 70px rgba(65,105,225,0.6);
        }
        
        .armor-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4169E1, #6495ED, #87CEEB);
            border-radius: 12px;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .armor-bar-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: armorShine 2s ease-in-out infinite;
        }
        
        @keyframes armorShine {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }
        
        @keyframes armorGlow {
            from { 
                box-shadow: 0 8px 25px rgba(0,0,0,0.6), inset 0 0 20px rgba(65,105,225,0.15), 0 0 25px rgba(65,105,225,0.5), 0 0 40px rgba(65,105,225,0.3);
                border-color: #4169E1;
            }
            to { 
                box-shadow: 0 8px 25px rgba(0,0,0,0.6), inset 0 0 20px rgba(65,105,225,0.25), 0 0 35px rgba(65,105,225,0.8), 0 0 60px rgba(65,105,225,0.5);
                border-color: #87CEEB;
            }
        }
        
        .armor-text {
            color: #4169E1;
            font-size: clamp(16px, 2vw, 24px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(65,105,225,0.8);
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: clamp(10px, 1.4vw, 14px) clamp(16px, 2.2vw, 24px);
            border-radius: 12px;
            border: 2px solid #4169E1;
            box-shadow: 0 6px 18px rgba(0,0,0,0.7), inset 0 0 15px rgba(65,105,225,0.15), 0 0 20px rgba(65,105,225,0.6);
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            animation: armorTextGlow 2s ease-in-out infinite alternate;
        }
        
        .armor-text:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.8), inset 0 0 20px rgba(65,105,225,0.25), 0 0 30px rgba(65,105,225,0.8);
        }
        
        @keyframes armorTextGlow {
            from { 
                box-shadow: 0 6px 18px rgba(0,0,0,0.7), inset 0 0 15px rgba(65,105,225,0.15), 0 0 20px rgba(65,105,225,0.6);
                border-color: #4169E1;
            }
            to { 
                box-shadow: 0 6px 18px rgba(0,0,0,0.7), inset 0 0 15px rgba(65,105,225,0.25), 0 0 25px rgba(65,105,225,0.8), 0 0 40px rgba(65,105,225,0.4);
                border-color: #87CEEB;
            }
        }
        
        .lives-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(255,20,147,0.2), rgba(255,105,180,0.1));
            border-radius: 15px;
            border: 2px solid #FF1493;
            box-shadow: 0 8px 25px rgba(255,20,147,0.4), inset 0 0 20px rgba(255,20,147,0.1), 0 0 30px rgba(255,20,147,0.6);
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            animation: livesGlow 3s ease-in-out infinite alternate;
            align-self: flex-end;
        }
        
        .lives-display:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 35px rgba(255,20,147,0.6), inset 0 0 30px rgba(255,20,147,0.2), 0 0 45px rgba(255,20,147,0.8);
        }
        
        @keyframes livesGlow {
            from { 
                box-shadow: 0 8px 25px rgba(255,20,147,0.4), inset 0 0 20px rgba(255,20,147,0.1), 0 0 30px rgba(255,20,147,0.6);
                border-color: #FF1493;
            }
            to { 
                box-shadow: 0 8px 25px rgba(255,20,147,0.6), inset 0 0 20px rgba(255,20,147,0.2), 0 0 40px rgba(255,20,147,0.8), 0 0 60px rgba(255,20,147,0.4);
                border-color: #FF69B4;
            }
        }
        
        .lives-icon {
            font-size: 32px;
            animation: heartBeat 2s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(255,20,147,0.8));
        }
        
        @keyframes heartBeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        .lives-text {
            color: #FFD700;
            font-size: clamp(16px, 2vw, 24px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,215,0,0.8);
            text-align: center;
        }
        
        /* Abilities Display Styles */
        .abilities-display {
            position: fixed;
            top: 18px;
            right: 2vw;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            animation: abilitiesContainerFloat 4s ease-in-out infinite;
            transform-origin: top right;
        }
        
        @keyframes abilitiesContainerFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-2px); }
        }
        
        .abilities-title {
            color: #FF6B35;
            font-size: clamp(12px, 1.6vw, 18px);
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            font-weight: 900;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(255,107,53,0.8);
            background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.95));
            padding: clamp(6px, 1vw, 10px) clamp(10px, 1.6vw, 16px);
            border-radius: 8px;
            border: 2px solid #FF6B35;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6), inset 0 0 12px rgba(255,107,53,0.15), 0 0 16px rgba(255,107,53,0.5);
            backdrop-filter: blur(10px);
        }
        
        .abilities-grid {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .ability-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 8px 10px;
            background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05));
            border-radius: 8px;
            border: 2px solid rgba(255,107,53,0.3);
            transition: all 0.3s ease;
            min-width: 52px;
        }
        
        .ability-item.active {
            background: linear-gradient(135deg, rgba(255,107,53,0.3), rgba(255,107,53,0.2));
            border-color: #FF6B35;
            box-shadow: 0 0 10px rgba(255,107,53,0.5);
            animation: abilityGlow 2s ease-in-out infinite alternate;
        }
        
        .ability-item.inactive {
            opacity: 0.4;
            filter: grayscale(0.8);
        }
        
        @keyframes abilityGlow {
            from { box-shadow: 0 0 10px rgba(255,107,53,0.5); }
            to { box-shadow: 0 0 20px rgba(255,107,53,0.8); }
        }
        
        .ability-icon {
            font-size: 26px;
            filter: drop-shadow(0 0 5px rgba(255,107,53,0.7));
        }
        
        .ability-label {
            font-size: 10px;
            color: #FF6B35;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .tab-btn.active {
            background: linear-gradient(135deg, #4CAF50, #45a049) !important;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        
        /* Marketplace Tab Button Styles */
        .marketplace-tab-btn {
            position: relative;
            overflow: hidden;
        }
        
        .marketplace-tab-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .marketplace-tab-btn:hover::before {
            left: 100%;
        }
        
        .marketplace-tab-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        .marketplace-tab-btn.active {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }
        
        /* Pause Menu Tab Button Styles */
        .pause-tab-btn {
            position: relative;
            overflow: hidden;
        }
        
        .pause-tab-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .pause-tab-btn:hover::before {
            left: 100%;
        }
        
        .pause-tab-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        .pause-tab-btn.active {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }
        
        /* Toggle Switch Styles */
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        input:checked + .toggle-slider {
            background-color: #4CAF50;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .marketplace-grid {
            max-height: 600px;
            overflow-y: auto;
            padding: 20px;
            scrollbar-width: thin;
            scrollbar-color: rgba(0,255,255,0.5) rgba(0,255,255,0.1);
        }
        
        .marketplace-grid::-webkit-scrollbar {
            width: 10px;
        }
        
        .marketplace-grid::-webkit-scrollbar-track {
            background: rgba(0,255,255,0.1);
            border-radius: 8px;
            margin: 5px;
        }
        
        .marketplace-grid::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, rgba(0,255,255,0.6), rgba(0,255,255,0.4));
            border-radius: 8px;
            border: 2px solid rgba(0,255,255,0.1);
        }
        
        .marketplace-grid::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, rgba(0,255,255,0.8), rgba(0,255,255,0.6));
        }
        
        /* Home Screen Animations */
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }
        
        @keyframes titleGlow {
            0%, 100% { filter: drop-shadow(0 0 40px #FFD700); }
            50% { filter: drop-shadow(0 0 60px #FFD700) drop-shadow(0 0 80px #FFA500); }
        }
        
        @keyframes logoGlow {
            0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.1); }
        }
        
        @keyframes subtitleGlow {
            0% { text-shadow: 2px 2px 8px rgba(0,0,0,0.9), 0 0 20px #00FFFF, 0 0 30px #00FFFF; }
            100% { text-shadow: 2px 2px 8px rgba(0,0,0,0.9), 0 0 30px #00FFFF, 0 0 40px #00FFFF, 0 0 50px #00FFFF; }
        }
        
        @keyframes subtitlePulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }
        
        @keyframes buttonGlow {
            0%, 100% { box-shadow: 0 0 40px rgba(255,215,0,0.6), 0 8px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); }
            50% { box-shadow: 0 0 60px rgba(255,215,0,0.8), 0 12px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.5); }
        }
        
        @keyframes buttonShine {
            0% { transform: rotate(45deg) translateX(-100%); }
            50% { transform: rotate(45deg) translateX(100%); }
            100% { transform: rotate(45deg) translateX(100%); }
        }
        
        @keyframes borderGlow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        /* Button Hover Effects */
        .home-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 0 60px rgba(255,215,0,0.8), 0 15px 35px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.5);
        }
        
        .start-btn:hover {
            box-shadow: 0 0 60px rgba(255,215,0,0.8), 0 15px 35px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.5);
        }
        
        .profile-btn:hover {
            box-shadow: 0 0 60px rgba(156,39,176,0.8), 0 15px 35px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.5);
        }
        
        .marketplace-btn:hover {
            box-shadow: 0 0 60px rgba(76,175,80,0.8), 0 15px 35px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.5);
        }
        
        /* Floating Elements */
        .floating-otter, .floating-coin {
            pointer-events: none;
            user-select: none;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .home-button {
                padding: 15px 25px !important;
                font-size: clamp(16px, 4vw, 20px) !important;
            }
        }
        
        /* Marketplace Item Darkening Effects */
        .marketplace-item {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .marketplace-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.6s ease;
            z-index: 1;
        }
        
        .marketplace-item:hover::before {
            left: 100%;
        }
        
        .marketplace-item:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 35px rgba(0,0,0,0.4), 0 0 20px rgba(255,215,0,0.3);
        }
        
        .marketplace-item:not(.owned) {
            opacity: 0.8;
        }
        
        .marketplace-item:not(.owned):hover {
            opacity: 0.95;
        }
        
        .marketplace-item.owned {
            animation: ownedItemGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes ownedItemGlow {
            0% { box-shadow: 0 4px 15px rgba(0,0,0,0.2), 0 0 10px rgba(76,175,80,0.3); }
            100% { box-shadow: 0 4px 15px rgba(0,0,0,0.2), 0 0 20px rgba(76,175,80,0.6); }
        }
        
        /* Profile Page Enhancements */
        #profileOtterImage {
            object-fit: cover;
            object-position: center;
            max-width: 100%;
            max-height: 100%;
            transition: all 0.3s ease;
        }
        
        #profileOtterImage:hover {
            transform: scale(1.1);
        }
        
        #profilePlayerName:hover {
            color: #00FFFF;
            text-shadow: 0 0 10px #00FFFF;
        }
        
        .profile-edit-btn {
            transition: all 0.3s ease;
        }
        
        .profile-edit-btn:hover {
            transform: scale(1.1);
            background: #00FFFF !important;
            color: #000 !important;
        }

        /* Wallet Integration Styles */
        .wallet-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
            font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            backdrop-filter: blur(10px);
        }

        .wallet-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .wallet-button.connected {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .wallet-button.connected:hover {
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .wallet-info {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: #FFD700;
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #FFD700;
            font-size: 12px;
            z-index: 999;
            display: none;
            max-width: 250px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        }

        .wallet-info.show {
            display: block;
        }

        .fish-earnings {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.3);
            animation: fishEarningsPulse 2s ease-in-out infinite;
        }

        .fish-earnings.show {
            display: block;
        }

        @keyframes fishEarningsPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .trait-bonus {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            z-index: 10000;
            display: none;
            text-align: center;
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            animation: traitBonusSlideIn 0.5s ease-out;
        }

        .trait-bonus.show {
            display: block;
        }

        @keyframes traitBonusSlideIn {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
        <div id="ui">
        <div class="game-title">
            <img src="public/otterfulotterbros.png" alt="Otter Bros" style="width: clamp(120px, 20vw, 200px); height: auto; filter: drop-shadow(0 0 10px #FFD700);" onload="console.log('Game title image loaded successfully')" onerror="console.log('Failed to load game title image')">
        </div>
        <div class="score-row">
            <div class="score-item"><span class="label">Score:</span> <span id="score">0</span></div>
            <div class="score-item"><span class="label">Coins:</span> <span id="coins">0</span></div>
            <div class="score-item"><span class="label">XP:</span> <span id="xp">0</span></div>
            <div class="score-item">
                <div class="xp-bar-container">
                    <div class="xp-bar">
                        <div class="xp-bar-fill" id="xpBarFill"></div>
                    </div>
                    <div class="xp-text" id="xpText">Level 1 <span id="xpProgress">(0/1000 XP)</span></div>
                </div>
            </div>
        </div>
            <div id="giantIndicator" style="display: none; color: #FF00FF; font-weight: bold; text-shadow: 0 0 10px #FF00FF;">🍄 GIANT MODE: 10s</div>
    </div>
    
    
    
            <div id="levelDisplay" class="corner-display top-left" style="top: 22px; left: 4vw;">Level: <span id="level">1</span></div>
    
    <!-- Real-time Collectibles Counter - Horizontal -->
            <div id="collectiblesCounter" class="corner-display top-left" style="top: 2vh; left: 11vw; display: flex; flex-direction: row; gap: 15px;">
        <div class="counter-item">
            <span class="counter-icon">🪙</span>
            <span class="counter-label">Coins:</span>
            <span id="coinsCounter" class="counter-value">0</span>
        </div>
        <div class="counter-item">
            <span class="counter-icon">💎</span>
            <span class="counter-label">Chests:</span>
            <span id="chestsCounter" class="counter-value">0</span>
        </div>
        <div class="counter-item">
            <span class="counter-icon">🔑</span>
            <span class="counter-label">Keys:</span>
            <span id="keysCounter" class="counter-value">0</span>
        </div>
    </div>
    
    <!-- Health Bar and Lives Display - Reorganized -->
    <div class="health-bar-container">
        <!-- Lives Display at Top -->
        <div class="lives-display" id="livesDisplay">
            <div class="lives-icon">❤️</div>
            <div class="lives-text">Lives: <span id="lives">3</span></div>
        </div>
        
        <!-- Health Bar in Middle -->
        <div class="bar-group">
            <div class="health-bar">
                <div class="health-bar-fill" id="healthBarFill" style="width: 100%;"></div>
            </div>
            <div class="health-text" id="healthText">Health: 100%</div>
        </div>
        
        <!-- Armor Bar at Bottom -->
        <div class="bar-group">
            <div class="armor-bar">
                <div class="armor-bar-fill" id="armorBarFill" style="width: 0%;"></div>
            </div>
            <div class="armor-text" id="armorText">Armor: 0%</div>
        </div>
    </div>

    <!-- Abilities Display -->
    <div class="abilities-display">
        <div class="abilities-title">⚡ ABILITIES</div>
        <div class="abilities-grid">
                          <div id="laserAbility" class="ability-item inactive">
                  <div class="ability-icon">🔫</div>
                  <div class="ability-label" style="display: none;"></div>
              </div>
            <div id="fireballAbility" class="ability-item inactive">
                <div class="ability-icon">🔥</div>
                <div class="ability-label">FIREBALL</div>
            </div>
            <div id="jetpackAbility" class="ability-item inactive">
                <div class="ability-icon">🚁</div>
                <div class="ability-label">JETPACK</div>
            </div>
        </div>
    </div>

    <!-- Wallet Info Display -->
    <div id="walletInfo" class="wallet-info">
        <div style="font-weight: bold; margin-bottom: 8px;">🔗 Wallet Connected</div>
        <div id="walletAddress" style="font-size: 10px; margin-bottom: 8px; word-break: break-all;"></div>
        <div style="font-size: 11px; margin-bottom: 8px;">🦦 Staked Otters: <span id="stakedCount">0</span></div>
        <div style="font-size: 11px; margin-bottom: 8px;">🐟 $FISH Earned: <span id="fishEarned">0</span></div>
        <div style="font-size: 11px;">⚡ Staking Rate: <span id="stakingRate">10/day</span></div>
    </div>

    <!-- Fish Earnings Display -->
    <div id="fishEarnings" class="fish-earnings">
        <div style="display: flex; align-items: center; gap: 8px;">
            <span>🐟</span>
            <span>+<span id="fishEarningsAmount">0</span> $FISH</span>
        </div>
        <div style="font-size: 12px; margin-top: 4px; opacity: 0.9;">From staked otters!</div>
    </div>

        <div id="titleScreen" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: url('public/fishhh.png') center center / cover, linear-gradient(135deg, rgba(26,26,46,0.9), rgba(22,33,62,0.9), rgba(15,52,96,0.9)); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 3000; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif; overflow: hidden;">
        
        <!-- Animated Background Elements -->
        <div class="floating-sparkle" style="position: absolute; top: 10%; left: 5%; font-size: 60px; animation: float 6s ease-in-out infinite; opacity: 0.3;">✨</div>
        <div class="floating-sparkle" style="position: absolute; top: 20%; right: 10%; font-size: 40px; animation: float 8s ease-in-out infinite reverse; opacity: 0.2;">✨</div>
        <div class="floating-sparkle" style="position: absolute; bottom: 30%; left: 15%; font-size: 50px; animation: float 7s ease-in-out infinite; opacity: 0.25;">✨</div>
        <div class="floating-sparkle" style="position: absolute; bottom: 20%; right: 5%; font-size: 45px; animation: float 9s ease-in-out infinite reverse; opacity: 0.3;">✨</div>
        
        <!-- Floating Coins -->
        <div class="floating-coin" style="position: absolute; top: 15%; left: 20%; font-size: 30px; animation: float 5s ease-in-out infinite; opacity: 0.4;">🪙</div>
        <div class="floating-coin" style="position: absolute; top: 25%; right: 20%; font-size: 25px; animation: float 6.5s ease-in-out infinite reverse; opacity: 0.3;">🪙</div>
        <div class="floating-coin" style="position: absolute; bottom: 25%; left: 25%; font-size: 35px; animation: float 7.5s ease-in-out infinite; opacity: 0.35;">🪙</div>
        <div class="floating-coin" style="position: absolute; bottom: 15%; right: 15%; font-size: 28px; animation: float 8.5s ease-in-out infinite reverse; opacity: 0.4;">🪙</div>
        
        <!-- Main Content Container -->
        <div style="text-align: center; color: #FFD700; background: url('public/FLOLW.png') center center / cover, linear-gradient(135deg, rgba(0,0,0,0.85), rgba(26,26,46,0.9)); padding: 40px; border-radius: 30px; border: 4px solid #FFD700; box-shadow: 0 0 60px rgba(255,215,0,0.6), inset 0 0 30px rgba(255,215,0,0.1), 0 20px 40px rgba(0,0,0,0.8); backdrop-filter: blur(10px); position: relative; z-index: 10;">
            <!-- FLOLW Overlay at 10% opacity -->
            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: url('public/FLOLW.png') center center / cover; opacity: 0.1; border-radius: 30px; pointer-events: none; z-index: -1;"></div>
            
            <!-- Glowing Border Effect -->
            <div style="position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700, #FFA500); border-radius: 32px; z-index: -1; animation: borderGlow 3s ease-in-out infinite;"></div>
            
            <!-- Title Logo with Enhanced Effects -->
            <div style="position: relative; margin-bottom: 30px;">
                <img src="public/otterfulotterbros.png" alt="Otter Bros" style="width: clamp(300px, 60vw, 600px); height: auto; filter: drop-shadow(0 0 40px #FFD700); animation: titleGlow 3s ease-in-out infinite; position: relative; z-index: 2;" onload="console.log('Title screen image loaded successfully')" onerror="console.log('Failed to load title screen image')">
                
                <!-- Logo Glow Effect -->
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; height: 100%; background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%); animation: logoGlow 4s ease-in-out infinite; z-index: 1;"></div>
                </div>
            
            <!-- Subtitle with Enhanced Styling -->
            <div style="margin-bottom: 40px; position: relative;">
                <p style="font-size: clamp(18px, 3.5vw, 28px); margin: 0; color: #00FFFF; text-shadow: 2px 2px 8px rgba(0,0,0,0.9), 0 0 20px #00FFFF, 0 0 30px #00FFFF; font-weight: bold; animation: subtitleGlow 2s ease-in-out infinite alternate;">A Platforming Adventure</p>
                <p style="font-size: clamp(14px, 2.5vw, 20px); margin: 25px 0 0 0; color: #000000; text-shadow: 1px 1px 4px rgba(255,255,255,0.8); opacity: 0.9; animation: subtitlePulse 3s ease-in-out infinite;">Embark on an epic journey with your otter companion!</p>
                </div>
            
            <!-- Enhanced Button Container -->
            <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 30px; align-items: center; position: relative;">
                
                <!-- Start Adventure Button -->
                <button id="startGameBtn" class="home-button start-btn" style="background: linear-gradient(135deg, #4CAF50, #45a049, #4CAF50); background-size: 200% 200%; color: #FFFFFF; border: 3px solid #4CAF50; padding: 18px 35px; border-radius: 30px; font-size: clamp(18px, 3vw, 24px); font-weight: bold; cursor: pointer; box-shadow: 0 0 40px rgba(76,175,80,0.6), 0 8px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); transition: all 0.3s ease; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: relative; overflow: hidden; animation: buttonGlow 2s ease-in-out infinite; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <span style="position: relative; z-index: 2;">🚀 Start Adventure</span>
                    <div class="button-shine" style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent); transform: rotate(45deg); animation: buttonShine 3s ease-in-out infinite;"></div>
                </button>
                
                <!-- Connect Wallet Button -->
                <button id="connectWalletBtn" class="home-button wallet-btn" style="background: linear-gradient(135deg, #667eea, #764ba2, #667eea); background-size: 200% 200%; color: #FFFFFF; border: 3px solid #667eea; padding: 18px 35px; border-radius: 30px; font-size: clamp(18px, 3vw, 24px); font-weight: bold; cursor: pointer; box-shadow: 0 0 40px rgba(102,126,234,0.6), 0 8px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); transition: all 0.3s ease; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: relative; overflow: hidden; animation: buttonGlow 2s ease-in-out infinite 0.3s; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <span style="position: relative; z-index: 2;">🔗 Connect Wallet</span>
                    <div class="button-shine" style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent); transform: rotate(45deg); animation: buttonShine 3s ease-in-out infinite 0.3s;"></div>
                </button>
                
                <!-- Marketplace Button -->
                <button id="marketplaceBtn" class="home-button marketplace-btn" style="background: linear-gradient(135deg, #2196F3, #1976D2, #2196F3); background-size: 200% 200%; color: #FFFFFF; border: 3px solid #2196F3; padding: 18px 35px; border-radius: 30px; font-size: clamp(18px, 3vw, 24px); font-weight: bold; cursor: pointer; box-shadow: 0 0 40px rgba(33,150,243,0.6), 0 8px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); transition: all 0.3s ease; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: relative; overflow: hidden; animation: buttonGlow 2s ease-in-out infinite 0.5s; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <span style="position: relative; z-index: 2;">🛒 Marketplace</span>
                    <div class="button-shine" style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent); transform: rotate(45deg); animation: buttonShine 3s ease-in-out infinite 0.5s;"></div>
                </button>
                
                <!-- Profile Button -->
                <button id="profileBtn" class="home-button profile-btn" style="background: linear-gradient(135deg, #9C27B0, #7B1FA2, #9C27B0); background-size: 200% 200%; color: #FFFFFF; border: 3px solid #9C27B0; padding: 18px 35px; border-radius: 30px; font-size: clamp(18px, 3vw, 24px); font-weight: bold; cursor: pointer; box-shadow: 0 0 40px rgba(156,39,176,0.6), 0 8px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3); transition: all 0.3s ease; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: relative; overflow: hidden; animation: buttonGlow 2s ease-in-out infinite 1s; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <span style="position: relative; z-index: 2;">👤 Profile</span>
                    <div class="button-shine" style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent); transform: rotate(45deg); animation: buttonShine 3s ease-in-out infinite 1s;"></div>
                </button>
                </div>
            
            <!-- Footer Info -->
            <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid rgba(255,215,0,0.3);">
                <p style="font-size: clamp(12px, 2vw, 16px); color: #000000; text-shadow: 1px 1px 4px rgba(255,255,255,0.8); opacity: 0.9; margin: 0;">Use Arrow Keys or WASD to move • SPACE to jump • Collect coins and defeat enemies!</p>
                </div>
            </div>
            
        <!-- Particle Effects Container -->
        <div id="particleContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;"></div>
    </div>
    
    <div id="cutscenePanel" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 4000; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
        <div id="cutsceneText" style="color: #FFD700; font-size: clamp(16px, 3vw, 24px); text-align: center; max-width: 80vw; line-height: 1.6; margin-bottom: 30px;"></div>
        <button id="skipCutsceneBtn" style="background: #FF4444; color: white; border: none; padding: 10px 20px; border-radius: 15px; cursor: pointer; font-size: 16px;">
            Skip Cutscene
        </button>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="levelComplete">
            <div class="level-name" id="levelCompleteName">Level Complete!</div>
            <div id="levelCompleteText">Level Complete!</div>
            <div style="font-size: 16px; margin-top: 10px;">Press SPACE to continue</div>
        </div>
        <div id="controls" style="text-align: center; padding: 10px;">
            <button id="pauseBtn" onclick="togglePauseMenu()" style="display: none; background: linear-gradient(135deg, rgba(255,107,53,0.9), rgba(255,68,68,0.8)); color: #000; padding: clamp(10px, 2vw, 15px) clamp(15px, 3vw, 25px); border-radius: 25px; font-size: clamp(14px, 2vw, 18px); font-weight: bold; border: 3px solid #FF6B35; box-shadow: 0 0 20px #FF6B35, 0 5px 15px rgba(0,0,0,0.3); backdrop-filter: blur(5px); cursor: pointer;">
                ⏸️ Pause
            </button>
            </div>
        
        <!-- Settings Button (Bottom Left) -->
        <button id="settingsBtn" onclick="togglePauseMenu()" style="position: fixed; bottom: 20px; left: 20px; background: linear-gradient(135deg, rgba(0,255,255,0.9), rgba(0,255,255,0.8)); color: #000; padding: clamp(12px, 2.5vw, 18px) clamp(18px, 3.5vw, 28px); border-radius: 25px; font-size: clamp(14px, 2.2vw, 18px); font-weight: bold; border: 3px solid #00FFFF; box-shadow: 0 0 20px #00FFFF, 0 5px 15px rgba(0,0,0,0.3); backdrop-filter: blur(5px); cursor: pointer; z-index: 1000; display: none; transition: all 0.3s ease; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
            ⚙️ Settings
        </button>
    </div>
    
    <!-- Leaderboard Panel -->
    <div id="leaderboardPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.98)); color: #FFD700; padding: clamp(20px, 3vw, 35px); border-radius: 25px; border: 3px solid #FFD700; box-shadow: 0 20px 60px rgba(0,0,0,0.8), 0 0 40px rgba(255,215,0,0.5); backdrop-filter: blur(20px); z-index: 2000; max-width: 90vw; max-height: 85vh; overflow-y: auto; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid #FFD700; padding-bottom: 15px;">
            <h2 style="margin: 0; font-size: clamp(20px, 4vw, 32px); text-shadow: 0 0 15px #FFD700;">🏆 Global Leaderboard</h2>
            <div style="display: flex; gap: 10px;">
                <button id="refreshLeaderboardBtn" onclick="refreshGlobalLeaderboard()" style="background: #00FF88; color: white; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; font-size: 12px; font-weight: bold;">🔄 Refresh</button>
                <button onclick="resetStats()" style="background: #FF8800; color: white; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; font-size: 12px; font-weight: bold;">Reset</button>
                <button onclick="toggleLeaderboard()" style="background: #FF4444; color: white; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold;">×</button>
            </div>
        </div>
        <div id="leaderboardContent">
            <!-- Global Leaderboard Section -->
            <div style="margin-bottom: 30px;">
                <h3 style="color: #FFD700; margin-bottom: 15px; text-align: center;">🌍 Global Rankings</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 15px; justify-content: center;">
                    <button id="scoreTabBtn" class="tab-btn active" onclick="switchLeaderboardTab('score')" style="background: #FFD700; color: black; border: none; padding: 8px 15px; border-radius: 10px; cursor: pointer; font-weight: bold;">High Scores</button>
                    <button id="coinsTabBtn" class="tab-btn" onclick="switchLeaderboardTab('coins')" style="background: rgba(255,215,0,0.3); color: #FFD700; border: none; padding: 8px 15px; border-radius: 10px; cursor: pointer; font-weight: bold;">Coin Collectors</button>
                    <button id="levelsTabBtn" class="tab-btn" onclick="switchLeaderboardTab('levels')" style="background: rgba(255,215,0,0.3); color: #FFD700; border: none; padding: 8px 15px; border-radius: 10px; cursor: pointer; font-weight: bold;">Level Masters</button>
                    <button id="bossesTabBtn" class="tab-btn" onclick="switchLeaderboardTab('bosses')" style="background: rgba(255,215,0,0.3); color: #FFD700; border: none; padding: 8px 15px; border-radius: 10px; cursor: pointer; font-weight: bold;">👑 Boss Slayers</button>
                </div>
                <div id="globalLeaderboardContent">
                    <div style="text-align: center; color: #FFD700; font-size: 18px; margin: 20px 0;">
                        Loading global leaderboard...
                    </div>
                </div>
                <div id="leaderboardStatus" style="text-align: center; color: #00FFFF; font-size: 12px; margin-top: 10px;">
                    Last updated: Never
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="submitToGlobalLeaderboard()" style="background: #FFD700; color: black; border: none; padding: 10px 20px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 14px;">
                        🏆 Submit My Score
                    </button>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00FFFF; margin-bottom: 10px;">📊 All-Time Stats</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #FFD700;">
                        <div style="font-size: 14px; color: #FFD700;">Total Score</div>
                        <div id="totalScore" style="font-size: 24px; font-weight: bold;">0</div>
                        <div style="font-size: 12px; color: #00FFFF;">Best: <span id="highestScore">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #FFD700;">
                        <div style="font-size: 14px; color: #FFD700;">Levels Completed</div>
                        <div id="totalLevels" style="font-size: 24px; font-weight: bold;">0</div>
                        <div style="font-size: 12px; color: #00FFFF;">Best: <span id="highestLevels">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #FFD700;">
                        <div style="font-size: 14px; color: #FFD700;">Coins Collected</div>
                        <div id="totalCoins" style="font-size: 24px; font-weight: bold;">0</div>
                        <div style="font-size: 12px; color: #00FFFF;">Best: <span id="highestCoins">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #FFD700;">
                        <div style="font-size: 14px; color: #FFD700;">Crabs Defeated</div>
                        <div id="totalCrabs" style="font-size: 24px; font-weight: bold;">0</div>
                        <div style="font-size: 12px; color: #00FFFF;">Best: <span id="highestCrabs">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #FFD700;">
                        <div style="font-size: 14px; color: #FFD700;">👑 Bosses Defeated</div>
                        <div id="totalBosses" style="font-size: 24px; font-weight: bold;">0</div>
                        <div style="font-size: 12px; color: #00FFFF;">Best: <span id="highestBosses">0</span></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00FFFF; margin-bottom: 10px;">🎯 Current Session</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #00FFFF;">
                        <div style="font-size: 14px; color: #00FFFF;">Session Score</div>
                        <div id="sessionScore" style="font-size: 24px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #00FFFF;">
                        <div style="font-size: 14px; color: #00FFFF;">Session Levels</div>
                        <div id="sessionLevels" style="font-size: 24px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #00FFFF;">
                        <div style="font-size: 14px; color: #00FFFF;">Session Coins</div>
                        <div id="sessionCoins" style="font-size: 24px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #00FFFF;">
                        <div style="font-size: 14px; color: #00FFFF;">Session Crabs</div>
                        <div id="sessionCrabs" style="font-size: 24px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 15px; border-left: 4px solid #00FFFF;">
                        <div style="font-size: 14px; color: #00FFFF;">👑 Session Bosses</div>
                        <div id="sessionBosses" style="font-size: 24px; font-weight: bold;">0</div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00FFFF; margin-bottom: 10px;">🎯 All-Time Collectibles</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div style="background: rgba(255,215,0,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #FFD700;">Fish</div>
                        <div id="totalFish" style="font-size: 18px; font-weight: bold;">0</div>
                        <div style="font-size: 10px; color: #00FFFF;">Best: <span id="highestFish">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #FFD700;">Health</div>
                        <div id="totalHealth" style="font-size: 18px; font-weight: bold;">0</div>
                        <div style="font-size: 10px; color: #00FFFF;">Best: <span id="highestHealth">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #FFD700;">Treasures</div>
                        <div id="totalTreasures" style="font-size: 18px; font-weight: bold;">0</div>
                        <div style="font-size: 10px; color: #00FFFF;">Best: <span id="highestTreasures">0</span></div>
                    </div>
                    <div style="background: rgba(255,215,0,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #FFD700;">Mushrooms</div>
                        <div id="totalMushrooms" style="font-size: 18px; font-weight: bold;">0</div>
                        <div style="font-size: 10px; color: #00FFFF;">Best: <span id="highestMushrooms">0</span></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00FFFF; margin-bottom: 10px;">🎯 Session Collectibles</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div style="background: rgba(0,255,255,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #00FFFF;">Fish</div>
                        <div id="sessionFish" style="font-size: 18px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #00FFFF;">Health</div>
                        <div id="sessionHealth" style="font-size: 18px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #00FFFF;">Treasures</div>
                        <div id="sessionTreasures" style="font-size: 18px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0,255,255,0.1); padding: 10px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 12px; color: #00FFFF;">Mushrooms</div>
                        <div id="sessionMushrooms" style="font-size: 18px; font-weight: bold;">0</div>
                    </div>
                </div>
            </div>
            
            <!-- Achievements/Badges Section -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00FFFF; margin-bottom: 10px;">🏆 Recent Achievements</h3>
                <div id="recentAchievements" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <!-- Achievements will be populated here -->
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="toggleProfile()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 8px 16px; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease;">View All Achievements</button>
                </div>
            </div>
            <div>
                <h3 style="color: #00FFFF; margin-bottom: 10px;">⏱️ Level Times</h3>
                <div id="levelTimes" style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 10px; padding: 10px;">
                    <div style="text-align: center; color: #888; font-style: italic;">No levels completed yet</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Instructions Panel -->
    <div id="instructionsPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.98)); color: #00FFFF; padding: clamp(20px, 3vw, 35px); border-radius: 25px; border: 3px solid #00FFFF; box-shadow: 0 20px 60px rgba(0,0,0,0.8), 0 0 40px rgba(0,255,255,0.5); backdrop-filter: blur(20px); z-index: 2000; max-width: 90vw; max-height: 85vh; overflow-y: auto; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid #00FFFF; padding-bottom: 15px;">
            <h2 style="margin: 0; font-size: clamp(20px, 4vw, 32px); text-shadow: 0 0 15px #00FFFF;">📖 How to Play</h2>
            <button onclick="toggleInstructions()" style="background: #FF4444; color: white; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold;">×</button>
        </div>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
            <!-- Basic Controls -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">🎮 Basic Controls</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>Move:</strong> Arrow Keys or WASD</li>
                    <li><strong>Jump:</strong> Spacebar (double jump available!)</li>
                    <li><strong>Swim:</strong> Use arrow keys in water (1.5x faster than walking)</li>
                    <li><strong>Jetpack:</strong> Hold Shift while in air (if collected)</li>
                    <li><strong>Laser Charge:</strong> Hold left mouse button to charge (unlocks at level 10, 20, 30, etc.)</li>
                    <li><strong>Golden Chest:</strong> Press F key near chest with key</li>
                </ul>
            </div>
            
            <!-- Game Mechanics -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">🎯 Game Mechanics</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>Goal:</strong> Reach the flag at the end of each level</li>
                    <li><strong>Platforms:</strong> Jump on static, moving, and disappearing platforms</li>
                    <li><strong>Checkpoints:</strong> Touch to activate - respawn here if you fall</li>
                    <li><strong>Water Physics:</strong> Swim underwater, different movement mechanics</li>
                    <li><strong>Breakable Tiles:</strong> Stomp or shoot to reveal secrets</li>
                    <li><strong>Secret Rooms:</strong> Hidden areas with rare treasures</li>
                    <li><strong>Boss Battles:</strong> Every 5 levels - defeat Captain Claws!</li>
                </ul>
            </div>
            
            <!-- Collectibles & Points -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">💎 Collectibles & Points</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>🐟 Fish:</strong> +100 points each</li>
                    <li><strong>💰 Coins:</strong> +1 coin, +25 points each (used in marketplace)</li>
                    <li><strong>❤️ Health:</strong> +25 points, 60% chance for +1 life</li>
                    <li><strong>🛡️ Armor:</strong> +50 points, +50 armor protection</li>
                    <li><strong>🛡️ Hidden Armor:</strong> +100 points, +75 armor protection</li>
                    <li><strong>🛡️ Boss Armor:</strong> +150 points, +100 armor protection</li>
                    <li><strong>💎 Treasures:</strong> +500-1000 points each</li>
                    <li><strong>💎 Rare Treasures:</strong> +1500-2500 points each, +25 coins, +1 life</li>
                    <li><strong>🍄 Mushrooms:</strong> +1000 points, giant mode + invincibility</li>
                    <li><strong>🔑 Keys:</strong> +200 points, opens golden chests</li>
                    <li><strong>🚁 Jetpack:</strong> +200 points, enables flight</li>
                    <li><strong>🔫 Laser:</strong> +200 points, shoot enemies from distance</li>
                    <li><strong>Level Complete:</strong> +500 points + fish bonus</li>
                    <li><strong>Every 10,000 points:</strong> +1 life</li>
                </ul>
            </div>
            
            <!-- Enemies -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">🦀 Enemies & Combat</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>🦀 Regular Crab:</strong> +200 points - patrols platforms, jump on head</li>
                    <li><strong>🦅 Eagle:</strong> +200 points - intelligent targeting, swoops and attacks</li>
                    <li><strong>🔴 ChargerCrab:</strong> +200 points - large red cube, charges after windup</li>
                    <li><strong>🐊 Gator:</strong> +200 points - sits on water surface, chases player</li>
                    <li><strong>🔮 Wizgator:</strong> +200 points - magical gator, shoots fireballs</li>
                    <li><strong>🦈 Shark:</strong> +200 points - underwater hunter, swoops and attacks</li>
                    <li><strong>🐟 Goldfish:</strong> +200 points - swims underwater, shoots lasers (level 5+)</li>
                    <li><strong>👑 Captain Claws (Boss):</strong> +1000 points - every 5 levels</li>
                    <li><strong>Combat Methods:</strong> Jump on head, shoot with laser, or giant mode</li>
                    <li><strong>Invincibility:</strong> 2 seconds after taking damage</li>
                </ul>
            </div>
            
            <!-- Abilities & Power-ups -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">⚡ Abilities & Power-ups</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>Double Jump:</strong> Jump again while in the air</li>
                    <li><strong>Armor System:</strong> Armor absorbs damage before health</li>
                    <li><strong>Giant Mode:</strong> Larger size, invincibility, enemy knockback</li>
                    <li><strong>Jetpack Flight:</strong> Hold Shift to fly through the air</li>
                    <li><strong>Laser Weapon:</strong> Shoot enemies from a distance</li>
                    <li><strong>Laser Charge System:</strong> Hold to charge for more powerful shots (unlocks every 10 levels)</li>
                    <li><strong>Water Swimming:</strong> 1.5x faster movement in water</li>
                    <li><strong>Screen Shake:</strong> Visual feedback for impacts</li>
                    <li><strong>Particle Effects:</strong> Visual effects for actions</li>
                </ul>
            </div>
            
            <!-- XP & Progression System -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">📈 XP & Progression System</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>XP Progression:</strong> Level 1-10: 500 XP increase per level, Level 10+: 1000 XP per level</li>
                    <li><strong>Laser Charge Unlocks:</strong> Every 10 levels (10, 20, 30, 40, 50, 60)</li>
                    <li><strong>Laser Charge Upgrades:</strong> Each unlock increases max charge level</li>
                    <li><strong>Level Rewards:</strong> Unlock new abilities and cosmetics as you progress</li>
                    <li><strong>Persistent Progress:</strong> All unlocks and levels are saved automatically</li>
                </ul>
            </div>
            
            <!-- New Features -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">🆕 New Features</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>🦉 AI Owl Guide:</strong> Provides tips and follows you</li>
                    <li><strong>🏪 Marketplace:</strong> Spend coins on owl hats and otter skins</li>
                    <li><strong>👤 Profile System:</strong> Track stats, achievements, and customization</li>
                    <li><strong>🏆 Global Leaderboard:</strong> Compete with players worldwide</li>
                    <li><strong>📊 Detailed Statistics:</strong> Track all your progress</li>
                    <li><strong>🏅 Achievements:</strong> Unlock achievements for milestones</li>
                    <li><strong>🎨 Customization:</strong> Change profile picture and player name</li>
                    <li><strong>💾 Save Progress:</strong> All data persists across sessions</li>
                </ul>
            </div>
            
            <!-- UI Controls -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">🎛️ UI Controls</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>🏠 Home Screen:</strong> Main menu with all options</li>
                    <li><strong>🏆 Leaderboard:</strong> View global rankings and stats</li>
                    
                    <li><strong>🏪 Marketplace:</strong> Buy hats and skins with coins</li>
                    <li><strong>👤 Profile:</strong> View achievements and stats</li>
                    <li><strong>📖 Instructions:</strong> This help panel</li>
                    <li><strong>🎨 Asset Import:</strong> Import custom sprites</li>
                    <li><strong>🔄 Refresh:</strong> Update leaderboard data</li>
                </ul>
            </div>
            
            <!-- Tips & Strategies -->
            <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid #00FFFF;">
                <h3 style="color: #00FFFF; margin-top: 0;">💡 Tips & Strategies</h3>
                <ul style="color: #FFD700; line-height: 1.6;">
                    <li><strong>Explore:</strong> Check high areas and underwater for secrets</li>
                    <li><strong>Break Tiles:</strong> Stomp or shoot breakable tiles for rewards</li>
                    <li><strong>Use Power-ups:</strong> Save mushrooms for difficult sections</li>
                    <li><strong>Collect Coins:</strong> Spend them in the marketplace for customization</li>
                    <li><strong>Check Leaderboard:</strong> See how you rank globally</li>
                    <li><strong>Complete Achievements:</strong> Unlock rewards and track progress</li>
                    <li><strong>Customize:</strong> Make your otter and owl unique</li>
                    
                </ul>
            </div>
        </div>
        </div>
    


    <!-- Marketplace Panel -->
    <div id="marketplacePanel" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.98)); backdrop-filter: blur(20px); z-index: 3500; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif; overflow: hidden;">
        
        <!-- Header Section -->
        <div style="position: relative; background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(26,26,46,0.9)); padding: 20px 30px; border-bottom: 2px solid rgba(0,255,255,0.3); box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
            <div style="display: flex; justify-content: space-between; align-items: center; max-width: 1400px; margin: 0 auto;">
                <div style="display: flex; align-items: center; gap: 20px;">
                    <h1 style="margin: 0; font-size: clamp(24px, 4vw, 36px); color: #00FFFF; text-shadow: 0 0 20px rgba(0,255,255,0.6); font-weight: 900;">🛒 Marketplace</h1>
                    <div style="display: flex; align-items: center; gap: 8px; background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 12px 20px; border-radius: 25px; border: 2px solid rgba(255,215,0,0.3); backdrop-filter: blur(10px);">
                        <span style="font-size: 20px;">🪙</span>
                        <span id="marketplaceCoins" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 10px rgba(255,215,0,0.5);">0</span>
                        <span style="color: #FFD700; font-size: 14px; font-weight: 600;">Coins</span>
        </div>
        </div>
                <button onclick="toggleMarketplace()" style="background: linear-gradient(135deg, #FF4444, #CC0000); color: white; border: none; padding: 12px 20px; border-radius: 50%; cursor: pointer; font-size: 20px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(255,68,68,0.3); width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;">×</button>
    </div>
        </div>
        
        <!-- Navigation Tabs -->
        <div style="background: rgba(0,0,0,0.6); padding: 15px 30px; border-bottom: 1px solid rgba(0,255,255,0.2);">
            <div style="display: flex; gap: 15px; max-width: 1400px; margin: 0 auto; justify-content: center;">
                <button id="hatsTabBtn" class="marketplace-tab-btn active" onclick="switchMarketplaceTab('hats')" style="background: linear-gradient(135deg, rgba(76,175,80,0.2), rgba(76,175,80,0.1)); color: #4CAF50; border: 2px solid rgba(76,175,80,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">🦉</div>
                    <div>Owl Hats</div>
                </button>
                <button id="skinsTabBtn" class="marketplace-tab-btn" onclick="switchMarketplaceTab('skins')" style="background: linear-gradient(135deg, rgba(33,150,243,0.2), rgba(33,150,243,0.1)); color: #2196F3; border: 2px solid rgba(33,150,243,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">🦦</div>
                    <div>Otter Skins</div>
                </button>
                <button id="abilitiesTabBtn" class="marketplace-tab-btn" onclick="switchMarketplaceTab('abilities')" style="background: linear-gradient(135deg, rgba(255,107,53,0.2), rgba(255,107,53,0.1)); color: #FF6B35; border: 2px solid rgba(255,107,53,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">⚡</div>
                    <div>Abilities</div>
                </button>
        </div>
        </div>
        
        <!-- Content Area -->
        <div style="flex: 1; overflow-y: auto; padding: 30px; max-width: 1400px; margin: 0 auto;">
        <div id="hatsTab" class="marketplace-content">
                <div class="marketplace-grid" id="hatsGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 25px;">
                <!-- Owl hats will be populated here -->
            </div>
        </div>
        
        <div id="skinsTab" class="marketplace-content" style="display: none;">
                <div class="marketplace-grid" id="skinsGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 25px;">
                <!-- Otter skins will be populated here -->
            </div>
        </div>
        
        <div id="abilitiesTab" class="marketplace-content" style="display: none;">
                <div class="marketplace-grid" id="abilitiesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 25px;">
                <!-- Abilities will be populated here -->
                </div>
            </div>
        </div>
        
        <!-- Footer -->
        <div style="background: rgba(0,0,0,0.6); padding: 20px 30px; border-top: 1px solid rgba(0,255,255,0.2); text-align: center;">
            <button onclick="toggleMarketplace()" style="background: linear-gradient(135deg, #666666, #444444); color: white; border: none; padding: 15px 30px; border-radius: 25px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); border: 2px solid rgba(255,255,255,0.1);">← Back to Menu</button>
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.98)); backdrop-filter: blur(20px); z-index: 4000; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif; overflow: hidden;">
        
        <!-- Header -->
        <div style="position: relative; background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(26,26,46,0.9)); padding: 20px 30px; border-bottom: 2px solid rgba(0,255,255,0.3); box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
            <div style="display: flex; justify-content: space-between; align-items: center; max-width: 1400px; margin: 0 auto;">
                <h1 style="margin: 0; font-size: clamp(24px, 4vw, 36px); color: #00FFFF; text-shadow: 0 0 20px rgba(0,255,255,0.6); font-weight: 900;">⏸️ PAUSED</h1>
                <button onclick="togglePauseMenu()" style="background: linear-gradient(135deg, #FF4444, #CC0000); color: white; border: none; padding: 12px 20px; border-radius: 50%; cursor: pointer; font-size: 20px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(255,68,68,0.3); width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;">×</button>
            </div>
        </div>
        
        <!-- Navigation Tabs -->
        <div style="background: rgba(0,0,0,0.6); padding: 15px 30px; border-bottom: 1px solid rgba(0,255,255,0.2);">
            <div style="display: flex; gap: 15px; max-width: 1400px; margin: 0 auto; justify-content: center; flex-wrap: wrap;">
                <button id="pauseInstructionsTabBtn" class="pause-tab-btn active" onclick="switchPauseTab('instructions')" style="background: linear-gradient(135deg, rgba(76,175,80,0.2), rgba(76,175,80,0.1)); color: #4CAF50; border: 2px solid rgba(76,175,80,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">📖</div>
                    <div>Instructions</div>
                </button>
                <button id="pauseSettingsTabBtn" class="pause-tab-btn" onclick="switchPauseTab('settings')" style="background: linear-gradient(135deg, rgba(33,150,243,0.2), rgba(33,150,243,0.1)); color: #2196F3; border: 2px solid rgba(33,150,243,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">⚙️</div>
                    <div>Settings</div>
                </button>
                <button id="pauseCustomizationTabBtn" class="pause-tab-btn" onclick="switchPauseTab('customization')" style="background: linear-gradient(135deg, rgba(255,107,53,0.2), rgba(255,107,53,0.1)); color: #FF6B35; border: 2px solid rgba(255,107,53,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">🎨</div>
                    <div>Customization</div>
                </button>
                <button id="pauseActionsTabBtn" class="pause-tab-btn" onclick="switchPauseTab('actions')" style="background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,215,0,0.1)); color: #FFD700; border: 2px solid rgba(255,215,0,0.4); padding: 15px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; backdrop-filter: blur(10px); min-width: 140px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                    <div style="font-size: 20px; margin-bottom: 5px;">🏠</div>
                    <div>Actions</div>
                </button>
            </div>
        </div>
        
        <!-- Content Area -->
        <div style="flex: 1; overflow-y: auto; padding: 30px; max-width: 1400px; margin: 0 auto;">
            
            <!-- Instructions Tab -->
            <div id="pauseInstructionsTab" class="pause-content">
                <div style="background: rgba(76,175,80,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(76,175,80,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #4CAF50; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(76,175,80,0.5);">🎮 Basic Controls</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #4CAF50; font-size: 18px;">Movement</h4>
                            <ul style="color: #FFD700; line-height: 1.6; margin: 0; padding-left: 20px;">
                                <li><strong>Move:</strong> Arrow keys or WASD</li>
                                <li><strong>Jump:</strong> Spacebar (double jump available!)</li>
                                <li><strong>Swim:</strong> Use arrow keys in water (1.5x faster than walking)</li>
                                <li><strong>Jetpack:</strong> Hold Shift while in air (if collected)</li>
                            </ul>
                        </div>
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #4CAF50; font-size: 18px;">Combat & Abilities</h4>
                            <ul style="color: #FFD700; line-height: 1.6; margin: 0; padding-left: 20px;">
                                <li><strong>Laser Charge:</strong> Hold left mouse button to charge (unlocks at level 10, 20, 30, etc.)</li>
                                <li><strong>Fireball:</strong> Right-click to shoot (if collected)</li>
                                <li><strong>Golden Chest:</strong> Press F key near chest with key</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(33,150,243,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(33,150,243,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #2196F3; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(33,150,243,0.5);">⚡ Abilities & Power-ups</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div style="background: rgba(33,150,243,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(33,150,243,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #2196F3; font-size: 18px;">Power-ups</h4>
                            <ul style="color: #FFD700; line-height: 1.6; margin: 0; padding-left: 20px;">
                                <li><strong>Mushroom:</strong> Temporary invincibility and size boost</li>
                                <li><strong>Giant Mode:</strong> Larger size, invincibility, enemy knockback</li>
                                <li><strong>Jetpack Flight:</strong> Hold Shift to fly through the air</li>
                                <li><strong>Laser Weapon:</strong> Shoot enemies from a distance</li>
                                <li><strong>Laser Charge System:</strong> Hold to charge for more powerful shots (unlocks every 10 levels)</li>
                                <li><strong>Water Swimming:</strong> 1.5x faster movement in water</li>
                                <li><strong>Screen Shake:</strong> Visual feedback for impacts</li>
                                <li><strong>Particle Effects:</strong> Visual effects for actions</li>
                            </ul>
                        </div>
                        <div style="background: rgba(33,150,243,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(33,150,243,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #2196F3; font-size: 18px;">Collectibles</h4>
                            <ul style="color: #FFD700; line-height: 1.6; margin: 0; padding-left: 20px;">
                                <li><strong>🪙 Coins:</strong> Collect for marketplace purchases</li>
                                <li><strong>🗝️ Keys:</strong> Open golden chests for rewards</li>
                                <li><strong>📦 Chests:</strong> Regular chests with coins and items</li>
                                <li><strong>💎 Golden Chests:</strong> Special chests requiring keys</li>
                                <li><strong>❤️ Hearts:</strong> Restore health</li>
                                <li><strong>🛡️ Armor:</strong> Provide damage protection</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(0,255,255,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(0,255,255,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #00FFFF; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(0,255,255,0.5);">📈 XP & Progression System</h3>
                    <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(0,255,255,0.2);">
                        <ul style="color: #FFD700; line-height: 1.6; margin: 0; padding-left: 20px;">
                            <li><strong>XP Progression:</strong> Level 1-10: 500 XP increase per level, Level 10+: 1000 XP per level</li>
                            <li><strong>Laser Charge Unlocks:</strong> Every 10 levels (10, 20, 30, 40, 50, 60)</li>
                            <li><strong>Laser Charge Upgrades:</strong> Each unlock increases max charge level</li>
                            <li><strong>Level Rewards:</strong> Unlock new abilities and cosmetics as you progress</li>
                            <li><strong>Persistent Progress:</strong> All unlocks and levels are saved automatically</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- Settings Tab -->
            <div id="pauseSettingsTab" class="pause-content" style="display: none;">
                <div style="background: rgba(33,150,243,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(33,150,243,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #2196F3; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(33,150,243,0.5);">🤖 AI Owl Bot Settings</h3>
                    <div style="display: flex; align-items: center; justify-content: center; gap: 20px; padding: 20px; background: rgba(33,150,243,0.1); border-radius: 15px; border: 1px solid rgba(33,150,243,0.2);">
                        <span style="color: #FFD700; font-size: 18px; font-weight: bold;">AI Owl Bot:</span>
                        <label class="toggle-switch" style="position: relative; display: inline-block; width: 60px; height: 34px;">
                            <input type="checkbox" id="aiOwlToggle" style="opacity: 0; width: 0; height: 0;">
                            <span class="toggle-slider" style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);"></span>
                        </label>
                        <span id="aiOwlStatus" style="color: #4CAF50; font-size: 16px; font-weight: bold;">ON</span>
                    </div>
                </div>
                
                <div style="background: rgba(255,107,53,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(255,107,53,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #FF6B35; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(255,107,53,0.5);">🎮 Game Settings</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div style="background: rgba(255,107,53,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,107,53,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FF6B35; font-size: 18px;">Visual Settings</h4>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Screen Shake:</label>
                                <input type="range" id="screenShakeSlider" min="0" max="100" value="50" style="width: 100%; height: 8px; border-radius: 5px; background: rgba(255,107,53,0.3); outline: none;">
                                <div style="text-align: center; color: #FFD700; font-size: 14px; margin-top: 5px;">50%</div>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Particle Effects:</label>
                                <input type="range" id="particleEffectsSlider" min="0" max="100" value="75" style="width: 100%; height: 8px; border-radius: 5px; background: rgba(255,107,53,0.3); outline: none;">
                                <div style="text-align: center; color: #FFD700; font-size: 14px; margin-top: 5px;">75%</div>
                            </div>
                        </div>
                        <div style="background: rgba(255,107,53,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,107,53,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FF6B35; font-size: 18px;">Audio Settings</h4>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Master Volume:</label>
                                <input type="range" id="masterVolumeSlider" min="0" max="100" value="80" style="width: 100%; height: 8px; border-radius: 5px; background: rgba(255,107,53,0.3); outline: none;">
                                <div style="text-align: center; color: #FFD700; font-size: 14px; margin-top: 5px;">80%</div>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">SFX Volume:</label>
                                <input type="range" id="sfxVolumeSlider" min="0" max="100" value="90" style="width: 100%; height: 8px; border-radius: 5px; background: rgba(255,107,53,0.3); outline: none;">
                                <div style="text-align: center; color: #FFD700; font-size: 14px; margin-top: 5px;">90%</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Customization Tab -->
            <div id="pauseCustomizationTab" class="pause-content" style="display: none;">
                <div style="background: rgba(255,107,53,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(255,107,53,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #FF6B35; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(255,107,53,0.5);">🎨 Character Customization</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div style="background: rgba(255,107,53,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,107,53,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FF6B35; font-size: 18px;">Otter Skins</h4>
                            <div id="pauseOtterSkins" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 10px;">
                                <!-- Otter skins will be populated here -->
                            </div>
                        </div>
                        <div style="background: rgba(255,107,53,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,107,53,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FF6B35; font-size: 18px;">Owl Hats</h4>
                            <div id="pauseOwlHats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 10px;">
                                <!-- Owl hats will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(255,215,0,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(255,215,0,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(255,215,0,0.5);">🎨 Asset Importer</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div style="background: rgba(255,215,0,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,215,0,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FFD700; font-size: 18px;">Character Assets</h4>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Otter Character:</label>
                                <input type="file" id="otterCharacterInput" accept="image/*" style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importOtterCharacter()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Otter</button>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Owl Companion:</label>
                                <input type="file" id="owlCompanionInput" accept="image/*" style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importOwlCompanion()" style="background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Owl</button>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Enemy Sprites:</label>
                                <input type="file" id="enemySpritesInput" accept="image/*" multiple style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importEnemySprites()" style="background: linear-gradient(135deg, #FF6B35, #F7931E); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Enemies</button>
                            </div>
                        </div>
                        <div style="background: rgba(255,215,0,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,215,0,0.2);">
                            <h4 style="margin: 0 0 15px 0; color: #FFD700; font-size: 18px;">Environment Assets</h4>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Background Images:</label>
                                <input type="file" id="backgroundInput" accept="image/*" multiple style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importBackgrounds()" style="background: linear-gradient(135deg, #9C27B0, #7B1FA2); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Backgrounds</button>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Platform Textures:</label>
                                <input type="file" id="platformInput" accept="image/*" multiple style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importPlatforms()" style="background: linear-gradient(135deg, #795548, #5D4037); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Platforms</button>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="color: #FFD700; font-size: 16px; display: block; margin-bottom: 8px;">Collectibles:</label>
                                <input type="file" id="collectiblesInput" accept="image/*" multiple style="width: 100%; padding: 8px; border-radius: 5px; background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); color: #FFD700;">
                                <button onclick="importCollectibles()" style="background: linear-gradient(135deg, #FFD700, #FFA000); color: #000; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-top: 8px; width: 100%;">Import Collectibles</button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(0,255,255,0.1); padding: 20px; border-radius: 15px; border: 2px solid rgba(0,255,255,0.3); margin-top: 20px;">
                        <h4 style="margin: 0 0 15px 0; color: #00FFFF; font-size: 18px; text-align: center;">Asset Management</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <button onclick="previewImportedAssets()" style="background: linear-gradient(135deg, #00BCD4, #0097A7); color: white; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease;">
                                👁️ Preview Assets
                            </button>
                            <button onclick="exportAssetPack()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease;">
                                📦 Export Pack
                            </button>
                            <button onclick="resetToDefaults()" style="background: linear-gradient(135deg, #FF4444, #CC0000); color: white; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease;">
                                🔄 Reset Defaults
                            </button>
                            <button onclick="clearAllAssets()" style="background: linear-gradient(135deg, #9E9E9E, #757575); color: white; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease;">
                                🗑️ Clear All
                            </button>
                        </div>
                    </div>
                    
                    <div id="assetPreviewArea" style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px; border: 2px solid rgba(255,215,0,0.2); margin-top: 20px; display: none;">
                        <h4 style="margin: 0 0 15px 0; color: #FFD700; font-size: 18px; text-align: center;">Asset Preview</h4>
                        <div id="assetPreviewGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; max-height: 300px; overflow-y: auto;">
                            <!-- Asset previews will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Actions Tab -->
            <div id="pauseActionsTab" class="pause-content" style="display: none;">
                <div style="background: rgba(255,215,0,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(255,215,0,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(255,215,0,0.5); font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">🏠 Game Actions</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                        <button onclick="resumeGame()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 20px; border-radius: 15px; cursor: pointer; font-size: 18px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; align-items: center; gap: 10px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                            <div style="font-size: 32px;">▶️</div>
                            <div>Resume Game</div>
                        </button>
                        <button onclick="restartLevel()" style="background: linear-gradient(135deg, #FF6B35, #F7931E); color: white; border: none; padding: 20px; border-radius: 15px; cursor: pointer; font-size: 18px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; align-items: center; gap: 10px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                            <div style="font-size: 32px;">🔄</div>
                            <div>Restart Level</div>
                        </button>
                        <button onclick="returnToHome()" style="background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; padding: 20px; border-radius: 15px; cursor: pointer; font-size: 18px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; align-items: center; gap: 10px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                            <div style="font-size: 32px;">🏠</div>
                            <div>Return Home</div>
                        </button>
                        <button onclick="saveAndQuit()" style="background: linear-gradient(135deg, #FF4444, #CC0000); color: white; border: none; padding: 20px; border-radius: 15px; cursor: pointer; font-size: 18px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; align-items: center; gap: 10px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                            <div style="font-size: 32px;">💾</div>
                            <div>Save & Quit</div>
                        </button>
                        <button onclick="resetAllGameData(); alert('All game data has been reset! The game will now start fresh.'); location.reload();" style="background: linear-gradient(135deg, #FF8800, #FF6600); color: white; border: none; padding: 20px; border-radius: 15px; cursor: pointer; font-size: 18px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; flex-direction: column; align-items: center; gap: 10px; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
                            <div style="font-size: 32px;">🔄</div>
                            <div>Reset All Data</div>
                        </button>
                    </div>
                </div>
                
                <div style="background: rgba(76,175,80,0.05); padding: 25px; border-radius: 20px; border: 2px solid rgba(76,175,80,0.3); margin-bottom: 25px;">
                    <h3 style="margin: 0 0 20px 0; color: #4CAF50; text-align: center; font-size: 24px; text-shadow: 0 0 10px rgba(76,175,80,0.5);">📊 Current Session</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2); text-align: center;">
                            <div style="font-size: 24px; margin-bottom: 10px;">🎯</div>
                            <div style="color: #FFD700; font-size: 18px; font-weight: bold;">Score</div>
                            <div id="pauseScore" style="color: #4CAF50; font-size: 24px; font-weight: bold;">0</div>
                        </div>
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2); text-align: center;">
                            <div style="font-size: 24px; margin-bottom: 10px;">🪙</div>
                            <div style="color: #FFD700; font-size: 18px; font-weight: bold;">Coins</div>
                            <div id="pauseCoins" style="color: #4CAF50; font-size: 24px; font-weight: bold;">0</div>
                        </div>
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2); text-align: center;">
                            <div style="font-size: 24px; margin-bottom: 10px;">❤️</div>
                            <div style="color: #FFD700; font-size: 18px; font-weight: bold;">Health</div>
                            <div id="pauseHealth" style="color: #4CAF50; font-size: 24px; font-weight: bold;">100</div>
                        </div>
                        <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(76,175,80,0.2); text-align: center;">
                            <div style="font-size: 24px; margin-bottom: 10px;">📈</div>
                            <div style="color: #FFD700; font-size: 18px; font-weight: bold;">Level</div>
                            <div id="pauseLevel" style="color: #4CAF50; font-size: 24px; font-weight: bold;">1</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Panel -->
    <div id="profilePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.98)); color: #00FFFF; padding: clamp(20px, 3vw, 35px); border-radius: 25px; border: 3px solid #00FFFF; box-shadow: 0 20px 60px rgba(0,0,0,0.8), 0 0 40px rgba(0,255,255,0.5); backdrop-filter: blur(20px); z-index: 3500; max-width: 90vw; max-height: 85vh; overflow-y: auto; font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid #00FFFF; padding-bottom: 15px;">
            <h2 style="margin: 0; font-size: clamp(20px, 4vw, 32px); text-shadow: 0 0 15px #00FFFF;">👤 Player Profile</h2>
            <button onclick="toggleProfile()" style="background: #FF4444; color: white; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold;">×</button>
        </div>
        
        <!-- Profile Header -->
        <div style="display: flex; align-items: center; margin-bottom: 25px; padding: 20px; background: rgba(255,215,0,0.1); border-radius: 15px; border: 2px solid #FFD700;">
            <div style="margin-right: 20px; position: relative;">
                <div style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid #FFD700; box-shadow: 0 0 20px rgba(255,215,0,0.5); background: rgba(0,0,0,0.1); cursor: pointer; display: flex; align-items: center; justify-content: center; overflow: hidden;" onclick="editProfilePicture()">
                    <img id="profileOtterImage" src="public/oggg.png" alt="Player Otter" style="width: 100%; height: 100%; object-fit: cover; object-position: center;">
                </div>
                <div class="profile-edit-btn" style="position: absolute; bottom: -5px; right: -5px; background: #4CAF50; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; border: 2px solid #FFD700;" onclick="editProfilePicture()" title="Edit Profile Picture">✏️</div>
            </div>
            <div style="flex: 1;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <h3 id="profilePlayerName" style="margin: 0; color: #FFD700; font-size: 24px; cursor: pointer;" onclick="editPlayerName()">Otter Player</h3>
                    <button class="profile-edit-btn" onclick="editPlayerName()" style="background: none; border: none; color: #00FFFF; font-size: 16px; cursor: pointer; padding: 2px 6px; border-radius: 5px; transition: all 0.3s ease;" title="Edit Name">✏️</button>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 20px;">🪙</span>
                    <span id="profileCoins" style="font-size: 18px; font-weight: bold; color: #FFD700;">0</span>
                    <span style="margin-left: 5px;">Coins</span>
                </div>
            </div>
        </div>
        
        <!-- Profile Tabs -->
        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
            <button id="statsTabBtn" class="tab-btn active" onclick="switchProfileTab('stats')" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #FF6B35, #F7931E); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">📊 Stats</button>
            <button id="achievementsTabBtn" class="tab-btn" onclick="switchProfileTab('achievements')" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #FFD700, #FFA500); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">🏆 Achievements</button>
            <button id="customizationTabBtn" class="tab-btn" onclick="switchProfileTab('customization')" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">🎨 Customization</button>
            <button id="walletTabBtn" class="tab-btn" onclick="switchProfileTab('wallet')" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">🔗 Wallet</button>
        </div>
        
        <!-- Stats Tab -->
        <div id="statsTab" class="profile-content">
            <!-- Main Stats Grid -->
            <!-- Main Stats Section -->
            <div style="background: rgba(255,107,53,0.05); padding: 20px; border-radius: 20px; border: 2px solid #FF6B35; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #FF6B35; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(255,107,53,0.5);">🏆 Main Statistics</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 24px; margin-bottom: 8px;">🎯</div>
                        <div style="font-size: 12px; color: #FF6B35; margin-bottom: 5px; font-weight: bold;">TOTAL SCORE</div>
                        <div id="profileTotalScore" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 24px; margin-bottom: 8px;">🏆</div>
                        <div style="font-size: 12px; color: #FF6B35; margin-bottom: 5px; font-weight: bold;">LEVELS COMPLETED</div>
                        <div id="profileLevelsCompleted" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 24px; margin-bottom: 8px;">🪙</div>
                        <div style="font-size: 12px; color: #FF6B35; margin-bottom: 5px; font-weight: bold;">TOTAL COINS</div>
                        <div id="profileTotalCoins" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 24px; margin-bottom: 8px;">⚔️</div>
                        <div style="font-size: 12px; color: #FF6B35; margin-bottom: 5px; font-weight: bold;">ENEMIES DEFEATED</div>
                        <div id="profileEnemiesDefeated" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 24px; margin-bottom: 8px;">👑</div>
                        <div style="font-size: 12px; color: #FF6B35; margin-bottom: 5px; font-weight: bold;">BOSSES DEFEATED</div>
                        <div id="profileBossesDefeated" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                </div>
            </div>
            
            <!-- Detailed Stats Section -->
            <div style="background: rgba(255,215,0,0.05); padding: 20px; border-radius: 20px; border: 2px solid #FFD700; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(255,215,0,0.5);">📊 Detailed Statistics</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">🎮</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">GAMES PLAYED</div>
                        <div id="profileGamesPlayed" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">⏱️</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">TOTAL PLAY TIME</div>
                        <div id="profilePlayTime" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0 min</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">🏅</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">BEST SCORE</div>
                        <div id="profileBestScore" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">⭐</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">CURRENT LEVEL</div>
                        <div id="profileCurrentLevel" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">1</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">💎</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">TREASURES FOUND</div>
                        <div id="profileTreasuresFound" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">🔑</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">KEYS COLLECTED</div>
                        <div id="profileKeysCollected" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">❤️</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">HEALTH PICKUPS</div>
                        <div id="profileHealthPickups" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">🍄</div>
                        <div style="font-size: 11px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">MUSHROOMS EATEN</div>
                        <div id="profileMushroomsEaten" style="font-size: 18px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                </div>
            </div>
            
            <!-- Enemy Defeat Breakdown -->
            <div style="background: rgba(255,0,0,0.05); padding: 20px; border-radius: 20px; border: 2px solid #FF4444; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #FF4444; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(255,68,68,0.5);">⚔️ Enemy Defeat Breakdown</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, rgba(255,68,68,0.15), rgba(255,68,68,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,68,68,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">🦀</div>
                        <div style="font-size: 11px; color: #FF4444; margin-bottom: 5px; font-weight: bold;">CRABS DEFEATED</div>
                        <div id="profileCrabsDefeated" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,68,68,0.15), rgba(255,68,68,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,68,68,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">🦅</div>
                        <div style="font-size: 11px; color: #FF4444; margin-bottom: 5px; font-weight: bold;">EAGLES DEFEATED</div>
                        <div id="profileEaglesDefeated" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,68,68,0.15), rgba(255,68,68,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,68,68,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">🐊</div>
                        <div style="font-size: 11px; color: #FF4444; margin-bottom: 5px; font-weight: bold;">GATORS DEFEATED</div>
                        <div id="profileGatorsDefeated" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,68,68,0.15), rgba(255,68,68,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,68,68,0.3); text-align: center; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 20px; margin-bottom: 8px;">🦈</div>
                        <div style="font-size: 11px; color: #FF4444; margin-bottom: 5px; font-weight: bold;">SHARKS DEFEATED</div>
                        <div id="profileSharksDefeated" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                </div>
            </div>
            
            <!-- Recent Achievements Section -->
            <div style="background: rgba(0,255,255,0.05); padding: 20px; border-radius: 20px; border: 2px solid #00FFFF; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #00FFFF; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(0,255,255,0.5);">🎯 Recent Achievements</h3>
                <div id="profileRecentAchievements" style="font-size: 14px; color: #FFD700; background: rgba(0,255,255,0.1); padding: 15px; border-radius: 12px; border: 1px solid rgba(0,255,255,0.3);">
                    <div style="text-align: center; font-style: italic;">🎉 Welcome to Otter Bros! Complete achievements to see them here!</div>
                </div>
            </div>
        </div>
        
        <!-- Achievements Tab -->
        <div id="achievementsTab" class="profile-content" style="display: none;">
            <div style="background: rgba(76,175,80,0.05); padding: 20px; border-radius: 20px; border: 2px solid #4CAF50; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #4CAF50; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(76,175,80,0.5);">🏆 Achievement Collection</h3>
                <div style="text-align: center; margin-bottom: 20px; color: #00FFFF; font-size: 14px;">
                    Complete challenges to unlock achievements and earn XP rewards!
                </div>
                <div id="profileAchievementsList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">
                    <!-- Achievements will be populated here -->
                </div>
            </div>
        </div>
        
        <!-- Customization Tab -->
        <div id="customizationTab" class="profile-content" style="display: none;">
            <!-- Currently Equipped Section -->
            <div style="margin-bottom: 30px;">
                <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 20px;">🎯 Currently Equipped</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div style="background: rgba(76,175,80,0.1); padding: 15px; border-radius: 15px; border: 2px solid #4CAF50;">
                        <h4 style="margin: 0 0 10px 0; color: #00FFFF; text-align: center;">🦦 Current Skin</h4>
                        <div id="profileCurrentSkin" style="display: flex; align-items: center; gap: 15px;">
                            <img id="profileSkinImage" src="public/oggg.png" alt="Current Skin" style="width: 60px; height: 60px; border-radius: 10px; object-fit: contain; background: rgba(0,0,0,0.1);">
                            <div>
                                <div id="profileSkinName" style="font-size: 16px; font-weight: bold; color: #4CAF50;">Classic Otter</div>
                                <div id="profileSkinDescription" style="font-size: 12px; color: #00FFFF;">The original look</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(76,175,80,0.1); padding: 15px; border-radius: 15px; border: 2px solid #4CAF50;">
                        <h4 style="margin: 0 0 10px 0; color: #00FFFF; text-align: center;">🦉 Current Hat</h4>
                        <div id="profileCurrentHat" style="display: flex; align-items: center; gap: 15px;">
                            <div id="profileHatImage" style="width: 60px; height: 60px; border-radius: 10px; background: #8B4513; display: flex; align-items: center; justify-content: center; font-size: 24px;">🦉</div>
                            <div>
                                <div id="profileHatName" style="font-size: 16px; font-weight: bold; color: #4CAF50;">No Hat</div>
                                <div id="profileHatDescription" style="font-size: 12px; color: #00FFFF;">Classic owl look</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Current Abilities Section -->
                <div style="margin-top: 20px;">
                    <h4 style="margin: 0 0 10px 0; color: #FF6B35; text-align: center;">⚡ Current Abilities</h4>
                    <div id="profileCurrentAbilities" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Currently equipped abilities will be populated here -->
                    </div>
                </div>
            </div>
            
            <!-- Inventory Section -->
            <div style="margin-bottom: 30px;">
                <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 20px;">🎒 Your Inventory</h3>
                
                <!-- Otter Skins Inventory -->
                <div style="margin-bottom: 25px;">
                    <h4 style="margin: 0 0 15px 0; color: #00FFFF; border-bottom: 2px solid #00FFFF; padding-bottom: 5px;">🦦 Otter Skins</h4>
                    <div id="profileSkinsInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Skins will be populated here -->
                    </div>
                </div>
                
                <!-- Owl Hats Inventory -->
                <div>
                    <h4 style="margin: 0 0 15px 0; color: #00FFFF; border-bottom: 2px solid #00FFFF; padding-bottom: 5px;">🦉 Owl Hats</h4>
                    <div id="profileHatsInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Hats will be populated here -->
                    </div>
                </div>
                
                            <!-- Abilities Inventory -->
            <div>
                <h4 style="margin: 0 0 15px 0; color: #00FFFF; border-bottom: 2px solid #00FFFF; padding-bottom: 5px;">⚡ Abilities</h4>
                <div id="profileAbilitiesInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                    <!-- Abilities will be populated here -->
                </div>
            </div>
            
            <!-- Laser Charging Level -->
            <div style="margin-top: 20px;">
                <h4 style="margin: 0 0 15px 0; color: #FF0000; border-bottom: 2px solid #FF0000; padding-bottom: 5px;">🔫 Laser Charging</h4>
                <div style="background: rgba(255,0,0,0.1); border: 2px solid #FF0000; border-radius: 15px; padding: 15px; text-align: center;">
                    <div style="font-size: 24px; margin-bottom: 10px;">⚡</div>
                    <div style="font-size: 18px; font-weight: bold; color: #FF0000; margin-bottom: 5px;">Level <span id="profileLaserLevel">1</span></div>
                    <div style="font-size: 14px; color: #00FFFF; margin-bottom: 10px;">Max Charge: <span id="profileMaxCharge">5</span></div>
                    <div style="font-size: 12px; color: #888;">Upgrade every 10 levels</div>
                    </div>
                </div>
            </div>
            
            <!-- Quick Equip Section -->
            <div style="background: rgba(255,215,0,0.1); padding: 20px; border-radius: 15px; border: 2px solid #FFD700;">
                <h4 style="margin: 0 0 15px 0; color: #FFD700; text-align: center;">⚡ Quick Equip</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <label style="color: #FFD700; font-size: 14px; margin-bottom: 5px; display: block;">Equip Skin:</label>
                        <select id="quickEquipSkin" onchange="quickEquipSkin(this.value)" style="width: 100%; padding: 8px; border-radius: 8px; border: 2px solid #FFD700; background: rgba(0,0,0,0.8); color: #FFD700;">
                            <option value="">Select a skin...</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #FFD700; font-size: 14px; margin-bottom: 5px; display: block;">Equip Hat:</label>
                        <select id="quickEquipHat" onchange="quickEquipHat(this.value)" style="width: 100%; padding: 8px; border-radius: 8px; border: 2px solid #FFD700; background: rgba(0,0,0,0.8); color: #FFD700;">
                            <option value="">Select a hat...</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Wallet Tab -->
        <div id="walletTab" class="profile-content" style="display: none;">
            <!-- Wallet Connection Status -->
            <div style="background: rgba(102,126,234,0.1); padding: 20px; border-radius: 20px; border: 2px solid #667eea; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #667eea; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(102,126,234,0.5);">🔗 Wallet Status</h3>
                <div id="walletStatusDisplay" style="text-align: center;">
                    <div id="walletConnectedStatus" style="display: none;">
                        <div style="font-size: 24px; margin-bottom: 10px;">✅</div>
                        <div style="font-size: 18px; font-weight: bold; color: #4CAF50; margin-bottom: 5px;">Connected to ApeChain</div>
                        <div id="walletAddressDisplay" style="font-size: 14px; color: #00FFFF; font-family: monospace; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 8px; margin: 10px 0;">0x0000...0000</div>
                        <div style="margin-top: 15px;">
                            <button onclick="refreshWalletData()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">🔄 Refresh Data</button>
                            <button onclick="refreshMetadata()" style="background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; margin-left: 10px;">🌐 Refresh Metadata</button>
                            <button onclick="checkNFTs()" style="background: linear-gradient(135deg, #FF9800, #F57C00); color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; margin-left: 10px;">🔍 Check NFTs</button>
                            <button onclick="scanAllOtterfulOtters()" style="background: linear-gradient(135deg, #9C27B0, #7B1FA2); color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; margin-left: 10px;">🔍 Scan All 2222</button>
                            <button onclick="disconnectWalletFromProfile()" style="background: linear-gradient(135deg, #F44336, #D32F2F); color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; margin-left: 10px;">❌ Disconnect</button>
                        </div>
                    </div>
                    <div id="walletDisconnectedStatus">
                        <div style="font-size: 24px; margin-bottom: 10px;">🔌</div>
                        <div style="font-size: 18px; font-weight: bold; color: #FF4444; margin-bottom: 10px;">Wallet Not Connected</div>
                        <button onclick="connectWalletFromProfile()" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">🔗 Connect Wallet</button>
                        <button onclick="refreshWalletData()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; margin-left: 10px;">🔄 Refresh Data</button>
                        <button onclick="testContractConnection()" style="background: linear-gradient(135deg, #FF6B35, #F7931E); color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; margin-left: 10px;">🧪 Test Contract</button>
                        <button onclick="testMetadataFetching()" style="background: linear-gradient(135deg, #9C27B0, #7B1FA2); color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease; margin-left: 10px;">🌐 Test Metadata</button>
                    </div>
                </div>
            </div>
            
            <!-- NFT Collection Overview -->
            <div style="background: rgba(255,215,0,0.1); padding: 20px; border-radius: 20px; border: 2px solid #FFD700; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(255,215,0,0.5);">🦦 NFT Collection</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 8px;">🦦</div>
                        <div style="font-size: 12px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">TOTAL NFTS</div>
                        <div id="profileTotalNFTs" style="font-size: 20px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 8px;">⭐</div>
                        <div style="font-size: 12px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">STAKED NFTS</div>
                        <div id="profileStakedNFTs" style="font-size: 20px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 8px;">👑</div>
                        <div style="font-size: 12px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">LEGENDARY NFTS</div>
                        <div id="profileLegendaryNFTs" style="font-size: 20px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 8px;">💎</div>
                        <div style="font-size: 12px; color: #FFD700; margin-bottom: 5px; font-weight: bold;">EPIC NFTS</div>
                        <div id="profileEpicNFTs" style="font-size: 20px; font-weight: bold; color: #00FFFF; text-shadow: 0 0 8px rgba(0,255,255,0.5);">0</div>
                    </div>
                </div>
            </div>
            
            <!-- Staking Rewards -->
            <div style="background: rgba(76,175,80,0.1); padding: 20px; border-radius: 20px; border: 2px solid #4CAF50; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #4CAF50; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(76,175,80,0.5);">🐟 Staking Rewards</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, rgba(76,175,80,0.15), rgba(76,175,80,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(76,175,80,0.3); text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 8px;">🐟</div>
                        <div style="font-size: 12px; color: #4CAF50; margin-bottom: 5px; font-weight: bold;">$FISH EARNED</div>
                        <div id="profileFishEarned" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(76,175,80,0.15), rgba(76,175,80,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(76,175,80,0.3); text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 8px;">⚡</div>
                        <div style="font-size: 12px; color: #4CAF50; margin-bottom: 5px; font-weight: bold;">STAKING RATE</div>
                        <div id="profileStakingRate" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0/day</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(76,175,80,0.15), rgba(76,175,80,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(76,175,80,0.3); text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 8px;">📈</div>
                        <div style="font-size: 12px; color: #4CAF50; margin-bottom: 5px; font-weight: bold;">AVG MULTIPLIER</div>
                        <div id="profileAvgMultiplier" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">1.0x</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(76,175,80,0.15), rgba(76,175,80,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(76,175,80,0.3); text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 8px;">⏱️</div>
                        <div style="font-size: 12px; color: #4CAF50; margin-bottom: 5px; font-weight: bold;">STAKING TIME</div>
                        <div id="profileStakingTime" style="font-size: 20px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">0h</div>
                    </div>
                </div>
            </div>
            
            <!-- Active Traits -->
            <div style="background: rgba(255,107,53,0.1); padding: 20px; border-radius: 20px; border: 2px solid #FF6B35; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #FF6B35; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(255,107,53,0.5);">🎮 Active Traits</h3>
                <div id="profileActiveTraits" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                    <!-- Active traits will be populated here -->
                </div>
            </div>
            
            <!-- Game Multipliers -->
            <div style="background: rgba(102,126,234,0.1); padding: 20px; border-radius: 20px; border: 2px solid #667eea; margin-bottom: 25px;">
                <h3 style="margin: 0 0 20px 0; color: #667eea; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(102,126,234,0.5);">⚡ Game Multipliers</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, rgba(102,126,234,0.15), rgba(102,126,234,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(102,126,234,0.3); text-align: center;">
                        <div style="font-size: 20px; margin-bottom: 8px;">🏃</div>
                        <div style="font-size: 12px; color: #667eea; margin-bottom: 5px; font-weight: bold;">SPEED</div>
                        <div id="profileSpeedMultiplier" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">1.0x</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(102,126,234,0.15), rgba(102,126,234,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(102,126,234,0.3); text-align: center;">
                        <div style="font-size: 20px; margin-bottom: 8px;">🎯</div>
                        <div style="font-size: 12px; color: #667eea; margin-bottom: 5px; font-weight: bold;">POINTS</div>
                        <div id="profilePointsMultiplier" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">1.0x</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(102,126,234,0.15), rgba(102,126,234,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(102,126,234,0.3); text-align: center;">
                        <div style="font-size: 20px; margin-bottom: 8px;">⚔️</div>
                        <div style="font-size: 12px; color: #667eea; margin-bottom: 5px; font-weight: bold;">DAMAGE</div>
                        <div id="profileDamageMultiplier" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">1.0x</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(102,126,234,0.15), rgba(102,126,234,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(102,126,234,0.3); text-align: center;">
                        <div style="font-size: 20px; margin-bottom: 8px;">🛡️</div>
                        <div style="font-size: 12px; color: #667eea; margin-bottom: 5px; font-weight: bold;">DEFENSE</div>
                        <div id="profileDefenseMultiplier" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">1.0x</div>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(102,126,234,0.15), rgba(102,126,234,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(102,126,234,0.3); text-align: center;">
                        <div style="font-size: 20px; margin-bottom: 8px;">🍀</div>
                        <div style="font-size: 12px; color: #667eea; margin-bottom: 5px; font-weight: bold;">LUCK</div>
                        <div id="profileLuckMultiplier" style="font-size: 18px; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255,215,0,0.5);">1.0x</div>
                    </div>
                </div>
            </div>
            
            <!-- NFT Gallery -->
            <div style="background: rgba(255,215,0,0.1); padding: 20px; border-radius: 20px; border: 2px solid #FFD700;">
                <h3 style="margin: 0 0 20px 0; color: #FFD700; text-align: center; font-size: 22px; text-shadow: 0 0 10px rgba(255,215,0,0.5);">🖼️ NFT Gallery</h3>
                <div id="profileNFTGallery" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                    <!-- NFT cards will be populated here -->
                </div>
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 20px;">
            <button onclick="toggleProfile()" style="background: linear-gradient(135deg, #FF4444, #CC0000); color: white; border: none; padding: 12px 25px; border-radius: 15px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">Back to Menu</button>
        </div>
    </div>
    
    <!-- Asset Import Panel -->
    <div id="assetPanel" style="display: none;">
        <div class="asset-header">
            <h3>🎨 Asset Importer</h3>
            <button onclick="toggleAssetPanel()" class="close-btn">×</button>
        </div>
        <div class="asset-content">
            <div class="asset-section" style="background: rgba(0,255,0,0.1); border-left-color: #00FF00;">
                <h4 style="color: #00FF00;">💡 Tips for Best Results</h4>
                <ul style="color: #FFD700; font-size: 12px; margin: 5px 0; padding-left: 20px;">
                    <li>Use PNG images with transparent backgrounds for best results</li>
                    <li>Keep sprites around 100x100 pixels for characters and collectibles</li>
                    <li>Background images will tile/repeat automatically</li>
                    <li>Platform tiles should be seamless for smooth appearance</li>
                    <li>Use the Export/Import buttons to save your custom asset configurations</li>
                </ul>
            </div>
            <div class="asset-section">
                <h4>🦦 Player Character (Ollie the Otter)</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the otter character sprite (recommended: 100x100px PNG with transparent background)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="playerSprite" accept="image/*" onchange="loadAsset('player', this)">
                    <button onclick="clearAsset('player')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="playerPreview"></div>
            </div>
            <div class="asset-section">
                <h4>🦀 Enemy Sprites (Crabs)</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the crab enemy sprites (recommended: 96x80px PNG with transparent background)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="enemySprite" accept="image/*" onchange="loadAsset('enemy', this)">
                    <button onclick="clearAsset('enemy')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="enemyPreview"></div>
            </div>
            <div class="asset-section">
                <h4>🔮 Wizgator Sprite</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the wizgator sprite (recommended: 120x80px PNG with transparent background)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="wizgatorSprite" accept="image/*" onchange="loadAsset('wizgator', this)">
                    <button onclick="clearAsset('wizgator')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="wizgatorPreview"></div>
            </div>
            <div class="asset-section">
                <h4>💰 Collectibles</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace collectible item sprites (recommended: 38x38px PNG with transparent background)</p>
                <div style="margin: 10px 0;">
                    <label style="color: #FFD700; display: block; margin: 5px 0;">🪙 Coins (38x38px):</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="coinSprite" accept="image/*" onchange="loadAsset('coin', this)">
                        <button onclick="clearAsset('coin')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                    </div>
                </div>
                <div style="margin: 10px 0;">
                    <label style="color: #FFD700; display: block; margin: 5px 0;">❤️ Health Hearts (38x38px):</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="healthSprite" accept="image/*" onchange="loadAsset('health', this)">
                        <button onclick="clearAsset('health')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                    </div>
                </div>
                <div style="margin: 10px 0;">
                    <label style="color: #FFD700; display: block; margin: 5px 0;">💎 Treasures (38x38px):</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="treasureSprite" accept="image/*" onchange="loadAsset('treasure', this)">
                        <button onclick="clearAsset('treasure')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                    </div>
                </div>
                <div style="margin: 10px 0;">
                    <label style="color: #FFD700; display: block; margin: 5px 0;">🐟 Fish (38x38px):</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="fishSprite" accept="image/*" onchange="loadAsset('fish', this)">
                        <button onclick="clearAsset('fish')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                    </div>
                </div>
                <div class="preview" id="collectiblesPreview"></div>
            </div>
            <div class="asset-section">
                <h4>🌅 Background Image</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the sky background (will tile/repeat automatically, recommended: 512x512px PNG)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="backgroundSprite" accept="image/*" onchange="loadAsset('background', this)">
                    <button onclick="clearAsset('background')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="backgroundPreview"></div>
            </div>
            <div class="asset-section">
                <h4>🏔️ Platform Tiles</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the platform/ground tiles (recommended: 77x48px PNG, will tile seamlessly)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="platformSprite" accept="image/*" onchange="loadAsset('platform', this)">
                    <button onclick="clearAsset('platform')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="platformPreview"></div>
            </div>
            <div class="asset-section">
                <h4>🍄 Power-up Mushroom</h4>
                <p style="color: #FFD700; font-size: 12px; margin: 5px 0;">Replace the mushroom power-up sprite (recommended: 38x38px PNG with transparent background)</p>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="file" id="mushroomSprite" accept="image/*" onchange="loadAsset('mushroom', this)">
                    <button onclick="clearAsset('mushroom')" style="background: #FF4444; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>
                <div class="preview" id="mushroomPreview"></div>
            </div>
            <div class="asset-controls">
                <button onclick="resetToDefault()" class="reset-btn">Reset to Default</button>
                <button onclick="exportAssetConfig()" class="export-btn">Export Config</button>
                <button onclick="importAssetConfig()" class="import-btn">Import Config</button>
            </div>
        </div>
    </div>
    


    <script>
        // OtterfulWallet Integration - Define this first!
        class OtterfulWallet {
            constructor() {
                this.provider = null;
                this.account = null;
                this.isConnected = false;
                this.contractAddress = '0x4e5913922b7ddf916c8d27d1016827f799687e66';
                this.apeChainId = '0x8173'; // 33139 in hex
                this.userNFTs = [];
                this.stakedNFTs = [];
                this.fishCoins = 0;
                this.stakingStartTimes = {};
                
                // Updated trait multipliers based on your actual NFT attributes
                this.traitMultipliers = {
                    // Hat traits (most valuable)
                    'Hat-Stealth-v2': 2.5,
                    'Hat-Plumber-v5': 3.0,
                    'Hat-Plumber-v3': 2.5,
                    'Hat-Plumber-v4': 2.2,
                    'Hat-Plumber-v2': 2.0,
                    'Hat-Plumber': 1.8,
                    'Hat-Pirate': 2.0,
                    'Hat-Crown': 1.8,
                    'Hat-Wizard': 1.5,
                    'Hat-Baseball': 1.2,
                    'Hat-Beanie': 1.1,
                    
                    // Shirt/Overalls traits
                    'Shirt-Overalls-Orange': 1.6,
                    'Shirt-Overalls-Blue': 1.5,
                    'Shirt-Overalls-V2': 2.2,
                    'Shirt-Overalls-V3': 2.8,
                    
                    // Fur color traits
                    'Fur-Golden': 1.5,
                    'Fur-Rainbow': 1.3,
                    'Fur-Green': 1.2,
                    'Fur-Blue': 1.1,
                    
                    // Eye traits
                    'Eyes-Laser': 1.4,
                    'Eyes-Yellow-Scanner': 1.3,
                    'Eyes-Diamond': 1.3,
                    'Eyes-Sunglasses': 1.2,
                    
                    // Base traits
                    'Base-Stealth': 1.4,
                    'Base-Normal': 1.0
                };

                this.gamePerks = {
                    // Hat perks
                    'Hat-Stealth-v2': { type: 'stealth', value: 1.0, description: 'Invisible to enemies for 3 seconds' },
                    'Hat-Plumber-v5': { type: 'master', value: 1.0, description: 'Ultra Rare! All plumber abilities + 3x build speed' },
                    'Hat-Plumber-v3': { type: 'damage', value: 2.0, description: 'Pipe burst! Double damage output' },
                    'Hat-Plumber-v4': { type: 'speed', value: 1.8, description: 'Pipe rush! +80% movement speed' },
                    'Hat-Plumber-v2': { type: 'luck', value: 1.6, description: 'Pipe finder! +60% rare item discovery' },
                    'Hat-Plumber': { type: 'points', value: 1.5, description: 'Coin collector! +50% score multiplier' },
                    'Hat-Pirate': { type: 'speed', value: 1.5, description: '50% faster movement' },
                    'Hat-Crown': { type: 'points', value: 2.0, description: 'Double points scoring' },
                    'Hat-Wizard': { type: 'magic', value: 1.0, description: 'Unlock magic abilities' },
                    
                    // Shirt perks
                    'Shirt-Overalls-Orange': { type: 'construction', value: 1.0, description: 'Build temporary platforms' },
                    'Shirt-Overalls-V2': { type: 'construction', value: 1.0, description: 'Build platforms! Create temporary bridges' },
                    'Shirt-Overalls-V3': { type: 'master', value: 1.0, description: 'Master builder! All construction abilities + double build speed' },
                    
                    // Eye perks
                    'Eyes-Laser': { type: 'damage', value: 1.4, description: '40% more damage' },
                    'Eyes-Yellow-Scanner': { type: 'detection', value: 1.0, description: 'See hidden items and enemies' },
                    'Eyes-Diamond': { type: 'defense', value: 0.8, description: '20% damage reduction' },
                    'Eyes-Sunglasses': { type: 'cool', value: 1.0, description: 'Immunity to flash effects' },
                    
                    // Fur perks
                    'Fur-Golden': { type: 'luck', value: 1.3, description: '30% better item drops' },
                    'Fur-Rainbow': { type: 'rainbow', value: 1.0, description: 'Random ability every 30 seconds' },
                    
                    // Base perks
                    'Base-Stealth': { type: 'stealth', value: 0.7, description: 'Slightly harder for enemies to detect' }
                };
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.checkConnection();
                this.startStakingRewardsTimer();
            }

            setupEventListeners() {
                // Connect wallet button from title screen
                const connectWalletBtn = document.getElementById('connectWalletBtn');
                if (connectWalletBtn) {
                    connectWalletBtn.addEventListener('click', () => {
                        if (this.isConnected) {
                            this.disconnect();
                        } else {
                            this.connect();
                        }
                    });
                }

                // Wallet event listeners
                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', (accounts) => {
                        if (accounts.length === 0) {
                            this.disconnect();
                        } else {
                            this.account = accounts[0];
                            this.updateUI();
                            this.loadNFTs();
                        }
                    });

                    window.ethereum.on('chainChanged', (chainId) => {
                        this.updateUI();
                        if (chainId === this.apeChainId) {
                            this.loadNFTs();
                        }
                    });
                }
            }

            async checkConnection() {
                if (window.ethereum) {
                    try {
                        const accounts = await window.ethereum.request({
                            method: 'eth_accounts'
                        });
                        
                        if (accounts.length > 0) {
                            this.account = accounts[0];
                            this.provider = window.ethereum;
                            this.isConnected = true;
                            this.updateUI();
                            
                            const chainId = await window.ethereum.request({
                                method: 'eth_chainId'
                            });
                            
                            if (chainId === this.apeChainId) {
                                this.loadNFTs();
                            }
                        }
                    } catch (error) {
                        console.error('Error checking connection:', error);
                    }
                }
            }

            async connect() {
                console.log('🚀 connect() called');
                const connectWalletBtn = document.getElementById('connectWalletBtn');
                
                if (!window.ethereum) {
                    console.log('❌ No ethereum provider found');
                    this.showMessage('Please install MetaMask or another Web3 wallet!', 'error');
                    throw new Error('No ethereum provider found');
                }

                try {
                    console.log('🔗 Requesting accounts...');
                    if (connectWalletBtn) {
                        connectWalletBtn.innerHTML = '<span style="position: relative; z-index: 2;">🔄 Connecting...</span>';
                        connectWalletBtn.disabled = true;
                    }

                    const accounts = await window.ethereum.request({
                        method: 'eth_requestAccounts'
                    });

                    console.log('👤 Accounts received:', accounts);
                    this.account = accounts[0];
                    this.provider = window.ethereum;
                    this.isConnected = true;
                    
                    console.log('✅ Wallet connected successfully');
                    console.log('👤 Account:', this.account);
                    console.log('🔗 Provider:', this.provider);
                    console.log('🔗 isConnected:', this.isConnected);

                    console.log('🔄 Switching to ApeChain...');
                    await this.switchToApeChain();

                    console.log('🔄 Updating UI...');
                    this.updateUI();
                    console.log('🔄 Loading NFTs...');
                    await this.loadNFTs();
                    this.showMessage('Successfully connected to ApeChain!', 'success');

                } catch (error) {
                    console.error('❌ Connection failed:', error);
                    this.showMessage(`Connection failed: ${error.message}`, 'error');
                    throw error; // Re-throw the error so callers can catch it
                } finally {
                    if (connectWalletBtn) {
                        connectWalletBtn.disabled = false;
                    }
                }
            }

            async switchToApeChain() {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: this.apeChainId }],
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: this.apeChainId,
                                    chainName: 'ApeChain',
                                    nativeCurrency: {
                                        name: 'ApeCoin',
                                        symbol: 'APE',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://apechain.calderachain.xyz/http'],
                                    blockExplorerUrls: ['https://apechain.calderachain.xyz']
                                }]
                            });
                        } catch (addError) {
                            throw new Error('Failed to add ApeChain network');
                        }
                    } else {
                        throw switchError;
                    }
                }
            }

            async loadNFTs() {
                console.log('🚀 loadNFTs() called');
                console.log('🔗 isConnected:', this.isConnected);
                console.log('🔗 provider:', this.provider);
                console.log('👤 account:', this.account);
                
                if (!this.isConnected || !this.provider) {
                    console.log('❌ Not connected or no provider, returning');
                    return;
                }

                try {
                    console.log('🔗 Requesting chain ID...');
                    const chainId = await window.ethereum.request({
                        method: 'eth_chainId'
                    });

                    console.log('🔗 Current chain ID:', chainId);
                    console.log('🎯 Expected chain ID:', this.apeChainId);

                    if (chainId !== this.apeChainId) {
                        console.log('⚠️ Wrong chain, switching to ApeChain...');
                        await this.switchToApeChain();
                        return;
                    }

                    console.log('✅ On correct chain, checking balance...');
                    const balance = await this.getTokenBalance();
                    console.log('💰 Token balance:', balance);
                    
                    if (balance > 0) {
                        console.log('🦦 Loading NFT metadata...');
                        await this.loadUserNFTsWithMetadata(balance);
                    } else {
                        console.log('⚠️ No tokens found, loading sample data for testing...');
                        // Load sample data for testing
                        this.loadSampleNFTs(4); // Show 4 sample NFTs
                    }

                    this.updateUI();

                } catch (error) {
                    console.error('❌ Error loading NFTs:', error);
                    console.log('🔄 Loading sample data as fallback...');
                    this.loadSampleNFTs(4); // Load sample data on error
                    this.showMessage(`Error loading NFTs: ${error.message}`, 'error');
                }
            }

            async getTokenBalance() {
                try {
                    console.log('💰 Getting token balance for address:', this.account);
                    const data = '0x70a08231' + this.account.slice(2).padStart(64, '0');
                    console.log('📋 BalanceOf call data:', data);
                    
                    const result = await window.ethereum.request({
                        method: 'eth_call',
                        params: [{
                            to: this.contractAddress,
                            data: data
                        }, 'latest']
                    });

                    console.log('📄 BalanceOf result:', result);
                    const balance = parseInt(result, 16);
                    console.log('💰 Parsed balance:', balance);
                    return balance;
                } catch (error) {
                    console.error('❌ Error getting token balance:', error);
                    throw error;
                }
            }

            async loadUserNFTsWithMetadata(balance) {
                this.userNFTs = [];
                
                try {
                    // Get all token IDs owned by this address
                    const tokenIds = await this.getOwnedTokenIds();
                    console.log('🔍 Found token IDs:', tokenIds);
                    
                    // Load metadata for each token
                    for (const tokenId of tokenIds) {
                        try {
                            const metadata = await this.getTokenMetadata(tokenId);
                            console.log(`📄 Token ${tokenId} metadata:`, metadata);
                            
                            if (metadata && metadata.attributes) {
                                // Extract traits from metadata attributes - FIXED FORMAT
                                const traits = metadata.attributes.map(attr => {
                                    // Create proper trait format: "TraitType-Value" or just "Value" for single values
                                    if (attr.trait_type && attr.value) {
                                        return `${attr.trait_type}-${attr.value}`;
                                    } else if (attr.value) {
                                        return attr.value;
                                    } else {
                                        return attr.trait_type;
                                    }
                                }).filter(trait => trait);
                                
                                console.log(`🎨 Extracted traits for token ${tokenId}:`, traits);
                                
                                this.userNFTs.push({
                                    tokenId: tokenId,
                                    name: metadata.name || `Otter #${tokenId}`,
                                    traits: traits,
                                    multiplier: this.calculateMultiplier(traits),
                                    perks: this.calculatePerks(traits),
                                    rarity: this.calculateRarity(traits),
                                    image: metadata.image,
                                    description: metadata.description
                                });
                            } else if (metadata) {
                                // Metadata exists but no attributes - create basic NFT
                                console.log(`📄 Metadata without attributes for token ${tokenId}:`, metadata);
                                this.userNFTs.push({
                                    tokenId: tokenId,
                                    name: metadata.name || `Otter #${tokenId}`,
                                    traits: ['Base Otter'],
                                    multiplier: 1.0,
                                    perks: [],
                                    rarity: 'common',
                                    image: metadata.image,
                                    description: metadata.description || 'Otterful Otter NFT'
                                });
                            } else {
                                // Fallback for NFTs without metadata
                                console.log(`⚠️ No metadata for token ${tokenId}, creating basic NFT`);
                                this.userNFTs.push({
                                    tokenId: tokenId,
                                    name: `Otter #${tokenId}`,
                                    traits: ['Base Otter'],
                                    multiplier: 1.0,
                                    perks: [],
                                    rarity: 'common',
                                    image: null,
                                    description: 'Otterful Otter NFT'
                                });
                            }
                        } catch (error) {
                            console.warn(`⚠️ Error loading metadata for token ${tokenId}:`, error);
                            // Add basic NFT info even if metadata fails
                            this.userNFTs.push({
                                tokenId: tokenId,
                                name: `Otter #${tokenId}`,
                                traits: ['Base Otter'],
                                multiplier: 1.0,
                                perks: [],
                                rarity: 'common',
                                image: null,
                                description: 'Otterful Otter NFT'
                            });
                        }
                    }
                    
                    console.log('🦦 Loaded NFTs:', this.userNFTs);
                } catch (error) {
                    console.error('❌ Error loading NFT metadata:', error);
                    // Fallback to sample data if blockchain reading fails
                    this.loadSampleNFTs(balance);
                }
            }
            
            async getOwnedTokenIds() {
                const tokenIds = [];
                
                console.log('🔍 Starting to scan for owned tokens...');
                console.log('📋 Contract address:', this.contractAddress);
                console.log('👤 User address:', this.account);
                
                // Get all token IDs owned by this address
                // Scan all 2222 Otterful Otters
                let errorCount = 0;
                const TOTAL_OTTERS = 2222; // Total supply of Otterful Otters
                console.log(`🔍 Scanning all ${TOTAL_OTTERS} Otterful Otters for owned tokens...`);
                
                for (let i = 0; i < TOTAL_OTTERS; i++) {
                    try {
                        const owner = await this.getTokenOwner(i);
                        if (owner && owner.toLowerCase() === this.account.toLowerCase()) {
                            console.log(`✅ Found owned token: ${i}`);
                            tokenIds.push(i);
                        }
                        
                        // Show progress every 100 tokens
                        if (i % 100 === 0) {
                            console.log(`📊 Scan progress: ${i}/${TOTAL_OTTERS} (${Math.round(i/TOTAL_OTTERS*100)}%)`);
                        }
                    } catch (error) {
                        console.log(`❌ Error checking token ${i}:`, error.message);
                        errorCount++;
                        // Stop after 10 consecutive errors to avoid infinite loop
                        if (errorCount > 10) {
                            console.log('⚠️ Too many errors, stopping scan');
                            break;
                        }
                    }
                    
                    // Reset error count if we found a token
                    if (tokenIds.length > errorCount) {
                        errorCount = 0;
                    }
                }
                
                console.log('📊 Total owned tokens found:', tokenIds);
                return tokenIds;
            }
            
            async getTokenOwner(tokenId) {
                try {
                    const data = '0x6352211e' + tokenId.toString().padStart(64, '0');
                    console.log(`🔍 Calling ownerOf for token ${tokenId} with data:`, data);
                    
                    const result = await window.ethereum.request({
                        method: 'eth_call',
                        params: [{
                            to: this.contractAddress,
                            data: data
                        }, 'latest']
                    });
                    
                    console.log(`📄 Raw result for token ${tokenId}:`, result);
                    
                    if (result && result !== '0x' && result.length >= 26) {
                        const owner = '0x' + result.slice(26); // Remove padding and return address
                        console.log(`👤 Token ${tokenId} owner:`, owner);
                        return owner;
                    } else {
                        console.log(`⚠️ Invalid result for token ${tokenId}:`, result);
                        throw new Error('Invalid result from contract');
                    }
                } catch (error) {
                    console.error(`❌ Error getting owner for token ${tokenId}:`, error);
                    // Return null instead of throwing to continue scanning
                    return null;
                }
            }
            
            async getTokenMetadata(tokenId) {
                try {
                    // First get the token URI
                    const tokenURI = await this.getTokenURI(tokenId);
                    console.log(`🔗 Token ${tokenId} URI:`, tokenURI);
                    
                    if (!tokenURI) {
                        console.log(`⚠️ No URI found for token ${tokenId}, creating basic NFT`);
                        return {
                            name: `Otter #${tokenId}`,
                            description: 'Base Otterful Otter',
                            attributes: [
                                { trait_type: 'Type', value: 'Base Otter' }
                            ]
                        };
                    }
                    
                    if (tokenURI && tokenURI.startsWith('http')) {
                        console.log(`🌐 Fetching metadata from: ${tokenURI}`);
                        
                        // Try multiple approaches to handle CORS issues
                        let metadata = null;
                        
                        // Approach 1: Direct fetch
                        try {
                            const response = await fetch(tokenURI);
                            console.log(`📄 Response status:`, response.status);
                            
                            if (response.ok) {
                                metadata = await response.json();
                                console.log(`📄 Parsed metadata for token ${tokenId}:`, metadata);
                                return metadata;
                            } else {
                                console.warn(`⚠️ HTTP error ${response.status} for token ${tokenId}`);
                            }
                        } catch (error) {
                            console.warn(`⚠️ Direct fetch failed for token ${tokenId}:`, error);
                        }
                        
                        // Approach 2: Try CORS proxy
                        if (!metadata) {
                            try {
                                console.log(`🔄 Trying CORS proxy for token ${tokenId}...`);
                                const proxyURL = `https://cors-anywhere.herokuapp.com/${tokenURI}`;
                                const response = await fetch(proxyURL);
                                
                                if (response.ok) {
                                    metadata = await response.json();
                                    console.log(`📄 Proxy metadata for token ${tokenId}:`, metadata);
                                    return metadata;
                                }
                            } catch (error) {
                                console.warn(`⚠️ CORS proxy failed for token ${tokenId}:`, error);
                            }
                        }
                        
                        // Approach 3: Try alternative proxy
                        if (!metadata) {
                            try {
                                console.log(`🔄 Trying alternative proxy for token ${tokenId}...`);
                                const proxyURL = `https://api.allorigins.win/raw?url=${encodeURIComponent(tokenURI)}`;
                                const response = await fetch(proxyURL);
                                
                                if (response.ok) {
                                    metadata = await response.json();
                                    console.log(`📄 Alternative proxy metadata for token ${tokenId}:`, metadata);
                                    return metadata;
                                }
                            } catch (error) {
                                console.warn(`⚠️ Alternative proxy failed for token ${tokenId}:`, error);
                            }
                        }
                        
                    } else if (tokenURI && tokenURI.startsWith('ipfs://')) {
                        console.log(`🌐 Converting IPFS URI: ${tokenURI}`);
                        const ipfsGateway = 'https://ipfs.io/ipfs/';
                        const ipfsHash = tokenURI.replace('ipfs://', '');
                        const httpURI = ipfsGateway + ipfsHash;
                        console.log(`🌐 Converting IPFS to HTTP: ${httpURI}`);
                        
                        const response = await fetch(httpURI);
                        if (response.ok) {
                            const metadata = await response.json();
                            console.log(`📄 IPFS metadata for token ${tokenId}:`, metadata);
                            return metadata;
                        }
                    } else {
                        console.warn(`⚠️ Invalid URI format for token ${tokenId}:`, tokenURI);
                    }
                    
                    // If all else fails, create a basic NFT
                    console.log(`📄 Creating basic NFT for token ${tokenId}`);
                    return {
                        name: `Otter #${tokenId}`,
                        description: 'Base Otterful Otter',
                        attributes: [
                            { trait_type: 'Type', value: 'Base Otter' }
                        ]
                    };
                } catch (error) {
                    console.warn(`⚠️ Error getting metadata for token ${tokenId}:`, error);
                    // Return basic NFT on error
                    return {
                        name: `Otter #${tokenId}`,
                        description: 'Base Otterful Otter',
                        attributes: [
                            { trait_type: 'Type', value: 'Base Otter' }
                        ]
                    };
                }
            }
            
            async getTokenURI(tokenId) {
                try {
                    console.log(`🔗 Getting token URI for token ${tokenId}...`);
                    const data = '0xc87b56dd' + tokenId.toString().padStart(64, '0');
                    console.log(`📋 TokenURI call data:`, data);
                    
                    const result = await window.ethereum.request({
                        method: 'eth_call',
                        params: [{
                            to: this.contractAddress,
                            data: data
                        }, 'latest']
                    });
                    
                    console.log(`📄 TokenURI result for token ${tokenId}:`, result);
                    
                    // Decode the URI from the result
                    if (result && result !== '0x') {
                        // This is a simplified decoder - you might need a proper ABI decoder
                        const uri = this.decodeString(result);
                        console.log(`🔗 Decoded URI for token ${tokenId}:`, uri);
                        return uri;
                    } else {
                        console.log(`⚠️ No URI found for token ${tokenId}`);
                        return null;
                    }
                } catch (error) {
                    console.error(`❌ Error getting token URI for token ${tokenId}:`, error);
                    return null;
                }
            }
            
            decodeString(hexString) {
                try {
                    const hex = hexString.slice(2);
                    
                    // Try ABI string decoding first
                    if (hex.length >= 128) {
                        const lengthHex = hex.slice(64, 128);
                        const length = parseInt(lengthHex, 16);
                        
                        if (length > 0 && length < 1000) {
                            const dataHex = hex.slice(128, 128 + (length * 2));
                            let str = '';
                            for (let i = 0; i < dataHex.length; i += 2) {
                                const byte = parseInt(dataHex.substr(i, 2), 16);
                                if (byte !== 0) str += String.fromCharCode(byte);
                            }
                            console.log('🔍 ABI decoded string:', str);
                            return str.trim();
                        }
                    }
                    
                    // Fallback to simple conversion
                    let str = '';
                    for (let i = 0; i < hex.length; i += 2) {
                        const charCode = parseInt(hex.substr(i, 2), 16);
                        if (charCode === 0) break;
                        if (charCode >= 32 && charCode <= 126) {
                            str += String.fromCharCode(charCode);
                        }
                    }
                    console.log('🔍 Simple decoded string:', str);
                    return str.trim();
                } catch (error) {
                    console.warn('Error decoding string:', error);
                    return null;
                }
            }
            
            loadSampleNFTs(balance) {
                console.log('🔄 Loading sample NFTs as fallback...');
                
                // Sample traits based on your actual NFT format
                const sampleTraitCombos = [
                    ['Hat-Stealth-v2', 'Fur-Green', 'Shirt-Overalls-Orange', 'Eyes-Yellow-Scanner', 'Base-Stealth'],
                    ['Hat-Plumber-v5', 'Fur-Golden', 'Shirt-Overalls-V3'],
                    ['Hat-Plumber-v3', 'Fur-Rainbow', 'Eyes-Laser'],
                    ['Hat-Pirate', 'Fur-Golden', 'Eyes-Diamond'],
                    ['Hat-Crown', 'Fur-Rainbow', 'Shirt-Overalls-V2'],
                    ['Hat-Wizard', 'Eyes-Yellow-Scanner', 'Base-Stealth'],
                    ['Fur-Green', 'Eyes-Sunglasses', 'Shirt-Overalls-Orange'],
                    ['Base-Normal']
                ];

                for (let i = 0; i < Math.min(balance, 16); i++) {
                    const traits = sampleTraitCombos[i % sampleTraitCombos.length];
                    this.userNFTs.push({
                        tokenId: i + 1,
                        name: `Otter #${i + 1}`,
                        traits: traits,
                        multiplier: this.calculateMultiplier(traits),
                        perks: this.calculatePerks(traits),
                        rarity: this.calculateRarity(traits)
                    });
                }
            }

            calculateRarity(traits) {
                // Check for legendary traits
                if (traits.some(trait => 
                    trait.includes('Hat-Plumber-v5') || 
                    trait.includes('Hat-Stealth-v2') ||
                    trait.includes('Shirt-Overalls-V3')
                )) return 'legendary';
                
                // Check for epic traits
                if (traits.some(trait => 
                    trait.includes('Hat-Plumber-v3') || 
                    trait.includes('Fur-Golden')
                )) return 'epic';
                
                // Check for rare traits
                if (traits.some(trait => 
                    trait.includes('Hat-') || 
                    trait.includes('Eyes-Laser') ||
                    trait.includes('Base-Stealth')
                )) return 'rare';
                
                return 'common';
            }

            calculateMultiplier(traits) {
                let multiplier = 1.0;
                traits.forEach(trait => {
                    if (this.traitMultipliers[trait]) {
                        multiplier *= this.traitMultipliers[trait];
                    }
                });
                return Math.round(multiplier * 100) / 100;
            }

            calculatePerks(traits) {
                const perks = [];
                traits.forEach(trait => {
                    if (this.gamePerks[trait]) {
                        perks.push(this.gamePerks[trait]);
                    }
                });
                return perks;
            }

            startStakingRewardsTimer() {
                setInterval(() => {
                    if (this.stakedNFTs.length > 0) {
                        this.updateStakingStats();
                        
                        // Calculate and show fish earnings
                        let totalEarned = 0;
                        this.stakedNFTs.forEach(nft => {
                            const stakingTime = Date.now() - this.stakingStartTimes[nft.tokenId];
                            const hoursStaked = stakingTime / (1000 * 60 * 60);
                            totalEarned += Math.floor(hoursStaked * nft.multiplier * 10 / 24);
                        });
                        
                        if (totalEarned > 0) {
                            this.showFishEarnings(totalEarned);
                        }
                    }
                }, 30000); // Update every 30 seconds
            }

            updateStakingStats() {
                let totalEarned = this.fishCoins;
                let avgMultiplier = 1.0;

                if (this.stakedNFTs.length > 0) {
                    const totalMultiplier = this.stakedNFTs.reduce((sum, nft) => sum + nft.multiplier, 0);
                    avgMultiplier = totalMultiplier / this.stakedNFTs.length;
                    
                    // Add pending rewards
                    this.stakedNFTs.forEach(nft => {
                        const stakingTime = Date.now() - this.stakingStartTimes[nft.tokenId];
                        const hoursStaked = stakingTime / (1000 * 60 * 60);
                        totalEarned += Math.floor(hoursStaked * nft.multiplier * 10 / 24);
                    });
                }

                // Update UI elements
                const stakedCountEl = document.getElementById('stakedCount');
                const fishEarnedEl = document.getElementById('fishEarned');
                const stakingRateEl = document.getElementById('stakingRate');
                
                if (stakedCountEl) stakedCountEl.textContent = this.stakedNFTs.length;
                if (fishEarnedEl) fishEarnedEl.textContent = Math.floor(totalEarned);
                if (stakingRateEl) stakingRateEl.textContent = `${Math.round(avgMultiplier * 10)}/day`;
            }

            showFishEarnings(amount) {
                const fishEarningsEl = document.getElementById('fishEarnings');
                const fishEarningsAmountEl = document.getElementById('fishEarningsAmount');
                
                if (fishEarningsEl && fishEarningsAmountEl) {
                    fishEarningsAmountEl.textContent = amount;
                    fishEarningsEl.classList.add('show');
                    
                    setTimeout(() => {
                        fishEarningsEl.classList.remove('show');
                    }, 3000);
                }
            }

            disconnect() {
                this.provider = null;
                this.account = null;
                this.isConnected = false;
                this.userNFTs = [];
                this.stakedNFTs = [];
                this.fishCoins = 0;
                this.stakingStartTimes = {};
                this.updateUI();
                this.showMessage('Wallet disconnected', 'success');
            }

            updateUI() {
                const connectWalletBtn = document.getElementById('connectWalletBtn');
                const walletInfo = document.getElementById('walletInfo');
                const walletAddress = document.getElementById('walletAddress');

                if (this.isConnected) {
                    if (connectWalletBtn) {
                        connectWalletBtn.innerHTML = '<span style="position: relative; z-index: 2;">✅ Connected</span>';
                        connectWalletBtn.classList.add('connected');
                    }
                    
                    if (walletInfo) {
                        walletInfo.classList.add('show');
                    }
                    
                    if (walletAddress) {
                        walletAddress.textContent = `${this.account.slice(0, 6)}...${this.account.slice(-4)}`;
                    }
                    
                    this.updateStakingStats();
                } else {
                    if (connectWalletBtn) {
                        connectWalletBtn.innerHTML = '<span style="position: relative; z-index: 2;">🔗 Connect Wallet</span>';
                        connectWalletBtn.classList.remove('connected');
                    }
                    
                    if (walletInfo) {
                        walletInfo.classList.remove('show');
                    }
                }
            }

            showMessage(text, type = 'info') {
                console.log(`${type.toUpperCase()}: ${text}`);
                // You can add a notification system here
            }

            // Game integration methods
            getActiveTraits() {
                const activeTraits = new Set();
                [...this.userNFTs, ...this.stakedNFTs].forEach(nft => {
                    nft.traits.forEach(trait => {
                        if (trait && trait !== 'Base-Normal') {
                            activeTraits.add(trait);
                        }
                    });
                });
                return Array.from(activeTraits);
            }

            getGameMultipliers() {
                const multipliers = {
                    speed: 1.0,
                    points: 1.0,
                    damage: 1.0,
                    defense: 1.0,
                    luck: 1.0
                };

                this.getActiveTraits().forEach(trait => {
                    const perk = this.gamePerks[trait];
                    if (perk) {
                        if (perk.type === 'defense') {
                            multipliers[perk.type] *= perk.value; // Defense is damage reduction
                        } else {
                            multipliers[perk.type] *= perk.value;
                        }
                    }
                });

                return multipliers;
            }

            hasSpecialAbilities() {
                return this.getActiveTraits().some(trait => 
                    ['Hat-Wizard', 'Eyes-Laser', 'Hat-Pirate'].includes(trait)
                );
            }

            getStakingBonus() {
                return {
                    fishPerSecond: this.stakedNFTs.reduce((total, nft) => 
                        total + (nft.multiplier * 10 / (24 * 60 * 60)), 0),
                    totalStaked: this.stakedNFTs.length,
                    totalFish: this.fishCoins
                };
            }

            // Auto-stake all NFTs for demo purposes
            autoStakeAll() {
                this.userNFTs.forEach(nft => {
                    if (!this.stakedNFTs.some(staked => staked.tokenId === nft.tokenId)) {
                        this.stakedNFTs.push(nft);
                        this.stakingStartTimes[nft.tokenId] = Date.now();
                    }
                });
                this.updateUI();
                this.showMessage('All otters auto-staked for demo!', 'success');
            }
        }

        // Initialize the wallet integration immediately
        let otterWallet;
        try {
            otterWallet = new OtterfulWallet();
            console.log('🔗 OtterfulWallet initialized successfully');
        } catch (error) {
            console.error('❌ Failed to initialize OtterfulWallet:', error);
            otterWallet = null;
        }

        console.log('🎮 Game script starting...');
        
        const canvas = document.getElementById('gameCanvas');
        if (!canvas) {
            console.error('❌ Canvas element not found!');
            alert('Canvas element not found!');
            throw new Error('Canvas element not found');
        }
        
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            console.error('❌ Canvas context not available!');
            alert('Canvas context not available!');
            throw new Error('Canvas context not available');
        }
        
        console.log('✅ Canvas initialized successfully');
        
        // Global variables
        let aiOwlBotEnabled = true;
        
        // Responsive canvas setup
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerRect = container.getBoundingClientRect();
            
            // Set canvas size to container size with fallback
            let newWidth = containerRect.width - 20; // Account for padding
            let newHeight = containerRect.height - 20; // Account for padding
            
            // Ensure minimum dimensions
            if (newWidth < 400) newWidth = 400;
            if (newHeight < 300) newHeight = 300;
            
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // Calculate scale factors
            const baseWidth = 1920;
            const baseHeight = 1080;
            const scaleX = canvas.width / baseWidth;
            const scaleY = canvas.height / baseHeight;
            const scale = Math.min(scaleX, scaleY);
            
            // Store scale for use in game logic
            game.scale = scale;
            game.canvasWidth = canvas.width;
            game.canvasHeight = canvas.height;
        }
        
        // Initial resize with delay to ensure DOM is ready
        setTimeout(resizeCanvas, 100);
        
        // Resize on window resize
        window.addEventListener('resize', resizeCanvas);
        
        // Game state
        const game = {
            score: 0,
            lives: 3,
            level: 1,
            gameState: 'menu', // 'menu', 'playing', 'paused'
            camera: { x: 0, y: 0 },
            keys: {},
            gameOver: false,
            levelComplete: false,
            levelTransition: false,
            coins: 0,
            keyCount: 0,
            maxLives: 99, // Increased max lives to 99
            lastLifeScore: 0,
            jumpPressed: false,
            selectedOtter: 'otter1', // Default selected otter
            secretChestsSpawned: false, // Track if secret chests have been spawned
            secretChestConditions: {
                coinsCollected: 0,
                treasuresCollected: 0,
                keysCollected: 0
            },
            // AI Bot system
            aiBot: {
                x: 0,
                y: 0,
                width: 60,
                height: 60,
                offsetX: -80, // Position behind the player
                offsetY: 0,
                currentTip: '',
                tipTimer: 0,
                tipDuration: 5000, // 5 seconds per tip
                lastTipTime: 0,
                tipCooldown: 12000, // 12 seconds between tips (increased for better performance)
                isVisible: true,
                bobOffset: 0,
                bobSpeed: 0.02,
                glowIntensity: 0,
                lookDirection: 1, // Track owl's looking direction
                lookDelay: 0, // Delay for natural head turning
                currentHat: 'none' // Current hat equipped
            },
            
            // Marketplace system
            marketplace: {
                coins: 0,
                ownedHats: ['none'],
                ownedSkins: ['default'],
                ownedAbilities: [],
                currentSkin: 'default',
                currentHat: 'none',
                currentAbilities: []
            },
            
            // Profile system
            profile: {
                playerName: 'Otter Player',
                level: 1,
                experience: 0,
                achievements: [],
                recentAchievements: ['🎉 Welcome to Otter Bros!'],
                playTime: 0,
                gamesPlayed: 0,
                bestScore: 0,
                favoriteLevel: 1
            },
            // Mouse tracking for laser aiming
            mouseX: 0,
            mouseY: 0,
            // Laser cycling system
            laserCycleIndex: 0,
            laserCycleTimer: 0,
            laserCycleSpeed: 200, // Change every 200ms
            // Responsive scaling
            scale: 1,
            canvasWidth: 1920,
            canvasHeight: 1080,
            // Leaderboard tracking
            sessionStats: {
                // Cumulative stats (total across all sessions)
                totalScore: 0,
                levelsCompleted: 0,
                totalCoins: 0,
                crabsDefeated: 0,
                eaglesDefeated: 0,
                gatorsDefeated: 0,
                sharksDefeated: 0,
                bossesDefeated: 0,
                fishCollected: 0,
                healthCollected: 0,
                treasuresCollected: 0,
                mushroomsCollected: 0,
                keysCollected: 0,
                treasuresFound: 0,
                healthPickups: 0,
                mushroomsEaten: 0,
                levelTimes: [],
                levelStartTime: Date.now(),
                // Highest scores (best single session)
                highestScore: 0,
                highestLevels: 0,
                highestCoins: 0,
                highestCrabs: 0,
                highestFish: 0,
                highestHealth: 0,
                highestTreasures: 0,
                highestMushrooms: 0,
                // Current session tracking
                currentSessionScore: 0,
                currentSessionLevels: 0,
                currentSessionCoins: 0,
                currentSessionCrabs: 0,
                currentSessionBosses: 0,
                currentSessionFish: 0,
                currentSessionHealth: 0,
                currentSessionTreasures: 0,
                currentSessionMushrooms: 0
            },
            // Checkpoint system
            checkpoints: [],
            activeCheckpoint: null,
            checkpointProgress: {}, // Store checkpoint activation by level
            // Boss system
            currentBoss: null,
            bossActive: false,
            // Secret system
            secrets: [],
            secretRooms: [],
            // Environmental effects
            particles: [],
            screenShake: 0,
            freezeFrame: 0,
            // Water system
            waterLevel: 1400, // Water starts at 1400px from top
            waterDepth: 2000, // Water extends 2000px down
            deathBarrier: 2400, // Death barrier at 2400px (1400 + 1000)
            // Lava system for boss levels
            lavaLevel: 1400, // Lava starts at same level as water
            lavaDepth: 2000, // Lava extends same depth as water
            inLava: false,
            lavaSinkTime: 0,
            lavaSinkDuration: 1500, // 1.5 seconds to sink and die
            lavaBouncePower: 8, // Bounce up when touching lava
            lavaDamageInvulnerability: 2000, // 2 seconds of invulnerability after lava damage
            // Extra abilities


            // Story system
            storyMode: false,
            cutsceneActive: false,
            cutsceneText: '',
            cutsceneIndex: 0,
            typewriterInterval: null,
            
            // Real-time collectibles tracking
            collectiblesCount: {
                coinsCollected: 0,
                chestsCollected: 0,
                goldenChestsCollected: 0
            }
        };
        
        // 🔫 FORCE LASER ARRAY INITIALIZATION
        let laserPowerups = [];
        console.log('🔫 Global laserPowerups array initialized');
        
        // 🔥 FIREBALL ARRAY INITIALIZATION
        let fireballPowerups = [];
        let playerFireballs = [];
        console.log('🔥 Global fireball arrays initialized');
        
        // Achievements System
        const achievements = [
            // Basic Achievements (Easy) - 50 XP each
            { id: 'first_game', name: 'First Steps', description: 'Play your first game', icon: '🎮', unlocked: false, xpReward: 50 },
            { id: 'first_coin', name: 'Coin Collector', description: 'Collect your first coin', icon: '🪙', unlocked: false, xpReward: 50 },
            { id: 'first_level', name: 'Level Up!', description: 'Complete your first level', icon: '⭐', unlocked: false, xpReward: 50 },
            { id: 'first_enemy', name: 'Combat Ready', description: 'Defeat your first enemy', icon: '⚔️', unlocked: false, xpReward: 50 },
            { id: 'ten_coins', name: 'Rich Otter', description: 'Collect 10 coins in one game', icon: '💰', unlocked: false, xpReward: 50 },
            { id: 'five_levels', name: 'Adventure Seeker', description: 'Complete 5 levels', icon: '🗺️', unlocked: false, xpReward: 50 },
            { id: 'hundred_score', name: 'Score Master', description: 'Score 100 points in one game', icon: '🏆', unlocked: false, xpReward: 50 },
            { id: 'jetpack_user', name: 'Jetpack Jockey', description: 'Use a jetpack for the first time', icon: '🚁', unlocked: false, xpReward: 50 },
            { id: 'laser_user', name: 'Laser Expert', description: 'Use a laser for the first time', icon: '🔫', unlocked: false, xpReward: 50 },
            { id: 'mushroom_user', name: 'Giant Mode', description: 'Use a mushroom for the first time', icon: '🍄', unlocked: false, xpReward: 50 },
            { id: 'underwater_explorer', name: 'Deep Diver', description: 'Explore underwater areas', icon: '🌊', unlocked: false, xpReward: 50 },
            { id: 'boss_defeater', name: 'Boss Slayer', description: 'Defeat your first boss', icon: '👑', unlocked: false, xpReward: 50 },
            { id: 'marketplace_shopper', name: 'Fashion Forward', description: 'Buy your first item from the marketplace', icon: '🛒', unlocked: false, xpReward: 50 },
            { id: 'hat_collector', name: 'Hat Enthusiast', description: 'Own 3 different owl hats', icon: '🦉', unlocked: false, xpReward: 50 },
            { id: 'skin_collector', name: 'Style Master', description: 'Own 3 different otter skins', icon: '🦦', unlocked: false, xpReward: 50 },
            
            // Intermediate Achievements (Medium) - 100 XP each
            { id: 'fifty_coins', name: 'Coin Hoarder', description: 'Collect 50 coins in one game', icon: '💎', unlocked: false, xpReward: 100 },
            { id: 'ten_levels', name: 'Level Master', description: 'Complete 10 levels', icon: '🏔️', unlocked: false, xpReward: 100 },
            { id: 'complete_10_levels', name: 'Level Master', description: 'Complete 10 levels', icon: '🏔️', unlocked: false, xpReward: 100 },
            { id: 'thousand_score', name: 'High Scorer', description: 'Score 1,000 points in one game', icon: '🎯', unlocked: false, xpReward: 100 },
            { id: 'twenty_enemies', name: 'Enemy Hunter', description: 'Defeat 20 enemies in one game', icon: '🗡️', unlocked: false, xpReward: 100 },
            { id: 'five_bosses', name: 'Boss Hunter', description: 'Defeat 5 bosses', icon: '👑', unlocked: false, xpReward: 100 },
            { id: 'defeat_5_bosses', name: 'Boss Hunter', description: 'Defeat 5 bosses', icon: '👑', unlocked: false, xpReward: 100 },
            { id: 'all_hats', name: 'Hat Master', description: 'Own all owl hats', icon: '🎩', unlocked: false, xpReward: 100 },
            { id: 'all_skins', name: 'Skin Master', description: 'Own all otter skins', icon: '🎨', unlocked: false, xpReward: 100 },
            { id: 'speed_runner', name: 'Speed Runner', description: 'Complete a level in under 30 seconds', icon: '⚡', unlocked: false, xpReward: 100 },
            { id: 'no_damage', name: 'Untouchable', description: 'Complete a level without taking damage', icon: '🛡️', unlocked: false, xpReward: 100 },
            { id: 'collector', name: 'Collector', description: 'Collect 100 items in one game', icon: '📦', unlocked: false, xpReward: 100 },
            
            // Advanced Achievements (Hard) - 200 XP each
            { id: 'hundred_coins', name: 'Coin Millionaire', description: 'Collect 100 coins in one game', icon: '💎', unlocked: false, xpReward: 200 },
            { id: 'collect_100_coins', name: 'Coin Collector Master', description: 'Collect 100 coins total', icon: '💎', unlocked: false, xpReward: 200 },
            { id: 'twenty_levels', name: 'Level Legend', description: 'Complete 20 levels', icon: '🏆', unlocked: false, xpReward: 200 },
            { id: 'reach_level_20', name: 'Level 20 Master', description: 'Reach player level 20', icon: '🏆', unlocked: false, xpReward: 200 },
            { id: 'ten_thousand_score', name: 'Score Legend', description: 'Score 10,000 points in one game', icon: '🌟', unlocked: false, xpReward: 200 },
            { id: 'fifty_enemies', name: 'Enemy Slayer', description: 'Defeat 50 enemies in one game', icon: '⚔️', unlocked: false, xpReward: 200 },
            { id: 'defeat_50_enemies', name: 'Enemy Slayer', description: 'Defeat 50 enemies total', icon: '⚔️', unlocked: false, xpReward: 200 },
            { id: 'ten_bosses', name: 'Boss Legend', description: 'Defeat 10 bosses', icon: '👑', unlocked: false, xpReward: 200 },
            { id: 'perfect_run', name: 'Perfect Run', description: 'Complete a level with 100% items collected', icon: '💯', unlocked: false, xpReward: 200 },
            { id: 'no_jump', name: 'Ground Walker', description: 'Complete a level without jumping', icon: '🚶', unlocked: false, xpReward: 200 },
            { id: 'underwater_master', name: 'Underwater Master', description: 'Spend 5 minutes underwater in one game', icon: '🐠', unlocked: false, xpReward: 200 },
            { id: 'jetpack_master', name: 'Jetpack Master', description: 'Use jetpack for 3 minutes in one game', icon: '🚁', unlocked: false, xpReward: 200 },
            { id: 'laser_master', name: 'Laser Master', description: 'Defeat 10 enemies with laser in one game', icon: '🔫', unlocked: false, xpReward: 200 },
            
            // Expert Achievements (Very Hard) - 500 XP each
            { id: 'two_hundred_coins', name: 'Coin Billionaire', description: 'Collect 200 coins in one game', icon: '💎', unlocked: false, xpReward: 500 },
            { id: 'fifty_levels', name: 'Level God', description: 'Complete 50 levels', icon: '🏆', unlocked: false, xpReward: 500 },
            { id: 'hundred_thousand_score', name: 'Score God', description: 'Score 100,000 points in one game', icon: '🌟', unlocked: false, xpReward: 500 },
            { id: 'hundred_enemies', name: 'Enemy God', description: 'Defeat 100 enemies in one game', icon: '⚔️', unlocked: false, xpReward: 500 },
            { id: 'twenty_bosses', name: 'Boss God', description: 'Defeat 20 bosses', icon: '👑', unlocked: false, xpReward: 500 },
            { id: 'no_powerups', name: 'Pure Skill', description: 'Complete 5 levels without using any powerups', icon: '🎯', unlocked: false, xpReward: 500 },
            { id: 'speed_god', name: 'Speed God', description: 'Complete a level in under 15 seconds', icon: '⚡', unlocked: false, xpReward: 500 },
            { id: 'invincible', name: 'Invincible', description: 'Complete 3 levels without taking damage', icon: '🛡️', unlocked: false, xpReward: 500 },
            { id: 'master_collector', name: 'Master Collector', description: 'Collect 500 items in one game', icon: '📦', unlocked: false, xpReward: 500 },
            
            // New Gameplay Achievements - 150 XP each
            { id: 'fireball_master', name: 'Fireball Master', description: 'Hit 10 enemies with fireballs in one game', icon: '🔥', unlocked: false, xpReward: 150 },
            { id: 'underwater_explorer_master', name: 'Deep Sea Explorer', description: 'Spend 10 minutes underwater total', icon: '🌊', unlocked: false, xpReward: 150 },
            { id: 'jetpack_explorer', name: 'Sky Explorer', description: 'Use jetpack for 5 minutes total', icon: '🚁', unlocked: false, xpReward: 150 },
            { id: 'laser_expert', name: 'Laser Expert', description: 'Defeat 25 enemies with laser total', icon: '🔫', unlocked: false, xpReward: 150 },
            { id: 'treasure_hunter', name: 'Treasure Hunter', description: 'Collect 50 treasures total', icon: '💎', unlocked: false, xpReward: 150 },
            { id: 'health_master', name: 'Health Master', description: 'Collect 100 health pickups total', icon: '❤️', unlocked: false, xpReward: 150 },
            { id: 'mushroom_master', name: 'Mushroom Master', description: 'Eat 50 mushrooms total', icon: '🍄', unlocked: false, xpReward: 150 },
            { id: 'key_collector', name: 'Key Master', description: 'Collect 25 keys total', icon: '🗝️', unlocked: false, xpReward: 150 },
            { id: 'fish_collector', name: 'Fish Collector', description: 'Collect 100 fish total', icon: '🐟', unlocked: false, xpReward: 150 },
            { id: 'jump_master', name: 'Jump Master', description: 'Make 500 jumps total', icon: '🦘', unlocked: false, xpReward: 150 },
            
            // Hidden Achievements (Random/Secret) - 75 XP each
            { id: 'lucky_777', name: 'Lucky 777', description: 'Score exactly 777 points', icon: '🍀', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'collector_13', name: 'Unlucky Collector', description: 'Collect exactly 13 items', icon: '😱', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'enemy_666', name: 'Devil Hunter', description: 'Defeat exactly 666 enemies', icon: '😈', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'coin_42', name: 'Answer to Everything', description: 'Collect exactly 42 coins', icon: '🤖', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'level_69', name: 'Nice Level', description: 'Complete level 69', icon: '😏', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'random_master', name: 'Random Master', description: 'Unlock 5 hidden achievements', icon: '🎲', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'midnight_gamer', name: 'Midnight Gamer', description: 'Play at exactly midnight', icon: '🌙', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'early_bird', name: 'Early Bird', description: 'Play at exactly 6 AM', icon: '🌅', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'night_owl', name: 'Night Owl', description: 'Play for 2 hours straight', icon: '🦉', unlocked: false, hidden: true, xpReward: 75 },
            { id: 'weekend_warrior', name: 'Weekend Warrior', description: 'Play on a weekend', icon: '📅', unlocked: false, hidden: true, xpReward: 75 },
            
            // Special Event Achievements - 100 XP each
            { id: 'christmas_player', name: 'Christmas Player', description: 'Play during December', icon: '🎄', unlocked: false, hidden: true, xpReward: 100 },
            { id: 'halloween_player', name: 'Halloween Player', description: 'Play during October', icon: '🎃', unlocked: false, hidden: true, xpReward: 100 },
            { id: 'summer_player', name: 'Summer Player', description: 'Play during June-August', icon: '☀️', unlocked: false, hidden: true, xpReward: 100 },
            { id: 'spring_player', name: 'Spring Player', description: 'Play during March-May', icon: '🌸', unlocked: false, hidden: true, xpReward: 100 },
            
            // Ultra Rare Achievements (Extremely Hard) - 1000 XP each
            { id: 'million_score', name: 'Millionaire', description: 'Score 1,000,000 points in one game', icon: '💎', unlocked: false, xpReward: 1000 },
            { id: 'hundred_levels', name: 'Century Master', description: 'Complete 100 levels', icon: '🏆', unlocked: false, xpReward: 1000 },
            { id: 'thousand_enemies', name: 'Enemy Annihilator', description: 'Defeat 1,000 enemies', icon: '⚔️', unlocked: false, xpReward: 1000 },
            { id: 'fifty_bosses', name: 'Boss Annihilator', description: 'Defeat 50 bosses', icon: '👑', unlocked: false, xpReward: 1000 },
            { id: 'perfect_game', name: 'Perfect Game', description: 'Complete a game with 100% completion', icon: '💯', unlocked: false, xpReward: 1000 },
            { id: 'no_death_master', name: 'No Death Master', description: 'Complete 10 levels without dying', icon: '🛡️', unlocked: false, xpReward: 1000 },
            { id: 'speed_demon', name: 'Speed Demon', description: 'Complete a level in under 10 seconds', icon: '⚡', unlocked: false, xpReward: 1000 },
            { id: 'collector_god', name: 'Collector God', description: 'Collect 1,000 items in one game', icon: '📦', unlocked: false, xpReward: 1000 },
            { id: 'underwater_god', name: 'Underwater God', description: 'Spend 10 minutes underwater in one game', icon: '🐠', unlocked: false, xpReward: 1000 },
            { id: 'jetpack_god', name: 'Jetpack God', description: 'Use jetpack for 10 minutes in one game', icon: '🚁', unlocked: false, xpReward: 1000 }
        ];

        // Marketplace Items
        const marketplaceItems = {
                            hats: [
                    { id: 'none', name: 'No Hat', price: 0, description: 'Classic owl look', owned: true, equipped: true, image: 'public/owl.png' },
                    { id: 'party', name: 'Party Hat', price: 75, description: 'Celebration time!', owned: false, equipped: false, image: 'public/owl-hats/Party.png' },
                    { id: 'snow_plumber', name: 'Snow Plumber', price: 150, description: 'Winter warrior', owned: false, equipped: false, image: 'public/owl-hats/Snow-Plumber.png' },
                    { id: 'yellow_plumber', name: 'Yellow Plumber', price: 200, description: 'Sunny disposition', owned: false, equipped: false, image: 'public/owl-hats/Yellow-Plumber.png' },
                    { id: 'purple_plumber', name: 'Purple Plumber', price: 175, description: 'Royal plumber', owned: false, equipped: false, image: 'public/owl-hats/Purple-Plumber.png' },
                    { id: 'green_plumber', name: 'Green Plumber', price: 125, description: 'Nature lover', owned: false, equipped: false, image: 'public/owl-hats/Green-Plumber.png' },
                    { id: 'red_plumber', name: 'Red Plumber', price: 100, description: 'Fire and passion', owned: false, equipped: false, image: 'public/owl-hats/Red-Plumber.png' }
                ],
            skins: [
                { id: 'default', name: 'Classic Otter', price: 0, description: 'The original look', owned: true, equipped: true, image: 'public/oggg.png', unlockType: 'default' },
                { id: 'king_otter', name: 'King Otter', price: 50000, description: 'Royal majesty - Premium skin', owned: false, equipped: false, image: 'public/otter-skins/King Otter.png', unlockType: 'purchase' },
                { id: 'purple_plumber', name: 'Purple Plumber', price: 0, description: 'Royal plumber otter - Unlock by defeating 50 enemies', owned: false, equipped: false, image: 'public/otter-skins/Purple Plumber.png', unlockType: 'achievement', achievementId: 'defeat_50_enemies' },
                { id: 'yellow_plumber', name: 'Yellow Plumber', price: 0, description: 'Sunny plumber otter - Unlock by collecting 100 coins', owned: false, equipped: false, image: 'public/otter-skins/Yellow Plumber.png', unlockType: 'achievement', achievementId: 'collect_100_coins' },
                { id: 'green_plumber', name: 'Green Plumber', price: 0, description: 'Nature plumber otter - Unlock by completing 10 levels', owned: false, equipped: false, image: 'public/otter-skins/Green Plumber.png', unlockType: 'achievement', achievementId: 'complete_10_levels' },
                { id: 'red_plumber', name: 'Red Plumber', price: 0, description: 'Fire plumber otter - Unlock by defeating 5 bosses', owned: false, equipped: false, image: 'public/otter-skins/Red Plumber.png', unlockType: 'achievement', achievementId: 'defeat_5_bosses' },
                { id: 'snow_plumber', name: 'Snow Plumber', price: 0, description: 'Winter plumber otter - Unlock by reaching level 20', owned: false, equipped: false, image: 'public/otter-skins/Snow Plumber.png', unlockType: 'achievement', achievementId: 'reach_level_20' }
            ],
            abilities: [
                { id: 'jetpack', name: 'Jetpack', price: 25000, description: 'Start with jetpack ability', owned: false, equipped: false, image: 'public/jet.png' },
                { id: 'laser', name: 'Laser', price: 50000, description: 'Start with laser ability', owned: false, equipped: false, image: 'public/laser.png' },
                { id: 'fireball', name: 'Fireball', price: 1000, description: 'Shoot bouncing fireballs with right-click', owned: false, equipped: false, image: 'public/fireball.png' },
                { id: 'armor', name: 'Armor Boost', price: 15000, description: 'Start with enhanced armor (Level 1: +25% armor)', owned: false, equipped: false, image: 'public/armor.png' }
            ]
        };

        // 🤖 AI Bot Tips System
        const aiBotTips = {
            // General gameplay tips
            general: [
                "💡 Pro tip: Double jump can save you from falls!",
                "🎯 Remember: Jump on enemies to defeat them!",
                "💎 Collect coins for extra points and lives!",
                "❤️ Health pickups restore your health!",
                "🛡️ Armor protects you from damage!",
                "🍄 Mushrooms make you giant and invincible!",
                "🔑 Keys unlock special treasures!",
                "🐟 Fish give you bonus points!",
                "💎 Treasures are worth big points!",
                "🚁 Jetpacks let you fly around!",
                "🔫 Lasers can shoot enemies from afar!",
                "☁️ Cloud platforms disappear when you touch them!",
                "🌊 Underwater platforms are hidden treasures!",
                "⚡ Moving platforms require timing!",
                "🎮 Use checkpoints to avoid starting over!",
                "🎮 Press F to interact with golden chests!",
                "🎮 Use Shift for jetpack boost!",
                "🎮 Space shoots lasers when you have them!",
                "🎮 Break crates to find secrets!",
                "🎮 High places often have better rewards!",
                "🎮 Water areas hide special items!",
                "🎮 Boss levels have unique challenges!",
                "🎮 Every 10,000 points gives you a life!",
                "🎮 Armor absorbs damage before health!",
                "🎮 Giant mode makes you unstoppable!",
                "🎮 Keys are rare but valuable!",
                "🎮 Explore every corner for secrets!"
            ],
            
            // Level-specific tips
            level1: [
                "🎉 Welcome to your first adventure!",
                "🚶‍♂️ Use arrow keys or WASD to move!",
                "🦘 Press SPACE to jump!",
                "🦘 Press SPACE twice for double jump!",
                "🎯 Try jumping on that crab!",
                "💎 See that coin? Collect it for points!",
                "🎮 This is your first level - take it slow!",
                "🎯 Crabs are your first enemies - jump on them!",
                "💎 Coins give you points and extra lives!",
                "❤️ Health pickups restore your health!",
                "🎮 Use checkpoints to save your progress!",
                "🎯 Don't rush - explore and collect everything!"
            ],
            
            level2: [
                "🦅 Eagles are smart - they'll dive at you!",
                "🌊 Watch out for water - you can swim!",
                "🛡️ Look for armor in high places!",
                "🔍 Break tiles to find secrets!",
                "🎯 Eagles are more dangerous than crabs!",
                "🌊 Swimming is slower but safer!",
                "💎 Underwater areas hide treasures!",
                "🎮 You're getting better at this!",
                "🛡️ Armor is your best friend!",
                "🎯 Watch for eagle dive patterns!",
                "🌊 Water areas are great for exploration!",
                "💎 Don't forget to collect everything!"
            ],
            
            level3: [
                "🐊 Gators wait on water surfaces!",
                "⚡ Moving platforms need good timing!",
                "💎 Rare treasures need keys to unlock!",
                "🎯 Eagles are more aggressive now!",
                "🐊 Gators are slow but deadly!",
                "⚡ Time your jumps on moving platforms!",
                "🔑 Keys unlock the best treasures!",
                "🎯 This level introduces new challenges!",
                "💎 Golden chests need keys to open!",
                "🎮 Moving platforms require patience!",
                "🐊 Stay away from gator mouths!",
                "💎 Keys are worth the effort to find!"
            ],
            
            level4: [
                "🔮 Wizgators shoot fireballs!",
                "🦈 Sharks hunt underwater!",
                "🍄 Mushrooms make you unstoppable!",
                "🚁 Jetpacks are game changers!",
                "🔮 Wizgators are magical enemies!",
                "🦈 Sharks are fast underwater hunters!",
                "🍄 Mushrooms give you super powers!",
                "🚁 Jetpacks let you fly freely!",
                "🔮 Dodge wizgator fireballs!",
                "🦈 Sharks can't reach you on land!",
                "🍄 Giant mode makes you invincible!",
                "🚁 Use jetpacks to reach high places!",
                "🔮 Wizgators are vulnerable when not shooting!",
                "🦈 Underwater combat is dangerous!",
                "🍄 Mushroom power lasts 10 seconds!",
                "🚁 Jetpacks work great underwater too!"
            ],
            
            level5: [
                "👑 Boss level! Captain Claws awaits!",
                "🔥 Lava is deadly - don't touch it!",
                "🛡️ Boss armor gives extra protection!",
                "🎯 Dodge his attacks and counter!",
                "👑 Captain Claws is your first boss!",
                "🔥 Lava deals massive damage!",
                "🛡️ Boss armor is the strongest!",
                "🎯 Watch for boss attack patterns!",
                "👑 Boss battles are epic challenges!",
                "🔥 Stay away from lava pools!",
                "🛡️ Boss armor can save your life!",
                "🎯 Attack when the boss is vulnerable!",
                "👑 This is a test of your skills!",
                "🔥 Lava bounces you up but hurts!",
                "🛡️ Armor absorbs boss damage!",
                "🎯 Patience is key in boss fights!"
            ],
            
            // Situation-specific tips
            lowHealth: [
                "❤️ Your health is low! Find health pickups!",
                "🛡️ Look for armor to protect yourself!",
                "💎 Treasures often contain health!",
                "🌊 Check underwater for hidden health!",
                "❤️ Be extra careful with low health!",
                "🛡️ Armor will protect you from damage!",
                "💎 Golden chests might have health!",
                "🌊 Underwater areas hide health pickups!",
                "❤️ Avoid dangerous enemies when low on health!",
                "🛡️ Boss armor gives maximum protection!",
                "💎 Break crates to find health!",
                "🌊 Swim carefully when health is low!"
            ],
            
            noArmor: [
                "🛡️ You're vulnerable! Find some armor!",
                "💎 Armor is often in high places!",
                "🔍 Break tiles to find hidden armor!",
                "🌊 Underwater areas hide good armor!",
                "🛡️ Without armor, you're fragile!",
                "💎 High platforms often have armor!",
                "🔍 Hidden armor is the best kind!",
                "🌊 Underwater armor is special!",
                "🛡️ Armor absorbs damage before health!",
                "💎 Cloud platforms hide armor!",
                "🔍 Boss armor is the strongest!",
                "🌊 Water areas are armor hotspots!"
            ],
            
            manyEnemies: [
                "⚔️ Lots of enemies! Use your abilities!",
                "🍄 Mushroom power makes you invincible!",
                "🔫 Lasers can take them out safely!",
                "🦘 Jump on them from above!"
            ],
            
            bossLevel: [
                "👑 Boss battle! Stay focused!",
                "🔥 Watch out for lava attacks!",
                "🛡️ Boss armor gives major protection!",
                "🎯 Attack when he's vulnerable!"
            ],
            
            underwater: [
                "🌊 You're underwater! Swim carefully!",
                "🦈 Sharks are more dangerous here!",
                "💎 Underwater treasures are valuable!",
                "🚁 Jetpacks work great underwater!"
            ],
            
            highPlatforms: [
                "☁️ High platforms need precise jumping!",
                "🦘 Double jump helps reach them!",
                "💎 High places often have treasures!",
                "🛡️ Armor is usually up high!",
                "☁️ Cloud platforms are tricky but rewarding!",
                "🦘 Use double jump for extra height!",
                "💎 The best treasures are up high!",
                "🛡️ Hidden armor loves high places!",
                "☁️ Take your time on high platforms!",
                "🦘 Double jump is your best friend!",
                "💎 High risk, high reward!",
                "🛡️ Boss armor is often up high!"
            ],
            
            // Fun and encouraging tips
            encouragement: [
                "🎉 You're doing great! Keep it up!",
                "🌟 You're getting better at this!",
                "🎯 Nice moves! You're a natural!",
                "💪 You've got this! Keep going!",
                "🎮 You're mastering the controls!",
                "⭐ You're becoming an otter pro!",
                "🎊 Excellent gameplay!",
                "🏆 You're on fire today!",
                "🎯 Perfect timing on that jump!",
                "🌟 You're making this look easy!",
                "💪 Your skills are improving!",
                "🎮 You're a platforming master!",
                "🦉 Wise choice on that jump!",
                "🦉 Your platforming wisdom grows!",
                "🦉 Excellent navigation, young otter!",
                "🦉 You're learning the ways of the platform!",
                "🦉 Your otter instincts are sharp!",
                "🦉 Magnificent display of otter agility!",
                "🦉 You're becoming a true otter master!"
            ]
        };
        
        // 🤖 AI Bot Toggle Function (removed - button no longer exists)
        // Note: AI Bot can still be controlled through the pause menu
        
        // 🤖 AI Bot Functions
        function updateAiBot() {
            // Skip updates if AI Owl Bot is disabled
            if (!aiOwlBotEnabled) return;
            
            // Update bot position to follow player (simplified)
            game.aiBot.x = player.x + game.aiBot.offsetX;
            game.aiBot.y = player.y + game.aiBot.offsetY;
            
            // Simplified bobbing motion (less frequent updates)
            if (Math.random() < 0.1) { // Only 10% chance to update bobbing
                game.aiBot.bobOffset = Math.sin(Date.now() * game.aiBot.bobSpeed) * 1;
            }
            
            // Simplified glow effect (less frequent updates)
            if (Math.random() < 0.05) { // Only 5% chance to update glow
                game.aiBot.glowIntensity = Math.sin(Date.now() * 0.002) * 0.2 + 0.8;
            }
            
            // Update owl's looking direction with delay
            if (game.aiBot.lookDelay > 0) {
                game.aiBot.lookDelay--;
            } else if (game.aiBot.lookDirection !== player.direction) {
                // Change direction with a small delay for natural movement
                game.aiBot.lookDirection = player.direction;
                game.aiBot.lookDelay = 10; // 10 frames delay
            }
            
            // Check if it's time for a new tip (less frequent checks)
            const now = Date.now();
            if (now - game.aiBot.lastTipTime > game.aiBot.tipCooldown) {
                selectAndShowTip();
                game.aiBot.lastTipTime = now;
            }
            
            // Update tip timer (simplified)
            if (game.aiBot.currentTip) {
                game.aiBot.tipTimer += 16;
                if (game.aiBot.tipTimer > game.aiBot.tipDuration) {
                    game.aiBot.currentTip = '';
                    game.aiBot.tipTimer = 0;
                }
            }
        }
        
        function selectAndShowTip() {
            // Simplified tip selection (less processing)
            const tipCategories = [];
            
            // Add level-specific tips (simplified check)
            if (game.level <= 5) {
                tipCategories.push(`level${game.level}`);
            }
            
            // Add situation-specific tips (simplified checks)
            if (player.health < 50) {
                tipCategories.push('lowHealth');
            }
            
            if (player.armor === 0) {
                tipCategories.push('noArmor');
            }
            
            if (enemies.length > 8) {
                tipCategories.push('manyEnemies');
            }
            
            if (game.bossActive) {
                tipCategories.push('bossLevel');
            }
            
            if (player.inWater) {
                tipCategories.push('underwater');
            }
            
            // Simplified high platform check (less frequent)
            if (Math.random() < 0.3) { // Only 30% chance to check
                const nearbyHighPlatforms = platforms.filter(p => 
                    Math.abs(p.x - player.x) < 300 && p.y < 800
                );
                if (nearbyHighPlatforms.length > 0) {
                    tipCategories.push('highPlatforms');
                }
            }
            
            // Always include general tips
            tipCategories.push('general');
            
            // Add encouragement tips occasionally (20% chance)
            if (Math.random() < 0.2) {
                tipCategories.push('encouragement');
            }
            
            // Select a random category
            const selectedCategory = tipCategories[Math.floor(Math.random() * tipCategories.length)];
            const tips = aiBotTips[selectedCategory];
            
            if (tips && tips.length > 0) {
                const randomTip = tips[Math.floor(Math.random() * tips.length)];
                game.aiBot.currentTip = randomTip;
                game.aiBot.tipTimer = 0;
                // Removed console.log to reduce performance impact
            }
        }
        
        function drawAiBot() {
            if (!game.aiBot.isVisible || !aiOwlBotEnabled) return;
            
            const botScreenX = game.aiBot.x - game.camera.x;
            const botScreenY = game.aiBot.y - game.camera.y + game.aiBot.bobOffset;
            
            // Only draw if on screen (simplified check)
            if (botScreenX < -150 || botScreenX > game.canvasWidth + 150 || 
                botScreenY < -150 || botScreenY > game.canvasHeight + 150) {
                return;
            }
            
            ctx.save();
            
            // Draw owl glow effect (simplified)
            if (Math.random() < 0.2) { // Only 20% chance to draw glow
                ctx.fillStyle = `rgba(255, 215, 0, ${game.aiBot.glowIntensity * 0.3})`;
                ctx.beginPath();
                ctx.arc(botScreenX + game.aiBot.width/2, botScreenY + game.aiBot.height/2, 
                       game.aiBot.width/2 + 8, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw owl image with hat if equipped, otherwise default owl
            if (game.marketplace.currentHat && game.marketplace.currentHat !== 'none') {
                // Draw hat-equipped owl
                drawOwlHat(botScreenX, botScreenY);
            } else {
                // Draw default owl image
                if (gameAssets.owl) {
                    ctx.save();
                    // Flip owl based on owl's looking direction
                    if (game.aiBot.lookDirection === -1) {
                        ctx.scale(-1, 1);
                        ctx.drawImage(gameAssets.owl, -botScreenX - game.aiBot.width, botScreenY, game.aiBot.width, game.aiBot.height);
                    } else {
                        ctx.drawImage(gameAssets.owl, botScreenX, botScreenY, game.aiBot.width, game.aiBot.height);
                    }
                    ctx.restore();
                } else {
                    // Fallback to simple owl shape if image not loaded
                    ctx.fillStyle = '#8B4513'; // Brown color for owl
                    ctx.fillRect(botScreenX, botScreenY, game.aiBot.width, game.aiBot.height);
                    
                    // Draw owl eyes based on direction
                    ctx.fillStyle = '#FFD700'; // Golden eyes
                    if (game.aiBot.lookDirection === -1) {
                        // Looking left - adjust eye positions
                        ctx.beginPath();
                        ctx.arc(botScreenX + 15, botScreenY + 20, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(botScreenX + 45, botScreenY + 20, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw owl beak pointing left
                        ctx.fillStyle = '#FFA500'; // Orange beak
                        ctx.beginPath();
                        ctx.moveTo(botScreenX + 30, botScreenY + 35);
                        ctx.lineTo(botScreenX + 35, botScreenY + 45);
                        ctx.lineTo(botScreenX + 25, botScreenY + 45);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Looking right - normal eye positions
                        ctx.beginPath();
                        ctx.arc(botScreenX + 15, botScreenY + 20, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(botScreenX + 45, botScreenY + 20, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw owl beak pointing right
                        ctx.fillStyle = '#FFA500'; // Orange beak
                        ctx.beginPath();
                        ctx.moveTo(botScreenX + 30, botScreenY + 35);
                        ctx.lineTo(botScreenX + 25, botScreenY + 45);
                        ctx.lineTo(botScreenX + 35, botScreenY + 45);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
            
            ctx.restore();
            
            // Draw speech bubble if there's a tip
            if (game.aiBot.currentTip) {
                drawSpeechBubble(botScreenX, botScreenY);
            }
        }
        
        function drawPlayerHat(playerX, playerY, player) {
            ctx.save();
            
            // Position hat on player's head
            const hatX = playerX + player.collisionOffsetX + player.collisionWidth/2;
            const hatY = playerY + player.collisionOffsetY - 10; // Above the player's head
            
            // Scale hat based on player size and giant mode
            const hatScale = (player.isGiant ? 1.5 : 1.0);
            
            // Get the current hat image
            const currentHat = marketplaceItems.hats.find(hat => hat.id === game.marketplace.currentHat);
            if (currentHat && currentHat.image) {
                // Create a new image object for the hat
                const hatImage = new Image();
                hatImage.src = currentHat.image;
                
                if (hatImage.complete) {
                    // Draw the hat image
                    const hatWidth = 32 * hatScale; // Adjust size as needed
                    const hatHeight = 24 * hatScale;
                    ctx.drawImage(hatImage, hatX - hatWidth/2, hatY - hatHeight, hatWidth, hatHeight);
                } else {
                    // Fallback to colored rectangle if image not loaded
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(hatX - 8 * hatScale, hatY - 5 * hatScale, 16 * hatScale, 8 * hatScale);
                }
            }
            
            ctx.restore();
        }
        
        function drawOwlHat(botX, botY) {
            ctx.save();
            
            // Get the current hat image from marketplace
            const currentHat = marketplaceItems.hats.find(hat => hat.id === game.marketplace.currentHat);
            if (currentHat && currentHat.image) {
                // Create a new image object for the hat-equipped owl
                const hatOwlImage = new Image();
                hatOwlImage.src = currentHat.image;
                
                if (hatOwlImage.complete) {
                    // Draw the complete hat-equipped owl image with proper sizing
                    const owlWidth = game.aiBot.width;
                    const owlHeight = game.aiBot.height;
                    
                    // Handle directional flipping like the default owl
                    if (game.aiBot.lookDirection === -1) {
                        ctx.scale(-1, 1);
                        ctx.drawImage(hatOwlImage, -botX - owlWidth, botY, owlWidth, owlHeight);
                    } else {
                        ctx.drawImage(hatOwlImage, botX, botY, owlWidth, owlHeight);
                    }
                } else {
                    // Fallback to default owl if image not loaded
                    if (gameAssets.owl) {
                        if (game.aiBot.lookDirection === -1) {
                            ctx.scale(-1, 1);
                            ctx.drawImage(gameAssets.owl, -botX - game.aiBot.width, botY, game.aiBot.width, game.aiBot.height);
                        } else {
                            ctx.drawImage(gameAssets.owl, botX, botY, game.aiBot.width, game.aiBot.height);
                        }
                    }
                }
            }
            
            ctx.restore();
        }
        
        function drawSpeechBubble(botX, botY) {
            const bubbleX = botX + game.aiBot.width + 10;
            const bubbleY = botY - 80; // Moved higher from -40 to -80
            const bubbleWidth = 220; // Made wider from 200 to 220
            const bubbleHeight = 70; // Made taller from 60 to 70
            
            ctx.save();
            
            // Draw bubble background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.strokeStyle = '#4169E1';
            ctx.lineWidth = 2;
            
            // Main bubble (using manual rounded rectangle)
            ctx.beginPath();
            ctx.moveTo(bubbleX + 10, bubbleY);
            ctx.lineTo(bubbleX + bubbleWidth - 10, bubbleY);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + 10);
            ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - 10);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - 10, bubbleY + bubbleHeight);
            ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight);
            ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - 10);
            ctx.lineTo(bubbleX, bubbleY + 10);
            ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + 10, bubbleY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Speech bubble tail
            ctx.beginPath();
            ctx.moveTo(botX + game.aiBot.width, botY + 10);
            ctx.lineTo(bubbleX, bubbleY + bubbleHeight/2);
            ctx.lineTo(bubbleX + 5, bubbleY + bubbleHeight/2 + 5);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw tip text
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 14px Arial'; // Made larger from 12px to 14px
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            
            // Wrap text if needed
            const words = game.aiBot.currentTip.split(' ');
            let line = '';
            let lineHeight = 18; // Increased from 15 to 18
            let currentY = bubbleY + 20; // Increased from 15 to 20
            
            for (let word of words) {
                const testLine = line + word + ' ';
                const testWidth = ctx.measureText(testLine).width;
                
                if (testWidth > bubbleWidth - 20 && line !== '') {
                    ctx.fillText(line, bubbleX + 10, currentY);
                    line = word + ' ';
                    currentY += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, bubbleX + 10, currentY);
            
            ctx.restore();
        }
        
        // 🔑 KEY GENERATION FUNCTION - HIGH WATER PROBABILITY
        function generateRandomKeys(platforms, levelNum) {
            const keys = [];
            
            console.log('🔑 generateRandomKeys called for level:', levelNum, 'with platforms:', platforms.length);
            
            // FORCE key to spawn on EVERY level - GUARANTEED but DIFFICULT (MAX 1 KEY)
            if (platforms.length > 0 && keys.length === 0) { // Ensure only 1 key per level
                // Find a DIFFICULT platform - prioritize water areas
                let targetPlatform = null;
                
                // Filter for challenging platforms based on level
                let challengingPlatforms = [];
                
                // 🌊 HIGH PRIORITY: Water platforms (underwater platforms)
                let waterPlatforms = platforms.filter(p => p.type === 'underwater');
                console.log('🔑 Found', waterPlatforms.length, 'water platforms for key placement');
                
                // Skip lava areas on boss levels
                if (game.bossActive) {
                    waterPlatforms = waterPlatforms.filter(p => p.y < game.lavaLevel - 100);
                    console.log('🔑 Filtered out lava areas, remaining water platforms:', waterPlatforms.length);
                }
                
                // If we have water platforms, use them with high probability
                if (waterPlatforms.length > 0 && Math.random() < 0.8) { // 80% chance to use water platforms
                    challengingPlatforms = waterPlatforms;
                    console.log('🔑 Using water platforms for key placement!');
                } else {
                    // Fallback to regular challenging platforms - NEVER spawn keys in lava
                    if (levelNum === 1) {
                        // First level: place on higher platforms (above 1000 Y) but not in lava
                        challengingPlatforms = platforms.filter(p => p.y < 1000 && p.x > 1000 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    } else if (levelNum <= 3) {
                        // Early levels: place on high platforms (above 800 Y) and far into level but not in lava
                        challengingPlatforms = platforms.filter(p => p.y < 800 && p.x > 1500 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    } else if (levelNum <= 5) {
                        // Mid levels: place on very high platforms (above 600 Y) and very far but not in lava
                        challengingPlatforms = platforms.filter(p => p.y < 600 && p.x > 2000 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    } else {
                        // Later levels: place on extremely high platforms (above 400 Y) and extremely far but not in lava
                        challengingPlatforms = platforms.filter(p => p.y < 400 && p.x > 2500 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    }
                    
                    // If no challenging platforms found, use fallback - still make it difficult but not in lava
                    if (challengingPlatforms.length === 0) {
                        // Find platforms in the second half of the level but not in lava
                        const midPoint = Math.floor(platforms.length / 2);
                        challengingPlatforms = platforms.slice(midPoint).filter(p => p.y < 1200 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    }
                    
                    // If still no platforms, use any platform but make it higher and not in lava
                    if (challengingPlatforms.length === 0) {
                        challengingPlatforms = platforms.filter(p => p.y < 1200 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    }
                    
                    // If still no platforms, use any platform but not in lava
                    if (challengingPlatforms.length === 0) {
                        challengingPlatforms = platforms.filter(p => !game.bossActive || p.y < game.lavaLevel - 100);
                    }
                }
                
                // Select a random challenging platform
                targetPlatform = challengingPlatforms[Math.floor(Math.random() * challengingPlatforms.length)];
                
                // Place key in a challenging position on the platform
                const keyX = targetPlatform.x + (targetPlatform.width * 0.8); // Near the edge of platform
                const keyY = targetPlatform.y - 60; // Higher above platform for more challenge
                
                keys.push({
                    x: keyX,
                    y: keyY,
                    collected: false,
                    type: 'key'
                });
                
                console.log('🔑 DIFFICULT Key placed at position:', keyX, keyY, 'on platform at:', targetPlatform.x, targetPlatform.y);
                console.log('🔑 Platform difficulty - Y:', targetPlatform.y, 'X:', targetPlatform.x, 'Level:', levelNum);
            } else {
                console.warn('🔑 No platforms available for key placement!');
            }
            
            console.log('🔑 Generated', keys.length, 'key items for level', levelNum);
            return keys;
        }

        // Otter player
        const player = {
            x: 240, // Start at correct X position (scaled from 100)
            y: 1200, // Start at correct Y position on starting platform (1320 - 80 - 40)
            width: 64, // Rectangular sprite
            height: 93, // Rectangular sprite
            velX: 0,
            velY: 0,
            speed: 4.69, // 25% faster movement speed (3.75 * 1.25 = 4.69)
            jumpPower: 20, // 25% faster jump power (16 * 1.25 = 20)
            onGround: true, // Start on ground to prevent immediate falling
            canDoubleJump: true,
            direction: 1,
            // Collision box that matches the visual sprite exactly
            collisionWidth: 64, // Same as sprite width
            collisionHeight: 93, // Same as sprite height
            collisionOffsetX: 0, // No offset - collision matches sprite exactly
            collisionOffsetY: 0, // No offset - collision matches sprite exactly
            // Health system
            health: 100,
            maxHealth: 100,
            // Armor system
            armor: 0,
            maxArmor: 100,
            // Invulnerability system
            invulnerable: false,
            invulnerableTime: 0,
            invulnerableDuration: 2000, // 2 seconds of invulnerability after taking damage
            damageInvulnerable: false, // Separate from mushroom invulnerability
            // Mushroom power-up system
            isGiant: false,
            giantTime: 0,
            giantDuration: 10000, // 10 seconds of giant mode
            // Last platform tracking for respawn
            lastPlatform: null,
            // Platform movement tracking
            onMovingPlatform: false,
            platformOffsetX: 0,
            platformOffsetY: 0,
            platformStartTime: 0,
            // Extra abilities

            // Jetpack system
            hasJetpack: false,
            jetpackActive: false,
            jetpackTime: 0,
            jetpackDuration: Infinity, // No time limit - usable for entire level
            jetpackPower: 22.5, // 25% faster jetpack power (18 * 1.25 = 22.5)
            waterJetpackPower: 375, // 25% faster water jetpack power (300 * 1.25 = 375)
            lastJumpTime: 0,
            // Laser system
            hasLaser: false,
            laserActive: false,
            laserTime: 0,
            laserDuration: Infinity, // No time limit - usable for entire level
            laserCooldown: 0,
            laserSpeed: 10, // 25% faster laser speed (8 * 1.25 = 10)
            laserColors: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'], // Red, Green, Blue, Yellow, Magenta, Cyan
            currentLaserColor: 0,
              // Laser charging system
              isCharging: false,
              chargeStartTime: 0,
              chargeLevel: 0,
            maxChargeLevel: 6, // Fixed max charge level
              chargeTime: 1000, // 1 second to fully charge
            
            // Fireball system
            hasFireball: false,
            fireballCooldown: 0,
            fireballSpeed: 7.5, // 25% faster fireball speed (6 * 1.25 = 7.5)
            fireballLifetime: 0,
            maxFireballLifetime: 3000, // 3 seconds in milliseconds
            
            // Armor system
            hasArmorBoost: false,
            armorLevel: 0, // 0 = no boost, 1 = +25%, 2 = +50%, 3 = +75%
            maxArmorLevel: 3,
            
            // XP and Reward System
            xp: 0,
            level: 1,
            xpToNextLevel: 1000, // XP needed for next level (will be calculated dynamically)
            totalScore: 0,

            laserChargingLevel: 0, // Start at 0 - must be unlocked
            maxLaserChargingLevel: 6, // Maximum charging level
            unlockedRewards: [], // Track unlocked rewards
            laserChargeLockedMessageShown: false, // Track if laser charge locked message has been shown
            rewards: {
                xpPerScore: 0.1, // Reduced XP gained per score point (was 1)
                levelCompletionBonus: 50, // Reduced base XP for completing a level (was 100)

                // Laser charge ability unlocks every 10 levels (10, 20, 30, 40, 50, 60)
                laserChargeUnlockLevels: [10, 20, 30, 40, 50, 60], // Levels where laser charge ability unlocks
                laserUpgradeLevels: [10, 20, 30, 40, 50, 60], // Levels where laser charging upgrades (max 6 upgrades)
                // New unlock rewards system
                unlockRewards: {
                    5: { type: 'cosmetic', name: 'Golden Otter Skin', description: 'Unlock golden otter skin' },
                    10: { type: 'laser', name: 'Laser Level 2', description: 'Upgrade laser charging to level 2' },
                    15: { type: 'cosmetic', name: 'Rainbow Trail', description: 'Unlock rainbow trail effect' },
                    20: { type: 'laser', name: 'Laser Level 3', description: 'Upgrade laser charging to level 3' },
                    25: { type: 'ability', name: 'Double Jump', description: 'Unlock double jump ability' },
                    30: { type: 'laser', name: 'Laser Level 4', description: 'Upgrade laser charging to level 4' },
                    35: { type: 'cosmetic', name: 'Particle Effects', description: 'Unlock enhanced particle effects' },
                    40: { type: 'laser', name: 'Laser Level 5', description: 'Upgrade laser charging to level 5' },
                    50: { type: 'laser', name: 'Laser Level 6', description: 'Upgrade laser charging to level 6' },
                    60: { type: 'cosmetic', name: 'Legendary Status', description: 'Unlock legendary player status' }
                },
                
                // Armor upgrade levels (requires armor ability to be purchased first)
                armorUpgradeLevels: [15, 30, 45] // Levels where armor upgrades (Level 2, 3, 4)
            },
            // Key system
            keys: 0,
            // Water system
            inWater: false,
            swimming: false,
            swimSpeed: 3.44, // 25% faster swimming speed (2.75 * 1.25 = 3.44)
            waterResistance: 0.3,
            // Lava system
            inLava: false,
                          lavaSinkTime: 0,
              lavaDamageTime: 0,
              lastLavaDamageTime: 0,
              lavaInvulnerable: false
        };
        
        // Level generator functions
        function generateRandomPlatforms(levelNum) {
            const platforms = [
                { x: 0, y: 1320, width: 480, height: 120, type: 'static' }, // Starting platform (scaled from 200x50)
                { x: -100, y: 0, width: 50, height: 2000, type: 'barrier' } // Left barrier wall to prevent going too far left
            ];
            
            const difficulty = Math.min(levelNum, 10); // Cap difficulty scaling
            const platformCount = 20 + Math.floor(difficulty * 2); // More platforms for better coverage
            const minGap = levelNum === 1 ? Math.max(400, 500 - difficulty * 2.4) : Math.max(500, 600 - difficulty * 2.4); // MUCH larger gaps for proper spacing
            const maxGap = levelNum === 1 ? Math.max(600, 700 - difficulty * 2.4) : Math.max(700, 800 - difficulty * 2.4); // MUCH larger gaps for proper spacing
            
            let currentX = 720; // Scaled from 300 (300*2.4=720)
            
            // Create multiple paths and exploration areas
            for (let i = 0; i < platformCount; i++) {
                // Chaotic gap and width generation
                const gapX = minGap + Math.random() * (maxGap - minGap) + (Math.random() < 0.3 ? Math.random() * 200 : 0); // Sometimes add extra random gap
                
                // Generate longer platforms more frequently
                let platformWidth;
                if (Math.random() < 0.6) { // 60% chance for long platforms
                    platformWidth = 300 + Math.random() * 400; // Long platforms (300-700 pixels)
                } else {
                    platformWidth = 120 + Math.random() * 200; // Regular platforms (120-320 pixels)
                }
                
                // Create VARIED platform heights - much more accessible
                let platformY;
                
                // Generate more low platforms for better gameplay
                if (Math.random() < 0.6) { // 60% chance for low platforms
                    platformY = 1000 + Math.random() * 200; // Low platforms (1000-1200) - close to water
                } else if (Math.random() < 0.3) { // 30% chance for medium platforms
                    platformY = 800 + Math.random() * 200; // Medium platforms (800-1000)
                } else {
                    // 10% chance for higher platforms - much more limited
                    if (levelNum === 1) {
                        platformY = 700 + Math.random() * 100; // First level: moderate heights
                    } else if (levelNum <= 3) {
                        platformY = 650 + Math.random() * 150; // Early levels: varied heights
                    } else {
                        platformY = 600 + Math.random() * 200; // Later levels: higher heights (but still reachable)
                    }
                }
                
                // Determine platform type based on level and position
                let platformType = 'static';
                if (levelNum >= 2 && Math.random() < 0.2) {
                    platformType = 'linear';
                } else if (levelNum >= 4 && Math.random() < 0.15) {
                    platformType = 'disappearing';
                } else if (levelNum >= 3 && Math.random() < 0.25) {
                    platformType = 'cloud'; // Add cloud platforms
                }
                
                // Add random X offset for more chaotic positioning
                const randomXOffset = Math.random() < 0.4 ? (Math.random() - 0.5) * 200 : 0; // 40% chance for random X offset
                
                const platform = {
                    x: currentX + randomXOffset,
                    y: Math.max(700, Math.min(1200, platformY)), // Lower maximum Y to ensure reachability
                    width: platformWidth,
                    height: 48, // Scaled from 20 (20*2.4=48)
                    type: platformType
                };
                
                // Adjust cloud platform Y position to be 200px higher than regular platforms (more reachable)
                if (platformType === 'cloud') {
                    platform.y = Math.max(400, platform.y - 200); // 200px higher, but not below 400
                }
                
                // Add movement properties for moving platforms
                if (platformType === 'linear') {
                    platform.moveSpeed = 0.625 + Math.random() * 0.625; // 25% faster platform speed (0.5*1.25=0.625, 0.5*1.25=0.625)
                    platform.moveDistance = 50 + Math.random() * 100; // Shorter distance (50-150)
                    platform.startX = currentX;
                    platform.startY = platform.y;
                    platform.moveDirection = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                    platform.moveProgress = 0;
                } else if (platformType === 'disappearing') {
                    platform.disappearTime = 3000 + Math.random() * 2000; // 3-5 seconds
                    platform.reappearTime = 2000 + Math.random() * 2000; // 2-4 seconds
                    platform.isVisible = true;
                    platform.lastToggle = Date.now();
                } else if (platformType === 'cloud') {
                    // Cloud platform properties
                    platform.cloudType = Math.floor(Math.random() * 3); // 0, 1, or 2 for different cloud styles
                    platform.cloudOpacity = 0.7 + Math.random() * 0.3; // 0.7-1.0 opacity
                    platform.cloudPuffiness = 0.8 + Math.random() * 0.4; // 0.8-1.2 puffiness
                    platform.cloudColor = Math.random() < 0.3 ? '#E6F3FF' : '#FFFFFF'; // Sometimes light blue
                    platform.cloudTime = Date.now(); // For animation
                    
                    // Cloud disappearing behavior
                    platform.isVisible = true;
                    platform.cloudStartTime = null; // When player first steps on cloud
                    platform.cloudDisappearTime = 3000; // 3 seconds to disappear
                    platform.isDisappearing = false;
                    
                    // Special cloud properties
                    if (Math.random() < 0.2) {
                        platform.isRainCloud = true; // 20% chance for rain cloud
                        platform.rainIntensity = 0.5 + Math.random() * 0.5;
                    }
                    if (Math.random() < 0.15) {
                        platform.isThunderCloud = true; // 15% chance for thunder cloud
                        platform.thunderTimer = 0;
                    }
                    if (Math.random() < 0.1) {
                        platform.isGoldenCloud = true; // 10% chance for golden cloud (special rewards)
                    }
                }
                
                platforms.push(platform);
                
                // Add intermediate platforms randomly for chaotic layout
                if (levelNum > 1 && Math.random() < 0.1 && i > 2) { // Very rare for chaotic layout
                    const intermediateX = currentX + Math.random() * platformWidth;
                    const intermediateY = platformY - 72 - Math.random() * 72; // Closer to main platform (scaled from 30, 30)
                    platforms.push({
                        x: intermediateX,
                        y: Math.max(672, intermediateY), // Scaled from 280 (280*2.4=672)
                        width: 144 + Math.random() * 96, // Scaled from 60, 40 (60*2.4=144, 40*2.4=96)
                        height: 48 // Scaled from 20 (20*2.4=48)
                    });
                }
                
                // Add extra stepping stone platforms randomly for chaotic layout
                if (levelNum > 1 && Math.random() < 0.05 && i > 3) { // Very rare for chaotic layout
                    const stepX = currentX + Math.random() * platformWidth;
                    const stepY = platformY - 120 - Math.random() * 60; // Lower stepping stone
                    platforms.push({
                        x: stepX,
                        y: Math.max(672, stepY),
                        width: 120 + Math.random() * 72, // Smaller stepping stone
                        height: 48,
                        isSteppingStone: true
                    });
                }
                
                // Add some branching platforms for exploration (only in later levels)
                if (levelNum > 2 && Math.random() < 0.3 && i > 5) { // Increased from 0.2 to 0.3
                    const branchX = currentX + Math.random() * platformWidth;
                    const branchY = platformY - 96 - Math.random() * 96; // Scaled from 40, 40 (40*2.4=96, 40*2.4=96)
                    platforms.push({
                        x: branchX,
                        y: Math.max(672, branchY), // Scaled from 280 (280*2.4=672)
                        width: 144 + Math.random() * 96, // Scaled from 60, 40 (60*2.4=144, 40*2.4=96)
                        height: 48 // Scaled from 20 (20*2.4=48)
                    });
                }
                
                // Add high platforms with rare treasures (challenging to reach)
                if (levelNum > 1 && Math.random() < 0.15 && i > 3) {
                    const highPlatformX = currentX + Math.random() * platformWidth;
                    const highPlatformY = 480 + Math.random() * 192; // Scaled from 200, 80 (200*2.4=480, 80*2.4=192)
                    platforms.push({
                        x: highPlatformX,
                        y: highPlatformY,
                        width: 192 + Math.random() * 96, // Scaled from 80, 40 (80*2.4=192, 40*2.4=96)
                        height: 48, // Scaled from 20 (20*2.4=48)
                        isHighPlatform: true // Mark as high platform for treasure placement
                    });
                    
                    // Add stepping stone platforms to reach high platforms
                    if (Math.random() < 0.7) { // 70% chance to add stepping stones
                        const step1X = highPlatformX - 144 - Math.random() * 72; // Scaled from 60, 30
                        const step1Y = highPlatformY + 96 + Math.random() * 48; // Scaled from 40, 20
                        platforms.push({
                            x: step1X,
                            y: step1Y,
                            width: 120 + Math.random() * 72, // Scaled from 50, 30
                            height: 48, // Scaled from 20 (20*2.4=48)
                            isSteppingStone: true
                        });
                        
                        const step2X = step1X - 120 - Math.random() * 72; // Scaled from 50, 30
                        const step2Y = step1Y + 72 + Math.random() * 48; // Scaled from 30, 20
                        platforms.push({
                            x: step2X,
                            y: step2Y,
                            width: 120 + Math.random() * 72, // Scaled from 50, 30
                            height: 48, // Scaled from 20 (20*2.4=48)
                            isSteppingStone: true
                        });
                    }
                }
                
                currentX += gapX + platformWidth;
            }
            
            // Note: Final goal platform is now added at the very end after floating platforms
            
            // Add multiple tiers of platforms for proper progression
            const screenHeight = 1800;
            const groundExtensions = [];
            
            // Create multiple height tiers for climbing progression
            const tierHeights = [1200, 1000, 800, 600, 400, 200]; // Multiple tiers from ground up
            const levelWidth = currentX + 600;
            
            // Add intermediate platforms at different tiers
            for (let x = 200; x < levelWidth; x += 400) { // More frequent platforms
                if (Math.random() < 0.6) { // 60% chance for more platforms
                    const tierIndex = Math.floor(Math.random() * tierHeights.length);
                    const tierY = tierHeights[tierIndex];
                    const platformWidth = 120 + Math.random() * 200;
                    const platformX = x + Math.random() * 200;
                    
                    // Check if this area is empty (no existing platform nearby)
                    const isAreaEmpty = !platforms.some(p => 
                        Math.abs(p.x - platformX) < 150 && Math.abs(p.y - tierY) < 100
                    );
                    
                    if (isAreaEmpty) {
            platforms.push({
                            x: platformX,
                            y: tierY,
                            width: platformWidth,
                            height: 40,
                            type: 'static'
                        });
                    }
                }
            }
            
            // Add ground extensions for platforms that are too high to reach
            platforms.forEach(platform => {
                if (platform.y < 800) { // For platforms that are high up
                    const actualBottom = screenHeight;
                    const platformBottom = platform.y + platform.height;
                    const extensionHeight = actualBottom - platformBottom;
                    
                    if (extensionHeight > 300) { // Only if there's significant space to fill
                        groundExtensions.push({
                            x: platform.x,
                            y: platformBottom,
                            width: platform.width,
                            height: extensionHeight,
                            type: 'ground',
                            isGroundExtension: true
                        });
                    }
                }
            });
            
            // Add strategic ground pillars for climbing
            for (let x = 0; x < levelWidth; x += 600) { // More frequent pillars
                if (Math.random() < 0.5) { // 50% chance
                    const pillarWidth = 100 + Math.random() * 150;
                    const pillarY = 1100 + Math.random() * 200; // Near ground level
                    const pillarHeight = screenHeight - pillarY;
                    
                    groundExtensions.push({
                        x: x + Math.random() * 200,
                        y: pillarY,
                        width: pillarWidth,
                        height: pillarHeight,
                        type: 'ground',
                        isGroundExtension: true
                    });
                }
            }
            
            // Add ground extensions to the main platforms array
            platforms.push(...groundExtensions);
            
            // Add some floating platforms in the air for better respawn points
            const floatingPlatforms = [];
            for (let i = 0; i < 3; i++) { // Add 3 floating platforms
                const floatX = 800 + i * 600 + Math.random() * 400; // Spread them out
                const floatY = 800 + Math.random() * 200; // Mid-height platforms
                const floatWidth = 200 + Math.random() * 200; // 200-400 pixels wide
                
                floatingPlatforms.push({
                    x: floatX,
                    y: floatY,
                    width: floatWidth,
                    height: 48, // Standard platform height
                    type: 'static',
                    isFloating: true
                });
            }
            
            platforms.push(...floatingPlatforms);
            
            // Add cloud platforms - GUARANTEED on every level, dispersed throughout
            const cloudPlatforms = [];
            
            // Calculate level width and add clouds throughout the entire level (but stop before goal)
            const goalArea = currentX + 600; // Goal flag position
            const cloudCutoff = goalArea - 800; // Stop clouds 800px before the goal
            const cloudSpacing = 600; // Distance between cloud platforms
            const cloudCount = Math.floor(cloudCutoff / cloudSpacing) + 1; // Ensure clouds cover the level but stop before goal
            
            for (let i = 0; i < cloudCount; i++) {
                // Find the highest platform to position clouds above it
                const highestPlatform = platforms.reduce((highest, platform) => 
                    platform.y < highest.y ? platform : highest, platforms[0]);
                
                const cloudX = 200 + i * cloudSpacing + Math.random() * 400; // Spread clouds evenly across the level
                // Ensure cloud doesn't go beyond the cutoff point
                if (cloudX > cloudCutoff) continue; // Skip this cloud if it would be too close to goal
                const baseCloudY = Math.max(200, highestPlatform.y - 300); // Base position 300px above highest platform
                const heightVariation = Math.random() * 400; // 0-400px additional height variation
                const cloudY = baseCloudY - heightVariation; // Vary height above the base position
                const cloudWidth = 200 + Math.random() * 300; // 200-500 pixels wide
                
                const cloudPlatform = {
                    x: cloudX,
                    y: cloudY,
                    width: cloudWidth,
                    height: 48,
                    type: 'cloud',
                    cloudType: Math.floor(Math.random() * 3), // 0, 1, or 2 for different cloud styles
                    cloudOpacity: 0.7 + Math.random() * 0.3, // 0.7-1.0 opacity
                    cloudPuffiness: 0.8 + Math.random() * 0.4, // 0.8-1.2 puffiness
                    cloudColor: Math.random() < 0.3 ? '#E6F3FF' : '#FFFFFF', // Sometimes light blue
                    cloudTime: Date.now(), // For animation
                    
                    // Cloud disappearing behavior
                    isVisible: true,
                    cloudStartTime: null, // When player first steps on cloud
                    cloudDisappearTime: 3000, // 3 seconds to disappear
                    isDisappearing: false,
                    respawnStartTime: null // When cloud starts respawning
                };
                
                // Special cloud properties
                if (Math.random() < 0.2) {
                    cloudPlatform.isRainCloud = true; // 20% chance for rain cloud
                    cloudPlatform.rainIntensity = 0.5 + Math.random() * 0.5;
                }
                if (Math.random() < 0.15) {
                    cloudPlatform.isThunderCloud = true; // 15% chance for thunder cloud
                    cloudPlatform.thunderTimer = 0;
                }
                if (Math.random() < 0.1) {
                    cloudPlatform.isGoldenCloud = true; // 10% chance for golden cloud (special rewards)
                }
                
                cloudPlatforms.push(cloudPlatform);
            }
            
            platforms.push(...cloudPlatforms);
            
            // 🌊 Add underwater platforms extending down to death barrier
            const underwaterPlatformCount = 15 + Math.floor(levelNum * 3); // Much more underwater platforms
            const underwaterStartY = game.waterLevel + 200; // Start 200px below water surface
            const underwaterEndY = game.deathBarrier - 200; // Stop 200px above death barrier
            
            // Skip underwater platforms on boss levels (lava instead of water)
            if (!game.bossActive) {
            
            for (let i = 0; i < underwaterPlatformCount; i++) {
                const underwaterX = 200 + Math.random() * (currentX + 400); // Spread across level width
                const underwaterY = underwaterStartY + (i * (underwaterEndY - underwaterStartY) / underwaterPlatformCount) + Math.random() * 200;
                const underwaterWidth = 120 + Math.random() * 240; // 120-360px wide
                
            platforms.push({
                    x: underwaterX,
                    y: underwaterY,
                    width: underwaterWidth,
                    height: 60, // Thinner underwater platforms
                    type: 'underwater' // New platform type for underwater
                });
            }
            } // Close the if (!game.bossActive) block
            
            // Add final goal platform at the very end (after all other platforms)
            const finalLevelWidth = Math.max(...platforms.map(p => p.x + p.width)) + 1200; // 1200px beyond the last platform
            
            // Add extra space for boss levels to prevent accidental goal completion
            const isBossLevel = levelNum % 5 === 0;
            const extraBossSpace = isBossLevel ? 2000 : 0; // 2000px extra space for boss levels
            const goalPlatformX = finalLevelWidth + extraBossSpace;
            
            // For boss levels, create a long boss platform before the goal
            if (isBossLevel) {
                const bossPlatformX = finalLevelWidth + 800; // 800px before the goal
                const bossPlatformWidth = 1200; // Very long platform for boss battles
                
                platforms.push({
                    x: bossPlatformX,
                    y: 1200, // Same height as goal platform
                    width: bossPlatformWidth,
                    height: 120,
                    type: 'boss' // Special boss platform type
                });
                
                // Store boss platform info for positioning
                game.bossPlatformX = bossPlatformX;
                game.bossPlatformWidth = bossPlatformWidth;
            }
            
            platforms.push({
                x: goalPlatformX,
                y: 1200, // Scaled from 500 (500*2.4=1200)
                width: 360, // Scaled from 150 (150*2.4=360)
                height: 120 // Scaled from 50 (50*2.4=120)
            });
            
            // Store goal position for collision detection
            game.goalX = goalPlatformX;
            game.goalY = 1200;
            
            return platforms;
        }
        
        function generateRandomFish(platforms, levelNum) {
            const fish = [];
            const fishCount = 8 + Math.floor(levelNum * 1.5); // More fish for longer levels
            
            // Place fish on or above platforms
            for (let i = 1; i < Math.min(platforms.length - 1, fishCount + 1); i++) {
                const platform = platforms[i];
                const fishX = platform.x + platform.width / 2;
                const fishY = platform.y - 72 - Math.random() * 120; // Scaled from 30, 50 (30*2.4=72, 50*2.4=120)
                
                fish.push({
                    x: fishX,
                    y: fishY,
                    collected: false
                });
            }
            
            return fish;
        }
        
        function generateRandomEnemies(platforms, levelNum) {
            const enemies = [];
            const enemyCount = Math.min(12 + Math.floor(levelNum * 5), 60); // Much more enemies for higher levels
            const enemySpeed = Math.min(1.0 + levelNum * 0.19, 4.0); // 25% faster enemies (0.8*1.25=1.0, 0.15*1.25=0.19, 3.2*1.25=4.0)
            
            // Enemy types and properties
            const enemyTypes = {
                basic: { width: 60, height: 50, speed: enemySpeed, health: 1, type: 'crab', collisionWidth: 50, collisionHeight: 40, collisionOffsetX: 5, collisionOffsetY: 5 },
                shooter: { width: 60, height: 50, speed: enemySpeed * 0.5, health: 1, type: 'crab', canShoot: true, shotCooldown: 2000, collisionWidth: 50, collisionHeight: 40, collisionOffsetX: 5, collisionOffsetY: 5 },
                eagle: { width: 100, height: 80, speed: 1.5, health: 1, type: 'eagle', canFly: true, diveSpeed: 2.75, diveRange: 300, sineOffset: 0, collisionWidth: 90, collisionHeight: 70, collisionOffsetX: 4, collisionOffsetY: 4, isAttacking: false, targetPlayer: false, isFlyingBack: false, originalYSet: false, isRetreating: false, retreatStartTime: undefined, originalPatrolY: undefined },
                charger: { width: 70, height: 60, speed: enemySpeed * 0.8, health: 2, type: 'charger', canCharge: true, chargeSpeed: 5, chargeWindup: 1000, chargeCooldown: 3000, isCharging: false, chargeStartTime: 0, collisionWidth: 60, collisionHeight: 50, collisionOffsetX: 5, collisionOffsetY: 5 },
                goldfish: { width: 80, height: 60, speed: enemySpeed * 1.2, health: 1, type: 'goldfish', canSwim: true, swimSpeed: enemySpeed * 1.2, collisionWidth: 70, collisionHeight: 50, collisionOffsetX: 5, collisionOffsetY: 5, canShoot: false, shotCooldown: 3000 },
                gator: { width: 80, height: 53, speed: enemySpeed * 0.3, health: 2, type: 'gator', canSwim: true, isOnWaterSurface: true, chaseRange: 300, chaseSpeed: enemySpeed * 0.75, chaseDuration: 1500, isChasing: false, chaseStartTime: 0, collisionWidth: 73, collisionHeight: 47, collisionOffsetX: 3, collisionOffsetY: 3 },
                wizgator: { width: 80, height: 53, speed: enemySpeed * 0.3, health: 2, type: 'wizgator', canSwim: true, isOnLiquidSurface: true, chaseRange: 300, chaseSpeed: enemySpeed * 0.75, chaseDuration: 1500, isChasing: false, chaseStartTime: 0, collisionWidth: 73, collisionHeight: 47, collisionOffsetX: 3, collisionOffsetY: 3, canShoot: true, shotCooldown: 3000 },
                shark: { width: 120, height: 60, speed: 1.875, health: 3, type: 'shark', canSwim: true, isUnderwater: true, diveSpeed: 3.125, diveRange: 400, sineOffset: 0, collisionWidth: 110, collisionHeight: 50, collisionOffsetX: 5, collisionOffsetY: 5, isAttacking: false, targetPlayer: false, isSwimmingBack: false, originalYSet: false, isRetreating: false, retreatStartTime: undefined, originalPatrolY: undefined }
            };
            
            // Distribute enemies evenly across the entire level
            const totalPlatforms = platforms.length;
            const platformsPerEnemy = Math.max(1, Math.floor(totalPlatforms / enemyCount)); // Ensure at least 1 platform per enemy
            
            console.log('🔍 ENEMY SPAWNING DEBUG: Level', levelNum, 'Boss Active:', game.bossActive, 'Platforms:', platforms.length, 'Enemy Count:', enemyCount, 'Platforms per Enemy:', platformsPerEnemy);
            
            // Place enemies on platforms (skip first 2 platforms for safety)
            for (let i = 2; i < Math.min(platforms.length - 1, enemyCount * 2); i++) { // Check more platforms for better distribution
                let spawnChance = 0.4; // Base 40% chance per platform
                
                // Even distribution across all sections
                const sectionProgress = i / totalPlatforms;
                if (sectionProgress <= 0.33) {
                    spawnChance = 0.5; // Beginning section
                } else if (sectionProgress <= 0.66) {
                    spawnChance = 0.6; // Middle section
                } else {
                    spawnChance = 0.7; // End section
                }
                
                // Increase spawn chance based on level difficulty
                spawnChance += levelNum * 0.05; // +5% per level for more balanced progression
                spawnChance = Math.min(spawnChance, 0.85); // Cap at 85% for better distribution
                
                console.log('🎲 PLATFORM SPAWN CHECK! Platform', i, 'Spawn Chance:', spawnChance.toFixed(2), 'Random:', Math.random().toFixed(2));
                if (Math.random() < spawnChance) {
                    console.log('✅ SPAWN CHANCE PASSED! Platform', i, 'will spawn enemy');
                    const platform = platforms[i];
                    
                    // Check distance from player starting position (240, ~1170)
                    const playerStartX = 240;
                    const playerStartY = 1170; // Approximate player Y position on starting platform
                    const enemySpawnX = platform.x + 72;
                    const enemySpawnY = platform.y;
                    
                    const distanceFromPlayer = Math.sqrt(
                        Math.pow(enemySpawnX - playerStartX, 2) + 
                        Math.pow(enemySpawnY - playerStartY, 2)
                    );
                    
                    // Additional check: prevent spawning on the starting platform itself
                    const startingPlatform = platforms.find(p => p.x === 0 && p.y === 1320);
                    if (startingPlatform && platform === startingPlatform) {
                        console.log('🚫 STARTING PLATFORM DETECTED! Skipping enemy spawn');
                        continue; // Skip the starting platform entirely
                    }
                    
                    if (distanceFromPlayer < 150) {
                        console.log('🚫 ENEMY TOO CLOSE TO PLAYER! Distance:', distanceFromPlayer.toFixed(0), 'px, Skipping spawn');
                        continue; // Skip this platform
                    }
                    
                    // Check if this platform is suitable for enemies
                    const isUnderwaterPlatform = platform.type === 'underwater';
                    const hasSolidGround = platform.y >= 1100 || // Platform is near ground level
                                          platform.isGroundExtension || // Platform is a ground extension
                                          platform.type === 'ground'; // Platform is ground type
                    
                    // Skip spawning enemies in lava areas on boss levels (but allow some platforms for wizgators)
                    if (game.bossActive && platform.y > game.lavaLevel - 100) {
                        console.log('🌋 LAVA PLATFORM DETECTED! Platform Y:', platform.y, 'Lava Level:', game.lavaLevel);
                        // Allow 20% of lava-adjacent platforms for potential wizgator spawning
                        if (Math.random() > 0.2) {
                            console.log('🌋 SKIPPING LAVA PLATFORM');
                            continue; // Skip most platforms near lava on boss levels
                        } else {
                            console.log('🌋 ALLOWING LAVA PLATFORM FOR WIZGATOR');
                        }
                    }
                    
                    // Spawn enemies on underwater platforms, solid ground, or easily reachable platforms
                    if (!hasSolidGround && !isUnderwaterPlatform && platform.y < 1000) {
                        console.log('🚫 SKIPPING HIGH PLATFORM! Platform Y:', platform.y, 'Has Solid Ground:', hasSolidGround, 'Is Underwater:', isUnderwaterPlatform);
                        continue; // Skip floating platforms that are too high (unless underwater)
                    }
                    
                    // Increase spawn chance for underwater platforms
                    if (isUnderwaterPlatform) {
                        spawnChance += 0.3; // +30% bonus for underwater platforms
                        spawnChance = Math.min(spawnChance, 0.98); // Cap at 98%
                    }
                    
                    // Choose enemy type based on level and position
                    let enemyType = 'basic';
                    
                    // Balanced enemy type selection based on level
                    if (levelNum >= 6 && Math.random() < 0.25) {
                        enemyType = 'shooter';
                    } else if (levelNum >= 4 && Math.random() < 0.2) {
                        enemyType = 'charger';
                    } else if (levelNum >= 3 && Math.random() < 0.3) {
                        enemyType = 'eagle';
                    } else if (levelNum >= 2 && Math.random() < 0.25) {
                        enemyType = 'gator';
                    } else if (levelNum >= 4 && Math.random() < 0.15) {
                        enemyType = 'wizgator';
                    } else if (levelNum >= 2 && Math.random() < 0.4) {
                        enemyType = 'shark';
                    }
                    
                    // Prevent eagles from spawning on underwater platforms
                    if (enemyType === 'eagle' && platform.y > 1200) {
                        console.log('🦅 Skipping underwater platform for eagle - platform Y:', platform.y, 'water level:', game.waterLevel);
                        continue; // Skip this platform for eagles
                    }
                    
                    // Prevent sharks from spawning on boss levels (lava levels)
                    if (enemyType === 'shark' && game.bossActive) {
                        console.log('🦈 Skipping shark spawn on boss level - sharks only spawn in water levels');
                        continue; // Skip shark spawning on boss levels
                    }
                    

                    
                    const enemyConfig = enemyTypes[enemyType];
                    const enemy = {
                        x: platform.x + 72,
                        y: platform.y - enemyConfig.height, // Position on top of platform
                        width: enemyConfig.width,
                        height: enemyConfig.height,
                        velX: enemyConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: enemyConfig.type,
                        health: enemyConfig.health,
                        ...enemyConfig
                    };
                    
                    // Ensure enemy is properly positioned on top of the platform
                    enemy.y = platform.y - enemy.height;
                    
                    // Additional safety check: ensure enemy is not floating above platform
                    if (enemy.y < platform.y - enemy.height - 5) {
                        enemy.y = platform.y - enemy.height;
                    }
                    
                    // Debug: Log enemy positioning and health
                    console.log(`Enemy spawned: type=${enemy.type}, health=${enemy.health}, at y=${enemy.y}, platform at y=${platform.y}, enemy height=${enemy.height}, platform type=${platform.type}, collisionBox=${enemy.collisionWidth}x${enemy.collisionHeight}, offset=(${enemy.collisionOffsetX},${enemy.collisionOffsetY})`);
                    
                    // Special debug for eagles
                    if (enemy.type === 'eagle') {
                        console.log('🦅 EAGLE SPAWNED! Position:', enemy.x, enemy.y, 'Platform Y:', platform.y, 'Water Level:', game.waterLevel, 'Level:', levelNum);
                    }
                    
                    // Add type-specific properties
                    if (enemyType === 'eagle') {
                        enemy.y = platform.y - 200; // Fly above platforms
                        enemy.sineOffset = Math.random() * Math.PI * 2;
                        enemy.originalY = enemy.y;
                        enemy.originalPatrolY = enemy.y; // Store original patrol height
                        enemy.originalSpawnY = enemy.y; // Store original spawn position for retreat
                        enemy.originalSpawnX = enemy.x; // Store original spawn X position for retreat
                    } else if (enemyType === 'charger') {
                        enemy.lastChargeTime = 0;
                    } else if (enemyType === 'shooter') {
                        enemy.lastShot = 0;
                        enemy.canShoot = true;
                        enemy.shotCooldown = 2000 + Math.random() * 1000; // 2-3 seconds between shots
                        console.log('🔫 SHOOTER CRAB SPAWNED! Position:', enemy.x, enemy.y, 'Level:', levelNum);
                    } else if (enemyType === 'gator') {
                        // Position gator on water surface
                        enemy.y = game.waterLevel - enemy.height + 20; // Sit on water surface
                        enemy.originalX = enemy.x; // Store original position for patrol
                        enemy.patrolDirection = Math.random() < 0.5 ? 1 : -1;
                        enemy.isChasing = false; // Ensure chase state is initialized
                        enemy.chaseStartTime = 0; // Initialize chase timer
                        
                        console.log('🐊 GATOR SPAWNED! Position:', enemy.x, enemy.y, 'Water Level:', game.waterLevel, 'Level:', levelNum);
                    } else if (enemyType === 'wizgator') {
                        // Position wizgator on water/lava surface
                        enemy.y = game.waterLevel - enemy.height + 20; // Sit on water/lava surface
                        enemy.originalX = enemy.x; // Store original position for patrol
                        enemy.patrolDirection = Math.random() < 0.5 ? 1 : -1;
                        enemy.isChasing = false; // Ensure chase state is initialized
                        enemy.chaseStartTime = 0; // Initialize chase timer
                        enemy.lastShot = 0; // Initialize shooting timer
                        
                        console.log('🔮 WIZGATOR SPAWNED! Position:', enemy.x, enemy.y, 'Surface Level:', game.waterLevel, 'Level:', levelNum, game.bossActive ? '(Boss Level - Lava)' : '(Water)');
                        console.log('🔮 WIZGATOR ADDED TO ENEMIES ARRAY! Total enemies:', enemies.length);
                                            } else if (enemyType === 'goldfish') {
                            // Set goldfish level for proper speed scaling
                            enemy.level = levelNum;
                            
                            // Enable shooting for goldfish at level 5+
                            if (levelNum >= 5) {
                                enemy.canShoot = true;
                                enemy.lastShot = 0;
                                enemy.shotCooldown = 3000 + Math.random() * 1000; // 3-4 seconds between shots
                                console.log('🔫 SHOOTING GOLDFISH SPAWNED! Position:', enemy.x, enemy.y, 'Level:', levelNum);
                            }
                        } else if (enemyType === 'shark') {
                            // Position shark underwater
                            enemy.y = game.waterLevel + 100 + Math.random() * 200; // Swim underwater at varying depths
                            enemy.sineOffset = Math.random() * Math.PI * 2;
                            enemy.originalY = enemy.y;
                            enemy.originalPatrolY = enemy.y; // Store original patrol depth
                            
                            console.log('🦈 SHARK SPAWNED! Position:', enemy.x, enemy.y, 'Water Level:', game.waterLevel, 'Level:', levelNum);
                        }
                    
                    enemies.push(enemy);
                }
            }
            
            // Ensure minimum enemy count for higher levels
            const currentEnemyCount = enemies.length;
            const minimumEnemies = Math.max(8, Math.floor(levelNum * 2)); // At least 8 enemies, or 2 per level
            
            if (currentEnemyCount < minimumEnemies) {
                console.log('⚠️ Not enough enemies spawned! Current:', currentEnemyCount, 'Minimum:', minimumEnemies);
                
                // Force spawn additional enemies on suitable platforms
                const suitablePlatforms = platforms.filter(p => 
                    p.y >= 1000 || p.type === 'underwater' || p.type === 'ground' || p.isGroundExtension
                );
                
                const additionalEnemiesNeeded = minimumEnemies - currentEnemyCount;
                for (let i = 0; i < additionalEnemiesNeeded && i < suitablePlatforms.length; i++) {
                    const platform = suitablePlatforms[i];
                    
                    // Check distance from player starting position for forced spawns too
                    const playerStartX = 240;
                    const playerStartY = 1170;
                    const enemySpawnX = platform.x + 72;
                    const enemySpawnY = platform.y;
                    
                    const distanceFromPlayer = Math.sqrt(
                        Math.pow(enemySpawnX - playerStartX, 2) + 
                        Math.pow(enemySpawnY - playerStartY, 2)
                    );
                    
                    // Additional check: prevent spawning on the starting platform itself
                    const startingPlatform = platforms.find(p => p.x === 0 && p.y === 1320);
                    if (startingPlatform && platform === startingPlatform) {
                        console.log('🚫 FORCED ENEMY: STARTING PLATFORM DETECTED! Skipping forced spawn');
                        continue; // Skip the starting platform entirely
                    }
                    
                    if (distanceFromPlayer < 150) {
                        console.log('🚫 FORCED ENEMY TOO CLOSE TO PLAYER! Distance:', distanceFromPlayer.toFixed(0), 'px, Skipping forced spawn');
                        continue; // Skip this platform
                    }
                    const enemyType = 'basic'; // Use basic enemies for guaranteed spawns
                    const enemyConfig = enemyTypes[enemyType];
                    
                    const enemy = {
                        x: platform.x + 72,
                        y: platform.y - enemyConfig.height,
                        width: enemyConfig.width,
                        height: enemyConfig.height,
                        velX: enemyConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: enemyConfig.type,
                        health: enemyConfig.health,
                        ...enemyConfig
                    };
                    
                    enemies.push(enemy);
                    console.log('⚠️ FORCED ENEMY SPAWN! Type:', enemyType, 'Platform:', platform.x, platform.y);
                }
            }
            
            // GUARANTEED EAGLE SPAWN - Force at least one eagle on every level
            const currentEagleCount = enemies.filter(e => e.type === 'eagle').length;
            if (currentEagleCount === 0) {
                console.log('🦅 No eagles found, forcing eagle spawn!');
                
                // Find a suitable platform for the eagle (middle section)
                const middleStart = Math.floor(platforms.length * 0.3);
                const middleEnd = Math.floor(platforms.length * 0.7);
                
                for (let i = middleStart; i < middleEnd; i++) {
                    if (i >= 0 && i < platforms.length) {
                        const platform = platforms[i];
                        
                        // Check if platform is suitable for eagle (not underwater)
                        if (platform.y < 1200 && platform.width > 100) {
                            console.log('🦅 Found suitable platform for guaranteed eagle - platform Y:', platform.y, 'water level:', game.waterLevel);
                            const eagleConfig = enemyTypes.eagle;
                            const eagle = {
                                x: platform.x + platform.width / 2,
                                y: platform.y - 200, // Fly above platform
                                width: eagleConfig.width,
                                height: eagleConfig.height,
                                velX: eagleConfig.speed,
                                direction: Math.random() < 0.5 ? 1 : -1,
                                type: 'eagle',
                                health: eagleConfig.health,
                                canFly: true,
                                diveSpeed: 2.2,
                                diveRange: 300,
                                sineOffset: Math.random() * Math.PI * 2,
                                originalY: platform.y - 200,
                                originalPatrolY: platform.y - 200, // Store original patrol height
                                isAttacking: false,
                                targetPlayer: false,
                                isFlyingBack: false,
                                originalYSet: false,
                                collisionWidth: 90,
                                collisionHeight: 70,
                                collisionOffsetX: 4,
                                collisionOffsetY: 4
                            };
                            
                            enemies.push(eagle);
                            console.log('🦅 FORCED EAGLE SPAWNED! Position:', eagle.x, eagle.y, 'Level:', levelNum);
                            break; // Only spawn one guaranteed eagle
                        }
                    }
                }
            }
            
            // 🦈 GUARANTEED SHARK SPAWN - Exactly 4 sharks equally spaced in water per level
            const currentSharkCount = enemies.filter(e => e.type === 'shark').length;
            const targetSharkCount = 4; // Exactly 4 sharks per level
            
            if (currentSharkCount < targetSharkCount && !game.bossActive) {
                console.log('🦈 Generating', targetSharkCount - currentSharkCount, 'equally spaced sharks for level', levelNum);
                
                // Calculate level width for equal spacing
                const levelWidth = Math.max(...platforms.map(p => p.x + p.width));
                const sharkSpacing = levelWidth / (targetSharkCount + 1); // +1 to avoid edges
                
                for (let i = currentSharkCount; i < targetSharkCount; i++) {
                    // Calculate equally spaced X position
                    const sharkX = sharkSpacing * (i + 1);
                    
                    // Vary the depth for each shark
                    const sharkDepth = game.waterLevel + 100 + (i * 50) + Math.random() * 100;
                    
                    const sharkConfig = enemyTypes.shark;
                    const shark = {
                        x: sharkX,
                        y: sharkDepth,
                        width: sharkConfig.width,
                        height: sharkConfig.height,
                        velX: sharkConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'shark',
                        health: sharkConfig.health,
                        canSwim: true,
                        isUnderwater: true,
                        diveSpeed: 2.5,
                        diveRange: 400,
                        sineOffset: Math.random() * Math.PI * 2,
                        originalY: sharkDepth,
                        originalPatrolY: sharkDepth,
                        isAttacking: false,
                        targetPlayer: false,
                        isSwimmingBack: false,
                        originalYSet: false,
                        isRetreating: false,
                        retreatStartTime: undefined,
                        isBackingAway: false,
                        backAwayStartTime: undefined,
                        backAwayDirection: undefined,
                        attackCooldown: false,
                        collisionWidth: 110,
                        collisionHeight: 50,
                        collisionOffsetX: 5,
                        collisionOffsetY: 5
                    };
                    
                    enemies.push(shark);
                    console.log('🦈 EQUALLY SPACED SHARK SPAWNED! Position:', shark.x, shark.y, 'Water Level:', game.waterLevel, 'Level:', levelNum, 'Shark #', i + 1, 'of 4');
                }
            }
            
            // CLOUD EAGLE GENERATION - Add eagles specifically in cloud areas
            const cloudEagleCount = Math.min(3 + Math.floor(levelNum / 1.5), 8); // 3-8 eagles in clouds
            console.log('🦅 Generating', cloudEagleCount, 'cloud eagles for level', levelNum);
            
            // 🐊 GUARANTEED GATOR SPAWN - Force at least 2-4 gators on every level
            const guaranteedGatorCount = Math.min(2 + Math.floor(levelNum / 3), 6); // 2-6 gators guaranteed
            console.log('🐊 Generating', guaranteedGatorCount, 'guaranteed gators for level', levelNum);
            
            for (let i = 0; i < cloudEagleCount; i++) {
                // Find cloud platforms
                const cloudPlatforms = platforms.filter(p => p.type === 'cloud');
                
                if (cloudPlatforms.length > 0) {
                    // Pick a random cloud platform
                    const cloudPlatform = cloudPlatforms[Math.floor(Math.random() * cloudPlatforms.length)];
                    
                    const eagleConfig = enemyTypes.eagle;
                    const cloudEagle = {
                        x: cloudPlatform.x + cloudPlatform.width / 2,
                        y: cloudPlatform.y - 100, // Fly just above the cloud
                        width: eagleConfig.width,
                        height: eagleConfig.height,
                        velX: eagleConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'eagle',
                        health: eagleConfig.health,
                        canFly: true,
                        diveSpeed: 2.2,
                        diveRange: 300, // 300px detection range
                        sineOffset: Math.random() * Math.PI * 2,
                        originalY: cloudPlatform.y - 100,
                        originalPatrolY: cloudPlatform.y - 100, // Store original patrol height
                        isAttacking: false,
                        targetPlayer: false,
                        isFlyingBack: false,
                        originalYSet: false,
                        collisionWidth: 90,
                        collisionHeight: 70,
                        collisionOffsetX: 4,
                        collisionOffsetY: 4,
                        isCloudEagle: true // Mark as cloud eagle
                    };
                    
                    enemies.push(cloudEagle);
                    console.log('🦅 CLOUD EAGLE SPAWNED! Position:', cloudEagle.x, cloudEagle.y, 'Above cloud at:', cloudPlatform.x, cloudPlatform.y, 'Level:', levelNum);
                }
            }
            
            // 🐊 GUARANTEED GATOR SPAWNING - Add gators specifically in water areas (skip on boss levels)
            if (!game.bossActive) {
                for (let i = 0; i < guaranteedGatorCount; i++) {
                // Find a suitable position near water
                const waterAreaX = 800 + i * 600 + Math.random() * 400; // Spread gators across the level
                const waterAreaY = game.waterLevel - 80; // Position on water surface
                
                // Check if this area is suitable (not too close to other enemies)
                const isAreaClear = !enemies.some(enemy => 
                    Math.abs(enemy.x - waterAreaX) < 200 && Math.abs(enemy.y - waterAreaY) < 100
                );
                
                if (isAreaClear) {
                    const gatorConfig = enemyTypes.gator;
                    const guaranteedGator = {
                        x: waterAreaX,
                        y: waterAreaY,
                        width: gatorConfig.width,
                        height: gatorConfig.height,
                        velX: gatorConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'gator',
                        health: gatorConfig.health,
                        canSwim: true,
                        isOnWaterSurface: true,
                        chaseRange: 300,
                        chaseSpeed: gatorConfig.chaseSpeed,
                        chaseDuration: 1500,
                        isChasing: false,
                        chaseStartTime: 0,
                        collisionWidth: 110,
                        collisionHeight: 70,
                        collisionOffsetX: 5,
                        collisionOffsetY: 5,
                        originalX: waterAreaX,
                        patrolDirection: Math.random() < 0.5 ? 1 : -1,
                        isChasing: false,
                        chaseStartTime: 0
                    };
                    
                    // Enable shooting for guaranteed gators at level 5+
                    if (levelNum >= 5) {
                        guaranteedGator.canShoot = true;
                        guaranteedGator.lastShot = 0;
                        guaranteedGator.shotCooldown = 2500 + Math.random() * 1000;
                        console.log('🔫 SHOOTING GUARANTEED GATOR SPAWNED! Position:', guaranteedGator.x, guaranteedGator.y, 'Level:', levelNum);
                    }
                    
                    enemies.push(guaranteedGator);
                    console.log('🐊 GUARANTEED GATOR SPAWNED! Position:', guaranteedGator.x, guaranteedGator.y, 'Level:', levelNum);
                }
            }
            } // Close the if (!game.bossActive) block for guaranteed gators
            
            // Add extra enemies throughout the level for more challenge
            const extraEnemyCount = Math.min(5 + Math.floor(levelNum * 2), 12); // More extra enemies
            
            for (let i = 0; i < extraEnemyCount; i++) {
                // Pick a random platform from the middle and end sections
                const startIndex = Math.floor(platforms.length * 0.2); // Start from 20% into the level
                const endIndex = platforms.length - 2; // Don't place on last 2 platforms
                const randomIndex = startIndex + Math.floor(Math.random() * (endIndex - startIndex));
                
                if (randomIndex >= 0 && randomIndex < platforms.length) {
                    const platform = platforms[randomIndex];
                    
                    // Check if this platform has solid ground beneath it or is easily reachable
                    const hasSolidGround = platform.y >= 1100 || // Platform is near ground level
                                          platform.isGroundExtension || // Platform is a ground extension
                                          platform.type === 'ground'; // Platform is ground type
                    
                    // Only spawn enemies on platforms with solid ground or that are easily reachable
                    if (!hasSolidGround && platform.y < 1000) {
                        continue; // Skip floating platforms that are too high
                    }
                    
                    const enemyWidth = 60;
                    const enemyHeight = 50;
                    const enemyX = platform.x + 72 + Math.random() * (platform.width - 144);
                    let enemyY = platform.y - enemyHeight; // Position on top of platform
                    
                    // Ensure enemy is properly positioned on top of the platform
                    enemyY = platform.y - enemyHeight;
                    
                    enemies.push({
                        x: enemyX,
                        y: enemyY,
                        width: enemyWidth,
                        height: enemyHeight,
                        velX: enemySpeed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'crab',
                        health: 1, // Add missing health property
                        canShoot: levelNum >= 5, // Enable shooting from level 5
                        lastShot: 0,
                        shotCooldown: 2000 + Math.random() * 1000, // 2-3 seconds between shots
                        collisionWidth: 50, // Match the updated collision box size
                        collisionHeight: 40, // Match the updated collision box size
                        collisionOffsetX: 5, // Match the updated offset
                        collisionOffsetY: 5 // Match the updated offset
                    });
                    console.log(`Extra enemy spawned: type=crab, health=1, collisionBox=50x40, offset=(5,5)`);
                }
            }
            
            // Add extra enemies specifically at the very end of the level
            const finalPlatforms = platforms.slice(-4); // Last 4 platforms
            const finalEnemyCount = Math.min(4 + Math.floor(levelNum), 10); // 4-10 extra enemies based on level
            
            for (let i = 0; i < finalEnemyCount; i++) {
                if (finalPlatforms.length > 0) {
                    const platform = finalPlatforms[Math.floor(Math.random() * finalPlatforms.length)];
                    
                    // Check if this platform has solid ground beneath it or is easily reachable
                    const hasSolidGround = platform.y >= 1100 || // Platform is near ground level
                                          platform.isGroundExtension || // Platform is a ground extension
                                          platform.type === 'ground'; // Platform is ground type
                    
                    // Only spawn enemies on platforms with solid ground or that are easily reachable
                    if (!hasSolidGround && platform.y < 1000) {
                        continue; // Skip floating platforms that are too high
                    }
                    
                    const enemyWidth = 60;
                    const enemyHeight = 50;
                    const enemyX = platform.x + 72 + Math.random() * (platform.width - 144);
                    let enemyY = platform.y - enemyHeight; // Position on top of platform
                    
                    // Ensure enemy is properly positioned on top of the platform
                    enemyY = platform.y - enemyHeight;
                    
                    enemies.push({
                        x: enemyX,
                        y: enemyY,
                        width: enemyWidth,
                        height: enemyHeight,
                        velX: enemySpeed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'crab',
                        health: 1, // Add missing health property
                        canShoot: levelNum >= 5, // Enable shooting from level 5
                        lastShot: 0,
                        shotCooldown: 2000 + Math.random() * 1000, // 2-3 seconds between shots
                        collisionWidth: 50, // Match the updated collision box size
                        collisionHeight: 40, // Match the updated collision box size
                        collisionOffsetX: 5, // Match the updated offset
                        collisionOffsetY: 5 // Match the updated offset
                    });
                    console.log(`Final enemy spawned: type=crab, health=1, collisionBox=50x40, offset=(5,5)`);
                }
            }
            
            // 🐠 GOLDFISH ENEMY GENERATION - Spawn underwater enemies (skip on boss levels)
            if (!game.bossActive) {
                const goldfishCount = Math.min(8 + Math.floor(levelNum * 2), 25); // 8-25 goldfish per level, scales aggressively
                console.log('🐠 Generating', goldfishCount, 'goldfish enemies for level', levelNum);
                
                for (let i = 0; i < goldfishCount; i++) {
                // Find underwater platforms (below water level)
                const underwaterPlatforms = platforms.filter(p => p.y > game.waterLevel + 200);
                
                if (underwaterPlatforms.length > 0) {
                    // Pick a random underwater platform
                    const underwaterPlatform = underwaterPlatforms[Math.floor(Math.random() * underwaterPlatforms.length)];
                    
                    const goldfishConfig = enemyTypes.goldfish;
                    
                    // Progressive difficulty scaling (no size changes)
                    const speedMultiplier = 1 + (levelNum - 1) * 0.2; // 20% faster each level
                    const healthMultiplier = Math.min(1 + Math.floor(levelNum / 3), 3); // Extra health every 3 levels, max 3x
                    
                    const goldfish = {
                        x: underwaterPlatform.x + Math.random() * underwaterPlatform.width,
                        y: game.waterLevel + 150 + Math.random() * 300, // Random depth in water
                        width: goldfishConfig.width, // Fixed size - no scaling
                        height: goldfishConfig.height, // Fixed size - no scaling
                        velX: goldfishConfig.speed * speedMultiplier, // Faster fish in higher levels
                        velY: (Math.random() - 0.5) * 3 * speedMultiplier, // More erratic vertical movement
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: 'goldfish',
                        health: Math.floor(goldfishConfig.health * healthMultiplier), // More health in higher levels
                        canSwim: true,
                        swimSpeed: goldfishConfig.swimSpeed * speedMultiplier,
                        collisionWidth: goldfishConfig.collisionWidth, // Fixed collision size
                        collisionHeight: goldfishConfig.collisionHeight, // Fixed collision size
                        collisionOffsetX: goldfishConfig.collisionOffsetX,
                        collisionOffsetY: goldfishConfig.collisionOffsetY,
                        isUnderwater: true,
                        level: levelNum, // Store level for difficulty tracking
                        speedMultiplier: speedMultiplier
                    };
                    
                    enemies.push(goldfish);
                    console.log('🐠 GOLDFISH SPAWNED! Position:', goldfish.x, goldfish.y, 'Underwater near platform:', underwaterPlatform.x, underwaterPlatform.y, 'Level:', levelNum);
                }
            }
            } // Close the if (!game.bossActive) block for goldfish
            
            // 🦀 UNDERWATER CRAB GENERATION - Spawn extra crabs on underwater platforms (skip on boss levels)
            if (!game.bossActive) {
                const underwaterCrabCount = Math.min(6 + Math.floor(levelNum * 2), 20); // 6-20 underwater crabs per level
                console.log('🦀 Generating', underwaterCrabCount, 'underwater crabs for level', levelNum);
                
                for (let i = 0; i < underwaterCrabCount; i++) {
                // Find underwater platforms
                const underwaterPlatforms = platforms.filter(p => p.type === 'underwater');
                
                if (underwaterPlatforms.length > 0) {
                    // Pick a random underwater platform
                    const underwaterPlatform = underwaterPlatforms[Math.floor(Math.random() * underwaterPlatforms.length)];
                    
                    // Choose crab type (basic or shooter)
                    const isShooter = levelNum >= 5 && Math.random() < 0.4; // 40% chance for shooter crabs at level 5+
                    const crabType = isShooter ? 'shooter' : 'basic';
                    const crabConfig = enemyTypes[crabType];
                    
                    const underwaterCrab = {
                        x: underwaterPlatform.x + 72 + Math.random() * (underwaterPlatform.width - 144),
                        y: underwaterPlatform.y - crabConfig.height, // Position on top of underwater platform
                        width: crabConfig.width,
                        height: crabConfig.height,
                        velX: crabConfig.speed,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        type: crabConfig.type,
                        health: crabConfig.health,
                        collisionWidth: crabConfig.collisionWidth,
                        collisionHeight: crabConfig.collisionHeight,
                        collisionOffsetX: crabConfig.collisionOffsetX,
                        collisionOffsetY: crabConfig.collisionOffsetY,
                        isUnderwater: true
                    };
                    
                    // Add shooter properties if it's a shooter crab
                    if (isShooter) {
                        underwaterCrab.canShoot = true;
                        underwaterCrab.lastShot = 0;
                        underwaterCrab.shotCooldown = 2000 + Math.random() * 1000;
                        console.log('🔫 UNDERWATER SHOOTER CRAB SPAWNED! Position:', underwaterCrab.x, underwaterCrab.y, 'Level:', levelNum);
                    }
                    
                    enemies.push(underwaterCrab);
                    console.log('🦀 UNDERWATER CRAB SPAWNED! Position:', underwaterCrab.x, underwaterCrab.y, 'Platform Y:', underwaterPlatform.y, 'Level:', levelNum);
                }
            }
            } // Close the if (!game.bossActive) block for underwater crabs
            
            // Count eagles for debugging
            const eagleCount = enemies.filter(e => e.type === 'eagle').length;
            const totalGoldfishCount = enemies.filter(e => e.type === 'goldfish').length;
            const totalUnderwaterCrabCount = enemies.filter(e => e.type === 'crab' && e.isUnderwater).length;
            console.log(`🦅 Enemy generation complete: ${enemies.length} total enemies, ${eagleCount} eagles, ${totalGoldfishCount} goldfish, ${totalUnderwaterCrabCount} underwater crabs`);
            
            return enemies;
        }
        
        function generateCheckpoints(platforms, levelNum) {
            const checkpoints = [];
            
            // Filter for static platforms only (no moving or disappearing platforms)
            const staticPlatforms = platforms.filter(p => p.type !== 'linear' && p.type !== 'disappearing');
            
            if (staticPlatforms.length === 0) {
                console.log('No static platforms found for checkpoints');
                return checkpoints;
            }
            
            // Get the last platform (where goal flag is)
            const lastPlatform = platforms[platforms.length - 1];
            
            // Find the actual middle X position of the level
            const levelStartX = Math.min(...platforms.map(p => p.x));
            const levelEndX = Math.max(...platforms.map(p => p.x + p.width));
            const levelMiddleX = levelStartX + (levelEndX - levelStartX) / 2;
            
            console.log('Level X range:', levelStartX, 'to', levelEndX, 'Middle X:', levelMiddleX);
            
            // Find the static platform closest to the middle X position
            let closestPlatform = staticPlatforms[0];
            let closestDistance = Math.abs(levelMiddleX - (closestPlatform.x + closestPlatform.width / 2));
            
            for (let i = 0; i < staticPlatforms.length; i++) {
                const platform = staticPlatforms[i];
                const platformCenterX = platform.x + platform.width / 2;
                const distance = Math.abs(levelMiddleX - platformCenterX);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPlatform = platform;
                }
            }
                
                // Double-check that this platform is not too close to the goal
            const distanceToGoal = lastPlatform.x - closestPlatform.x;
            if (distanceToGoal > 800) { // Increased minimum distance to ensure it's not too close to end
                    checkpoints.push({
                    x: closestPlatform.x + closestPlatform.width / 2,
                    y: closestPlatform.y - 120, // Adjusted for 2x bigger checkpoint (was 60)
                    width: 80, // Updated to match the 2x bigger size
                    height: 120, // Updated to match the 2x bigger size
                        activated: false,
                    platform: closestPlatform
                    });
                console.log('Checkpoint placed at true middle X position:', closestPlatform.x, closestPlatform.y, 'Distance to goal:', distanceToGoal, 'Level middle X was:', levelMiddleX);
                } else {
                    console.log('Skipping checkpoint placement - too close to goal (distance:', distanceToGoal, ')');
            }
            
            return checkpoints;
        }
        
        function generateBreakableTiles(platforms, levelNum) {
            const breakables = [];
            // Generate exactly 5 breakable walls per level
            const breakableCount = 5;
            
            // Filter out platforms in lava areas
            const safePlatforms = platforms.filter(p => !game.bossActive || p.y < game.lavaLevel - 100);
            
            for (let i = 0; i < breakableCount; i++) {
                if (safePlatforms.length === 0) break; // No safe platforms available
                
                const platform = safePlatforms[Math.floor(Math.random() * safePlatforms.length)];
                if (platform && platform.width > 100) {
                    // Determine reward type for this breakable tile
                    const rewardTypes = ['mushroom', 'health'];
                    const rewardType = rewardTypes[Math.floor(Math.random() * rewardTypes.length)];
                    
                    breakables.push({
                        x: platform.x + Math.random() * (platform.width - 50),
                        y: platform.y - 50,
                        width: 50,
                        height: 50,
                        broken: false,
                        health: 3,
                        type: 'breakable',
                        reward: rewardType // Add reward type to the tile
                    });
                }
            }
            
            console.log(`🧱 Generated ${breakables.length} breakable walls for level ${levelNum} (lava-protected)`);
            return breakables;
        }
        
        function generateSecretRooms(levelNum) {
            const secretRooms = [];
            if (levelNum >= 3 && Math.random() < 0.3) { // 30% chance for secret room from level 3
                secretRooms.push({
                    x: 2000 + Math.random() * 1000,
                    y: 400 + Math.random() * 400,
                    width: 300,
                    height: 200,
                    discovered: false,
                    contains: Math.random() < 0.5 ? 'treasure' : 'mushroom',
                    parallaxLayer: 0.5
                });
            }
            
            return secretRooms;
        }
        
        function generateRandomCoins(platforms, levelNum) {
            const coins = [];
            
            // Generate exactly 100 coins per level
            const coinCount = 100;
            
            // Filter out platforms in lava areas
            const safePlatforms = platforms.filter(p => !game.bossActive || p.y < game.lavaLevel - 100);
            
            for (let i = 0; i < coinCount; i++) {
                if (safePlatforms.length === 0) break; // No safe platforms available
                
                // Place coins evenly across safe platforms
                const platform = safePlatforms[Math.floor(Math.random() * safePlatforms.length)];
                const coinX = platform.x + Math.random() * platform.width;
                const coinY = platform.y - 36 - Math.random() * 48; // Scaled from 15, 20 (15*2.4=36, 20*2.4=48)
                
                coins.push({
                    x: coinX,
                    y: coinY,
                    collected: false,
                    type: 'coin'
                });
            }
            
            console.log(`💰 Generated ${coins.length} coins for level ${levelNum} (lava-protected)`);
            return coins;
        }
        
        function generateRandomHealth(platforms, levelNum) {
            const health = [];
            
            // Score-based health system: 1 health for every 30,000 points
            const currentScore = game.score || 0;
            const healthThreshold = 30000;
            const healthCount = Math.floor(currentScore / healthThreshold);
            
            // Only spawn health if player has earned it through score AND it's an even-numbered level
            if (healthCount > 0 && levelNum % 2 === 0) {
                // Place health in difficult locations based on score
                let targetPlatforms;
                if (currentScore < 60000) {
                    // First health: medium difficulty
                    targetPlatforms = platforms.filter(p => p.y < 1080 && p.y > 840);
                } else if (currentScore < 120000) {
                    // Second health: high difficulty
                    targetPlatforms = platforms.filter(p => p.y < 840 && p.y > 600);
                } else {
                    // Third+ health: very high difficulty
                    targetPlatforms = platforms.filter(p => p.y < 600 && p.y > 360);
                }
            
            if (targetPlatforms.length > 0) {
                const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                const healthX = platform.x + Math.random() * platform.width;
                const healthY = platform.y - 48; // Scaled from 20 (20*2.4=48)
                
                health.push({
                    x: healthX,
                    y: healthY,
                    collected: false,
                    type: 'health'
                });
                    console.log(`❤️ Health pickup earned at ${currentScore} score on level ${levelNum}, placed at:`, healthX, healthY);
                }
            } else if (healthCount === 0) {
                console.log(`❤️ No health pickup - need ${healthThreshold - (currentScore % healthThreshold)} more points for next health`);
            } else if (levelNum % 2 !== 0) {
                console.log(`❤️ No health pickup - health only spawns on even-numbered levels (level ${levelNum} is odd)`);
            }
            
            return health;
        }
        
        function generateRandomArmor(platforms, levelNum) {
            const armor = [];
            
            // Base armor count - more armor on higher levels
            let baseArmorCount = 1;
            if (levelNum >= 5) baseArmorCount = 2;
            if (levelNum >= 10) baseArmorCount = 3;
            if (levelNum >= 15) baseArmorCount = 4;
            
            // Additional armor for exploration (hidden in secret areas)
            let hiddenArmorCount = 0;
            if (levelNum >= 3) hiddenArmorCount = 1;
            if (levelNum >= 7) hiddenArmorCount = 2;
            if (levelNum >= 12) hiddenArmorCount = 3;
            
            const totalArmorCount = baseArmorCount + hiddenArmorCount;
            
            console.log(`🛡️ Generating ${totalArmorCount} armor pickups for level ${levelNum} (${baseArmorCount} base + ${hiddenArmorCount} hidden)`);
            
            // Generate base armor pickups (accessible)
            for (let i = 0; i < baseArmorCount; i++) {
                let targetPlatforms;
                
                // Different difficulty tiers based on level
                if (levelNum <= 3) {
                    // Early levels: medium difficulty, spread across level
                    targetPlatforms = platforms.filter(p => p.y < 1080 && p.y > 840 && p.x > 500);
                } else if (levelNum <= 7) {
                    // Mid levels: high difficulty, further into level
                    targetPlatforms = platforms.filter(p => p.y < 840 && p.y > 600 && p.x > 800);
                } else {
                    // High levels: very high difficulty, deep into level
                    targetPlatforms = platforms.filter(p => p.y < 600 && p.y > 360 && p.x > 1200);
                }
                
                if (targetPlatforms.length > 0) {
                    const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                    const armorX = platform.x + Math.random() * platform.width;
                    const armorY = platform.y - 48; // Scaled from 20 (20*2.4=48)
                    
                    armor.push({
                        x: armorX,
                        y: armorY,
                        collected: false,
                        type: 'armor',
                        isHidden: false
                    });
                    console.log(`🛡️ Base armor pickup ${i + 1} placed on level ${levelNum} at:`, armorX, armorY);
                }
            }
            
            // Generate hidden armor pickups (in secret areas)
            for (let i = 0; i < hiddenArmorCount; i++) {
                let targetPlatforms;
                
                // Hidden armor in very difficult locations
                if (levelNum <= 5) {
                    // Early levels: hidden in high areas
                    targetPlatforms = platforms.filter(p => p.y < 600 && p.y > 400 && p.x > 1000);
                } else if (levelNum <= 10) {
                    // Mid levels: hidden in very high areas or underwater
                    targetPlatforms = platforms.filter(p => 
                        (p.y < 500 && p.y > 300 && p.x > 1200) || 
                        (p.type === 'underwater' && p.y > 1400 && p.x > 800)
                    );
                } else {
                    // High levels: hidden in extreme locations
                    targetPlatforms = platforms.filter(p => 
                        (p.y < 400 && p.y > 200 && p.x > 1500) || 
                        (p.type === 'underwater' && p.y > 1600 && p.x > 1000) ||
                        (p.type === 'cloud' && p.y < 300 && p.x > 1200)
                    );
                }
                
                if (targetPlatforms.length > 0) {
                    const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                    const armorX = platform.x + Math.random() * platform.width;
                    const armorY = platform.y - 48;
                    
                    armor.push({
                        x: armorX,
                        y: armorY,
                        collected: false,
                        type: 'armor',
                        isHidden: true,
                        hiddenType: platform.type === 'underwater' ? 'underwater' : 
                                   platform.type === 'cloud' ? 'cloud' : 'high'
                    });
                    console.log(`🛡️ Hidden armor pickup ${i + 1} placed on level ${levelNum} at:`, armorX, armorY, `(${platform.type} platform)`);
                }
            }
            
            // Add bonus armor for boss levels (every 5 levels)
            if (levelNum % 5 === 0) {
                const bossArmorCount = Math.floor(levelNum / 5); // More armor on higher boss levels
                for (let i = 0; i < bossArmorCount; i++) {
                    // Boss level armor near the boss platform
                    const bossPlatforms = platforms.filter(p => p.type === 'boss' || (p.x > 2000 && p.y < 1200));
                    if (bossPlatforms.length > 0) {
                        const platform = bossPlatforms[Math.floor(Math.random() * bossPlatforms.length)];
                        const armorX = platform.x + Math.random() * platform.width;
                        const armorY = platform.y - 48;
                        
                        armor.push({
                            x: armorX,
                            y: armorY,
                            collected: false,
                            type: 'armor',
                            isHidden: false,
                            isBossArmor: true
                        });
                        console.log(`🛡️ Boss level armor pickup ${i + 1} placed on level ${levelNum} at:`, armorX, armorY);
                    }
                }
            }
            
            console.log(`🛡️ Total armor pickups generated for level ${levelNum}:`, armor.length);
            return armor;
        }
        
        function generateRandomTreasures(platforms, levelNum) {
            const treasures = [];
            
            // Generate exactly 10 chests per level
            const treasureCount = 10;
            
            // Filter out platforms in lava areas - NEVER spawn chests in lava
            const safePlatforms = platforms.filter(p => !game.bossActive || p.y < game.lavaLevel - 100);
            
            for (let i = 0; i < treasureCount; i++) {
                if (safePlatforms.length === 0) break; // No safe platforms available
                
                // Place treasures evenly across safe platforms
                const platform = safePlatforms[Math.floor(Math.random() * safePlatforms.length)];
                    const treasureX = platform.x + Math.random() * platform.width;
                    const treasureY = platform.y - 60; // Scaled from 25 (25*2.4=60)
                    
                    treasures.push({
                        x: treasureX,
                        y: treasureY,
                        collected: false,
                        type: 'treasure',
                        value: 500 + Math.floor(Math.random() * 500) // 500-1000 points
                    });
                    
                console.log(`💎 Treasure chest ${i + 1} placed at:`, treasureX, treasureY, 'Level:', levelNum, '(lava-protected)');
            }
            
            // Add 1 golden chest on every level that requires a key
            if (platforms.length > 0) {
                // 🌊 HIGH PRIORITY: Find a suitable platform for the golden chest - heavily prefer water
                let targetPlatforms;
                
                // First, try to find water platforms (underwater platforms)
                let waterPlatforms = platforms.filter(p => p.type === 'underwater');
                console.log('🔑 Found', waterPlatforms.length, 'water platforms for golden chest placement');
                
                // Skip lava areas on boss levels
                if (game.bossActive) {
                    waterPlatforms = waterPlatforms.filter(p => p.y < game.lavaLevel - 100);
                    console.log('🔑 Filtered out lava areas, remaining water platforms:', waterPlatforms.length);
                }
                
                // Then, try to find cloud platforms
                let cloudPlatforms = platforms.filter(p => p.type === 'cloud');
                
                // 🌊 VERY HIGH PRIORITY: Use water platforms with 90% probability
                if (waterPlatforms.length > 0 && Math.random() < 0.9) {
                    targetPlatforms = waterPlatforms;
                    console.log('🔑 Golden chest will spawn in WATER area!');
                } else if (cloudPlatforms.length > 0 && Math.random() < 0.7) {
                    // Use cloud platforms with 70% probability if no water
                    targetPlatforms = cloudPlatforms;
                    console.log('🔑 Golden chest will spawn in cloud area!');
                } else {
                    // Fallback to regular platform selection - NEVER spawn in lava
                    if (levelNum === 1) {
                        // First level: place on any platform (but not in lava)
                        targetPlatforms = platforms.filter(p => p.y < 1200 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    } else if (levelNum <= 3) {
                        // Early levels: place on medium platforms (but not in lava)
                        targetPlatforms = platforms.filter(p => p.y < 1080 && p.y > 840 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    } else {
                        // Later levels: place on higher platforms for challenge (but not in lava)
                        targetPlatforms = platforms.filter(p => p.y < 960 && p.y > 672 && (!game.bossActive || p.y < game.lavaLevel - 100));
                    }
                }
                
                if (targetPlatforms.length > 0) {
                    const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                    const goldenChestX = platform.x + platform.width / 2; // Center on platform
                    const goldenChestY = platform.y - 76; // Sit on platform (doubled size: 38*2=76)
                
                treasures.push({
                        x: goldenChestX,
                        y: goldenChestY,
                    collected: false,
                    type: 'rareTreasure',
                        value: 2000 + Math.floor(Math.random() * 1000), // 2000-3000 points for golden chests
                        requiresKey: true, // New property to indicate key requirement
                        isGoldenChest: true // New property to identify golden chests
                });
                    
                    console.log('🔑 Golden chest placed on level', levelNum, 'at:', goldenChestX, goldenChestY, 'on platform:', platform.x, platform.y);
                }
            } else {
                console.log('🔑 No golden chest - no suitable platforms found for level', levelNum);
            }
            
            return treasures;
        }
        
        function generateRandomJetpacks(platforms, levelNum) {
            const jetpacks = [];
            
            // Add multiple jetpacks per level based on level difficulty
            const jetpackCount = Math.min(2 + Math.floor(levelNum / 2), 5); // 2-5 jetpacks per level
            
            console.log('🚀 Generating', jetpackCount, 'jetpacks for level', levelNum);
            
            for (let i = 0; i < jetpackCount; i++) {
                if (platforms.length > 0) {
                    // Different placement strategies for each jetpack
                    let targetPlatforms = [];
                    let placementType = '';
                    
                    if (i === 0) {
                        // First jetpack: early section (200-400px from start)
                        const earlyPlatforms = platforms.filter(p => 
                            p.x >= 200 && p.x <= 400 &&
                            (!game.bossActive || p.y < game.lavaLevel - 100)
                        );
                        
                        targetPlatforms = earlyPlatforms;
                        placementType = 'early-section';
                    } else if (i === 1) {
                        // Second jetpack: late section (900-1100px from start)
                        const latePlatforms = platforms.filter(p => 
                            p.x >= 900 && p.x <= 1100 &&
                            (!game.bossActive || p.y < game.lavaLevel - 100)
                        );
                        
                        targetPlatforms = latePlatforms;
                        placementType = 'late-section';
                    } else if (i === 2) {
                        // Third jetpack: higher up, mix of cloud and regular platforms
                        const highCloudPlatforms = platforms.filter(p => 
                            p.type === 'cloud' && 
                            p.y < game.waterLevel - 200
                        );
                        
                        const highRegularPlatforms = platforms.filter(p => 
                            p.y < game.waterLevel - 200 && 
                            p.type !== 'cloud' &&
                            p.type !== 'underwater'
                        );
                        
                        targetPlatforms = [...highCloudPlatforms, ...highRegularPlatforms];
                        placementType = 'high-mixed';
                    } else {
                        // Additional jetpacks: random placement across all platform types
                        targetPlatforms = platforms.filter(p => 
                            p.y < game.waterLevel - 100 || 
                            p.y > game.waterLevel + 200
                        );
                        placementType = 'random-mixed';
                    }
                    
                    // Fallback to any platform if no specific targets found
                    if (targetPlatforms.length === 0) {
                        targetPlatforms = platforms.filter(p => p.y < 1200);
                    }
                    
                    if (targetPlatforms.length > 0) {
                        const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                        const isUnderwater = platform.y > game.waterLevel + 200;
                        const isCloud = platform.type === 'cloud';
                        
                        let jetpackX, jetpackY;
                        
                        if (isUnderwater) {
                            // Place jetpack ON underwater platform (not floating in water)
                            jetpackX = platform.x + Math.random() * platform.width;
                            jetpackY = platform.y - 60; // ON the platform, just like regular platforms
                            console.log('🌊 Underwater jetpack', i+1, 'placed ON platform at:', jetpackX, jetpackY, 'Platform Y:', platform.y, '(', placementType, ')');
                        } else if (isCloud) {
                            // Place jetpack on cloud platform
                            jetpackX = platform.x + Math.random() * platform.width;
                            jetpackY = platform.y - 60; // Above the cloud
                            console.log('☁️ Cloud jetpack', i+1, 'placed at:', jetpackX, jetpackY, '(', placementType, ')');
                        } else {
                            // Place jetpack on regular platform
                            jetpackX = platform.x + Math.random() * platform.width;
                            jetpackY = platform.y - 60; // Above the platform
                            console.log('🚀 Regular jetpack', i+1, 'placed at:', jetpackX, jetpackY, '(', placementType, ')');
                        }
                        
                        // Check distance from existing jetpacks
                        let tooClose = false;
                        for (const existingJetpack of jetpacks) {
                            const distance = Math.sqrt(
                                Math.pow(jetpackX - existingJetpack.x, 2) + 
                                Math.pow(jetpackY - existingJetpack.y, 2)
                            );
                            if (distance < 500) {
                                console.log('🚫 Jetpack too close to existing jetpack! Distance:', distance.toFixed(0), 'px, Skipping spawn');
                                tooClose = true;
                                break;
                            }
                        }
                        
                        if (!tooClose) {
                            jetpacks.push({
                                x: jetpackX,
                                y: jetpackY,
                                collected: false,
                                type: 'jetpack'
                            });
                            console.log('✅ Jetpack', i+1, 'placed successfully at:', jetpackX, jetpackY, '(', placementType, ')');
                        } else {
                            console.log('⚠️ Skipping jetpack', i+1, 'due to proximity to existing jetpack');
                        }
                    }
                }
            }
            
            console.log('🚀 Generated', jetpacks.length, 'jetpacks for level', levelNum);
            return jetpacks;
        }
        
        function generateRandomHearts(platforms, levelNum) {
            const hearts = [];
            
            // Spawn 1 heart every 3 levels, starting from level 3
            if (levelNum >= 3 && levelNum % 3 === 0) {
                console.log('❤️ Generating heart for level', levelNum);
                
                // Place heart on a medium-height platform for accessibility
                const targetPlatforms = platforms.filter(p => 
                    p.y < 1080 && p.y > 960 && // Medium height platforms
                    p.type !== 'cloud' && // Not on cloud platforms
                    p.type !== 'underwater' // Not underwater
                );
                
                if (targetPlatforms.length > 0) {
                    const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                    const heartX = platform.x + Math.random() * platform.width;
                    const heartY = platform.y - 60; // Above the platform
                    
                    hearts.push({
                        x: heartX,
                        y: heartY,
                        collected: false,
                        type: 'heart'
                    });
                    
                    console.log('❤️ Heart placed at:', heartX, heartY, 'on platform Y:', platform.y);
                } else {
                    console.log('⚠️ No suitable platforms found for heart placement');
                }
            }
            
            return hearts;
        }
        
        function generateRandomMushrooms(platforms, levelNum) {
            const mushrooms = [];
            // Very rare - only 1 mushroom per 3 levels, starting from level 3
            if (levelNum >= 3 && levelNum % 3 === 0) {
                // Place mushroom on a medium-height platform for accessibility
                const targetPlatforms = platforms.filter(p => p.y < 1080 && p.y > 960); // Scaled from 450, 400 (450*2.4=1080, 400*2.4=960)
                
                if (targetPlatforms.length > 0) {
                    const platform = targetPlatforms[Math.floor(Math.random() * targetPlatforms.length)];
                    const mushroomX = platform.x + Math.random() * platform.width;
                    const mushroomY = platform.y - 60; // Scaled from 25 (25*2.4=60)
                    
                    mushrooms.push({
                        x: mushroomX,
                        y: mushroomY,
                        collected: false,
                        type: 'mushroom',
                        value: 1000 // 1000 points for mushroom
                    });
                }
            }
            
            return mushrooms;
        }
        
        // 🔫 LASER GENERATION FUNCTION - FIXED VERSION
        function generateRandomLasers(platforms, levelNum) {
            const laserPowerups = [];
            
            // Debug logging to check if function is called
            console.log('🔫 generateRandomLasers called for level:', levelNum, 'with platforms:', platforms.length);

            // FORCE laser to spawn on EVERY level - GUARANTEED
            if (platforms.length > 0) {
                // Place laser in the early-middle section of the level (300-600px from start)
                let targetPlatform = platforms[0];
                for (let i = 0; i < platforms.length; i++) {
                    const platform = platforms[i];
                    if (platform.x >= 300 && platform.x <= 600) {
                        targetPlatform = platform;
                        break;
                    }
                }
                
                const laserX = targetPlatform.x + targetPlatform.width / 2; // Center of platform
                const laserY = targetPlatform.y - 40; // 40 pixels above platform
                
                laserPowerups.push({
                    x: laserX,
                    y: laserY,
                    collected: false,
                    type: 'laser'
                });
                
                console.log('🔫 FORCED Laser placed at position:', laserX, laserY, 'on platform at:', targetPlatform.x, targetPlatform.y);
            } else {
                console.warn('🔫 No platforms available for laser placement!');
            }
            
            console.log('🔫 Generated', laserPowerups.length, 'laser items for level', levelNum);
            return laserPowerups;
        }
        
        // 🔥 FIREBALL GENERATION FUNCTION
        function generateRandomFireballs(platforms, levelNum) {
            const fireballPowerups = [];
            
            console.log('🔥 generateRandomFireballs called for level:', levelNum, 'with platforms:', platforms.length);

            // FORCE fireball to spawn on EVERY level - GUARANTEED
            if (platforms.length > 0) {
                // Place fireball in the middle-late section of the level (600-900px from start)
                let targetPlatform = platforms[0];
                for (let i = 0; i < platforms.length; i++) {
                    const platform = platforms[i];
                    if (platform.x >= 600 && platform.x <= 900) {
                        targetPlatform = platform;
                        break;
                    }
                }
                
                const fireballX = targetPlatform.x + targetPlatform.width / 2;
                const fireballY = targetPlatform.y - 40;
                
                fireballPowerups.push({
                    x: fireballX,
                    y: fireballY,
                    collected: false,
                    type: 'fireball'
                });
                
                console.log('🔥 FORCED Fireball placed at position:', fireballX, fireballY, 'on platform at:', targetPlatform.x, targetPlatform.y);
            } else {
                console.warn('🔥 No platforms available for fireball placement!');
            }
            
            console.log('🔥 Generated', fireballPowerups.length, 'fireball items for level', levelNum);
            return fireballPowerups;
        }
        
        function getLevelTheme(levelNum) {
            const themes = [
                {
                    name: "Sunny Shores",
                    skyColors: ['#87CEEB', '#98FB98'],
                    groundColor: '#228B22',
                    platformColor: '#654321'
                },
                {
                    name: "Sunset Cliffs", 
                    skyColors: ['#FF6B35', '#F7931E'],
                    groundColor: '#D2691E',
                    platformColor: '#8B4513'
                },
                {
                    name: "Moonlit Waters",
                    skyColors: ['#2C3E50', '#34495E'],
                    groundColor: '#1B4F72',
                    platformColor: '#566573'
                },
                {
                    name: "Storm Peaks",
                    skyColors: ['#34495E', '#2C3E50'],
                    groundColor: '#5D4E75',
                    platformColor: '#85929E'
                },
                {
                    name: "Crystal Caves",
                    skyColors: ['#8E44AD', '#3498DB'],
                    groundColor: '#9B59B6',
                    platformColor: '#A569BD'
                },
                {
                    name: "Lava Lands",
                    skyColors: ['#E74C3C', '#C0392B'],
                    groundColor: '#E67E22',
                    platformColor: '#D35400'
                },
                {
                    name: "Ice Fields",
                    skyColors: ['#EBF5FB', '#AED6F1'],
                    groundColor: '#5DADE2',
                    platformColor: '#85C1E9'
                },
                {
                    name: "Alien World",
                    skyColors: ['#1ABC9C', '#16A085'],
                    groundColor: '#27AE60',
                    platformColor: '#2ECC71'
                }
            ];
            
            return themes[(levelNum - 1) % themes.length];
        }
        
        function generateLevel(levelNum) {
            console.log('🔫 generateLevel called for level:', levelNum);
            
            const theme = getLevelTheme(levelNum);
            const platforms = generateRandomPlatforms(levelNum);
            const goalX = platforms[platforms.length - 1].x + 480; // Scaled from 200 (200*2.4=480)
            
            console.log('🔫 About to generate lasers for level:', levelNum, 'with platforms:', platforms.length);
            
            // Force laser generation with error handling
            let laserArray = [];
            try {
                laserArray = generateRandomLasers(platforms, levelNum);
                console.log('🔫 Laser generation successful, generated:', laserArray.length, 'lasers');
            } catch (error) {
                console.error('🔫 ERROR in laser generation:', error);
                // Create a fallback laser
                if (platforms.length > 0) {
                    const platform = platforms[0];
                    laserArray = [{
                        x: platform.x + 100,
                        y: platform.y - 80,
                        collected: false,
                        type: 'laser'
                    }];
                    console.log('🔫 Created fallback laser at:', platform.x + 100, platform.y - 80);
                }
            }
            
            // Generate fireballs with error handling
            let fireballArray = [];
            try {
                fireballArray = generateRandomFireballs(platforms, levelNum);
                console.log('🔥 Fireball generation successful, generated:', fireballArray.length, 'fireballs');
            } catch (error) {
                console.error('🔥 ERROR in fireball generation:', error);
            }
            
            // Generate keys for this level
            console.log('🔑 About to generate keys for level:', levelNum, 'with platforms:', platforms.length);
            let keyArray = [];
            try {
                keyArray = generateRandomKeys(platforms, levelNum);
                console.log('🔑 Key generation successful, generated:', keyArray.length, 'keys');
            } catch (error) {
                console.error('🔑 ERROR in key generation:', error);
                // Create a fallback key
                if (platforms.length > 0) {
                    const platform = platforms[0];
                    keyArray = [{
                        x: platform.x + 100,
                        y: platform.y - 80,
                        collected: false,
                        type: 'key'
                    }];
                    console.log('🔑 Created fallback key at:', platform.x + 100, platform.y - 80);
                }
            }
            
            const levelData = {
                name: theme.name,
                skyColors: theme.skyColors,
                groundColor: theme.groundColor,
                platformColor: theme.platformColor,
                platforms: platforms,
                fish: generateRandomFish(platforms, levelNum),
                enemies: generateRandomEnemies(platforms, levelNum),
                coins: generateRandomCoins(platforms, levelNum),
                health: generateRandomHealth(platforms, levelNum),
                hearts: generateRandomHearts(platforms, levelNum),
                armor: generateRandomArmor(platforms, levelNum),
                treasures: generateRandomTreasures(platforms, levelNum),
                jetpacks: generateRandomJetpacks(platforms, levelNum),
                mushrooms: generateRandomMushrooms(platforms, levelNum),
                keys: keyArray,
                lasers: laserArray,
                fireballs: fireballArray,
                checkpoints: generateCheckpoints(platforms, levelNum),
                breakables: generateBreakableTiles(platforms, levelNum),
                secretRooms: generateSecretRooms(levelNum),
                goalX: goalX
            };
            
            console.log('🔫 Level generated with lasers:', levelData.lasers.length);
            return levelData;
        }
        
        function loadLevel(levelNum) {
            console.log('🔫 loadLevel called for level:', levelNum);
            
            currentLevel = generateLevel(levelNum);
            platforms = [...currentLevel.platforms];
            fish = currentLevel.fish.map(f => ({ ...f, collected: false }));
            enemies = [...currentLevel.enemies];
            coins = currentLevel.coins.map(c => ({ ...c, collected: false }));
            health = currentLevel.health.map(h => ({ ...h, collected: false }));
            hearts = currentLevel.hearts ? currentLevel.hearts.map(h => ({ ...h, collected: false })) : [];
            armor = currentLevel.armor ? currentLevel.armor.map(a => ({ ...a, collected: false })) : [];
            treasures = currentLevel.treasures.map(t => ({ ...t, collected: false }));
            jetpacks = currentLevel.jetpacks.map(j => ({ ...j, collected: false }));
            mushrooms = currentLevel.mushrooms.map(m => ({ ...m, collected: false }));
            
            // Load keys for this level
            console.log('🔑 Loading keys from currentLevel:', currentLevel.keys ? currentLevel.keys.length : 'undefined');
            keys = currentLevel.keys ? currentLevel.keys.map(k => ({ ...k, collected: false })) : [];
            console.log('🔑 Keys loaded:', keys.length);
            
            // Debug: Log all key positions
            if (keys.length > 0) {
                keys.forEach((key, index) => {
                    console.log(`🔑 Key ${index}: x=${key.x}, y=${key.y}, collected=${key.collected}`);
                });
            }
            
            console.log('🔫 Loading lasers from currentLevel:', currentLevel.lasers ? currentLevel.lasers.length : 'undefined');
            laserPowerups = currentLevel.lasers ? currentLevel.lasers.map(l => ({ ...l, collected: false })) : [];
            console.log('🔫 Laser powerups loaded:', laserPowerups.length);
            
            console.log('🔥 Loading fireballs from currentLevel:', currentLevel.fireballs ? currentLevel.fireballs.length : 'undefined');
            fireballPowerups = currentLevel.fireballs ? currentLevel.fireballs.map(f => ({ ...f, collected: false })) : [];
            console.log('🔥 Fireball powerups loaded:', fireballPowerups.length);
            
            checkpoints = [...currentLevel.checkpoints];
            
            // Reset checkpoints for this level (they should be fresh each time)
            game.activeCheckpoint = null;
            if (game.checkpointProgress[levelNum]) {
                delete game.checkpointProgress[levelNum];
            }
            console.log('Checkpoints reset for level', levelNum);
            breakables = [...currentLevel.breakables];
            secretRooms = [...currentLevel.secretRooms];
            // Note: lasers array is already set above, don't clear it here
            
            // Reset player position - ensure they start exactly on the starting platform
            player.x = 240; // Scaled from 100 (100*2.4=240)
            player.velX = 0;
            player.velY = 0;
            player.canDoubleJump = true;
            player.onGround = true; // Start on ground to prevent immediate falling
                                player.onMovingPlatform = false;
                    player.health = player.maxHealth; // Reset health to full for new level
                    player.armor = 0; // Reset armor to 0 for new level
            
            // Reset jetpack system for each level
            player.hasJetpack = false;
            player.jetpackActive = false;
            player.jetpackTime = 0;
            
            // Reset laser system for each level (but preserve laser charging level)
            player.hasLaser = false;
            player.laserActive = false;
            player.laserTime = 0;
            player.laserCooldown = 0;
            player.currentLaserColor = 0;
            // Reset charging system (but preserve unlocked charging level)
              player.isCharging = false;
              player.chargeStartTime = 0;
              player.chargeLevel = 0;
            // Note: player.laserChargingLevel and player.maxChargeLevel are preserved across levels
              
            // Reset fireball system for each level
            player.hasFireball = false;
            player.fireballCooldown = 0;
              
            // Check for equipped abilities from marketplace
            if (game.marketplace.currentAbilities && game.marketplace.currentAbilities.length > 0) {
                game.marketplace.currentAbilities.forEach(abilityId => {
                    if (abilityId === 'jetpack') {
                        player.hasJetpack = true;
                        console.log('⚡ Jetpack ability equipped from marketplace!');
                    } else if (abilityId === 'laser') {
                        player.hasLaser = true;
                        console.log('⚡ Laser ability equipped from marketplace!');
                    } else if (abilityId === 'fireball') {
                        player.hasFireball = true;
                        console.log('🔥 Fireball ability equipped from marketplace!');
                    } else if (abilityId === 'armor') {
                        player.hasArmorBoost = true;
                        player.armorLevel = 1; // Start at level 1 (+25% armor)
                        console.log('🛡️ Armor ability equipped from marketplace! Level 1 (+25% armor)');
                    }
                });
            }
            
            // Update abilities display after resetting/equipping abilities
            updateAbilitiesDisplay();
            
            playerLasers = []; // Clear player lasers
            bossLasers = []; // Clear boss lasers
            playerFireballs = []; // Clear player fireballs
            
            // Reset key count for each level (only 1 key per level)
            game.keyCount = 0;
            player.keys = 0;
            
            // Force exact positioning on starting platform using collision box
            const startingPlatform = platforms.find(p => p.x === 0 && p.y === 1320);
            if (startingPlatform) {
                player.y = startingPlatform.y - player.collisionHeight - player.collisionOffsetY;
                player.lastPlatform = startingPlatform; // Set initial last platform
                player.onGround = true; // Ensure player starts on ground
                player.canDoubleJump = true; // Ensure double jump is available
                console.log('Player positioned at:', player.y, 'on platform at:', startingPlatform.y); // Debug
            } else {
                // Fallback position
                player.y = 1200;
                player.onGround = true; // Ensure player starts on ground
                player.canDoubleJump = true; // Ensure double jump is available
                console.log('Using fallback position:', player.y); // Debug
            }
            
            game.camera.x = 0;
            game.camera.y = player.y - canvas.height / 2; // Position camera to show player
            // No limits - camera can follow player anywhere
            game.levelComplete = false;
            game.levelTransition = false;
            
            // Reset level start time for timing
            game.sessionStats.levelStartTime = Date.now();
            
            // Reset collectibles counter for new level
            game.collectiblesCount.coinsCollected = 0;
            game.collectiblesCount.chestsCollected = 0;
            game.collectiblesCount.goldenChestsCollected = 0;
            
            // Update counter display with new level totals
            updateCollectiblesCounter();
            
            // 🤖 Initialize AI Bot for new level
            game.aiBot.lastTipTime = Date.now();
            game.aiBot.currentTip = '';
            game.aiBot.tipTimer = 0;
            game.aiBot.isVisible = true;
            game.aiBot.lookDirection = player.direction; // Initialize owl direction
            game.aiBot.lookDelay = 0;
            
            // Initialize boss for boss levels
            game.currentBoss = createBoss(levelNum);
            if (game.currentBoss) {
                // Position boss on the boss platform (if it exists)
                if (game.bossPlatformX !== undefined) {
                    // Position boss on the long boss platform
                    game.currentBoss.x = game.bossPlatformX + game.bossPlatformWidth / 2 - game.currentBoss.width / 2;
                    game.currentBoss.y = 1200 - game.currentBoss.height; // On the boss platform
                    console.log('🔫 BOSS CREATED on boss platform!', game.currentBoss);
                } else {
                    // Fallback to last platform positioning
                const lastPlatform = platforms[platforms.length - 1];
                game.currentBoss.x = lastPlatform.x + lastPlatform.width / 2 - game.currentBoss.width / 2;
                game.currentBoss.y = lastPlatform.y - game.currentBoss.height;
                console.log('🔫 BOSS CREATED!', game.currentBoss);
                }
                game.bossActive = true;
                console.log('Boss level! Captain Claws appears!');
            } else {
                // No boss for this level - ensure boss mode is off
                game.bossActive = false;
                console.log('Regular level - boss mode disabled');
            }
        }
        
        function createBoss(levelNum) {
            if (levelNum % 5 === 0) { // Boss every 5 levels
                // Scale boss health with level
                const baseHealth = 100;
                const healthScaling = Math.floor(levelNum / 5) * 50; // +50 health per boss level
                const bossHealth = baseHealth + healthScaling;
                
                console.log('👑 Creating boss for level', levelNum, 'with health:', bossHealth);
                
                return {
                    name: "Captain Claws",
                    x: 0,
                    y: 0,
                    width: 200,
                    height: 150,
                    health: bossHealth,
                    maxHealth: bossHealth,
                    state: 'shoot', // Boss ONLY shoots lasers
                    stateTimer: 0,
                    stateDuration: 2000,
                    direction: 1,
                    velX: 0,
                    velY: 0,
                    isGrounded: false,
                    lastAttack: 0,
                    attackCooldown: 3000,
                    addSpawnTimer: 0,
                    addSpawnCooldown: 5000,
                    adds: []
                };
            }
            return null;
        }
        
        function createParticle(x, y, type) {
            const particles = [];
            const count = type === 'land' ? 8 : type === 'splash' ? 12 : type === 'stomp' ? 15 : type === 'golden' ? 10 : 6;
            
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    velX: (Math.random() - 0.5) * 8,
                    velY: (Math.random() - 0.5) * 8 - 2,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.03,
                    color: type === 'land' ? '#8B4513' : 
                           type === 'splash' ? '#00FFFF' : 
                           type === 'stomp' ? '#FFD700' : 
                           type === 'golden' ? '#FFD700' : '#FFFFFF',
                    size: type === 'golden' ? 3 + Math.random() * 4 : 2 + Math.random() * 3
                });
            }
            
            return particles;
        }
        
        function addScreenShake(intensity) {
            game.screenShake = Math.min(game.screenShake + intensity, 20);
        }
        
        function addFreezeFrame(duration) {
            game.freezeFrame = Math.min(duration, 100);
        }
        
        // Asset management system
        const gameAssets = {
            player: null,
            enemy: null,
            coin: null,
            health: null,
            heart: null,
            treasure: null,
            rareTreasure: null,
            mushroom: null,
            fish: null,
            background: null,
            platform: null,
            crate: null,
            crate1: null,
            crate2: null,
            key: null,
                              eagle: null, // Idle eagle
                  eagle1: null, // Attacking eagle
                  swimmingOtter: null, // Swimming otter asset
            redPlumberSwimming: null,
            greenPlumberSwimming: null,
            yellowPlumberSwimming: null,
            purplePlumberSwimming: null,
            snowPlumberSwimming: null,
                  jetpack1: null, // Jetpack1 asset
                                     goldfish: null, // Goldfish enemy asset
                   wizgator: null, // Wizgator asset
            useCustomAssets: false
        };
        
        let currentLevel = generateLevel(1);
        let platforms = [...currentLevel.platforms];
        let fish = [...currentLevel.fish];
        let enemies = [...currentLevel.enemies];
        let coins = [...currentLevel.coins];
        let health = [...currentLevel.health];
        let hearts = []; // Array to store hearts (extra lives)
        let armor = []; // Array to store armor pickups
        let treasures = [...currentLevel.treasures];
        let mushrooms = [...currentLevel.mushrooms];
        let keys = []; // Array to store keys
        let checkpoints = [...currentLevel.checkpoints];
        let breakables = [...currentLevel.breakables];
        let secretRooms = [...currentLevel.secretRooms];
        let lasers = []; // Array to store enemy lasers
        let playerLasers = []; // Array to store player lasers
        let bossLasers = []; // Array to store boss lasers
        
        // Initialize the first level properly
        loadLevel(1);
        
        // Load saved stats from localStorage
        loadStats();
        
        // Load marketplace data
        loadMarketplaceData();
        
        // Load profile data
        loadProfileData();
        
        // Initialize home screen particle effects
        initHomeScreenParticles();
        
        // Add dynamic background effect
        addDynamicBackground();
        
        // ========================================
        // 🔧 ENHANCED INPUT HANDLING
        // ========================================
        document.addEventListener('keydown', (e) => {
            // 🛡️ Prevent browser conflicts with game keys
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
                e.preventDefault();
            }
            
            game.keys[e.code] = true;
            
            // 🚀 ENHANCED JUMP DETECTION - Prevents input conflicts
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                if (!game.jumpPressed) {
                    game.jumpPressed = true;
                    game.keys['jumpJustPressed'] = true;
                    console.log('🎯 Jump key pressed:', e.code, 'Frame time:', Date.now());
                }
            }
            
            // 🔽 DOWN JUMP - Drop through platforms
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                if (player.onGround && !game.keys['downJumpPressed']) {
                    game.keys['downJumpPressed'] = true;
                    player.onGround = false;
                    player.velY = 2; // Small downward push to start falling
                    console.log('🔽 Down jump activated - dropping through platform', player.isGiant ? '(Giant Mode)' : '');
                } else if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                    // Debug: Log why down jump failed
                    console.log('🔽 Down jump failed:', {
                        onGround: player.onGround,
                        downJumpPressed: game.keys['downJumpPressed'],
                        isGiant: player.isGiant,
                        velY: player.velY.toFixed(2),
                        collisionHeight: player.collisionHeight
                    });
                }
            }
            
            // Toggle asset panel with 'C' key
            if (e.code === 'KeyC') {
                toggleAssetPanel();
            }
            

            
            // Jetpack activation (Shift key) - usable for entire level
            if (e.code === 'ShiftLeft' && player.hasJetpack) {
                const currentTime = Date.now();
                const timeSinceLastBoost = currentTime - player.jetpackTime;
                
                // Allow boost every 200ms while jetpack is active
                if (!player.jetpackActive || timeSinceLastBoost > 200) {
                    if (!player.jetpackActive) {
                        // Start jetpack mode
                        player.jetpackActive = true;
                        player.jetpackTime = currentTime;
                        game.sessionStats.jetpacksUsed++;
                        addScreenShake(2);
                        console.log('Jetpack activated for entire level!');
                    }
                    
                    // Apply boost - horizontal in water, vertical on land
                    if (player.inWater) {
                        // Horizontal boost in water - much stronger
                        player.velX = player.direction * player.waterJetpackPower;
                        console.log('Water jetpack boost - horizontal! velX:', player.velX);
                    } else {
                        // Vertical boost on land
                    player.velY = -player.jetpackPower;
                        console.log('Land jetpack boost - vertical!');
                    }
                    player.jetpackTime = currentTime;
                    addScreenShake(1);
                }
            }
            

            
            // 🎨 Change laser color (K key)
            if (e.code === 'KeyK' && player.hasLaser) {
                player.currentLaserColor = (player.currentLaserColor + 1) % player.laserColors.length;
                console.log('🎨 Laser color changed to:', player.laserColors[player.currentLaserColor]);
            }
            

            
            // Debug: Show all enemies info (P key)
            if (e.code === 'KeyP') {
                console.log('🔍 All enemies info:');
                enemies.forEach((enemy, index) => {
                    const collisionBox = {
                        x: enemy.x + (enemy.collisionOffsetX || 0),
                        y: enemy.y + (enemy.collisionOffsetY || 0),
                        width: enemy.collisionWidth || enemy.width,
                        height: enemy.collisionHeight || enemy.height
                    };
                    console.log(`Enemy ${index}:`, {
                        type: enemy.type,
                        health: enemy.health,
                        position: { x: enemy.x, y: enemy.y },
                        collisionBox: collisionBox,
                        onPlatform: enemy.y === (enemy.lastPlatform?.y - enemy.height) || 'unknown'
                    });
                });
                
                console.log('💎 All treasures info:');
                treasures.forEach((treasure, index) => {
                    const collisionBox = {
                        x: treasure.x - 19,
                        y: treasure.y - 19,
                        width: 38,
                        height: 38
                    };
                    console.log(`Treasure ${index}:`, {
                        type: treasure.type,
                        value: treasure.value,
                        collected: treasure.collected,
                        position: { x: treasure.x, y: treasure.y },
                        collisionBox: collisionBox
                    });
                });
            }
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
            
            // Reset jump tracking when key is released
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                game.jumpPressed = false;
            }
            
            // Reset down jump tracking when key is released
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                game.keys['downJumpPressed'] = false;
            }
            

        });
        
        // Add click event listeners for buttons
        // Note: Removed event listeners for deleted buttons (leaderboardBtn, instructionsBtn, instructionsBtn2)

        
        // Mouse tracking for laser aiming
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouseX = e.clientX - rect.left;
            game.mouseY = e.clientY - rect.top;
        });
        
        // Mouse events for laser charging and shooting
        let mouseDownTime = 0;
        let isMouseDown = false;
        
        // Mouse down - start charging OR quick shoot (LEFT CLICK ONLY)
        canvas.addEventListener('mousedown', (e) => {
            // Only handle left click for laser shooting
            if (e.button === 0 && player.hasLaser && player.laserCooldown <= 0) {
                // Quick shoot on click (no charging)
                if (!player.isCharging) {
                    // Calculate direction from player to mouse
                    const playerScreenX = player.x - game.camera.x;
                    const playerScreenY = player.y - game.camera.y;
                    const deltaX = game.mouseX - playerScreenX;
                    const deltaY = game.mouseY - playerScreenY;
                    
                    // Normalize direction
                    const distance = Math.max(1, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                    const normalizedX = deltaX / distance;
                    const normalizedY = deltaY / distance;
                    
                    // Calculate otter's eye position
                    const otterEyeX = player.x + player.collisionOffsetX + player.collisionWidth / 2;
                    const otterEyeY = player.y + player.collisionOffsetY + player.collisionHeight * 0.15;
                    
                    // Create quick laser
                    const laser = {
                        x: otterEyeX,
                        y: otterEyeY,
                        velX: normalizedX * player.laserSpeed,
                        velY: normalizedY * player.laserSpeed,
                        width: 30,
                        height: 8,
                        color: player.laserColors[player.currentLaserColor],
                        active: true,
                        damage: 1,
                        chargeLevel: 0,
                        chargeTime: 0,
                        pierce: false,
                        maxPierce: 0,
                        explosionRadius: 0,
                        knockback: 0
                    };
                    
                    playerLasers.push(laser);
                    player.laserCooldown = 150; // Quick cooldown for rapid firing
                    game.sessionStats.lasersUsed++;
                    addScreenShake(1);
                    
                    console.log('🔫 Quick laser shot! Direction:', { x: normalizedX.toFixed(3), y: normalizedY.toFixed(3) });
                }
                
                // Also start charging for hold-to-charge (only if laser charge ability is unlocked)
                if (!player.isCharging && player.laserChargingLevel > 0) {
                    player.isCharging = true;
                    player.chargeStartTime = Date.now();
                    player.chargeLevel = 0;
                    mouseDownTime = Date.now();
                    isMouseDown = true;
                    console.log('🔫 Mouse laser charging started!');
                } else if (!player.isCharging && player.laserChargingLevel === 0) {
                    console.log('🔫 Laser charge ability not unlocked yet! Complete level requirements to unlock.');
                    // Show a helpful notification to the player only once
                    if (!player.laserChargeLockedMessageShown) {
                        showLaserChargeLockedNotification();
                        player.laserChargeLockedMessageShown = true;
                    }
                }
            }
        });
        
        // Right click - fire fireball
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Prevent context menu
            console.log('🔥 Right-click detected!');
            console.log('🔥 Player hasFireball:', player.hasFireball);
            console.log('🔥 Player fireballCooldown:', player.fireballCooldown);
            
            if (player.hasFireball && player.fireballCooldown <= 0) {
                // Fixed spawn position near the otter (regardless of mouse position)
                const spawnX = player.x + player.collisionOffsetX + player.collisionWidth / 2;
                const spawnY = player.y + player.collisionOffsetY + player.collisionHeight * 0.4;
                
                // Calculate direction from fixed spawn position to mouse
                const spawnScreenX = spawnX - game.camera.x;
                const spawnScreenY = spawnY - game.camera.y;
                const deltaX = game.mouseX - spawnScreenX;
                const deltaY = game.mouseY - spawnScreenY;
                
                // Normalize direction
                const distance = Math.max(1, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const normalizedX = deltaX / distance;
                const normalizedY = deltaY / distance;
                
                console.log('🔥 Fixed Fireball Spawn:');
                console.log('  - Fixed spawn position:', { x: spawnX, y: spawnY });
                console.log('  - Mouse position:', { x: game.mouseX, y: game.mouseY });
                console.log('  - Direction:', { x: normalizedX.toFixed(3), y: normalizedY.toFixed(3) });
                
                // Create fireball
                const fireball = {
                    x: spawnX,
                    y: spawnY,
                    velX: normalizedX * player.fireballSpeed,
                    velY: normalizedY * player.fireballSpeed,
                    width: 24,
                    height: 24,
                    active: true,
                    damage: 3, // Increased damage to ensure enemies are killed
                    creationTime: Date.now(),
                    lifetime: 0,
                    maxLifetime: player.maxFireballLifetime,
                    color: '#FF4500' // Orange-red fireball color
                };
                
                console.log('  - Fireball created at:', { x: fireball.x, y: fireball.y });
                console.log('  - Fireball velocity:', { x: fireball.velX.toFixed(3), y: fireball.velY.toFixed(3) });
                
                playerFireballs.push(fireball);
                player.fireballCooldown = 300; // 300ms cooldown
                game.sessionStats.fireballsShot++;
                addScreenShake(2);
                
                console.log('🔥 Fireball shot! Direction:', { x: normalizedX.toFixed(3), y: normalizedY.toFixed(3) });
            }
        });
        
        // Mouse up - fire charged laser (LEFT CLICK ONLY)
        // FIXED MOUSE-BASED LASER CONTROLS
        canvas.addEventListener('mouseup', (e) => {
            // Only handle left click for laser charging (only if laser charge ability is unlocked)
            if (e.button === 0 && player.hasLaser && player.isCharging && isMouseDown && player.laserChargingLevel > 0) {
                const currentTime = Date.now();
                const chargeDuration = currentTime - player.chargeStartTime;
                
                // Calculate charge level (0-6) with debugging
                const chargeTimePerLevel = player.chargeTime / player.maxChargeLevel;
                const rawChargeLevel = chargeDuration / chargeTimePerLevel;
                player.chargeLevel = Math.min(player.maxChargeLevel, Math.floor(rawChargeLevel));
                
                console.log('🔫 Charge Calculation Debug:');
                console.log('  - Charge Duration:', chargeDuration, 'ms');
                console.log('  - Charge Time Per Level:', chargeTimePerLevel, 'ms');
                console.log('  - Raw Charge Level:', rawChargeLevel.toFixed(2));
                console.log('  - Final Charge Level:', player.chargeLevel);
                console.log('  - Max Charge Level:', player.maxChargeLevel);
                
                // Create laser from otter's eyes with mouse aiming
                const playerScreenX = player.x - game.camera.x;
                const playerScreenY = player.y - game.camera.y;
                const deltaX = game.mouseX - playerScreenX;
                const deltaY = game.mouseY - playerScreenY;
                
                // FIX: Ensure minimum distance for direction calculation
                const minDistance = 1; // Prevent division by zero
                const distance = Math.max(minDistance, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                
                // FIX: Always normalize direction properly, even for straight up
                let normalizedX = deltaX / distance;
                let normalizedY = deltaY / distance;
                
                // FIX: Special handling for straight up aiming
                if (Math.abs(deltaX) < 5 && deltaY < -10) {
                    // Force straight up direction
                    normalizedX = 0;
                    normalizedY = -1;
                    console.log('🔫 FORCING STRAIGHT UP AIM');
                }
                
                // DEBUG: Comprehensive laser positioning troubleshooting
                console.log('=== 🔫 LASER DEBUG START ===');
                console.log('🔫 Charge Level:', player.chargeLevel);
                console.log('🔫 Max Charge Level:', player.maxChargeLevel);
                console.log('🔫 Charge Duration:', chargeDuration, 'ms');
                console.log('🔫 Player Position:', { x: player.x.toFixed(1), y: player.y.toFixed(1) });
                console.log('🔫 Player Collision Box:', { 
                    offsetX: player.collisionOffsetX, 
                    offsetY: player.collisionOffsetY,
                    width: player.collisionWidth, 
                    height: player.collisionHeight 
                });
                
                // Calculate laser size first
                const laserWidth = 30 * Math.pow(2, player.chargeLevel);
                const laserHeight = 8 * Math.pow(2, player.chargeLevel);
                console.log('🔫 Laser Size:', { width: laserWidth, height: laserHeight });
                
                // Calculate otter's eye position (center of head)
                const otterEyeX = player.x + player.collisionOffsetX + player.collisionWidth / 2;
                const otterEyeY = player.y + player.collisionOffsetY + player.collisionHeight * 0.15;
                console.log('🔫 Otter Eye Position:', { x: otterEyeX.toFixed(1), y: otterEyeY.toFixed(1) });
                
                // Start with otter's eye position
                let laserX = otterEyeX;
                let laserY = otterEyeY;
                
                console.log('🔫 Aiming Direction:', { 
                    normalizedX: normalizedX.toFixed(3), 
                    normalizedY: normalizedY.toFixed(3),
                    deltaX: deltaX.toFixed(1),
                    deltaY: deltaY.toFixed(1)
                });
                
                // Specific distance values for different charge levels (ONLY for left/right aiming)
                let distanceFromOtter = 0; // Default for levels 0-3
                if (player.chargeLevel === 4) {
                    distanceFromOtter = -200; // Level 4: -200px
                } else if (player.chargeLevel === 5) {
                    distanceFromOtter = -500; // Level 5: -500px
                } else if (player.chargeLevel === 6) {
                    distanceFromOtter = -1000; // Level 6: -1000px
                }
                
                if (normalizedX < -0.5) { // Aiming left
                    laserX -= laserWidth / 2; // Move left edge to otter's eyes
                    laserX += distanceFromOtter * normalizedX; // Apply distance for left aiming
                    console.log('🔫 Aiming LEFT - Adjusted X by -', laserWidth / 2, 'and moved', distanceFromOtter, 'px');
                } else if (normalizedX > 0.5) { // Aiming right
                    laserX += laserWidth / 2; // Move right edge to otter's eyes
                    laserX += distanceFromOtter * normalizedX; // Apply distance for right aiming
                    console.log('🔫 Aiming RIGHT - Adjusted X by +', laserWidth / 2, 'and moved', distanceFromOtter, 'px');
                } else {
                    laserX += distanceFromOtter * normalizedX; // Apply distance for horizontal
                }
                
                if (normalizedY < -0.5) { // Aiming up
                    laserY -= laserHeight / 2; // Move top edge to otter's eyes
                    // Apply distance for up aiming (levels 5-6 only)
                    if (player.chargeLevel === 5) {
                        laserY += -100 * normalizedY; // Level 5: -100px
                        console.log('🔫 Aiming UP - Level 5: -100px distance');
                    } else if (player.chargeLevel === 6) {
                        laserY += -300 * normalizedY; // Level 6: -300px
                        console.log('🔫 Aiming UP - Level 6: -300px distance');
                    } else {
                        console.log('🔫 Aiming UP - Level', player.chargeLevel, ': 0px distance');
                    }
                } else if (normalizedY > 0.5) { // Aiming down
                    laserY += laserHeight / 2; // Move bottom edge to otter's eyes
                    // Apply distance for down aiming (levels 5-6 only)
                    if (player.chargeLevel === 5) {
                        laserY += -100 * normalizedY; // Level 5: -100px
                        console.log('🔫 Aiming DOWN - Level 5: -100px distance');
                    } else if (player.chargeLevel === 6) {
                        laserY += -300 * normalizedY; // Level 6: -300px
                        console.log('🔫 Aiming DOWN - Level 6: -300px distance');
                    } else {
                        console.log('🔫 Aiming DOWN - Level', player.chargeLevel, ': 0px distance');
                    }
                } else {
                    // NO distance adjustment for vertical - always 0px
                }
                
                console.log('🔫 Final Laser Position:', { 
                    x: laserX.toFixed(1), 
                    y: laserY.toFixed(1),
                    width: laserWidth,
                    height: laserHeight
                });
                console.log('🔫 Laser should appear to come from otter eyes at:', { x: otterEyeX.toFixed(1), y: otterEyeY.toFixed(1) });
                console.log('=== 🔫 LASER DEBUG END ===');
                
                // Set laser velocity based on normalized direction
                const velX = normalizedX * player.laserSpeed;
                const velY = normalizedY * player.laserSpeed;
                
                console.log('🔫 Laser direction - X:', normalizedX.toFixed(3), 'Y:', normalizedY.toFixed(3));
                console.log('🔫 Laser velocity - X:', velX.toFixed(3), 'Y:', velY.toFixed(3));
                
                // Create laser with enhanced properties based on charge level
                const laser = {
                    x: laserX,
                    y: laserY,
                    velX: velX,
                    velY: velY,
                    width: laserWidth, // Use pre-calculated size
                    height: laserHeight, // Use pre-calculated size
                    color: player.laserColors[player.currentLaserColor],
                    active: true,
                    damage: 1 + (player.chargeLevel * 3), // Much more damage for higher charge (1, 4, 7, 10, 13, 16, 19)
                    chargeLevel: player.chargeLevel, // Store charge level for visual effects
                    chargeTime: chargeDuration, // Store charge time for particle effects
                    // Enhanced properties for charged lasers
                    pierce: player.chargeLevel > 0, // Charged lasers can pierce through enemies
                    maxPierce: player.chargeLevel, // Number of enemies it can pierce through
                    explosionRadius: player.chargeLevel * 20, // Explosion radius for charged lasers
                    knockback: player.chargeLevel * 50 // Knockback force for charged lasers
                };
                
                playerLasers.push(laser);
                game.sessionStats.lasersUsed++;
                
                // Set cooldown based on charge level
                player.laserCooldown = 100 + (player.chargeLevel * 50);
                
                // Add screen shake based on charge level
                addScreenShake(1 + player.chargeLevel);
                
                // Reset charging
                player.isCharging = false;
                player.chargeStartTime = 0;
                player.chargeLevel = 0;
                isMouseDown = false;
                
                console.log('🔫 Charged mouse laser fired! Level:', laser.chargeLevel, 'Damage:', laser.damage, 'Size:', laser.width + 'x' + laser.height);
                console.log('🔫 Laser Object Created:', {
                    x: laser.x.toFixed(1),
                    y: laser.y.toFixed(1),
                    width: laser.width,
                    height: laser.height,
                    velX: laser.velX.toFixed(3),
                    velY: laser.velY.toFixed(3)
                });
            }
        });
        document.getElementById('startGameBtn').addEventListener('click', (event) => {
            addButtonClickEffect(event.target);
            
            // Check if wallet is connected and show trait bonuses
            if (otterWallet && otterWallet.isConnected) {
                const multipliers = otterWallet.getGameMultipliers();
                const stakingBonus = otterWallet.getStakingBonus();
                
                console.log('🎮 Starting game with wallet bonuses:', multipliers);
                console.log('💰 Staking bonus:', stakingBonus);
                
                // Auto-stake all NFTs for demo
                if (otterWallet.userNFTs.length > 0) {
                    otterWallet.autoStakeAll();
                }
                
                // Show trait bonus notification
                const activeTraits = otterWallet.getActiveTraits();
                if (activeTraits.length > 0) {
                    showTraitBonusNotification(activeTraits, multipliers);
                }
            } else if (otterWallet) {
                console.log('🎮 Starting game without wallet connection');
            } else {
                console.log('🎮 Starting game without wallet integration');
            }
            
            startGame();
        });
        document.getElementById('profileBtn').addEventListener('click', (event) => {
            console.log('👤 Profile button clicked via event listener!');
            addButtonClickEffect(event.target);
            toggleProfile();
        });
        document.getElementById('marketplaceBtn').addEventListener('click', (event) => {
            console.log('🛒 Marketplace button clicked via event listener!');
            addButtonClickEffect(event.target);
            toggleMarketplace();
        });
        document.getElementById('skipCutsceneBtn').addEventListener('click', skipCutscene);
        // Note: Removed event listeners for deleted buttons (returnToStartBtn, toggleAiBotBtn)
        

        
        // Preload otter images
        const otterImages = {
            otter1: new Image(),
            otter2: new Image(),
            otter3: new Image(),
            otter4: new Image(),
            otter5: new Image()
        };
        otterImages.otter1.src = 'public/oggg.png';
        otterImages.otter2.src = 'public/ottegi.png'; // Green Plumber
        otterImages.otter3.src = 'public/ottio.png';  // Red Plumber
        otterImages.otter4.src = 'public/otto.png';   // Yellow
        otterImages.otter5.src = 'public/ottwe.png';  // Purple
        
        // Preload fish skeleton image
        gameAssets.fish = new Image();
        gameAssets.fish.onload = function() {
            console.log('Fish skeleton image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.fish.onerror = function() {
            console.log('Failed to load fish skeleton image, using default fish');
            gameAssets.fish = null;
        };
        gameAssets.fish.src = 'public/fishy-log.png.png';
        
        // Preload crab image
        gameAssets.enemy = new Image();
        gameAssets.enemy.onload = function() {
            console.log('Crab image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.enemy.onerror = function() {
            console.log('Failed to load crab image, using default crab');
            gameAssets.enemy = null;
        };
        gameAssets.enemy.src = 'public/crab.png';
        
        // Preload jetpack image
        gameAssets.jetpack = new Image();
        gameAssets.jetpack.onload = function() {
            console.log('Jetpack image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.jetpack.onerror = function() {
            console.log('Failed to load jetpack image, using default jetpack');
            gameAssets.jetpack = null;
        };
        gameAssets.jetpack.src = 'public/jetpack.png';
        
        // Preload jet image for jetpack powerups
        gameAssets.jet = new Image();
        gameAssets.jet.onload = function() {
            console.log('Jet image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.jet.onerror = function() {
            console.log('Failed to load jet image, using default jetpack');
            gameAssets.jet = null;
        };
        gameAssets.jet.src = 'public/jet.png';
        
        // Preload fireball image for fireball powerups
        gameAssets.fireball = new Image();
        gameAssets.fireball.onload = function() {
            console.log('Fireball image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.fireball.onerror = function() {
            console.log('Failed to load fireball image, using default fireball');
            gameAssets.fireball = null;
        };
        gameAssets.fireball.src = 'public/fireball.png';
        
        // Preload armor image for armor pickups
        gameAssets.armor = new Image();
        gameAssets.armor.onload = function() {
            console.log('Armor image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.armor.onerror = function() {
            console.log('Failed to load armor image, using default armor');
            gameAssets.armor = null;
        };
        gameAssets.armor.src = 'public/armor.png';
        
        // Preload piratecrab image for charger enemies
        gameAssets.piratecrab = new Image();
        gameAssets.piratecrab.onload = function() {
            console.log('Piratecrab image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.piratecrab.onerror = function() {
            console.log('Failed to load piratecrab image, using default charger');
            gameAssets.piratecrab = null;
        };
        gameAssets.piratecrab.src = 'public/piratecrab.png';
        
        // Preload kingcrab image for Captain Claws boss
        gameAssets.kingcrab = new Image();
        gameAssets.kingcrab.onload = function() {
            console.log('Kingcrab image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.kingcrab.onerror = function() {
            console.log('Failed to load kingcrab image, using default boss');
            gameAssets.kingcrab = null;
        };
        gameAssets.kingcrab.src = 'public/kingcrab.png';
        
        // Load regular treasure chest asset
        gameAssets.treasure = new Image();
        gameAssets.treasure.onload = function() {
            console.log('Regular treasure chest asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.treasure.onerror = function() {
            console.warn('Failed to load regular treasure chest asset, using default');
            gameAssets.treasure = null;
        };
        gameAssets.treasure.src = 'public/chest.png';
        
        // Load rare treasure chest asset (golden)
        gameAssets.rareTreasure = new Image();
        gameAssets.rareTreasure.onload = function() {
            console.log('Rare treasure chest asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.rareTreasure.onerror = function() {
            console.warn('Failed to load rare treasure chest asset, using default');
            gameAssets.rareTreasure = null;
        };
        gameAssets.rareTreasure.src = 'public/goldchest.png';
        
        // Load crate assets for breakable tiles
        gameAssets.crate = new Image();
        gameAssets.crate.onload = function() {
            console.log('Crate asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.crate.onerror = function() {
            console.warn('Failed to load crate asset, using default');
            gameAssets.crate = null;
        };
        gameAssets.crate.src = 'public/crate.png';
        
        gameAssets.crate1 = new Image();
        gameAssets.crate1.onload = function() {
            console.log('Crate1 asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.crate1.onerror = function() {
            console.warn('Failed to load crate1 asset, using default');
            gameAssets.crate1 = null;
        };
        gameAssets.crate1.src = 'public/crate1.png';
        
        gameAssets.crate2 = new Image();
        gameAssets.crate2.onload = function() {
            console.log('Crate2 asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.crate2.onerror = function() {
            console.warn('Failed to load crate2 asset, using default');
            gameAssets.crate2 = null;
        };
        gameAssets.crate2.src = 'public/crate2.png';
        
        // Load mushroom asset
        gameAssets.mushroom = new Image();
        gameAssets.mushroom.onload = function() {
            console.log('Mushroom asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.mushroom.onerror = function() {
            console.warn('Failed to load mushroom asset, using default');
            gameAssets.mushroom = null;
        };
        gameAssets.mushroom.src = 'public/mushroom.png';
        
        // Load key asset
        gameAssets.key = new Image();
        gameAssets.key.onload = function() {
            console.log('Key asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.key.onerror = function() {
            console.warn('Failed to load key asset, using default');
            gameAssets.key = null;
        };
        gameAssets.key.src = 'public/key.png';
        
        // Load heart asset
        gameAssets.heart = new Image();
        gameAssets.heart.onload = function() {
            console.log('Heart asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.heart.onerror = function() {
            console.warn('Failed to load heart asset, using default');
            gameAssets.heart = null;
        };
        gameAssets.heart.src = 'public/heart.png';
        
        // Load eagle assets
        gameAssets.eagle = new Image();
        gameAssets.eagle.onload = function() {
            console.log('🦅 Eagle (idle) asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.eagle.onerror = function() {
            console.warn('Failed to load eagle asset, using default');
            gameAssets.eagle = null;
        };
        gameAssets.eagle.src = 'public/eagle.png';
        
        gameAssets.eagle1 = new Image();
        gameAssets.eagle1.onload = function() {
            console.log('🦅 Eagle1 (attacking) asset loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.eagle1.onerror = function() {
            console.warn('Failed to load eagle1 asset, using default');
            gameAssets.eagle1 = null;
        };
        gameAssets.eagle1.src = 'public/eagle1.png';
        
        // Load swimming otter asset
        gameAssets.swimmingOtter = new Image();
        gameAssets.swimmingOtter.onload = function() {
            console.log('Swimming otter image loaded successfully');
            gameAssets.useCustomAssets = true;
        };
        gameAssets.swimmingOtter.onerror = function() {
            console.log('Swimming otter image failed to load, using default');
            gameAssets.swimmingOtter = null;
        };
                      gameAssets.swimmingOtter.src = 'public/swimmingotter.png';
            
            // Load plumber swimming assets
            gameAssets.redPlumberSwimming = new Image();
            gameAssets.redPlumberSwimming.onload = function() {
                console.log('✅ Red Plumber Swimming loaded');
            };
            gameAssets.redPlumberSwimming.onerror = function() {
                console.log('❌ Failed to load Red Plumber Swimming');
                gameAssets.redPlumberSwimming = null;
            };
            gameAssets.redPlumberSwimming.src = 'public/redplumberswimming.png';
            
            gameAssets.greenPlumberSwimming = new Image();
            gameAssets.greenPlumberSwimming.onload = function() {
                console.log('✅ Green Plumber Swimming loaded');
            };
            gameAssets.greenPlumberSwimming.onerror = function() {
                console.log('❌ Failed to load Green Plumber Swimming');
                gameAssets.greenPlumberSwimming = null;
            };
            gameAssets.greenPlumberSwimming.src = 'public/greenplumberswimming.png';
            
            gameAssets.yellowPlumberSwimming = new Image();
            gameAssets.yellowPlumberSwimming.onload = function() {
                console.log('✅ Yellow Plumber Swimming loaded');
            };
            gameAssets.yellowPlumberSwimming.onerror = function() {
                console.log('❌ Failed to load Yellow Plumber Swimming');
                gameAssets.yellowPlumberSwimming = null;
            };
            gameAssets.yellowPlumberSwimming.src = 'public/yellowplumberswimming.png';
            
            gameAssets.purplePlumberSwimming = new Image();
            gameAssets.purplePlumberSwimming.onload = function() {
                console.log('✅ Purple Plumber Swimming loaded');
            };
            gameAssets.purplePlumberSwimming.onerror = function() {
                console.log('❌ Failed to load Purple Plumber Swimming');
                gameAssets.purplePlumberSwimming = null;
            };
            gameAssets.purplePlumberSwimming.src = 'public/purpleplumberswimming.png';
            
            gameAssets.snowPlumberSwimming = new Image();
            gameAssets.snowPlumberSwimming.onload = function() {
                console.log('✅ Snow Plumber Swimming loaded');
            };
            gameAssets.snowPlumberSwimming.onerror = function() {
                console.log('❌ Failed to load Snow Plumber Swimming');
                gameAssets.snowPlumberSwimming = null;
            };
            gameAssets.snowPlumberSwimming.src = 'public/snowplumberswimming.png';
              
              // Load jetpack1 asset
              gameAssets.jetpack1 = new Image();
              gameAssets.jetpack1.onload = function() {
                  console.log('Jetpack1 image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.jetpack1.onerror = function() {
                  console.log('Jetpack1 image failed to load, using default');
                  gameAssets.jetpack1 = null;
              };
              gameAssets.jetpack1.src = 'public/jetpack1.png';
              
              // Load goldfish asset
              gameAssets.goldfish = new Image();
              gameAssets.goldfish.onload = function() {
                  console.log('Goldfish image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.goldfish.onerror = function() {
                  console.log('Goldfish image failed to load, using default');
                  gameAssets.goldfish = null;
              };
              gameAssets.goldfish.src = 'public/goldfish.png';
              
              // Load gator assets
              gameAssets.gator = new Image();
              gameAssets.gator.onload = function() {
                  console.log('Gator image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.gator.onerror = function() {
                  console.log('Gator image failed to load, using default');
                  gameAssets.gator = null;
              };
              gameAssets.gator.src = 'public/gator.png';
              
              gameAssets.gator1 = new Image();
              gameAssets.gator1.onload = function() {
                  console.log('Gator1 image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.gator1.onerror = function() {
                  console.log('Gator1 image failed to load, using default');
                  gameAssets.gator1 = null;
              };
              gameAssets.gator1.src = 'public/gator1.png';
              
              // Load wizgator assets
              gameAssets.wizgator = new Image();
              gameAssets.wizgator.onload = function() {
                  console.log('Wizgator image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.wizgator.onerror = function() {
                  console.log('Wizgator image failed to load, using default');
                  gameAssets.wizgator = null;
              };
              gameAssets.wizgator.src = 'public/wizgator1.png';
              
              // Load shark assets
              gameAssets.shark = new Image();
              gameAssets.shark.onload = function() {
                  console.log('Shark image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.shark.onerror = function() {
                  console.log('Shark image failed to load, using default');
                  gameAssets.shark = null;
              };
              gameAssets.shark.src = 'public/shark.png';
              
              gameAssets.shark1 = new Image();
              gameAssets.shark1.onload = function() {
                  console.log('Shark1 (attacking) image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.shark1.onerror = function() {
                  console.log('Shark1 image failed to load, using default');
                  gameAssets.shark1 = null;
              };
              gameAssets.shark1.src = 'public/shark1.png';
              
              // Load owl asset for AI bot
              gameAssets.owl = new Image();
              gameAssets.owl.onload = function() {
                  console.log('Owl image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.owl.onerror = function() {
                  console.log('Owl image failed to load, using fallback');
                  gameAssets.owl = null;
              };
              gameAssets.owl.src = 'public/owl.png';
              
              // Load checkpoint assets
              gameAssets.checkpoint = new Image();
              gameAssets.checkpoint.onload = function() {
                  console.log('Checkpoint image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.checkpoint.onerror = function() {
                  console.log('Checkpoint image failed to load, using default');
                  gameAssets.checkpoint = null;
              };
              gameAssets.checkpoint.src = 'public/Check.png';
              
              gameAssets.checkpointActivated = new Image();
              gameAssets.checkpointActivated.onload = function() {
                  console.log('Activated checkpoint image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.checkpointActivated.onerror = function() {
                  console.log('Activated checkpoint image failed to load, using default');
                  gameAssets.checkpointActivated = null;
              };
              gameAssets.checkpointActivated.src = 'public/Check1.png';
              
              // Load goal flag asset
              gameAssets.goalFlag = new Image();
              gameAssets.goalFlag.onload = function() {
                  console.log('Goal flag image loaded successfully');
                  gameAssets.useCustomAssets = true;
              };
              gameAssets.goalFlag.onerror = function() {
                  console.log('Goal flag image failed to load, using default');
                  gameAssets.goalFlag = null;
              };
              gameAssets.goalFlag.src = 'public/GoalFlag.png';
              
              // Load laser assets for cycling
              gameAssets.laser = new Image();
              gameAssets.laser.onload = function() {
                  console.log('Laser image loaded successfully');
              };
              gameAssets.laser.onerror = function() {
                  console.log('Laser image failed to load');
                  gameAssets.laser = null;
              };
              gameAssets.laser.src = 'public/laser.png';
              
              gameAssets.laser1 = new Image();
              gameAssets.laser1.onload = function() {
                  console.log('Laser1 image loaded successfully');
              };
              gameAssets.laser1.onerror = function() {
                  console.log('Laser1 image failed to load');
                  gameAssets.laser1 = null;
              };
              gameAssets.laser1.src = 'public/laser1.png';
              
              gameAssets.laser2 = new Image();
              gameAssets.laser2.onload = function() {
                  console.log('Laser2 image loaded successfully');
              };
              gameAssets.laser2.onerror = function() {
                  console.log('Laser2 image failed to load');
                  gameAssets.laser2 = null;
              };
              gameAssets.laser2.src = 'public/laser2.png';
              
              gameAssets.laser3 = new Image();
              gameAssets.laser3.onload = function() {
                  console.log('Laser3 image loaded successfully');
              };
              gameAssets.laser3.onerror = function() {
                  console.log('Laser3 image failed to load');
                  gameAssets.laser3 = null;
              };
              gameAssets.laser3.src = 'public/laser3.png';
              
              gameAssets.laser4 = new Image();
              gameAssets.laser4.onload = function() {
                  console.log('Laser4 image loaded successfully');
              };
              gameAssets.laser4.onerror = function() {
                  console.log('Laser4 image failed to load');
                  gameAssets.laser4 = null;
              };
              gameAssets.laser4.src = 'public/laser4.png';
              
              gameAssets.laser5 = new Image();
              gameAssets.laser5.onload = function() {
                  console.log('Laser5 image loaded successfully');
              };
              gameAssets.laser5.onerror = function() {
                  console.log('Laser5 image failed to load');
                  gameAssets.laser5 = null;
              };
              gameAssets.laser5.src = 'public/laser5.png';
              
              gameAssets.laser6 = new Image();
              gameAssets.laser6.onload = function() {
                  console.log('Laser6 image loaded successfully');
              };
              gameAssets.laser6.onerror = function() {
                  console.log('Laser6 image failed to load');
                  gameAssets.laser6 = null;
              };
              gameAssets.laser6.src = 'public/laser6.png';
              
              gameAssets.laser7 = new Image();
              gameAssets.laser7.onload = function() {
                  console.log('Laser7 image loaded successfully');
              };
              gameAssets.laser7.onerror = function() {
                  console.log('Laser7 image failed to load');
                  gameAssets.laser7 = null;
              };
              gameAssets.laser7.src = 'public/laser7.png';
        
        // XP and Reward System Functions
        function addXP(amount) {
            player.xp += amount;
            player.totalScore += amount;
            
            // Calculate new level based on XP progression system
            let newLevel = 1;
            let totalXPNeeded = 0;
            
            // Calculate level using the new XP progression system
            // Level 1: 0-999 XP (1000 total)
            // Level 2: 1000-2499 XP (1500 total)
            // Level 3: 2500-4499 XP (2000 total)
            // ... and so on until level 10
            // Level 10+: 1000 XP per level
            
            if (player.xp < 1000) {
                newLevel = 1;
                player.xpToNextLevel = 1000;
            } else if (player.xp < 2500) {
                newLevel = 2;
                player.xpToNextLevel = 2500;
            } else if (player.xp < 4500) {
                newLevel = 3;
                player.xpToNextLevel = 4500;
            } else if (player.xp < 7000) {
                newLevel = 4;
                player.xpToNextLevel = 7000;
            } else if (player.xp < 10000) {
                newLevel = 5;
                player.xpToNextLevel = 10000;
            } else if (player.xp < 13500) {
                newLevel = 6;
                player.xpToNextLevel = 13500;
            } else if (player.xp < 17500) {
                newLevel = 7;
                player.xpToNextLevel = 17500;
            } else if (player.xp < 22000) {
                newLevel = 8;
                player.xpToNextLevel = 22000;
            } else if (player.xp < 27000) {
                newLevel = 9;
                player.xpToNextLevel = 27000;
            } else if (player.xp < 32500) {
                newLevel = 10;
                player.xpToNextLevel = 32500;
            } else {
                // Level 10+: 1000 XP per level
                const level10Plus = Math.floor((player.xp - 32500) / 1000) + 10;
                newLevel = level10Plus;
                player.xpToNextLevel = 32500 + (level10Plus - 10) * 1000;
            }
            
            if (newLevel > player.level) {
                levelUp(newLevel);
            }
            
            // Save progress
            savePlayerProgress();
            
            console.log(`🎯 Gained ${amount} XP! Total: ${player.xp}, Level: ${player.level}, XP to next: ${player.xpToNextLevel - player.xp}`);
        }
        
        function levelUp(newLevel) {
            const oldLevel = player.level;
            player.level = newLevel;
            
            // Check for laser charge ability unlock (every 10 levels)
            if (player.rewards.laserChargeUnlockLevels.includes(newLevel)) {
                unlockLaserChargeAbility();
            }
            
            // Check for laser charging level upgrade
            if (player.rewards.laserUpgradeLevels.includes(newLevel)) {
                upgradeLaserChargingLevel();
            }
            
            // Check for armor level upgrade (only if armor ability is purchased)
            if (player.hasArmorBoost && player.rewards.armorUpgradeLevels.includes(newLevel)) {
                upgradeArmorLevel();
            }
            
            // Check for unlock rewards
            if (player.rewards.unlockRewards[newLevel]) {
                const reward = player.rewards.unlockRewards[newLevel];
                if (!player.unlockedRewards.includes(newLevel)) {
                    player.unlockedRewards.push(newLevel);
                    showUnlockRewardNotification(reward);
                    console.log(`🎁 UNLOCKED: ${reward.name} - ${reward.description}`);
                }
            }
            
            // Show level up notification
            showLevelUpNotification(newLevel, oldLevel);
            
                            console.log(`🎉 LEVEL UP! ${oldLevel} → ${newLevel}`);
        }
        

        
        function unlockLaserChargeAbility() {
            if (player.laserChargingLevel === 0) {
                player.laserChargingLevel = 1;
                player.maxChargeLevel = 1; // Start with level 1 charge
                player.laserChargeLockedMessageShown = false; // Reset the flag so message can be shown again if needed
                
                showLaserChargeUnlockNotification();
                console.log(`🔫 Laser charge ability unlocked! Level: ${player.laserChargingLevel}`);
            }
        }
        
        function upgradeLaserChargingLevel() {
            if (player.laserChargingLevel < 6) { // Cap at level 6
                player.laserChargingLevel++;
                player.maxChargeLevel = player.laserChargingLevel; // Update max charge level
                
                showLaserUpgradeNotification();
                console.log(`⚡ Laser charging level upgraded! New max: ${player.maxChargeLevel}`);
            }
        }
        
        function showLevelUpNotification(newLevel, oldLevel) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FFD700, #FFA500);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                font-size: 24px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                animation: levelUpPulse 2s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 32px; margin-bottom: 10px;">🎉</div>
                <div>LEVEL UP!</div>
                <div style="font-size: 18px; margin-top: 5px;">${oldLevel} → ${newLevel}</div>

            `;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        function showLaserChargeUnlockNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FF0000, #FF6B35);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(255,0,0,0.4);
                animation: laserUpgradePulse 2s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">🔫</div>
                <div>LASER CHARGE UNLOCKED!</div>
                <div style="font-size: 14px; margin-top: 5px;">Hold left mouse button to charge!</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2500);
        }
        
        function showLaserChargeLockedNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #666666, #999999);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 16px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(0,0,0,0.4);
                animation: laserUpgradePulse 2s ease-in-out;
            `;
            
            const nextUnlockLevel = player.rewards.laserChargeUnlockLevels.find(level => level > player.level) || 10;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">🔒</div>
                <div>LASER CHARGE LOCKED</div>
                <div style="font-size: 14px; margin-top: 5px;">Unlock at level ${nextUnlockLevel}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }
        
        function showLaserUpgradeNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FF0000, #FF6B35);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(255,0,0,0.4);
                animation: laserUpgradePulse 2s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">⚡</div>
                <div>LASER UPGRADED!</div>
                <div style="font-size: 14px; margin-top: 5px;">Max Charge: ${player.maxChargeLevel}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2500);
        }
        
        function upgradeArmorLevel() {
            if (player.armorLevel < player.maxArmorLevel) {
                player.armorLevel++;
                showArmorUpgradeNotification();
                console.log(`🛡️ Armor level upgraded! New level: ${player.armorLevel} (+${player.armorLevel * 25}% armor)`);
            }
        }
        
        function showArmorUpgradeNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #4169E1, #87CEEB);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(65,105,225,0.4);
                animation: laserUpgradePulse 2s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">🛡️</div>
                <div>ARMOR UPGRADED!</div>
                <div style="font-size: 14px; margin-top: 5px;">Level ${player.armorLevel} (+${player.armorLevel * 25}% armor)</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        function showUnlockRewardNotification(reward) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FFD700, #FFA500);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(255,215,0,0.4);
                animation: levelUpPulse 3s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">🎁</div>
                <div>REWARD UNLOCKED!</div>
                <div style="font-size: 16px; margin-top: 5px;">${reward.name}</div>
                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">${reward.description}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        function savePlayerProgress() {
            const progress = {
                xp: player.xp,
                level: player.level,
                xpToNextLevel: player.xpToNextLevel,
                totalScore: player.totalScore,

                laserChargingLevel: player.laserChargingLevel,
                maxChargeLevel: player.maxChargeLevel,
                unlockedRewards: player.unlockedRewards,
                laserChargeLockedMessageShown: player.laserChargeLockedMessageShown,
                
                // Armor system
                hasArmorBoost: player.hasArmorBoost,
                armorLevel: player.armorLevel
            };
            localStorage.setItem('otterBrosProgress', JSON.stringify(progress));
        }
        
        function loadPlayerProgress() {
            // Start fresh - don't load any saved progress
            player.xp = 0;
            player.level = 1;
            player.xpToNextLevel = 1000;
            player.totalScore = 0;

            player.laserChargingLevel = 0; // Start at 0 - must be unlocked
            player.maxChargeLevel = 0; // Start at 0 - must be unlocked
            player.unlockedRewards = [];
            player.laserChargeLockedMessageShown = false;
            
            // Reset armor system
            player.hasArmorBoost = false;
            player.armorLevel = 0;

            console.log('🆕 Starting fresh - no saved progress loaded');
        }
        
        function resetAllGameData() {
            // Clear all localStorage data
            localStorage.removeItem('otterBrosProgress');
            localStorage.removeItem('otterBrosMarketplace');
            localStorage.removeItem('otterBrosProfile');
            localStorage.removeItem('otterBrosSettings');
            
            // Reset player data
            player.xp = 0;
            player.level = 1;
            player.xpToNextLevel = 1000;
            player.totalScore = 0;
            player.laserChargingLevel = 0;
            player.maxChargeLevel = 0;
            player.unlockedRewards = [];
            player.laserChargeLockedMessageShown = false;
            player.hasArmorBoost = false;
            player.armorLevel = 0;
            
            // Reset marketplace data
            game.marketplace.coins = 0;
            game.marketplace.ownedHats = [];
            game.marketplace.ownedSkins = [];
            game.marketplace.ownedAbilities = [];
            game.marketplace.currentHat = null;
            game.marketplace.currentSkin = null;
            game.marketplace.currentAbilities = [];
            
            // Reset game stats
            game.sessionStats = {
                totalScore: 0,
                levelsCompleted: 0,
                totalCoins: 0,
                crabsDefeated: 0,
                eaglesDefeated: 0,
                gatorsDefeated: 0,
                sharksDefeated: 0,
                bossesDefeated: 0,
                treasuresFound: 0,
                keysCollected: 0,
                healthPickups: 0,
                mushroomsEaten: 0,
                currentSessionScore: 0,
                levelStartTime: Date.now(),
                // Additional properties needed by updateLeaderboard
                fishCollected: 0,
                healthCollected: 0,
                treasuresCollected: 0,
                mushroomsCollected: 0,
                levelTimes: [],
                highestScore: 0,
                highestLevels: 0,
                highestCoins: 0,
                highestCrabs: 0,
                highestFish: 0,
                highestHealth: 0,
                highestTreasures: 0,
                highestMushrooms: 0,
                currentSessionLevels: 0,
                currentSessionCoins: 0,
                currentSessionCrabs: 0,
                currentSessionBosses: 0,
                currentSessionFish: 0,
                currentSessionHealth: 0,
                currentSessionTreasures: 0,
                currentSessionMushrooms: 0
            };
            
            // Reset profile data
            game.profile = {
                gamesPlayed: 0,
                playTime: 0,
                bestScore: 0,
                achievements: [],
                recentAchievements: [],
                playerName: 'Otter Player',
                profilePicture: null
            };
            
            // Reset marketplace items but keep defaults
            marketplaceItems.hats.forEach(hat => {
                if (hat.id === 'none') {
                    hat.owned = true;
                    hat.equipped = true;
                } else {
                    hat.owned = false;
                    hat.equipped = false;
                }
            });
            
            marketplaceItems.skins.forEach(skin => {
                if (skin.id === 'default') {
                    skin.owned = true;
                    skin.equipped = true;
                } else {
                    skin.owned = false;
                    skin.equipped = false;
                }
            });
            
            marketplaceItems.abilities.forEach(ability => {
                ability.owned = false;
                ability.equipped = false;
            });
            
            console.log('🔄 All game data reset to fresh start');
        }
        
        function addScoreWithXP(baseScore, source = 'unknown') {
            // Apply wallet bonuses if connected
            let scoreMultiplier = 1;
            if (otterWallet && otterWallet.isConnected) {
                try {
                    const multipliers = otterWallet.getGameMultipliers();
                    scoreMultiplier = multipliers.points;
                } catch (error) {
                    console.warn('⚠️ Error getting wallet multipliers:', error);
                }
            }
            
            const finalScore = Math.floor(baseScore * scoreMultiplier);
            
            // Add to game score
            game.score += finalScore;
            game.sessionStats.totalScore += finalScore;
            game.sessionStats.currentSessionScore += finalScore;
            
            // Add XP (1 XP per score point)
            const xpGained = Math.floor(finalScore * player.rewards.xpPerScore);
            addXP(xpGained);
            
            console.log(`🎯 ${source}: Score ${finalScore} (${baseScore} × ${scoreMultiplier}x), +${xpGained} XP`);
            
            return finalScore;
        }
        
        // Update collectibles counter display
        function updateCollectiblesCounter() {
            const coinsElement = document.getElementById('coinsCounter');
            const chestsElement = document.getElementById('chestsCounter');
            const keysElement = document.getElementById('keysCounter');
            
            // Get total counts for current level
            const totalCoins = coins ? coins.length : 0;
            const totalChests = treasures ? treasures.length : 0; // Include all chests (regular + golden)
            
            if (coinsElement) {
                coinsElement.textContent = `${game.collectiblesCount.coinsCollected}/${totalCoins}`;
                coinsElement.classList.add('updated');
                setTimeout(() => coinsElement.classList.remove('updated'), 500);
            }
            
            if (chestsElement) {
                chestsElement.textContent = `${game.collectiblesCount.chestsCollected}/${totalChests}`;
                chestsElement.classList.add('updated');
                setTimeout(() => chestsElement.classList.remove('updated'), 500);
            }
            
            if (keysElement) {
                keysElement.textContent = `${game.keyCount}/1`; // Always 1 key per level
                keysElement.classList.add('updated');
                setTimeout(() => keysElement.classList.remove('updated'), 500);
            }
        }
        
        // Character selection function
        function selectOtter(otterId) {
            game.selectedOtter = otterId;
            
            // Update visual selection
            document.querySelectorAll('.otter-option').forEach(option => {
                option.style.border = '3px solid #ccc';
                option.style.boxShadow = '0 0 20px rgba(255,215,0,0.1)';
                option.querySelector('p').style.color = '#ccc';
                option.querySelector('img').style.filter = 'drop-shadow(0 0 10px rgba(255,215,0,0.2))';
            });
            
            // Highlight selected otter
            const selectedOption = document.getElementById(otterId);
            selectedOption.style.border = '3px solid #FFD700';
            selectedOption.style.boxShadow = '0 0 20px rgba(255,215,0,0.3)';
            selectedOption.querySelector('p').style.color = '#FFD700';
            selectedOption.querySelector('img').style.filter = 'drop-shadow(0 0 10px rgba(255,215,0,0.5))';
            
            console.log('Selected otter:', otterId);
        }
        
        // Draw functions
        function drawBackground() {
            if (gameAssets.useCustomAssets && gameAssets.background && gameAssets.backgroundPattern) {
                // Draw custom background image using cached pattern
                ctx.save();
                ctx.fillStyle = gameAssets.backgroundPattern;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            } else {
                // Default sky gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, currentLevel.skyColors[0]);
                gradient.addColorStop(1, currentLevel.skyColors[1]);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Stars for night levels
                if (game.level >= 3) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    for (let i = 0; i < 20; i++) {
                        const x = (i * 123 + game.level * 50) % canvas.width;
                        const y = (i * 67) % (canvas.height * 0.6);
                        ctx.beginPath();
                        ctx.arc(x, y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Clouds (lighter for day, darker for night)
                const cloudAlpha = game.level >= 3 ? 0.3 : 0.8;
                ctx.fillStyle = `rgba(255, 255, 255, ${cloudAlpha})`;
                for (let i = 0; i < 4; i++) {
                    const x = (i * 300 - game.camera.x * 0.3) % (canvas.width + 100);
                    const y = 50 + i * 40;
                    ctx.beginPath();
                    ctx.arc(x, y, 15 + i * 3, 0, Math.PI * 2);
                    ctx.arc(x + 20, y, 20 + i * 2, 0, Math.PI * 2);
                    ctx.arc(x + 40, y, 15 + i * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function drawWater() {
            // Check if this is a boss level (lava instead of water)
            const isBossLevel = game.bossActive;
            
            if (isBossLevel) {
                // Draw lava for boss levels
                drawLava();
            } else {
                // Draw water for normal levels
                drawNormalWater();
            }
        }
        
        function drawLava() {
            // Calculate lava position relative to camera
            const lavaTop = game.lavaLevel - game.camera.y;
            const lavaBottom = (game.lavaLevel + game.lavaDepth) - game.camera.y;
            
            // Only draw lava if it's visible on screen
            if (lavaBottom > 0 && lavaTop < canvas.height) {
                ctx.save();
                
                // Create lava overlay with 100% opaque orange/red colors
                const lavaOverlay = ctx.createLinearGradient(0, lavaTop, 0, lavaBottom);
                lavaOverlay.addColorStop(0, 'rgb(255, 140, 0)'); // Solid orange at top
                lavaOverlay.addColorStop(0.5, 'rgb(255, 69, 0)'); // Solid red-orange in middle
                lavaOverlay.addColorStop(1, 'rgb(255, 0, 0)'); // Solid red at bottom
                
                // Draw lava overlay (top layer)
                ctx.fillStyle = lavaOverlay;
                ctx.fillRect(0, lavaTop, canvas.width, lavaBottom - lavaTop);
                
                // Add lava surface effect
                const time = Date.now() * 0.002;
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                // Animated lava surface waves
                for (let x = 0; x < canvas.width; x += 15) {
                    const waveY = lavaTop + Math.sin(time + x * 0.02) * 5;
                    if (x === 0) {
                        ctx.moveTo(x, waveY);
                    } else {
                        ctx.lineTo(x, waveY);
                    }
                }
                ctx.stroke();
                
                // Add lava particles/bubbles
                ctx.fillStyle = 'rgb(255, 100, 0)';
                for (let i = 0; i < 12; i++) {
                    const particleX = (i * 120 + Math.sin(time + i) * 40) % canvas.width;
                    const particleY = lavaBottom - 15 - Math.sin(time * 3 + i) * 8;
                    const particleSize = 3 + Math.sin(time + i * 0.7) * 2;
                    
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        function drawNormalWater() {
            // Calculate water position relative to camera
            const waterTop = game.waterLevel - game.camera.y;
            const waterBottom = (game.waterLevel + game.waterDepth) - game.camera.y;
            
            // Only draw water if it's visible on screen
            if (waterBottom > 0 && waterTop < canvas.height) {
                ctx.save();
                
                // Create water overlay with 25% opacity
                const waterOverlay = ctx.createLinearGradient(0, waterTop, 0, waterBottom);
                waterOverlay.addColorStop(0, 'rgba(0, 150, 255, 0.25)'); // Light blue overlay at top
                waterOverlay.addColorStop(0.5, 'rgba(0, 100, 200, 0.25)'); // Medium blue overlay in middle
                waterOverlay.addColorStop(1, 'rgba(0, 50, 150, 0.25)'); // Dark blue overlay at bottom
                
                // Draw water overlay (top layer)
                ctx.fillStyle = waterOverlay;
                ctx.fillRect(0, waterTop, canvas.width, waterBottom - waterTop);
                
                // Add water surface effect
                const time = Date.now() * 0.001;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // Animated water surface waves
                for (let x = 0; x < canvas.width; x += 20) {
                    const waveY = waterTop + Math.sin(time + x * 0.01) * 3;
                    if (x === 0) {
                        ctx.moveTo(x, waveY);
                    } else {
                        ctx.lineTo(x, waveY);
                    }
                }
                ctx.stroke();
                
                // Add water bubbles
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                for (let i = 0; i < 8; i++) {
                    const bubbleX = (i * 150 + Math.sin(time + i) * 50) % canvas.width;
                    const bubbleY = waterBottom - 20 - Math.sin(time * 2 + i) * 10;
                    const bubbleSize = 2 + Math.sin(time + i * 0.5) * 1;
                    
                    ctx.beginPath();
                    ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            // Draw death barrier at the bottom of the water
            const deathBarrierY = game.deathBarrier - game.camera.y;
            if (deathBarrierY > 0 && deathBarrierY < canvas.height) {
                ctx.save();
                
                // Create death barrier gradient (dark red/purple)
                const deathGradient = ctx.createLinearGradient(0, deathBarrierY - 50, 0, deathBarrierY + 50);
                deathGradient.addColorStop(0, 'rgba(139, 0, 0, 0.8)'); // Dark red
                deathGradient.addColorStop(0.5, 'rgba(128, 0, 128, 0.9)'); // Purple
                deathGradient.addColorStop(1, 'rgba(25, 25, 112, 1.0)'); // Midnight blue
                
                // Draw death barrier
                ctx.fillStyle = deathGradient;
                ctx.fillRect(0, deathBarrierY - 50, canvas.width, 100);
                
                // Add ominous warning pattern
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 10]);
                
                for (let x = 0; x < canvas.width; x += 40) {
                    ctx.beginPath();
                    ctx.moveTo(x, deathBarrierY - 20);
                    ctx.lineTo(x + 20, deathBarrierY + 20);
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                ctx.restore();
            }
        }
        
        function drawBarrierWall(platform) {
            const x = platform.x - game.camera.x;
            const y = platform.y - game.camera.y;
            
            // Only draw if barrier is visible on screen
            if (x + platform.width < 0 || x > game.canvasWidth) {
                return;
            }
            
            ctx.save();
            
            // Animated glow effect
            const time = Date.now() * 0.003;
            const glowIntensity = Math.sin(time) * 0.3 + 0.7;
            
            // Outer glow
            ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity * 0.3})`;
            ctx.fillRect(x - 5, y - 5, platform.width + 10, platform.height + 10);
            
            // Main barrier wall
            ctx.fillStyle = '#8B0000'; // Dark red
            ctx.fillRect(x, y, platform.width, platform.height);
            
            // Warning stripes
            ctx.fillStyle = '#FF0000';
            for (let i = 0; i < platform.height; i += 20) {
                ctx.fillRect(x, y + i, platform.width, 10);
            }
            
            // Warning text
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.save();
            ctx.translate(x + platform.width / 2, y + platform.height / 2);
            ctx.rotate(-Math.PI / 2); // Rotate text vertically
            ctx.strokeText('BARRIER', 0, 0);
            ctx.fillText('BARRIER', 0, 0);
            ctx.restore();
            
            // Pulsing border
            ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity})`;
            ctx.lineWidth = 3;
            ctx.strokeRect(x - 2, y - 2, platform.width + 4, platform.height + 4);
            
            ctx.restore();
        }
        
        function drawUnderwaterPlatform(platform) {
            const x = platform.x - game.camera.x;
            const y = platform.y - game.camera.y;
            
            ctx.save();
            
            // Underwater platform base (darker, more submerged look)
            const gradient = ctx.createLinearGradient(x, y, x, y + platform.height);
            gradient.addColorStop(0, 'rgba(139, 69, 19, 0.8)'); // Dark brown at top
            gradient.addColorStop(1, 'rgba(101, 67, 33, 0.9)'); // Darker brown at bottom
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, platform.width, platform.height);
            
            // Add underwater algae/seaweed effect
            ctx.fillStyle = 'rgba(34, 139, 34, 0.6)'; // Sea green
            for (let i = 0; i < platform.width; i += 30) {
                const algaeHeight = 15 + Math.random() * 20;
                ctx.fillRect(x + i, y - algaeHeight, 8, algaeHeight);
            }
            
            // Add some underwater bubbles around the platform
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            for (let i = 0; i < 5; i++) {
                const bubbleX = x + Math.random() * platform.width;
                const bubbleY = y - 10 - Math.random() * 20;
                const bubbleSize = 2 + Math.random() * 3;
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function drawOtter(x, y) {
            // Draw jetpack behind the otter if they have it
            if (player.hasJetpack) {
                ctx.save();
                ctx.translate(x + player.collisionOffsetX + player.collisionWidth/2, y + player.collisionOffsetY + player.collisionHeight/2);
                ctx.scale(player.direction, 1);
                
                if (player.inWater && gameAssets.jetpack1 && gameAssets.jetpack1.complete) {
                    // Draw jetpack1 with giant mode scaling
                    const jetpack1Width = gameAssets.jetpack1.width * (player.isGiant ? 1.5 : 1.0);
                    const jetpack1Height = gameAssets.jetpack1.height * (player.isGiant ? 1.5 : 1.0);
                    ctx.drawImage(gameAssets.jetpack1, -jetpack1Width/2, -jetpack1Height/2, jetpack1Width, jetpack1Height);
                } else if (gameAssets.jetpack && gameAssets.jetpack.complete) {
                    // Position regular jetpack on otter's back (slightly behind and to the side) with giant mode scaling
                    const jetpackWidth = player.collisionWidth * 0.6 * (player.isGiant ? 1.5 : 1.0);
                    const jetpackHeight = player.collisionHeight * 0.4 * (player.isGiant ? 1.5 : 1.0);
                    const jetpackX = -jetpackWidth/2 - player.collisionWidth * 0.1 * (player.isGiant ? 1.5 : 1.0); // Slightly behind
                    const jetpackY = -jetpackHeight/2 - player.collisionHeight * 0.1 * (player.isGiant ? 1.5 : 1.0); // Slightly above
                    
                    // Draw regular jetpack image
                    ctx.drawImage(gameAssets.jetpack, jetpackX, jetpackY, jetpackWidth, jetpackHeight);
                }
                
                ctx.restore();
            }
            
            // Flash effect when invulnerable
            if (player.invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                return; // Skip drawing every other frame to create flashing effect
            }
            
            // Giant mode glow effect
            if (player.isGiant) {
                const time = Date.now() * 0.005;
                const glowIntensity = Math.sin(time) * 0.3 + 0.7;
                ctx.save();
                ctx.fillStyle = `rgba(255, 0, 255, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(x + player.collisionOffsetX + player.collisionWidth/2, y + player.collisionOffsetY + player.collisionHeight/2, player.collisionWidth/2 + 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw selected otter image - use marketplace skin or appropriate swimming asset when in water
            let selectedImage = otterImages[game.selectedOtter];
            
            // Use marketplace skin if equipped
            const currentSkin = marketplaceItems.skins.find(skin => skin.id === game.marketplace.currentSkin);
            if (currentSkin && currentSkin.image) {
                // Create a new image object for the marketplace skin
                const skinImage = new Image();
                skinImage.src = currentSkin.image;
                if (skinImage.complete) {
                    selectedImage = skinImage;
                }
            }
            
            // Use appropriate swimming asset when in water based on current skin
            if (player.inWater) {
                const swimmingAsset = getCurrentSwimmingAsset();
                if (swimmingAsset && swimmingAsset.complete) {
                    selectedImage = swimmingAsset;
                }
            }
            
            if (selectedImage && selectedImage.complete) {
                // Draw selected otter sprite
                ctx.save();
                ctx.translate(x + player.collisionOffsetX + player.collisionWidth/2, y + player.collisionOffsetY + player.collisionHeight/2);
                ctx.scale(player.direction, 1);
                
                                // Draw swimming otter with giant mode scaling
                if (player.inWater && selectedImage !== otterImages[game.selectedOtter]) {
                    // Swimming assets: 93x64 (landscape orientation) with giant mode scaling
                    const swimWidth = 93 * (player.isGiant ? 1.5 : 1.0);
                    const swimHeight = 64 * (player.isGiant ? 1.5 : 1.0);
                    ctx.drawImage(selectedImage, -swimWidth/2, -swimHeight/2, swimWidth, swimHeight);
                } else {
                    // Normal otter: 64x93 (portrait orientation) with giant mode scaling
                    const normalWidth = player.collisionWidth * (player.isGiant ? 1.5 : 1.0);
                    const normalHeight = player.collisionHeight * (player.isGiant ? 1.5 : 1.0);
                    ctx.drawImage(selectedImage, -normalWidth/2, -normalHeight/2, normalWidth, normalHeight);
                }
                
                ctx.restore();
            } else {
                // Fallback to default drawn otter if image not loaded
                // Draw default otter - sized to match collision box
                ctx.save();
                ctx.translate(x + player.collisionOffsetX + player.collisionWidth/2, y + player.collisionOffsetY + player.collisionHeight/2);
                ctx.scale(player.direction, 1);
                
                // Calculate scaled dimensions based on collision box for realistic otter
                const bodyWidth = player.collisionWidth * 0.7;
                const bodyHeight = player.collisionHeight * 0.4;
                const headWidth = player.collisionWidth * 0.25;
                const headHeight = player.collisionHeight * 0.3;
                const eyeRadius = player.collisionWidth * 0.03;
                const noseRadius = player.collisionWidth * 0.015;
                const earRadius = player.collisionWidth * 0.04;
                const tailLength = player.collisionWidth * 0.4;
                const tailWidth = player.collisionHeight * 0.15;
                const pawRadius = player.collisionWidth * 0.04;
                
                // Main body (more elongated like real otter)
                ctx.fillStyle = '#654321';
                ctx.fillRect(-bodyWidth/2, -bodyHeight/2, bodyWidth, bodyHeight);
                
                // Belly (lighter color)
                ctx.fillStyle = '#D2B48C';
                ctx.fillRect(-bodyWidth/2 + bodyWidth*0.15, -bodyHeight/2 + bodyHeight*0.2, bodyWidth*0.7, bodyHeight*0.6);
                
                // Head (more oval-shaped)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(-bodyWidth/2 - headWidth/2, -bodyHeight/2 - headHeight/3, headWidth/2, headHeight/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Ears (small and round)
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(-bodyWidth/2 - headWidth/2 - earRadius, -bodyHeight/2 - headHeight/2 - earRadius, earRadius, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 - headWidth/2 + earRadius, -bodyHeight/2 - headHeight/2 - earRadius, earRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes (with white highlights)
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-bodyWidth/2 - headWidth/2 - eyeRadius*1.5, -bodyHeight/2 - headHeight/3 - eyeRadius, eyeRadius*1.2, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 - headWidth/2 + eyeRadius*1.5, -bodyHeight/2 - headHeight/3 - eyeRadius, eyeRadius*1.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-bodyWidth/2 - headWidth/2 - eyeRadius*1.5, -bodyHeight/2 - headHeight/3 - eyeRadius, eyeRadius*0.6, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 - headWidth/2 + eyeRadius*1.5, -bodyHeight/2 - headHeight/3 - eyeRadius, eyeRadius*0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // Nose (small and dark)
                ctx.fillStyle = '#2F1B14';
                ctx.beginPath();
                ctx.arc(-bodyWidth/2 - headWidth/2, -bodyHeight/2 - headHeight/3 + noseRadius*2, noseRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Whiskers
                ctx.strokeStyle = '#8B7355';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Left whiskers
                ctx.moveTo(-bodyWidth/2 - headWidth/2 - noseRadius, -bodyHeight/2 - headHeight/3 + noseRadius);
                ctx.lineTo(-bodyWidth/2 - headWidth/2 - noseRadius*4, -bodyHeight/2 - headHeight/3 + noseRadius*2);
                ctx.moveTo(-bodyWidth/2 - headWidth/2 - noseRadius, -bodyHeight/2 - headHeight/3 + noseRadius*2);
                ctx.lineTo(-bodyWidth/2 - headWidth/2 - noseRadius*4, -bodyHeight/2 - headHeight/3 + noseRadius*3);
                // Right whiskers
                ctx.moveTo(-bodyWidth/2 - headWidth/2 + noseRadius, -bodyHeight/2 - headHeight/3 + noseRadius);
                ctx.lineTo(-bodyWidth/2 - headWidth/2 + noseRadius*4, -bodyHeight/2 - headHeight/3 + noseRadius*2);
                ctx.moveTo(-bodyWidth/2 - headWidth/2 + noseRadius, -bodyHeight/2 - headHeight/3 + noseRadius*2);
                ctx.lineTo(-bodyWidth/2 - headWidth/2 + noseRadius*4, -bodyHeight/2 - headHeight/3 + noseRadius*3);
                ctx.stroke();
                
                // Tail (long and tapered like real otter)
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.ellipse(bodyWidth/2 + tailLength/2, 0, tailLength/2, tailWidth/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Tail tip (darker)
                ctx.fillStyle = '#4A3728';
                ctx.beginPath();
                ctx.ellipse(bodyWidth/2 + tailLength - tailWidth/4, 0, tailWidth/2, tailWidth/3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Front paws (webbed feet)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(-bodyWidth/2 - pawRadius, bodyHeight/2 + pawRadius, pawRadius, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 + pawRadius*2, bodyHeight/2 + pawRadius, pawRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Back paws
                ctx.beginPath();
                ctx.arc(bodyWidth/2 - pawRadius*2, bodyHeight/2 + pawRadius, pawRadius, 0, Math.PI * 2);
                ctx.arc(bodyWidth/2 + pawRadius, bodyHeight/2 + pawRadius, pawRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Paw details (toes)
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                // Front paw toes
                ctx.arc(-bodyWidth/2 - pawRadius - pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 - pawRadius + pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 + pawRadius*2 - pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(-bodyWidth/2 + pawRadius*2 + pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                // Back paw toes
                ctx.arc(bodyWidth/2 - pawRadius*2 - pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(bodyWidth/2 - pawRadius*2 + pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(bodyWidth/2 + pawRadius - pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.arc(bodyWidth/2 + pawRadius + pawRadius*0.5, bodyHeight/2 + pawRadius + pawRadius*0.5, pawRadius*0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function drawFish(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.fish) {
                // Draw custom fish skeleton sprite - made larger
                ctx.drawImage(gameAssets.fish, x - 25, y - 25, 50, 50); // Increased from 38x38 to 50x50
            } else {
                // Draw default fish - made larger
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
                ctx.arc(x, y, 18, 0, Math.PI * 2); // Increased from 14 to 18
            ctx.fill();
            
                // Fish tail - made larger
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
                ctx.moveTo(x + 18, y); // Increased from 14 to 18
                ctx.lineTo(x + 38, y - 13); // Increased from 29, 10 to 38, 13
                ctx.lineTo(x + 38, y + 13); // Increased from 29, 10 to 38, 13
            ctx.closePath();
            ctx.fill();
            
                // Eye - made larger
            ctx.fillStyle = 'black';
            ctx.beginPath();
                ctx.arc(x - 6, y - 3, 3, 0, Math.PI * 2); // Increased from 5, 2, 2 to 6, 3, 3
            ctx.fill();
            }
        }
        
        function drawCoin(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.coin) {
                // Draw custom coin sprite
                ctx.drawImage(gameAssets.coin, x - 19, y - 19, 38, 38); // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
            } else {
                // Draw default coin
                // Coin body
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2); // Scaled from 4 (4*2.4=9.6, rounded to 10)
                ctx.fill();
                
                // Coin shine
                ctx.fillStyle = '#FFF8DC';
                ctx.beginPath();
                ctx.arc(x - 2, y - 2, 5, 0, Math.PI * 2); // Scaled from 1, 2 (1*2.4=2.4, 2*2.4=4.8)
                ctx.fill();
                
                // Dollar sign
                ctx.fillStyle = '#B8860B';
                ctx.font = '19px Arial'; // Scaled from 8 (8*2.4=19.2, rounded to 19)
                ctx.textAlign = 'center';
                ctx.fillText('$', x, y + 5); // Scaled from 2 (2*2.4=4.8, rounded to 5)
            }
        }
        
        function drawHealth(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.heart && gameAssets.heart.complete) {
                // Draw custom heart sprite with enhanced effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.003;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Outer glow
                ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(0, 0, 29, 0, Math.PI * 2); // Scaled from 12 (12*2.4=28.8, rounded to 29)
                ctx.fill();
                
                // Draw the custom heart image
                ctx.drawImage(gameAssets.heart, -19, -19, 38, 38); // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 7, 0, Math.PI * 2); // Scaled from 3 (3*2.4=7.2, rounded to 7)
                ctx.fill();
                
                ctx.restore();
            } else {
                // Draw default heart
                ctx.save();
                ctx.translate(x, y);
                
                // Heart body
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(0, 10); // Scaled from 4 (4*2.4=9.6, rounded to 10)
                ctx.bezierCurveTo(-14, -5, -14, -19, 0, -19); // Scaled from 6, 2, 6, 8 (6*2.4=14.4, 2*2.4=4.8, 6*2.4=14.4, 8*2.4=19.2)
                ctx.bezierCurveTo(14, -19, 14, -5, 0, 10); // Scaled from 6, 8, 6, 2 (6*2.4=14.4, 8*2.4=19.2, 6*2.4=14.4, 2*2.4=4.8)
                ctx.fill();
                
                // Heart highlight
                ctx.fillStyle = '#FF6666';
                ctx.beginPath();
                ctx.moveTo(0, 5); // Scaled from 2 (2*2.4=4.8, rounded to 5)
                ctx.bezierCurveTo(-7, -7, -7, -14, 0, -14); // Scaled from 3, 3, 3, 6 (3*2.4=7.2, 3*2.4=7.2, 3*2.4=7.2, 6*2.4=14.4)
                ctx.bezierCurveTo(7, -14, 7, -7, 0, 5); // Scaled from 3, 6, 3, 3 (3*2.4=7.2, 6*2.4=14.4, 3*2.4=7.2, 3*2.4=7.2)
                ctx.fill();
                
                // Heart glow
                ctx.strokeStyle = '#FF4444';
                ctx.lineWidth = 5; // Scaled from 2 (2*2.4=4.8, rounded to 5)
                ctx.beginPath();
                ctx.moveTo(0, 10); // Scaled from 4 (4*2.4=9.6, rounded to 10)
                ctx.bezierCurveTo(-14, -5, -14, -19, 0, -19); // Scaled from 6, 2, 6, 8 (6*2.4=14.4, 2*2.4=4.8, 6*2.4=14.4, 8*2.4=19.2)
                ctx.bezierCurveTo(14, -19, 14, -5, 0, 10); // Scaled from 6, 8, 6, 2 (6*2.4=14.4, 8*2.4=19.2, 6*2.4=14.4, 2*2.4=4.8)
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        function drawHeart(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.heart && gameAssets.heart.complete) {
                // Draw custom heart sprite with enhanced effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect for extra life hearts
                const time = Date.now() * 0.004;
                const glowIntensity = Math.sin(time) * 0.5 + 0.5;
                
                // Outer glow (stronger than regular health)
                ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2); // Larger glow than regular health
                ctx.fill();
                
                // Draw the custom heart image (slightly larger than regular health)
                ctx.drawImage(gameAssets.heart, -24, -24, 48, 48); // Larger than regular health (38x38)
                
                // Extra life indicator
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('+1 LIFE', 0, 35);
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.8})`;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            } else {
                // Draw default heart (larger than regular health)
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect for extra life hearts
                const time = Date.now() * 0.004;
                const glowIntensity = Math.sin(time) * 0.5 + 0.5;
                
                // Outer glow (stronger than regular health)
                ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2); // Larger glow than regular health
                ctx.fill();
                
                // Heart body (larger than regular health)
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(0, 12); // Slightly larger than regular health
                ctx.bezierCurveTo(-16, -6, -16, -22, 0, -22); // Larger heart shape
                ctx.bezierCurveTo(16, -22, 16, -6, 0, 12);
                ctx.fill();
                
                // Heart highlight
                ctx.fillStyle = '#FF6666';
                ctx.beginPath();
                ctx.moveTo(0, 6);
                ctx.bezierCurveTo(-8, -8, -8, -16, 0, -16);
                ctx.bezierCurveTo(8, -16, 8, -8, 0, 6);
                ctx.fill();
                
                // Heart glow (stronger than regular health)
                ctx.strokeStyle = '#FF4444';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(0, 12);
                ctx.bezierCurveTo(-16, -6, -16, -22, 0, -22);
                ctx.bezierCurveTo(16, -22, 16, -6, 0, 12);
                ctx.stroke();
                
                // Extra life indicator
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('+1 LIFE', 0, 35);
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.8})`;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function drawArmor(x, y, armorData = {}) {
            ctx.save();
            ctx.translate(x, y);
            
            // Animated glow effect
            const time = Date.now() * 0.003;
            const glowIntensity = Math.sin(time) * 0.4 + 0.6;
            
            // All armor is blue, but different outer ring colors distinguish types
            const baseColor = '#4169E1'; // Blue for all armor
            const glowColor = 'rgba(65, 105, 225, 0.4)'; // Blue glow for all armor
            
            // Different outer ring colors for different armor types
            let outerRingColor = '#87CEEB'; // Light blue for regular armor
            
            if (armorData.isHidden) {
                if (armorData.hiddenType === 'underwater') {
                    outerRingColor = '#00CED1'; // Dark turquoise ring for underwater
                } else if (armorData.hiddenType === 'cloud') {
                    outerRingColor = '#9370DB'; // Purple ring for cloud
                } else {
                    outerRingColor = '#FFD700'; // Gold ring for high areas
                }
            } else if (armorData.isBossArmor) {
                outerRingColor = '#DC143C'; // Crimson ring for boss armor
            }
            
            // Outer glow (blue for all armor)
            ctx.fillStyle = glowColor;
            ctx.beginPath();
            ctx.arc(0, 0, 29, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw armor asset if available
            if (gameAssets.armor && gameAssets.armor.complete) {
                const armorWidth = gameAssets.armor.width * 0.7; // Scale down slightly
                const armorHeight = gameAssets.armor.height * 0.7;
                ctx.drawImage(gameAssets.armor, -armorWidth/2, -armorHeight/2, armorWidth, armorHeight);
            } else {
                // Fallback to custom armor drawing
                // Armor shield body (blue for all armor)
                ctx.fillStyle = baseColor;
                ctx.beginPath();
                ctx.arc(0, 0, 19, 0, Math.PI * 2); // Main shield circle
                ctx.fill();
                
                // Armor shield border (colored ring based on type)
                ctx.strokeStyle = outerRingColor;
                ctx.lineWidth = 4; // Thicker border to make color more visible
                ctx.beginPath();
                ctx.arc(0, 0, 19, 0, Math.PI * 2);
                ctx.stroke();
                
                // Armor cross symbol (white for all armor)
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-8, 0);
                ctx.lineTo(8, 0);
                ctx.moveTo(0, -8);
                ctx.lineTo(0, 8);
                ctx.stroke();
            }
            
            // Special effects for hidden armor
            if (armorData.isHidden) {
                // Sparkle effect for hidden armor
                const sparkleTime = Date.now() * 0.005;
                for (let i = 0; i < 4; i++) {
                    const angle = sparkleTime + (i * Math.PI / 2);
                    const sparkleX = Math.cos(angle) * 25;
                    const sparkleY = Math.sin(angle) * 25;
                    const sparkleSize = Math.sin(sparkleTime * 2 + i) * 2 + 3;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Pulsing center glow (white for all armor)
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
            ctx.beginPath();
            ctx.arc(0, 0, 7, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawJetpack(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Animated glow effect
            const time = Date.now() * 0.004;
            const glowIntensity = Math.sin(time) * 0.3 + 0.7;
            
            // Outer glow
            ctx.fillStyle = `rgba(0, 255, 255, ${glowIntensity * 0.4})`;
            ctx.beginPath();
            ctx.arc(0, 0, 29, 0, Math.PI * 2); // Scaled from 12 (12*2.4=28.8, rounded to 29)
            ctx.fill();
            
            // Draw jet asset if available
            if (gameAssets.jet && gameAssets.jet.complete) {
                const jetWidth = gameAssets.jet.width * 0.8; // Scale down slightly
                const jetHeight = gameAssets.jet.height * 0.8;
                ctx.drawImage(gameAssets.jet, -jetWidth/2, -jetHeight/2, jetWidth, jetHeight);
            } else {
                // Fallback to custom jetpack drawing
                // Jetpack body (blue)
                ctx.fillStyle = '#0066CC';
                ctx.fillRect(-12, -8, 24, 16); // Main body
                
                // Jetpack tanks (silver)
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(-14, -6, 6, 12); // Left tank
                ctx.fillRect(8, -6, 6, 12); // Right tank
                
                // Jetpack straps (brown)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-8, -12, 16, 4); // Top strap
                ctx.fillRect(-8, 8, 16, 4); // Bottom strap
                
                // Flame effect (animated)
                const flameIntensity = Math.sin(time * 2) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 100, 0, ${flameIntensity})`;
                ctx.beginPath();
                ctx.moveTo(-8, 8);
                ctx.lineTo(-4, 16);
                ctx.lineTo(0, 12);
                ctx.lineTo(4, 16);
                ctx.lineTo(8, 8);
                ctx.closePath();
                ctx.fill();
                
                // Inner flame (yellow)
                ctx.fillStyle = `rgba(255, 255, 0, ${flameIntensity * 0.8})`;
                ctx.beginPath();
                ctx.moveTo(-4, 8);
                ctx.lineTo(-2, 14);
                ctx.lineTo(0, 10);
                ctx.lineTo(2, 14);
                ctx.lineTo(4, 8);
                ctx.closePath();
                ctx.fill();
            }
            
            // Sparkles
            ctx.fillStyle = '#00FFFF';
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI / 2) + time;
                const sparkleX = Math.cos(angle) * 20;
                const sparkleY = Math.sin(angle) * 20;
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // 🔫 LASER DRAWING FUNCTION - CYCLING IMAGES
        function drawLaser(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Update laser cycle timer
            game.laserCycleTimer += 16; // Assuming 60fps (16ms per frame)
            if (game.laserCycleTimer >= game.laserCycleSpeed) {
                game.laserCycleIndex = (game.laserCycleIndex + 1) % 8; // Cycle through 8 laser images (0-7)
                game.laserCycleTimer = 0;
            }
            
            // Get current laser image based on cycle index
            let currentLaserImage = null;
            switch (game.laserCycleIndex) {
                case 0:
                    currentLaserImage = gameAssets.laser;
                    break;
                case 1:
                    currentLaserImage = gameAssets.laser1;
                    break;
                case 2:
                    currentLaserImage = gameAssets.laser2;
                    break;
                case 3:
                    currentLaserImage = gameAssets.laser3;
                    break;
                case 4:
                    currentLaserImage = gameAssets.laser4;
                    break;
                case 5:
                    currentLaserImage = gameAssets.laser5;
                    break;
                case 6:
                    currentLaserImage = gameAssets.laser6;
                    break;
                case 7:
                    currentLaserImage = gameAssets.laser7;
                    break;
            }
            
            // Draw the cycling laser image if available
            if (currentLaserImage && gameAssets.useCustomAssets) {
                // Draw the laser image with glow effect
                const time = Date.now() * 0.006;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Add glow effect behind the image
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 15 * glowIntensity;
                ctx.globalAlpha = 0.7;
                ctx.drawImage(currentLaserImage, -25, -20, 50, 40);
                
                // Draw the main image
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
                ctx.drawImage(currentLaserImage, -25, -20, 50, 40);
                
                // Add "LASER" text
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText('LASER', 0, 35);
                ctx.fillText('LASER', 0, 35);
                
                // Add pickup hint
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 10px Arial';
                ctx.strokeText('PICKUP!', 0, 50);
                ctx.fillText('PICKUP!', 0, 50);
            } else {
                // Fallback to original drawn version if images aren't loaded
            const time = Date.now() * 0.006;
            const glowIntensity = Math.sin(time) * 0.4 + 0.6;
            
            // MASSIVE outer glow for better visibility
            ctx.fillStyle = `rgba(255, 255, 0, ${glowIntensity * 0.3})`;
            ctx.beginPath();
            ctx.arc(0, 0, 50, 0, Math.PI * 2);
            ctx.fill();
            
            // Secondary glow (red)
            ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity * 0.5})`;
            ctx.beginPath();
            ctx.arc(0, 0, 35, 0, Math.PI * 2);
            ctx.fill();
            
            // White inner glow
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.7})`;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // Laser device body (dark gray) - larger and more visible
            ctx.fillStyle = '#222222';
            ctx.fillRect(-20, -15, 40, 30);
            
            // Laser barrel (silver) - larger
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(-25, -8, 15, 16);
            
            // Laser lens (glass effect) - larger
            ctx.fillStyle = '#00FFFF';
            ctx.beginPath();
            ctx.arc(-17, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner lens (reflection)
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-18, -2, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Energy core (pulsing) - larger
            const coreIntensity = Math.sin(time * 3) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, 0, 0, ${coreIntensity})`;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Energy particles - more visible and colorful
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI / 6) + time * 2;
                const particleX = Math.cos(angle) * 25;
                const particleY = Math.sin(angle) * 25;
                
                ctx.fillStyle = i % 2 === 0 ? '#FF0000' : '#FFFF00';
                ctx.beginPath();
                ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Add "LASER" text - bigger and more visible
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.strokeText('LASER', 0, 35);
            ctx.fillText('LASER', 0, 35);
            
            // Add pickup hint
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 10px Arial';
            ctx.strokeText('PICKUP!', 0, 50);
            ctx.fillText('PICKUP!', 0, 50);
            }
            
            ctx.restore();
        }
        
        function drawTreasure(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.treasure) {
                // Draw custom regular treasure chest sprite
                ctx.drawImage(gameAssets.treasure, x - 19, y - 19, 38, 38); // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
            } else {
                // Draw default treasure chest
                // Treasure chest
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - 14, y - 10, 29, 19); // Scaled from 6, 4, 12, 8 (6*2.4=14.4, 4*2.4=9.6, 12*2.4=28.8, 8*2.4=19.2)
                
                // Chest lid
                ctx.fillStyle = '#A0522D';
                ctx.fillRect(x - 14, y - 19, 29, 10); // Scaled from 6, 8, 12, 4 (6*2.4=14.4, 8*2.4=19.2, 12*2.4=28.8, 4*2.4=9.6)
                
                // Lock
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(x - 2, y - 5, 5, 5); // Scaled from 1, 2, 2, 2 (1*2.4=2.4, 2*2.4=4.8, 2*2.4=4.8, 2*2.4=4.8)
                
                // Sparkles
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(x - 19, y - 24, 2, 0, Math.PI * 2); // Scaled from 8, 10, 1 (8*2.4=19.2, 10*2.4=24, 1*2.4=2.4)
                ctx.arc(x + 19, y - 24, 2, 0, Math.PI * 2); // Scaled from 8, 10, 1 (8*2.4=19.2, 10*2.4=24, 1*2.4=2.4)
                ctx.arc(x, y - 29, 2, 0, Math.PI * 2); // Scaled from 0, 12, 1 (0*2.4=0, 12*2.4=28.8, 1*2.4=2.4)
                ctx.fill();
            }
        }
        
        function drawSecretChest(x, y, treasure) {
            ctx.save();
            ctx.translate(x, y);
            
            // Animated glow effect for secret chests
            const time = Date.now() * 0.005;
            const glowIntensity = Math.sin(time) * 0.3 + 0.7;
            
            // Outer glow
            ctx.fillStyle = `rgba(255, 0, 255, ${glowIntensity * 0.4})`;
            ctx.beginPath();
            ctx.arc(0, 0, 45, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw the secret chest (similar to regular chest but with special effects)
            if (gameAssets.useCustomAssets && gameAssets.treasure) {
                // Draw custom treasure chest sprite with secret effects
                ctx.drawImage(gameAssets.treasure, -19, -19, 38, 38);
            } else {
                // Draw default secret chest with special colors
                // Treasure chest base
                ctx.fillStyle = '#8B008B'; // Dark magenta
                ctx.fillRect(-14, -10, 29, 19);
                
                // Chest lid
                ctx.fillStyle = '#9932CC'; // Dark orchid
                ctx.fillRect(-14, -19, 29, 10);
                
                // Lock
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-2, -5, 5, 5);
            }
            
            // Magical sparkles
            ctx.fillStyle = '#FF00FF';
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI / 4) + time;
                const sparkleX = Math.cos(angle) * 30;
                const sparkleY = Math.sin(angle) * 30;
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Pulsing center glow
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Secret indicator text
            ctx.fillStyle = '#FF00FF';
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.strokeText('SECRET', 0, -35);
            ctx.fillText('SECRET', 0, -35);
            
            ctx.restore();
        }
        
        function drawRareTreasure(x, y, requiresKey = false) {
            if (gameAssets.useCustomAssets && gameAssets.rareTreasure) {
                // Draw custom golden treasure chest sprite (DOUBLED SIZE)
            ctx.save();
            ctx.translate(x, y);
            
            // Animated glow effect
            const time = Date.now() * 0.005;
            const glowIntensity = Math.sin(time) * 0.3 + 0.7;
            
                // Outer glow (doubled size)
            ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.3})`;
            ctx.beginPath();
                ctx.arc(0, 0, 58, 0, Math.PI * 2); // Doubled from 29 (29*2=58)
            ctx.fill();
            
                // Draw the golden chest image (doubled size)
                ctx.drawImage(gameAssets.rareTreasure, -38, -38, 76, 76); // Doubled from 38x38 (38*2=76)
                
                // Diamond sparkles (doubled size)
                ctx.fillStyle = '#00FFFF';
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI / 3) + time;
                    const sparkleX = Math.cos(angle) * 48; // Doubled from 24 (24*2=48)
                    const sparkleY = Math.sin(angle) * 48; // Doubled from 24 (24*2=48)
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 4, 0, Math.PI * 2); // Doubled from 2 (2*2=4)
                    ctx.fill();
                }
                
                // Pulsing center glow (doubled size)
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.5})`;
                ctx.beginPath();
                ctx.arc(0, 0, 14, 0, Math.PI * 2); // Doubled from 7 (7*2=14)
                ctx.fill();
                
                // Add key requirement indicator if needed
                if (requiresKey) {
                    // Shield effect to show laser immunity
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 65, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Shield text
                    ctx.fillStyle = '#00FFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeText('LASER IMMUNE', 0, -50);
                    ctx.fillText('LASER IMMUNE', 0, -50);
                    
                    ctx.fillStyle = '#FF0000';
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 3;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeText('KEY REQUIRED', 0, 50);
                    ctx.fillText('KEY REQUIRED', 0, 50);
                    
                    // Show key count
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = 'bold 14px Arial';
                    ctx.strokeText(`Keys: ${game.keyCount}`, 0, 70);
                    ctx.fillText(`Keys: ${game.keyCount}`, 0, 70);
                    
                    // Check if player is near to show F key prompt
                    const playerNear = checkCollision(player, { x: x + game.camera.x - 19, y: y + game.camera.y - 19, width: 38, height: 38 });
                    if (playerNear) {
                        // Show F key interaction prompt
                        ctx.fillStyle = '#00FF00';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.font = 'bold 18px Arial';
                        ctx.strokeText('Press F to Open', 0, 90);
                        ctx.fillText('Press F to Open', 0, 90);
                        
                        // Show if player has key or not
                        if (game.keyCount > 0) {
                            ctx.fillStyle = '#00FF00';
                            ctx.strokeText('✓ Has Key', 0, 110);
                            ctx.fillText('✓ Has Key', 0, 110);
                        } else {
                            ctx.fillStyle = '#FF0000';
                            ctx.strokeText('✗ No Key', 0, 110);
                            ctx.fillText('✗ No Key', 0, 110);
                        }
                    }
                }
                
                ctx.restore();
            } else {
                // Draw default rare treasure with special effects (DOUBLED SIZE)
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.005;
                const glowIntensity = Math.sin(time) * 0.3 + 0.7;
                
                // Outer glow (doubled size)
                ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.3})`;
                ctx.beginPath();
                ctx.arc(0, 0, 58, 0, Math.PI * 2); // Doubled from 29 (29*2=58)
                ctx.fill();
                
                // Treasure chest (golden) - doubled size
            ctx.fillStyle = '#FFD700';
                ctx.fillRect(-28, -20, 58, 38); // Doubled from 14, 10, 29, 19 (14*2=28, 10*2=20, 29*2=58, 19*2=38)
            
                // Chest lid - doubled size
            ctx.fillStyle = '#FFA500';
                ctx.fillRect(-28, -38, 58, 20); // Doubled from 14, 19, 29, 10 (14*2=28, 19*2=38, 29*2=58, 10*2=20)
            
                // Diamond lock - doubled size
            ctx.fillStyle = '#00FFFF';
                ctx.fillRect(-4, -10, 10, 10); // Doubled from 2, 5, 5, 5 (2*2=4, 5*2=10, 5*2=10, 5*2=10)
            
                // Diamond sparkles (doubled size)
            ctx.fillStyle = '#00FFFF';
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI / 3) + time;
                    const sparkleX = Math.cos(angle) * 48; // Doubled from 24 (24*2=48)
                    const sparkleY = Math.sin(angle) * 48; // Doubled from 24 (24*2=48)
                ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 4, 0, Math.PI * 2); // Doubled from 2 (2*2=4)
                ctx.fill();
            }
            
                // Pulsing center glow (doubled size)
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.5})`;
                ctx.beginPath();
                ctx.arc(0, 0, 14, 0, Math.PI * 2); // Doubled from 7 (7*2=14)
                ctx.fill();
                
                // Add key requirement indicator if needed
                if (requiresKey) {
                    // Shield effect to show laser immunity
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 65, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Shield text
                    ctx.fillStyle = '#00FFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeText('LASER IMMUNE', 0, -50);
                    ctx.fillText('LASER IMMUNE', 0, -50);
                    
                    ctx.fillStyle = '#FF0000';
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 3;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeText('KEY REQUIRED', 0, 50);
                    ctx.fillText('KEY REQUIRED', 0, 50);
                    
                    // Show key count
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = 'bold 14px Arial';
                    ctx.strokeText(`Keys: ${game.keyCount}`, 0, 70);
                    ctx.fillText(`Keys: ${game.keyCount}`, 0, 70);
                    
                    // Check if player is near to show F key prompt
                    const playerNear = checkCollision(player, { x: x + game.camera.x - 19, y: y + game.camera.y - 19, width: 38, height: 38 });
                    if (playerNear) {
                        // Show F key interaction prompt
                        ctx.fillStyle = '#00FF00';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.font = 'bold 18px Arial';
                        ctx.strokeText('Press F to Open', 0, 90);
                        ctx.fillText('Press F to Open', 0, 90);
                        
                        // Show if player has key or not
                        if (game.keyCount > 0) {
                            ctx.fillStyle = '#00FF00';
                            ctx.strokeText('✓ Has Key', 0, 110);
                            ctx.fillText('✓ Has Key', 0, 110);
                        } else {
                            ctx.fillStyle = '#FF0000';
                            ctx.strokeText('✗ No Key', 0, 110);
                            ctx.fillText('✗ No Key', 0, 110);
                        }
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawKey(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.key && gameAssets.key.complete) {
                // Draw custom key sprite with enhanced effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.004;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Golden outer glow
                ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2); // Reduced glow radius from 29 to 20
                ctx.fill();
                
                // Draw the custom key image (made skinnier)
                ctx.drawImage(gameAssets.key, -8, -13, 16, 26); // Reduced width from 26 to 16, kept height at 26
                
                // Pulsing center glow (shrunk by 1.5x)
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 7, 0, Math.PI * 2); // Scaled from 3 (3*2.4=7.2, rounded to 7)
                ctx.fill();
                
                ctx.restore();
            } else {
                // Draw default key with special effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.004;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Golden outer glow
                ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2); // Reduced glow radius from 29 to 20
                ctx.fill();
                
                // Key handle (golden) - made skinnier
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-3, -3, 6, 5); // Reduced width from 8 to 6, kept height at 5
                
                // Key shaft (golden) - made skinnier
                ctx.fillRect(-4, -1, 3, 3); // Reduced width from 4 to 3, kept height at 3
                
                // Key teeth (golden) - made skinnier
                ctx.fillRect(-4, -4, 1, 3); // Kept width at 1, kept height at 3
                ctx.fillRect(-3, -5, 1, 3); // Kept width at 1, kept height at 3
                ctx.fillRect(-2, -4, 1, 3); // Kept width at 1, kept height at 3
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
            ctx.beginPath();
            ctx.arc(0, 0, 7, 0, Math.PI * 2); // Scaled from 3 (3*2.4=7.2, rounded to 7)
            ctx.fill();
            
            ctx.restore();
            }
        }
        
        function drawMushroom(x, y) {
            if (gameAssets.useCustomAssets && gameAssets.mushroom && gameAssets.mushroom.complete) {
                // Draw custom mushroom sprite with enhanced effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.003;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Outer glow
                ctx.fillStyle = `rgba(255, 0, 255, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(0, 0, 29, 0, Math.PI * 2); // Scaled from 12 (12*2.4=28.8, rounded to 29)
                ctx.fill();
                
                // Draw the custom mushroom image
                ctx.drawImage(gameAssets.mushroom, -19, -19, 38, 38); // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 7, 0, Math.PI * 2); // Scaled from 3 (3*2.4=7.2, rounded to 7)
                ctx.fill();
                
                ctx.restore();
            } else {
                // Draw default mushroom with special effects
                ctx.save();
                ctx.translate(x, y);
                
                // Animated glow effect
                const time = Date.now() * 0.003;
                const glowIntensity = Math.sin(time) * 0.4 + 0.6;
                
                // Outer glow
                ctx.fillStyle = `rgba(255, 0, 255, ${glowIntensity * 0.4})`;
                ctx.beginPath();
                ctx.arc(0, 0, 29, 0, Math.PI * 2); // Scaled from 12 (12*2.4=28.8, rounded to 29)
                ctx.fill();
                
                // Mushroom cap (red with white spots)
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(0, -5, 12, 0, Math.PI * 2); // Scaled from 5 (5*2.4=12)
                ctx.fill();
                
                // White spots on cap
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(-5, -8, 2, 0, Math.PI * 2); // Scaled from 2, 3, 1 (2*2.4=4.8, 3*2.4=7.2, 1*2.4=2.4)
                ctx.arc(5, -6, 2, 0, Math.PI * 2); // Scaled from 2, 2, 1 (2*2.4=4.8, 2*2.4=4.8, 1*2.4=2.4)
                ctx.arc(0, -2, 2, 0, Math.PI * 2); // Scaled from 0, 1, 1 (0*2.4=0, 1*2.4=2.4, 1*2.4=2.4)
                ctx.fill();
                
                // Mushroom stem (white)
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(-4, 0, 8, 12); // Scaled from 2, 0, 3, 5 (2*2.4=4.8, 0*2.4=0, 3*2.4=7.2, 5*2.4=12)
                
                // Pulsing center glow
                ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, 7, 0, Math.PI * 2); // Scaled from 3 (3*2.4=7.2, rounded to 7)
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function drawCrab(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (gameAssets.useCustomAssets && gameAssets.enemy) {
                // Draw custom enemy sprite
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                ctx.drawImage(gameAssets.enemy, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                ctx.restore();
            } else {
                // Draw default crab
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                // Body
                ctx.fillStyle = '#FF6B6B';
                ctx.fillRect(-12, -8, 20, 12);
                
                // Claws
                ctx.fillStyle = '#FF4444';
                ctx.fillRect(-16, -4, 4, 6);
                ctx.fillRect(12, -4, 4, 6);
                
                // Laser indicators for shooting crabs (level 5+)
                if (enemy.canShoot) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(-18, -2, 2, 2);
                    ctx.fillRect(14, -2, 2, 2);
                }
                
                // Eyes
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-6, -8, 1, 0, Math.PI * 2);
                ctx.arc(-2, -8, 1, 0, Math.PI * 2);
                ctx.fill();
                
                // Legs
                ctx.strokeStyle = '#FF4444';
                ctx.lineWidth = 2;
                for(let i = -8; i < 8; i += 4) {
                    ctx.beginPath();
                    ctx.moveTo(i, 4);
                    ctx.lineTo(i, 8);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        function drawEagle(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -77 && x < game.canvasWidth + 77) {
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                // Choose eagle image based on state
                let eagleImage = null;
                if (enemy.isAttacking || enemy.isDiving) {
                    eagleImage = gameAssets.eagle1; // Attacking eagle
                } else {
                    eagleImage = gameAssets.eagle; // Idle eagle
                }
                
                if (gameAssets.useCustomAssets && eagleImage && eagleImage.complete) {
                    // Draw custom eagle sprite
                    ctx.drawImage(eagleImage, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                } else {
                    // Fallback to default eagle drawing
                // Body
                    ctx.fillStyle = enemy.isAttacking ? '#8B0000' : '#8B4513';
                ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                
                // Wings
                    ctx.fillStyle = enemy.isAttacking ? '#A0522D' : '#A0522D';
                ctx.fillRect(-enemy.width/2 - 10, -enemy.height/2, 10, enemy.height);
                ctx.fillRect(enemy.width/2, -enemy.height/2, 10, enemy.height);
                
                // Eyes
                    ctx.fillStyle = enemy.isAttacking ? '#FF0000' : '#FF6600';
                ctx.beginPath();
                ctx.arc(-enemy.width/4, -enemy.height/3, 2, 0, Math.PI * 2);
                ctx.arc(enemy.width/4, -enemy.height/3, 2, 0, Math.PI * 2);
                ctx.fill();
                    
                    // Beak
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(enemy.width/2 - 5, -2, 5, 4);
                }
                
                ctx.restore();
            }
        }
        
        function drawShark(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -150 && x < game.canvasWidth + 150) {
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                // Choose shark image based on state
                let sharkImage = null;
                if (enemy.isAttacking || enemy.isDiving) {
                    sharkImage = gameAssets.shark1; // Attacking shark
                } else {
                    sharkImage = gameAssets.shark; // Idle shark
                }
                
                if (gameAssets.useCustomAssets && sharkImage && sharkImage.complete) {
                    // Draw custom shark sprite
                    ctx.drawImage(sharkImage, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                } else {
                    // Fallback to default shark drawing
                    // Shark body (dark blue/gray)
                    ctx.fillStyle = enemy.isAttacking ? '#2F4F4F' : '#4682B4';
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Shark fin (dorsal fin)
                    ctx.fillStyle = '#2F4F4F';
                    ctx.beginPath();
                    ctx.moveTo(-enemy.width/4, -enemy.height/2);
                    ctx.lineTo(-enemy.width/4 - 8, -enemy.height/2 - 15);
                    ctx.lineTo(-enemy.width/4 + 8, -enemy.height/2 - 15);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Tail fin
                    ctx.fillStyle = '#2F4F4F';
                    ctx.beginPath();
                    ctx.moveTo(enemy.width/2, 0);
                    ctx.lineTo(enemy.width/2 + 20, -enemy.height/3);
                    ctx.lineTo(enemy.width/2 + 20, enemy.height/3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Eyes (red when attacking)
                    ctx.fillStyle = enemy.isAttacking ? '#FF0000' : '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 3, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye pupils
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 1, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 1, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gills
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(-enemy.width/3, -enemy.height/3, 3, 6);
                    ctx.fillRect(-enemy.width/3 + 5, -enemy.height/3, 3, 6);
                }
                
                // Underwater bubbles effect (always show for custom assets)
                if (enemy.isAttacking || enemy.isDiving) {
                    const time = Date.now() * 0.005;
                    for (let i = 0; i < 3; i++) {
                        const bubbleX = Math.cos(time + i) * 30;
                        const bubbleY = Math.sin(time + i * 2) * 20;
                        const bubbleSize = Math.sin(time + i) * 2 + 3;
                        
                        ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawGoldfish(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -100 && x < game.canvasWidth + 100) {
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                if (gameAssets.useCustomAssets && gameAssets.goldfish && gameAssets.goldfish.complete) {
                    // Draw custom goldfish sprite
                    ctx.drawImage(gameAssets.goldfish, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                } else {
                    // Fallback to default goldfish drawing
                    // Body
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Tail
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.moveTo(enemy.width/2, 0);
                    ctx.lineTo(enemy.width/2 + 15, -enemy.height/3);
                    ctx.lineTo(enemy.width/2 + 15, enemy.height/3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Eyes
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Fins
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(-enemy.width/3, -enemy.height/2 - 5, 8, 5);
                    ctx.fillRect(-enemy.width/3, enemy.height/2, 8, 5);
                }
                
                ctx.restore();
            }
        }
        
        function drawGator(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -130 && x < game.canvasWidth + 130) {
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                // Choose sprite based on whether gator is chasing
                let gatorImage = gameAssets.gator; // Default sprite
                if (enemy.isChasing && gameAssets.gator1 && gameAssets.gator1.complete) {
                    gatorImage = gameAssets.gator1; // Chasing sprite
                }
                
                if (gameAssets.useCustomAssets && gatorImage && gatorImage.complete) {
                    // Draw custom gator sprite
                    ctx.drawImage(gatorImage, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                } else {
                    // Fallback to default gator drawing
                    // Body
                    ctx.fillStyle = enemy.isChasing ? '#FF4444' : '#228B22'; // Red when chasing, green when patrolling
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Snout
                    ctx.fillStyle = enemy.isChasing ? '#CC3333' : '#006400';
                    ctx.fillRect(enemy.width/2 - 10, -enemy.height/3, 15, enemy.height/1.5);
                    
                    // Eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 4, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Teeth (when chasing)
                    if (enemy.isChasing) {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(enemy.width/2 - 5, -enemy.height/4, 3, 3);
                        ctx.fillRect(enemy.width/2 - 5, enemy.height/4, 3, 3);
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawWizgator(enemy) {
            console.log('🎨 DRAWING WIZGATOR! Position:', enemy.x, enemy.y, 'Camera:', game.camera.x, game.camera.y);
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -130 && x < game.canvasWidth + 130) {
                ctx.save();
                ctx.translate(x + enemy.width/2, y + enemy.height/2);
                ctx.scale(enemy.direction, 1);
                
                if (gameAssets.useCustomAssets && gameAssets.wizgator && gameAssets.wizgator.complete) {
                    console.log('🎨 DRAWING CUSTOM WIZGATOR SPRITE!');
                    // Draw custom wizgator sprite
                    ctx.drawImage(gameAssets.wizgator, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                } else {
                    console.log('🎨 DRAWING FALLBACK WIZGATOR GRAPHICS! useCustomAssets:', gameAssets.useCustomAssets, 'wizgator asset:', !!gameAssets.wizgator, 'complete:', gameAssets.wizgator ? gameAssets.wizgator.complete : 'N/A');
                    // Fallback to default wizgator drawing
                    // Body - purple/magenta theme for wizgators
                    ctx.fillStyle = enemy.isChasing ? '#FF00FF' : '#8B008B'; // Magenta when chasing, dark magenta when patrolling
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Snout
                    ctx.fillStyle = enemy.isChasing ? '#FF66FF' : '#4B0082'; // Light magenta when chasing, indigo when patrolling
                    ctx.fillRect(enemy.width/2 - 10, -enemy.height/3, 15, enemy.height/1.5);
                    
                    // Eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 4, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'purple';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/4, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Magic effects (when chasing)
                    if (enemy.isChasing) {
                        // Fireball charge effect
                        const time = Date.now() * 0.005;
                        const glowIntensity = Math.sin(time) * 0.3 + 0.7;
                        
                        // Fireball charge glow around snout
                        ctx.fillStyle = `rgba(255, 102, 0, ${glowIntensity * 0.6})`;
                        ctx.beginPath();
                        ctx.arc(enemy.width/2 + 5, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Magic sparkles
                        for (let i = 0; i < 3; i++) {
                            const sparkleX = Math.cos(time + i * 2) * 15;
                            const sparkleY = Math.sin(time + i * 2) * 15;
                            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.8})`;
                            ctx.beginPath();
                            ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawCharger(enemy) {
            const x = enemy.x - game.camera.x;
            const y = enemy.y - game.camera.y;
            
            if (x > -115 && x < game.canvasWidth + 115) {
                if (gameAssets.useCustomAssets && gameAssets.piratecrab) {
                    // Draw custom piratecrab sprite
                    ctx.save();
                    ctx.translate(x + enemy.width/2, y + enemy.height/2);
                    ctx.scale(enemy.direction, 1);
                    ctx.drawImage(gameAssets.piratecrab, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    ctx.restore();
                } else {
                    // Draw default charger (fallback)
                    ctx.save();
                    ctx.translate(x + enemy.width/2, y + enemy.height/2);
                    ctx.scale(enemy.direction, 1);
                    
                    // Body
                    ctx.fillStyle = enemy.isCharging ? '#FF0000' : '#CC3333';
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Horn
                    ctx.fillStyle = '#FF6666';
                    ctx.fillRect(-enemy.width/2 - 5, -enemy.height/2 + 5, 5, 10);
                    
                    // Eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/3, 3, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-enemy.width/4, -enemy.height/3, 1.5, 0, Math.PI * 2);
                    ctx.arc(enemy.width/4, -enemy.height/3, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
        }
        
        function drawCheckpoint(checkpoint) {
            const x = checkpoint.x - game.camera.x;
            const y = checkpoint.y - game.camera.y;
            
            if (x > -40 && x < game.canvasWidth + 40) {
                ctx.save();
                
                // Use custom checkpoint images if available
                if (gameAssets.useCustomAssets && gameAssets.checkpoint && gameAssets.checkpointActivated) {
                    const checkpointImage = checkpoint.activated ? gameAssets.checkpointActivated : gameAssets.checkpoint;
                    const imageWidth = 80; // 2x bigger (was 40)
                    const imageHeight = 120; // 2x bigger (was 60)
                    
                    // Draw the checkpoint image
                    ctx.drawImage(checkpointImage, x - 20, y - 20, imageWidth, imageHeight);
                    
                    // Add blue glow effect when activated
                    if (checkpoint.activated) {
                        ctx.shadowColor = '#00FFFF';
                        ctx.shadowBlur = 15;
                        ctx.globalAlpha = 0.3;
                        ctx.drawImage(checkpointImage, x - 20, y - 20, imageWidth, imageHeight);
                        ctx.globalAlpha = 1.0;
                        ctx.shadowBlur = 0;
                    }
                } else {
                    // Fallback to original rectangle-based rendering
                // Checkpoint flag
                ctx.fillStyle = checkpoint.activated ? '#00FF00' : '#FFFF00';
                ctx.fillRect(x, y, 4, checkpoint.height);
                
                // Flag banner
                ctx.fillStyle = checkpoint.activated ? '#00CC00' : '#FFCC00';
                ctx.fillRect(x + 4, y, 20, 15);
                
                // Flag pole
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x + 2, y, 2, checkpoint.height);
                
                // Activation glow
                if (checkpoint.activated) {
                    ctx.shadowColor = '#00FF00';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.fillRect(x - 5, y - 5, 30, checkpoint.height + 10);
                    }
                }
                
                ctx.restore();
            }
        }
        
        function drawPlatform(platform) {
            // Skip invisible disappearing platforms
            if (platform.type === 'disappearing' && !platform.isVisible) {
                return;
            }
            
            // Handle barrier walls separately
            if (platform.type === 'barrier') {
                drawBarrierWall(platform);
                return;
            }
            
            // Handle cloud platforms separately
            if (platform.type === 'cloud') {
                drawCloudPlatform(platform);
                return;
            }
            
            // Handle underwater platforms separately
            if (platform.type === 'underwater') {
                drawUnderwaterPlatform(platform);
                return;
            }
            
            const x = platform.x - game.camera.x;
            const y = platform.y - game.camera.y;
            
            // Cut off platforms at water surface (only for regular platforms, not underwater ones)
            const waterSurfaceY = game.waterLevel - game.camera.y;
            const platformBottom = y + platform.height;
            
            // Calculate draw height (declare at function level)
            let drawHeight = platform.height;
            
            // If platform extends below water surface, cut it off
            if (platformBottom > waterSurfaceY && platform.type !== 'underwater') {
                const cutOffHeight = platformBottom - waterSurfaceY;
                const adjustedHeight = platform.height - cutOffHeight;
                
                // Don't draw if platform is completely underwater
                if (adjustedHeight <= 0) {
                    return;
                }
                
                // Use adjusted height for drawing
                drawHeight = adjustedHeight;
            }
            
            if (gameAssets.useCustomAssets && gameAssets.platform) {
                // Draw custom platform sprite (tiled)
                const tileWidth = 77; // Scaled from 32 (32*2.4=76.8, rounded to 77)
                const tileHeight = drawHeight;
                
                for (let i = 0; i < platform.width; i += tileWidth) {
                    const drawWidth = Math.min(tileWidth, platform.width - i);
                    ctx.drawImage(gameAssets.platform, x + i, y, drawWidth, tileHeight);
                }
            } else {
                // Draw default platform
                // Platform base
                ctx.fillStyle = currentLevel.platformColor;
                ctx.fillRect(x, y, platform.width, drawHeight);
                
                // Grass/surface on top
                ctx.fillStyle = currentLevel.groundColor;
                ctx.fillRect(x, y - 12, platform.width, 12); // Scaled from 5 (5*2.4=12)
                
                // Surface details
                ctx.strokeStyle = currentLevel.groundColor;
                ctx.lineWidth = 5; // Scaled from 2 (2*2.4=4.8, rounded to 5)
                for(let i = 0; i < platform.width; i += 19) { // Scaled from 8 (8*2.4=19.2, rounded to 19)
                    ctx.beginPath();
                    ctx.moveTo(x + i, y - 12); // Scaled from 5 (5*2.4=12)
                    ctx.lineTo(x + i, y - 19); // Scaled from 8 (8*2.4=19.2, rounded to 19)
                    ctx.stroke();
                }
                
                // Visual indicators for moving platforms

            }
        }
        
        function drawCloudPlatform(platform) {
            const x = platform.x - game.camera.x;
            const y = platform.y - game.camera.y;
            const time = Date.now() * 0.001;
            
            // Create realistic cloud with multiple layers and gradients
            const cloudWidth = platform.width;
            const cloudHeight = platform.height;
            
            ctx.save();
            
            // Calculate fade-out effect for disappearing clouds and respawn effect
            let fadeOpacity = platform.cloudOpacity || 0.8;
            if (platform.isDisappearing && platform.cloudStartTime) {
                const timeOnCloud = Date.now() - platform.cloudStartTime;
                const fadeStart = platform.cloudDisappearTime - 1000; // Start fading 1 second before disappearing
                if (timeOnCloud > fadeStart) {
                    const fadeProgress = (timeOnCloud - fadeStart) / 1000; // 0 to 1 over 1 second
                    fadeOpacity *= (1 - fadeProgress * 0.7); // Fade to 30% opacity
                }
                
                // Add warning indicator when cloud is about to disappear
                if (timeOnCloud > platform.cloudDisappearTime - 500) { // Last 0.5 seconds
                    const warningOpacity = Math.sin(timeOnCloud * 0.01) * 0.5 + 0.5; // Blinking effect
                    ctx.strokeStyle = `rgba(255, 0, 0, ${warningOpacity})`;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x - 5, y - 5, cloudWidth + 10, cloudHeight + 10);
                }
            }
            
            // Respawn effect - show ghost cloud when respawning
            if (!platform.isVisible && platform.respawnStartTime) {
                const timeSinceDisappear = Date.now() - platform.respawnStartTime;
                const respawnProgress = Math.min(timeSinceDisappear / 5000, 1); // 0 to 1 over 5 seconds
                
                if (respawnProgress > 0.8) { // Show ghost cloud in last 20% of respawn time
                    const ghostOpacity = (respawnProgress - 0.8) * 5; // Fade in over last 20%
                    fadeOpacity = ghostOpacity * 0.3; // Ghost cloud is very faint
                    
                    // Add respawn indicator
                    const respawnOpacity = Math.sin(timeSinceDisappear * 0.01) * 0.5 + 0.5; // Blinking effect
                    ctx.strokeStyle = `rgba(0, 255, 0, ${respawnOpacity * ghostOpacity})`;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x - 3, y - 3, cloudWidth + 6, cloudHeight + 6);
                } else {
                    return; // Don't draw anything if not respawning yet
                }
            }
            
            // Determine cloud color based on special properties
            let cloudColor = platform.cloudColor || '#FFFFFF';
            if (platform.isRainCloud) {
                cloudColor = '#87CEEB'; // Light blue for rain clouds
            } else if (platform.isThunderCloud) {
                cloudColor = '#4A4A4A'; // Dark gray for thunder clouds
            } else if (platform.isGoldenCloud) {
                cloudColor = '#FFD700'; // Gold for golden clouds
            }
            
            // Cloud base layer (bottom shadow)
            ctx.fillStyle = `rgba(200, 200, 200, ${fadeOpacity * 0.3})`;
            ctx.fillRect(x, y + cloudHeight * 0.7, cloudWidth, cloudHeight * 0.3);
            
            // Main cloud body with gradient
            const gradient = ctx.createLinearGradient(x, y, x, y + cloudHeight);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${fadeOpacity * 1.1})`);
            gradient.addColorStop(0.7, `rgba(240, 240, 240, ${fadeOpacity})`);
            gradient.addColorStop(1, `rgba(220, 220, 220, ${fadeOpacity * 0.75})`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, cloudWidth, cloudHeight);
            
            // Create multiple cloud puffs with realistic shapes
            const puffCount = platform.cloudType === 0 ? 4 : platform.cloudType === 1 ? 6 : 5;
            const puffSize = (cloudWidth / puffCount) * (platform.cloudPuffiness || 1.0);
            
            for (let i = 0; i < puffCount; i++) {
                const puffX = x + (cloudWidth / puffCount) * i + (cloudWidth / puffCount) / 2;
                const puffY = y + cloudHeight * 0.4;
                
                // Animated cloud puffs with subtle movement
                const puffOffset = Math.sin(time + i * 0.3) * 1.5;
                
                // Main puff with gradient
                const puffGradient = ctx.createRadialGradient(
                    puffX + puffOffset, puffY, 0,
                    puffX + puffOffset, puffY, puffSize * 0.8
                );
                puffGradient.addColorStop(0, `rgba(255, 255, 255, ${fadeOpacity * 1.2})`);
                puffGradient.addColorStop(0.7, `rgba(245, 245, 245, ${fadeOpacity * 1.1})`);
                puffGradient.addColorStop(1, `rgba(230, 230, 230, ${fadeOpacity * 0.9})`);
                
                ctx.fillStyle = puffGradient;
                ctx.beginPath();
                ctx.arc(puffX + puffOffset, puffY, puffSize * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                // Smaller overlapping puffs for realistic cloud shape
                for (let j = 0; j < 4; j++) {
                    const smallPuffX = puffX + Math.cos(j * Math.PI / 2) * puffSize * 0.5;
                    const smallPuffY = puffY + Math.sin(j * Math.PI / 2) * puffSize * 0.5;
                    
                    const smallPuffGradient = ctx.createRadialGradient(
                        smallPuffX + puffOffset * 0.3, smallPuffY, 0,
                        smallPuffX + puffOffset * 0.3, smallPuffY, puffSize * 0.4
                    );
                    smallPuffGradient.addColorStop(0, `rgba(255, 255, 255, ${fadeOpacity * 1.1})`);
                    smallPuffGradient.addColorStop(1, `rgba(235, 235, 235, ${fadeOpacity * 0.75})`);
                    
                    ctx.fillStyle = smallPuffGradient;
                    ctx.beginPath();
                    ctx.arc(smallPuffX + puffOffset * 0.3, smallPuffY, puffSize * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Add cloud highlights (top layer)
            ctx.fillStyle = `rgba(255, 255, 255, ${fadeOpacity * 0.5})`;
            ctx.fillRect(x, y, cloudWidth, cloudHeight * 0.3);
            
            // Cloud shadow/outline with softer edges
            ctx.strokeStyle = `rgba(180, 180, 180, ${fadeOpacity * 0.4})`;
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, cloudWidth, cloudHeight);
            

            
            // Special cloud effects
            if (platform.isRainCloud) {
                // Draw rain drops
                ctx.strokeStyle = 'rgba(135, 206, 235, 0.6)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const rainX = x + Math.random() * platform.width;
                    const rainY = y + platform.height + Math.random() * 20;
                    ctx.beginPath();
                    ctx.moveTo(rainX, rainY);
                    ctx.lineTo(rainX, rainY + 15);
                    ctx.stroke();
                }
            }
            
            if (platform.isThunderCloud) {
                // Draw lightning effect
                if (Math.random() < 0.1) { // 10% chance per frame
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x + Math.random() * platform.width, y);
                    ctx.lineTo(x + Math.random() * platform.width, y + 50);
                    ctx.stroke();
                }
            }
            
            if (platform.isGoldenCloud) {
                // Draw golden sparkles
                ctx.fillStyle = '#FFD700';
                for (let i = 0; i < 5; i++) {
                    const sparkleX = x + Math.random() * platform.width;
                    const sparkleY = y + Math.random() * platform.height;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        function drawGoal() {
            // Use the stored goal coordinates for consistent positioning
            if (!game.goalX || !game.goalY) return;
            
            const x = game.goalX + 180 - game.camera.x; // Center of goal platform (360/2 = 180)
            const y = game.goalY - 192 - game.camera.y; // Above the goal platform
            
            // Use custom goal flag image if available
            if (gameAssets.useCustomAssets && gameAssets.goalFlag) {
                // Draw the goal flag image - reduced height by 30px
                const imageWidth = 120; // Keep width the same
                const imageHeight = 270; // Reduced from 300 to 270 (30px shorter)
                
                // Position the flag properly on the platform
                // The flag pole should be at the center of the platform, and the flag should extend upward
                const drawX = x - imageWidth / 2; // Center the flag horizontally on the platform
                const drawY = y - imageHeight + 192; // Position so the bottom of the flag is at platform level
                
                ctx.drawImage(gameAssets.goalFlag, drawX, drawY, imageWidth, imageHeight);
                
                // Add a subtle glow effect
                ctx.save();
                ctx.shadowColor = '#00FF00';
                ctx.shadowBlur = 10;
                ctx.globalAlpha = 0.3;
                ctx.drawImage(gameAssets.goalFlag, drawX, drawY, imageWidth, imageHeight);
                ctx.restore();
            } else {
                // Fallback to original rectangle-based rendering
            // Flag pole (larger)
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x, y, 19, 192); // Scaled from 8, 80 (8*2.4=19.2, 80*2.4=192)
            
            // Flag (larger)
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(x + 19, y, 96, 60); // Scaled from 8, 40, 25 (8*2.4=19.2, 40*2.4=96, 25*2.4=60)
            
            // Flag border
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 5; // Scaled from 2 (2*2.4=4.8, rounded to 5)
            ctx.strokeRect(x + 19, y, 96, 60); // Scaled from 8, 40, 25 (8*2.4=19.2, 40*2.4=96, 25*2.4=60)
            
            // GOAL text (smaller to fit in flag)
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Orbitron, Arial Black, sans-serif'; // Scaled from 10 (10*2.4=24)
            ctx.textAlign = 'center';
            ctx.fillText('GOAL', x + 67, y + 41); // Scaled from 28, 17 (28*2.4=67.2, 17*2.4=40.8)
            }
            
            // Reset text alignment
            ctx.textAlign = 'left';
        }
        
        // Collision detection
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // Triangle collision detection (point-in-triangle test)
        function checkTriangleCollision(px, py, x1, y1, x2, y2, x3, y3) {
            // Using barycentric coordinates to determine if point is inside triangle
            const denominator = ((y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3));
            const a = ((y2 - y3) * (px - x3) + (x3 - x2) * (py - y3)) / denominator;
            const b = ((y3 - y1) * (px - x3) + (x1 - x3) * (py - y3)) / denominator;
            const c = 1 - a - b;
            
            // Point is inside triangle if all barycentric coordinates are between 0 and 1
            return a >= 0 && a <= 1 && b >= 0 && b <= 1 && c >= 0 && c <= 1;
        }
        
        // Enhanced laser collision detection with larger hit area
        function checkLaserCollision(laser, enemy) {
            // Use a more generous collision area for lasers
            const laserHitArea = {
                x: laser.x - 5, // Extend hit area by 5 pixels on each side
                y: laser.y - 5,
                width: laser.width + 10,
                height: laser.height + 10
            };
            
            return checkCollision(laserHitArea, enemy);
        }
        
        // Update game logic
        function update() {
            if (game.gameOver) return;
            
            // Check achievements periodically (every 60 frames = 1 second at 60fps)
            if (game.frameCount % 60 === 0) {
                checkAllAchievements();
            }
            
            if (game.levelComplete) {
                if (game.keys['Space']) {
                    // Reset bossActive when changing levels (this is where lava should turn back to water)
                    game.bossActive = false;
                    game.level++;
                    loadLevel(game.level);
                    document.getElementById('level').textContent = game.level;
                    document.getElementById('levelComplete').style.display = 'none';
                }
                return;
            }
            
            // ========================================
            // 🎮 PLAYER MOVEMENT LOGIC
            // ========================================
            // Apply wallet speed bonuses if connected
            let currentSpeed = player.speed;
            if (otterWallet && otterWallet.isConnected) {
                try {
                    const multipliers = otterWallet.getGameMultipliers();
                    currentSpeed = player.speed * multipliers.speed;
                } catch (error) {
                    console.warn('⚠️ Error getting wallet speed multipliers:', error);
                }
            }
            
            if (game.keys['ArrowLeft'] || game.keys['KeyA']) {
                player.velX = -currentSpeed;
                player.direction = -1;
            } else if (game.keys['ArrowRight'] || game.keys['KeyD']) {
                player.velX = currentSpeed;
                player.direction = 1;
            } else {
                player.velX = 0;
            }

            // ========================================
            // 🚀 ROBUST DOUBLE JUMP SYSTEM
            // ========================================
            if (game.keys['jumpJustPressed']) {
                console.log('🎯 Jump attempt:', {
                    onGround: player.onGround,
                    canDoubleJump: player.canDoubleJump,
                    velY: player.velY.toFixed(2),
                    velX: player.velX,
                    movingRight: game.keys['ArrowRight'] || game.keys['KeyD'],
                    movingLeft: game.keys['ArrowLeft'] || game.keys['KeyA']
                });
                
                if (player.onGround) {
                    // ✅ FIRST JUMP - From ground
                    player.velY = -player.jumpPower;
                    player.onGround = false;
                    player.onMovingPlatform = false; // Reset moving platform state when jumping
                    game.sessionStats.jumpsMade++;
                    console.log('✅ First jump executed');
                } else if (player.canDoubleJump) {
                    // ⭐ DOUBLE JUMP - From air (always works regardless of velocity)
                    player.velY = -player.jumpPower * 0.7; // Reduced double jump power for better control
                    player.canDoubleJump = false;
                    game.sessionStats.jumpsMade++;
                    console.log('⭐ Double jump executed');
                } else if (player.inWater) {
                    // 🌊 WATER JUMP - Swim up when in water (always works, regardless of position)
                    player.velY = -player.swimSpeed * 0.25; // Reduced water jump power for better control
                    player.swimming = true;
                    player.onGround = false; // Ensure we're off ground when water jumping
                    game.sessionStats.jumpsMade++;
                    console.log('🌊 Water jump executed - velY:', player.velY);

                } else {
                    console.log('❌ Jump failed - onGround:', player.onGround, 'canDoubleJump:', player.canDoubleJump, 'inWater:', player.inWater);
                }
                
                // 🔄 ALWAYS reset the flag, even if jump failed
                game.keys['jumpJustPressed'] = false;
            }

            // ========================================
            // 🌍 PHYSICS & POSITION UPDATES
            // ========================================
                                        // Apply gravity (consistent for all movement)
            let gravityStrength = 0.37; // Standard gravity strength
            
            // Keep gravity consistent even when jetpack is active
            // This prevents the "floaty" feeling when switching between walking and jetpack
            
            player.velY += gravityStrength;

            // 📉 Cap maximum fall velocity for better feel
            let maxFallVelocity = 6.65; // Consistent fall velocity for all movement
            
            if (player.velY > maxFallVelocity) {
                player.velY = maxFallVelocity;
            }

            // 📈 Cap maximum upward velocity to prevent excessive bouncing
            if (player.velY < -20) {
                player.velY = -20;
            }

            // ========================================
            // 🌊 WATER PHYSICS
            // ========================================
            // Check if player is in water (more precise detection)
            const playerBottom = player.y + player.collisionHeight + player.collisionOffsetY;
            const playerTop = player.y + player.collisionOffsetY;
            const waterTop = game.waterLevel;
            const waterBottom = game.waterLevel + game.waterDepth;
            
            // Player is in water if any part of them is below water surface
            if (playerTop < waterBottom && playerBottom > waterTop) {
                // Player is in water
                if (!player.inWater) {
                    player.inWater = true;
                    console.log('🌊 Player entered water');
                }
                
                // Check if player is at water surface (within 20px of surface for more reliable detection)
                const isAtWaterSurface = playerBottom <= waterTop + 20;
                
                // Always allow jumping when in water (both surface and underwater)
                if (isAtWaterSurface) {
                    // At water surface - treat like normal ground for jumping
                    player.onGround = true;
                    player.canDoubleJump = true;
                    console.log('🌊 Player at water surface - allowing normal jumping');
                } else {
                    // Underwater - still allow jumping but apply water physics
                    if (player.onGround) {
                        player.onGround = false;
                        console.log('🌊 Underwater - off ground but can still jump');
                    }
                }
                
                // Water physics - apply to all underwater movement
                if (!isAtWaterSurface) {
                    // Don't apply water resistance if jetpack is active (to preserve boost)
                    if (!player.jetpackActive || !(game.keys['ShiftLeft'] || game.keys['ShiftRight'])) {
                        player.velX *= player.waterResistance; // Reduce horizontal velocity
                    }
                    
                    // Buoyancy - only reduce fall speed, don't affect upward movement
                    if (player.velY > 0) {
                        player.velY *= 0.5; // Reduce fall speed in water
                    }
                    
                    // Swimming controls - much faster and more responsive
                    if (game.keys['ArrowUp'] || game.keys['KeyW']) {
                        // Much faster upward movement
                        player.velY = Math.max(player.velY - player.swimSpeed * 1.2, -player.swimSpeed * 2.0);
                        player.swimming = true;
                        console.log('🌊 Swimming up - velY:', player.velY);
                    } else if (game.keys['ArrowDown'] || game.keys['KeyS']) {
                        player.velY = Math.min(player.velY + player.swimSpeed * 0.8, player.swimSpeed * 1.6);
                        player.swimming = true;
                    } else {
                        // Gradually return to neutral when no keys pressed
                        if (player.velY < 0) {
                            player.velY = Math.min(player.velY + 0.2, 0);
                        } else if (player.velY > 0) {
                            player.velY = Math.max(player.velY - 0.2, 0);
                        }
                        player.swimming = false;
                    }
                    
                    // Horizontal swimming
                    if (game.keys['ArrowLeft'] || game.keys['KeyA']) {
                        player.velX = -player.swimSpeed;
                        player.swimming = true;
                    } else if (game.keys['ArrowRight'] || game.keys['KeyD']) {
                        player.velX = player.swimSpeed;
                        player.swimming = true;
                    }
                } else {
                    // At water surface - normal movement controls
                    player.swimming = false;
                }
                
            } else {
                // Player is not in water
                if (player.inWater) {
                    player.inWater = false;
                    player.swimming = false;
                    console.log('🌊 Player left water');
                }
            }
            
            // Debug water state
            if (player.inWater) {
                console.log('🌊 Water debug - onGround:', player.onGround, 'velY:', player.velY.toFixed(2), 'swimming:', player.swimming);
            }
            
            // ========================================
            // 🔥 LAVA PHYSICS (BOSS LEVELS ONLY)
            // ========================================
            if (game.bossActive) {
                // Check if player is in lava (more precise detection)
                const playerBottom = player.y + player.collisionHeight + player.collisionOffsetY;
                const playerTop = player.y + player.collisionOffsetY;
                const lavaTop = game.lavaLevel;
                const lavaBottom = game.lavaLevel + game.lavaDepth;
                
                // Player is in lava if any part of them is below lava surface
                if (playerTop < lavaBottom && playerBottom > lavaTop) {
                    // Player is in lava
                                         if (!player.inLava) {
                         player.inLava = true;
                         player.lavaSinkTime = Date.now();
                         takeDamage(50); // Initial damage when falling into lava
                         addScreenShake(8);
                         console.log('🔥 Player fell into lava! Took 50 initial damage. Health remaining:', player.health);
                     }
                    
                                         // Check if player is at lava surface (within 20px of surface)
                     const isAtLavaSurface = playerBottom <= lavaTop + 20;
                     
                     // Continuous lava damage every second
                     const currentTime = Date.now();
                     if (!player.lastLavaDamageTime) {
                         player.lastLavaDamageTime = currentTime;
                     }
                     
                     const timeSinceLastDamage = currentTime - player.lastLavaDamageTime;
                     if (timeSinceLastDamage >= 1000) { // Every 1000ms (1 second)
                         takeDamage(15); // 15 damage per second
                         player.lastLavaDamageTime = currentTime;
                         addScreenShake(2);
                         console.log('🔥 Continuous lava damage! Took 15 damage. Health remaining:', player.health);
                     }
                     
                     if (isAtLavaSurface) {
                         // At lava surface - bounce up and take extra damage
                         if (!player.lavaInvulnerable) {
                             player.velY = -game.lavaBouncePower; // Bounce up
                             player.lavaInvulnerable = true;
                             player.lavaDamageTime = Date.now();
                             takeDamage(35); // Extra damage for touching surface (35 + 15 = 50 total)
                             addScreenShake(5);
                             console.log('🔥 Lava surface damage! Bounced up, took 35 extra damage. Health remaining:', player.health);
                         }
                     } else {
                        // Sinking in lava - check for death
                        const sinkTime = Date.now() - player.lavaSinkTime;
                        if (sinkTime > game.lavaSinkDuration) {
                            // Player has been in lava too long - death
                            takeDamage(100); // Use damage system instead of direct life loss
                            addScreenShake(10);
                            console.log('🔥 Lava death! Sunk for too long. Took 100 damage. Health remaining:', player.health);
                            
                            // Respawn at last platform
                            if (player.lastPlatform) {
                                player.x = player.lastPlatform.x + 100;
                                player.y = player.lastPlatform.y - player.collisionHeight - player.collisionOffsetY;
                                player.velX = 0;
                                player.velY = 0;
                                player.onGround = true;
                                player.canDoubleJump = true;
                                console.log('🔥 Respawned at last platform:', player.lastPlatform.x, player.lastPlatform.y);
                            }
                            
                            // Reset lava state
                            player.inLava = false;
                            player.lavaSinkTime = 0;
                        }
                    }
                    
                    // Lava physics - slow movement and sinking
                    player.velX *= 0.3; // Heavy resistance
                    if (player.velY > 0) {
                        player.velY *= 0.7; // Slow sinking
                    }
                    
                } else {
                    // Player is not in lava
                                         if (player.inLava) {
                         player.inLava = false;
                         player.lavaSinkTime = 0;
                         player.lastLavaDamageTime = 0; // Reset damage timer
                         console.log('🔥 Player left lava');
                     }
                }
                
                // Check lava invulnerability timer
                if (player.lavaInvulnerable) {
                    const invulnerabilityTime = Date.now() - player.lavaDamageTime;
                    if (invulnerabilityTime > game.lavaDamageInvulnerability) {
                        player.lavaInvulnerable = false;
                        console.log('🔥 Lava invulnerability ended');
                    }
                }
                
                // Debug lava state
                if (player.inLava) {
                    const sinkTime = Date.now() - player.lavaSinkTime;
                    console.log('🔥 Lava debug - sinkTime:', (sinkTime/1000).toFixed(1) + 's', 'invulnerable:', player.lavaInvulnerable);
                }
            }

            // 🚀 Continuous jetpack boost in water
            if (player.hasJetpack && player.jetpackActive && player.inWater && (game.keys['ShiftLeft'] || game.keys['ShiftRight'])) {
                const currentTime = Date.now();
                const timeSinceLastBoost = currentTime - player.jetpackTime;
                
                // Apply continuous boost every 100ms while holding Shift in water
                if (timeSinceLastBoost > 100) {
                    // Add to existing velocity for continuous boost - much stronger
                    player.velX += player.direction * player.waterJetpackPower * 0.3;
                    player.jetpackTime = currentTime;
                    console.log('🌊 Continuous water jetpack boost - velX:', player.velX.toFixed(2));
                }
            }

            // 🎯 Update player position
            player.x += player.velX;
            player.y += player.velY;

            // 🧱 Left boundary check - 200px from spawn
            const leftBoundaryX = 240 - 200; // 40px left of spawn
            if (player.x < leftBoundaryX) {
                console.log('🧱 Player hit left boundary - stopping movement');
                player.x = leftBoundaryX;
                player.velX = 0; // Stop horizontal movement
            }

            // 💀 Death barrier check
            if (player.y > game.deathBarrier) {
                console.log('💀 Player hit death barrier - respawning');
                game.lives--;
                if (game.lives <= 0) {
                    game.gameOver = true;
                } else {
                    // Respawn player at last checkpoint or starting position
                    if (game.activeCheckpoint) {
                        player.x = game.activeCheckpoint.platform.x + (game.activeCheckpoint.platform.width / 2) - (player.collisionWidth / 2);
                        player.y = game.activeCheckpoint.platform.y - player.collisionHeight - player.collisionOffsetY;
                    } else {
                        // Respawn at starting position
                        player.x = 240;
                        player.y = 1200;
                    }
                    player.velX = 0;
                    player.velY = 0;
                    player.onGround = false;
                    player.onMovingPlatform = false;
                    player.health = player.maxHealth; // Reset health to full on respawn
                    player.armor = 0; // Reset armor to 0 on respawn
                }
            }
            
            // 🧱 Invisible wall check - 300px past goal
            const invisibleWallX = game.goalX + 300;
            if (player.x > invisibleWallX) {
                console.log('🧱 Player hit invisible wall - stopping movement');
                player.x = invisibleWallX;
                player.velX = 0; // Stop horizontal movement
            }
            
            // Update invulnerability
            if (player.damageInvulnerable) {
                if (Date.now() - player.invulnerableTime > player.invulnerableDuration) {
                    player.damageInvulnerable = false;
                }
            }
            
            // Combined invulnerability check
            player.invulnerable = player.damageInvulnerable || player.isGiant;
            
            // Update giant mode
            if (player.isGiant) {
                if (Date.now() - player.giantTime > player.giantDuration) {
                    player.isGiant = false;
                    // Only reset invulnerability if it was set by the mushroom (not by damage)
                    if (Date.now() - player.invulnerableTime > player.invulnerableDuration) {
                        player.invulnerable = false;
                    }
                    // Reset player size to normal (new otter size)
                    player.width = 64;
                    player.height = 93;
                    player.collisionWidth = 64;
                    player.collisionHeight = 93;
                    // Adjust player position back down to keep feet on the same platform
                    player.y += 40; // Move player down to compensate for smaller collision box
                    console.log('Mushroom power-up expired! Back to normal size and vulnerable.');
                }
            }
            

            
            // No cooldown system - removed for simplicity
            

            
            // ========================================
            // 🔫 LASER PHYSICS & COOLDOWN
            // ========================================
            // Update laser cooldown
            if (player.laserCooldown > 0) {
                player.laserCooldown -= 16; // 60 FPS = 16ms per frame
            }
            
            // Update fireball cooldown
            if (player.fireballCooldown > 0) {
                player.fireballCooldown -= 16; // 60 FPS = 16ms per frame
            }
            

            
            // Update player lasers
            playerLasers.forEach((laser, index) => {
                // Move laser
                laser.x += laser.velX;
                laser.y += laser.velY;
                
                // Remove lasers that go off screen
                if (laser.x < game.camera.x - 100 || laser.x > game.camera.x + game.canvasWidth + 100) {
                    playerLasers.splice(index, 1);
                    return;
                }
                
                // Check collision with enemies
                enemies.forEach((enemy, enemyIndex) => {
                    // Use enemy collision box for more accurate detection
                    const enemyCollisionBox = {
                        x: enemy.x + (enemy.collisionOffsetX || 0),
                        y: enemy.y + (enemy.collisionOffsetY || 0),
                        width: enemy.collisionWidth || enemy.width,
                        height: enemy.collisionHeight || enemy.height
                    };
                    
                    // Use enhanced laser collision detection
                    if (checkLaserCollision(laser, enemyCollisionBox)) {
                        console.log('🔍 Laser collision detected with enemy:', {
                            laser: { x: laser.x, y: laser.y, width: laser.width, height: laser.height },
                            enemy: { x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height, type: enemy.type, health: enemy.health },
                            enemyCollisionBox: enemyCollisionBox,
                            enemyIndex: enemyIndex,
                            totalEnemies: enemies.length
                        });
                    }
                    
                    if (checkLaserCollision(laser, enemyCollisionBox)) {
                        // Laser hit enemy - use enhanced damage for charged lasers
                        let damage = laser.damage || 1;
                        
                        // For charged lasers, use the stored damage value
                        if (laser.chargeLevel > 0) {
                            damage = laser.damage; // Use the enhanced damage from charge level
                            console.log('🔫 Charged laser hit! Charge level:', laser.chargeLevel, 'Damage:', damage);
                        } else {
                            // Regular laser - adjust damage based on enemy type
                        if (enemy.type === 'basic' || enemy.type === 'crab') {
                                damage = 1;
                        } else if (enemy.type === 'charger' || enemy.type === 'eagle' || enemy.type === 'shooter' || enemy.type === 'gator') {
                                damage = 2;
                        } else if (enemy.type === 'shark') {
                                damage = 1;
                        } else {
                                damage = 1;
                            }
                        }
                        
                        // Apply wallet damage bonuses if connected
                        let finalDamage = damage;
                        if (otterWallet && otterWallet.isConnected) {
                            try {
                                const multipliers = otterWallet.getGameMultipliers();
                                finalDamage = Math.floor(damage * multipliers.damage);
                                if (finalDamage > damage) {
                                    console.log(`⚔️ Wallet damage boost: ${damage} → ${finalDamage} (${multipliers.damage}x)`);
                                }
                            } catch (error) {
                                console.warn('⚠️ Error getting wallet damage multipliers:', error);
                            }
                        }
                        
                        console.log('🔫 BEFORE: Enemy health was:', enemy.health, 'Type:', enemy.type);
                        enemy.health -= finalDamage;
                        console.log('🔫 AFTER: Laser hit', enemy.type, 'enemy! Damage:', finalDamage, 'Health remaining:', enemy.health);
                        
                        if (enemy.health <= 0) {
                            // Enemy defeated
                            enemies.splice(enemyIndex, 1);
                            
                            // Track specific enemy types
                            switch (enemy.type) {
                                case 'crab':
                            game.sessionStats.crabsDefeated++;
                            game.sessionStats.currentSessionCrabs++;
                                    break;
                                case 'eagle':
                                    game.sessionStats.eaglesDefeated++;
                                    break;
                                case 'gator':
                                    game.sessionStats.gatorsDefeated++;
                                    break;
                                case 'shark':
                                    game.sessionStats.sharksDefeated++;
                                    break;
                                default:
                                    game.sessionStats.crabsDefeated++;
                                    game.sessionStats.currentSessionCrabs++;
                            }
                            
                            // Add score with XP and multiplier
                            addScoreWithXP(200, `${enemy.type} Defeat`);
                            
                            // Update highest crabs if current session is higher
                            if (game.sessionStats.currentSessionCrabs > game.sessionStats.highestCrabs) {
                                game.sessionStats.highestCrabs = game.sessionStats.currentSessionCrabs;
                            }
                            saveStats();
                            
                            // Check for enemy-related achievements
                            if (game.sessionStats.crabsDefeated === 1) {
                                unlockAchievement('first_enemy');
                            }
                            
                            // Check all achievements after enemy defeat
                            checkAllAchievements();
                            
                            // Enhanced screen shake for charged lasers
                            addScreenShake(2 + (laser.chargeLevel || 0));
                            console.log('🔫 Enemy defeated by laser!');
                        }
                        
                        // Remove laser if it's not a piercing laser or if it's a regular laser
                        if (!laser.pierce || laser.chargeLevel === 0) {
                        playerLasers.splice(index, 1);
                        return;
                        }
                    }
                });
                
                // Check collision with breakable tiles
                breakables.forEach((tile, tileIndex) => {
                    if (!tile.broken && checkLaserCollision(laser, tile)) {
                        console.log('🔫 Laser hit breakable tile! Health before:', tile.health);
                        tile.health--;
                        addScreenShake(3);
                        addFreezeFrame(30);
                        
                        // Create impact particles
                        game.particles.push(...createParticle(tile.x + tile.width/2, tile.y + tile.height/2, 'stomp'));
                        
                        if (tile.health <= 0) {
                            tile.broken = true;
                            console.log('🔫 Breakable tile destroyed by laser!');
                            
                            // Give reward based on tile type
                            if (tile.reward) {
                                switch (tile.reward) {
                                    case 'mushroom':
                                        // Create mushroom at tile location
                                        mushrooms.push({
                                            x: tile.x + tile.width/2,
                                            y: tile.y + tile.height,
                                            collected: false,
                                            type: 'mushroom',
                                            value: 1000 // 1000 points for mushroom
                                        });
                                        console.log('🍄 Mushroom reward from laser-destroyed tile!');
                                        break;
                                    case 'health':
                                        // Create health pickup at tile location
                                        health.push({
                                            x: tile.x + tile.width/2,
                                            y: tile.y + tile.height,
                                            collected: false,
                                            type: 'health'
                                        });
                                        console.log('❤️ Health reward from laser-destroyed tile!');
                                        break;

                                }
                                
                                // Create reward particles
                                game.particles.push(...createParticle(tile.x + tile.width/2, tile.y + tile.height, 'reward'));
                            }
                            
                            // Check if this reveals a secret room
                            secretRooms.forEach(room => {
                                if (!room.discovered && 
                                    Math.abs(tile.x - room.x) < 300 && 
                                    Math.abs(tile.y - room.y) < 200) {
                                    room.discovered = true;
                                    console.log('🔍 Secret room discovered by laser!');
                                }
                            });
                        }
                        
                        // Remove laser
                        playerLasers.splice(index, 1);
                        return;
                    }
                });
                
                // Check collision with treasures (but ignore golden chests)
                treasures.forEach((treasure, treasureIndex) => {
                    if (checkLaserCollision(laser, treasure)) {
                        console.log('🔫 Laser collision detected with treasure:', {
                            treasureType: treasure.type,
                            isGoldenChest: treasure.isGoldenChest,
                            collected: treasure.collected,
                            x: treasure.x,
                            y: treasure.y
                        });
                    }
                    
                    if (!treasure.collected && !treasure.isGoldenChest && checkLaserCollision(laser, treasure)) {
                        // Regular treasure can be destroyed by laser
                            treasure.collected = true;
                        game.score += treasure.value;
                            game.sessionStats.treasuresCollected++;
                            game.sessionStats.treasuresFound++;
                        game.sessionStats.totalScore += treasure.value;
                            game.sessionStats.currentSessionTreasures++;
                        game.sessionStats.currentSessionScore += treasure.value;
                            
                            // Update highest treasures if current session is higher
                            if (game.sessionStats.currentSessionTreasures > game.sessionStats.highestTreasures) {
                                game.sessionStats.highestTreasures = game.sessionStats.currentSessionTreasures;
                            }
                        saveStats();
                            
                            if (treasure.type === 'rareTreasure') {
                                game.coins += 25; // Extra bonus coins for rare treasures
                                game.lives = Math.min(game.lives + 1, game.maxLives); // Bonus life for rare treasure
                            } else {
                                game.coins += 10; // Regular bonus coins for normal treasures
                        }
                        
                        addScreenShake(3);
                        console.log('🔫 Regular treasure destroyed by laser!');
                        
                        // Remove laser
                        playerLasers.splice(index, 1);
                        return;
                    } else if (!treasure.collected && treasure.isGoldenChest && checkLaserCollision(laser, treasure)) {
                        // Golden chest is immune to laser damage - just remove the laser
                        console.log('🔫 Golden chest is immune to laser damage! Use F key with a key to open.');
                        console.log('🛡️ Golden chest has laser immunity - cannot be destroyed by shooting!');
                        console.log('🛡️ Golden chest protection activated - laser removed, chest unharmed!');
                        addScreenShake(1);
                        
                        // Create golden sparkle effect to show immunity
                        game.particles.push(...createParticle(treasure.x + treasure.width/2, treasure.y + treasure.height/2, 'golden'));
                            
                            // Remove laser
                            playerLasers.splice(index, 1);
                            return;
                        }
                });
                
                // Check collision with boss
                if (game.currentBoss && checkCollision(laser, game.currentBoss)) {
                    // Boss takes MASSIVE damage from charged lasers
                    let bossDamage = 1; // Default damage for regular lasers
                    
                    // Use enhanced charged laser damage with boss multiplier
                    if (laser.chargeLevel > 0) {
                        // Boss damage multiplier: charged lasers do 2x damage to bosses
                        bossDamage = laser.damage * 2; // Double the charged laser damage against bosses
                        console.log('🔫 CHARGED LASER HIT BOSS! Charge level:', laser.chargeLevel, 'Base damage:', laser.damage, 'Boss damage:', bossDamage);
                    } else {
                        console.log('🔫 Regular laser hit boss! Damage:', bossDamage);
                    }
                    
                    game.currentBoss.health -= bossDamage;
                    addScreenShake(3 + (laser.chargeLevel || 0));
                    console.log('🔫 Boss hit by laser! Damage:', bossDamage, 'Health remaining:', game.currentBoss.health);
                    
                    if (game.currentBoss.health <= 0) {
                        // Boss defeated
                        game.currentBoss = null;
                        // Don't set bossActive to false yet - keep lava until level changes
                        // game.bossActive = false; // REMOVED - keep lava active
                        game.score += 1000;
                        game.sessionStats.bossesDefeated++;
                        game.sessionStats.currentSessionBosses++;
                        game.sessionStats.totalScore += 1000;
                        game.sessionStats.currentSessionScore += 1000;
                        saveStats();
                        addScreenShake(5);
                        console.log('🔫 Boss defeated by laser! Lava remains until level change.');
                    }
                    
                    // Remove laser
                    playerLasers.splice(index, 1);
                    return;
                }
                
                // REMOVED DUPLICATE TREASURE COLLISION - Golden chests are now properly protected!
                // The first treasure collision detection above handles golden chest immunity correctly.
            });
            
            // 🔥 Update player fireballs
            playerFireballs.forEach((fireball, index) => {
                // Update fireball lifetime
                fireball.lifetime = Date.now() - fireball.creationTime;
                
                // Remove fireballs that have exceeded their lifetime (3 seconds)
                if (fireball.lifetime >= fireball.maxLifetime) {
                    console.log('🔥 Fireball expired after 3 seconds');
                    playerFireballs.splice(index, 1);
                    return;
                }
                
                // Move fireball
                fireball.x += fireball.velX;
                fireball.y += fireball.velY;
                
                                 // Remove fireballs that go off screen
                 if (fireball.x < game.camera.x - 100 || fireball.x > game.camera.x + game.canvasWidth + 100 ||
                     fireball.y < game.camera.y - 100 || fireball.y > game.camera.y + game.canvasHeight + 100) {
                     playerFireballs.splice(index, 1);
                     return;
                 }
                 
                 // Check if fireball hit water/lava - fireballs die in water
                 if (fireball.y + fireball.height > game.waterLevel) {
                     // Check if this is a boss level (boss levels have lava instead of water)
                     const isBossLevel = game.currentBoss !== null;
                     
                     if (isBossLevel) {
                         console.log('🔥 Fireball hit lava - extinguishing!');
                         
                         // Create lava splash effect
                         for (let i = 0; i < 8; i++) {
                             const splashParticle = {
                                 x: fireball.x + fireball.width / 2,
                                 y: game.waterLevel,
                                 velX: (Math.random() - 0.5) * 4,
                                 velY: -Math.random() * 6 - 2,
                                 life: 60,
                                 maxLife: 60,
                                 size: Math.random() * 3 + 2,
                                 color: '#FF4500', // Orange-red lava splash
                                 type: 'lava_splash'
                             };
                             game.particles.push(splashParticle);
                         }
                         
                         // Create lava steam effect
                         for (let i = 0; i < 5; i++) {
                             const steamParticle = {
                                 x: fireball.x + fireball.width / 2,
                                 y: game.waterLevel,
                                 velX: (Math.random() - 0.5) * 2,
                                 velY: -Math.random() * 3 - 1,
                                 life: 90,
                                 maxLife: 90,
                                 size: Math.random() * 4 + 3,
                                 color: 'rgba(255, 165, 0, 0.8)', // Orange steam
                                 type: 'lava_steam'
                             };
                             game.particles.push(steamParticle);
                         }
                     } else {
                         console.log('🔥 Fireball hit water - extinguishing!');
                         
                         // Create water splash effect
                         for (let i = 0; i < 8; i++) {
                             const splashParticle = {
                                 x: fireball.x + fireball.width / 2,
                                 y: game.waterLevel,
                                 velX: (Math.random() - 0.5) * 4,
                                 velY: -Math.random() * 6 - 2,
                                 life: 60,
                                 maxLife: 60,
                                 size: Math.random() * 3 + 2,
                                 color: '#87CEEB', // Light blue water splash
                                 type: 'splash'
                             };
                             game.particles.push(splashParticle);
                         }
                         
                         // Create steam effect
                         for (let i = 0; i < 5; i++) {
                             const steamParticle = {
                                 x: fireball.x + fireball.width / 2,
                                 y: game.waterLevel,
                                 velX: (Math.random() - 0.5) * 2,
                                 velY: -Math.random() * 3 - 1,
                                 life: 90,
                                 maxLife: 90,
                                 size: Math.random() * 4 + 3,
                                 color: 'rgba(255, 255, 255, 0.7)', // White steam
                                 type: 'steam'
                             };
                             game.particles.push(steamParticle);
                         }
                     }
                     
                     playerFireballs.splice(index, 1);
                     addScreenShake(1);
                     return;
                 }
                
                // Check collision with platforms for bouncing (unlimited bounces for 3 seconds)
                platforms.forEach(platform => {
                    if (platform.isVisible !== false) {
                        // Add a longer delay to prevent premature bounces (300ms after creation)
                        if (fireball.lifetime < 300) {
                            return; // Skip collision detection for first 300ms
                        }
                        
                        // Skip water surface platforms to prevent glitching
                        if (platform.y >= game.waterLevel - 10 && platform.y <= game.waterLevel + 10) {
                            return; // Skip water surface platforms
                        }
                        
                        // Skip the starting platform to prevent initial glitches
                        if (platform.x === 0 && platform.y === 1320) {
                            return; // Skip starting platform
                        }
                        
                        // Check if player is inside this platform's collision box
                        const playerInPlatform = (
                            player.x < platform.x + platform.width &&
                            player.x + player.width > platform.x &&
                            player.y < platform.y + platform.height &&
                            player.y + player.height > platform.y
                        );
                        
                        // If player is inside this platform, skip collision for this platform
                        if (playerInPlatform) {
                            console.log('🔥 Player inside platform - fireball passes through');
                            return;
                        }
                        
                        // Use more precise collision detection
                        const fireballBounds = {
                            x: fireball.x,
                            y: fireball.y,
                            width: fireball.width,
                            height: fireball.height
                        };
                        
                        const platformBounds = {
                            x: platform.x,
                            y: platform.y,
                            width: platform.width,
                            height: platform.height
                        };
                        
                        if (checkCollision(fireballBounds, platformBounds)) {
                            // Bounce off platform (unlimited bounces within 3 second lifetime)
                            
                            // Determine bounce direction with more precise detection
                            const fireballCenterX = fireball.x + fireball.width / 2;
                            const fireballCenterY = fireball.y + fireball.height / 2;
                            const platformCenterX = platform.x + platform.width / 2;
                            const platformCenterY = platform.y + platform.height / 2;
                            
                            // Calculate which side of the platform was hit
                            const dx = fireballCenterX - platformCenterX;
                            const dy = fireballCenterY - platformCenterY;
                            
                            // More precise bounce detection
                            const horizontalOverlap = Math.min(fireball.x + fireball.width, platform.x + platform.width) - Math.max(fireball.x, platform.x);
                            const verticalOverlap = Math.min(fireball.y + fireball.height, platform.y + platform.height) - Math.max(fireball.y, platform.y);
                            
                            if (horizontalOverlap > 0 && verticalOverlap > 0) {
                                // Determine which side had the smaller overlap (the side that was hit)
                                if (horizontalOverlap < verticalOverlap) {
                                    // Hit left or right side
                                    fireball.velX = -fireball.velX;
                                    // Move fireball slightly away from platform to prevent sticking
                                    if (dx > 0) {
                                        fireball.x = platform.x + platform.width + 2;
                                    } else {
                                        fireball.x = platform.x - fireball.width - 2;
                                    }
                                } else {
                                    // Hit top or bottom side
                                    fireball.velY = -fireball.velY;
                                    // Move fireball slightly away from platform to prevent sticking
                                    if (dy > 0) {
                                        fireball.y = platform.y + platform.height + 2;
                                    } else {
                                        fireball.y = platform.y - fireball.height - 2;
                                    }
                                }
                                
                                // Add minimal randomness to bounce
                                fireball.velX += (Math.random() - 0.5) * 0.5; // Very minimal randomness
                                fireball.velY += (Math.random() - 0.5) * 0.5; // Very minimal randomness
                                
                                // Normalize velocity to maintain speed
                                const speed = Math.sqrt(fireball.velX * fireball.velX + fireball.velY * fireball.velY);
                                fireball.velX = (fireball.velX / speed) * player.fireballSpeed;
                                fireball.velY = (fireball.velY / speed) * player.fireballSpeed;
                                
                                addScreenShake(1);
                                console.log('🔥 Fireball bounced off platform! Lifetime remaining:', (fireball.maxLifetime - fireball.lifetime).toFixed(0), 'ms');
                            }
                        }
                    }
                });
                
                // Check collision with enemies
                enemies.forEach((enemy, enemyIndex) => {
                    const enemyCollisionBox = {
                        x: enemy.x + (enemy.collisionOffsetX || 0),
                        y: enemy.y + (enemy.collisionOffsetY || 0),
                        width: enemy.collisionWidth || enemy.width,
                        height: enemy.collisionHeight || enemy.height
                    };
                    
                    // Enhanced collision detection with larger hit area for fireballs
                    const fireballHitArea = {
                        x: fireball.x - 5,
                        y: fireball.y - 5,
                        width: fireball.width + 10,
                        height: fireball.height + 10
                    };
                    
                    if (checkCollision(fireballHitArea, enemyCollisionBox)) {
                        console.log('🔥 FIREBALL COLLISION DETECTED!');
                        console.log('🔥 Enemy type:', enemy.type, 'Health before:', enemy.health);
                        console.log('🔥 Fireball damage:', fireball.damage);
                        
                        // Fireball hit enemy
                        enemy.health -= fireball.damage;
                        game.sessionStats.fireballsHit++;
                        console.log('🔥 Fireball hit enemy! Damage:', fireball.damage, 'Health remaining:', enemy.health);
                        
                        if (enemy.health <= 0) {
                            // Enemy defeated
                            console.log('🔥 ENEMY KILLED BY FIREBALL! Type:', enemy.type);
                            enemies.splice(enemyIndex, 1);
                            
                            // Create explosion effect at enemy position
                            game.particles.push(...createParticle(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 'fireball'));
                            
                            // Track specific enemy types
                            switch (enemy.type) {
                                case 'crab':
                                    game.sessionStats.crabsDefeated++;
                                    game.sessionStats.currentSessionCrabs++;
                                    break;
                                case 'eagle':
                                    game.sessionStats.eaglesDefeated++;
                                    break;
                                case 'gator':
                                    game.sessionStats.gatorsDefeated++;
                                    break;
                                case 'shark':
                                    game.sessionStats.sharksDefeated++;
                                    break;
                                default:
                                    game.sessionStats.crabsDefeated++;
                                    game.sessionStats.currentSessionCrabs++;
                            }
                            
                            // Add score with XP and multiplier
                            addScoreWithXP(200, `${enemy.type} Defeat`);
                            
                            // Update highest crabs if current session is higher
                            if (game.sessionStats.currentSessionCrabs > game.sessionStats.highestCrabs) {
                                game.sessionStats.highestCrabs = game.sessionStats.currentSessionCrabs;
                            }
                            saveStats();
                            
                            // Check for enemy-related achievements
                            if (game.sessionStats.crabsDefeated === 1) {
                                unlockAchievement('first_enemy');
                            }
                        }
                        
                        // Remove fireball after hitting enemy
                        playerFireballs.splice(index, 1);
                        addScreenShake(2);
                        return;
                    }
                });
                
                // Check collision with boss
                if (game.currentBoss && checkCollision(fireball, game.currentBoss)) {
                    game.currentBoss.health -= fireball.damage * 2; // Double damage to boss
                    addScreenShake(3);
                    console.log('🔥 Fireball hit boss! Damage:', fireball.damage * 2, 'Health remaining:', game.currentBoss.health);
                    
                    if (game.currentBoss.health <= 0) {
                        // Boss defeated
                        game.currentBoss = null;
                        game.score += 1000;
                        game.sessionStats.bossesDefeated++;
                        game.sessionStats.currentSessionBosses++;
                        game.sessionStats.totalScore += 1000;
                        game.sessionStats.currentSessionScore += 1000;
                        saveStats();
                        addScreenShake(5);
                        console.log('🔥 Boss defeated by fireball!');
                    }
                    
                    // Remove fireball after hitting boss
                    playerFireballs.splice(index, 1);
                    return;
                }
            });
            
            // Safety check: prevent falling through platforms after size changes
            if (player.isGiant && player.lastPlatform && player.velY >= 0 && !player.onGround && !game.keys['downJumpPressed']) {
                const collisionX = player.x + player.collisionOffsetX;
                const collisionY = player.y + player.collisionOffsetY;
                
                // Check if player is over their last platform
                if (collisionX + player.collisionWidth > player.lastPlatform.x && 
                    collisionX < player.lastPlatform.x + player.lastPlatform.width &&
                    collisionY + player.collisionHeight >= player.lastPlatform.y - 16 &&
                    collisionY + player.collisionHeight <= player.lastPlatform.y + 16) {
                    
                    // Snap player back to platform
                    player.y = player.lastPlatform.y - player.collisionHeight - player.collisionOffsetY;
                    player.velY = 0;
                    player.onGround = true;
                    player.canDoubleJump = true; // Reset double jump when landing
                }
            }
            
            // Additional safety check for giant mode: if player is falling and not on ground, try to find platform
            if (player.isGiant && player.velY > 0 && !player.onGround && !game.keys['downJumpPressed']) {
                let foundPlatform = false;
                for (const platform of platforms) {
                    if (platform.isVisible !== false) {
                        const collisionX = player.x + player.collisionOffsetX;
                        const collisionY = player.y + player.collisionOffsetY;
                        
                        // Check if player is over this platform
                        if (collisionX + player.collisionWidth > platform.x && 
                            collisionX < platform.x + platform.width &&
                            collisionY + player.collisionHeight >= platform.y - 10 &&
                            collisionY + player.collisionHeight <= platform.y + 10) {
                            
                            // Snap player to this platform
                            player.y = platform.y - player.collisionHeight - player.collisionOffsetY;
                            player.velY = 0;
                            player.onGround = true;
                            player.canDoubleJump = true;
                            player.lastPlatform = platform;
                            
                            // 🚀 Set moving platform state if this is a moving platform
                            if (platform.type === 'linear') {
                                player.onMovingPlatform = true;
                                player.platformStartTime = Date.now();
                            } else {
                                player.onMovingPlatform = false;
                            }
                            
                            foundPlatform = true;
                            break;
                        }
                    }
                }
            }
            
            // Update moving platforms
            platforms.forEach(platform => {
                if (platform.type === 'linear') {
                    // Store previous position for delta calculation
                    const previousX = platform.x;
                    const previousY = platform.y;
                    
                    // Linear moving platform - much slower movement
                    platform.moveProgress += platform.moveSpeed * 0.005; // Reduced from 0.01 to 0.005
                    if (platform.moveProgress > 1) {
                        platform.moveProgress = 0;
                    }
                    
                    const progress = Math.sin(platform.moveProgress * Math.PI * 2);
                    if (platform.moveDirection === 'horizontal') {
                        platform.x = platform.startX + progress * platform.moveDistance;
                    } else {
                        platform.y = platform.startY + progress * platform.moveDistance;
                    }
                    
                    // Store movement delta for player movement
                    platform.deltaX = platform.x - previousX;
                    platform.deltaY = platform.y - previousY;
                } else if (platform.type === 'disappearing') {
                    // Disappearing platform
                    const timeSinceToggle = Date.now() - platform.lastToggle;
                    if (platform.isVisible && timeSinceToggle > platform.disappearTime) {
                        platform.isVisible = false;
                        platform.lastToggle = Date.now();
                    } else if (!platform.isVisible && timeSinceToggle > platform.reappearTime) {
                        platform.isVisible = true;
                        platform.lastToggle = Date.now();
                    }
                } else if (platform.type === 'cloud') {
                    // Cloud platform disappearing behavior
                    if (platform.isDisappearing && platform.cloudStartTime) {
                        const timeOnCloud = Date.now() - platform.cloudStartTime;
                        if (timeOnCloud >= platform.cloudDisappearTime) {
                            platform.isVisible = false;
                            platform.isDisappearing = false;
                            platform.cloudStartTime = null;
                            platform.respawnStartTime = Date.now(); // Start respawn timer
                        }
                    }
                    
                    // Cloud respawn behavior
                    if (!platform.isVisible && platform.respawnStartTime) {
                        const timeSinceDisappear = Date.now() - platform.respawnStartTime;
                        if (timeSinceDisappear >= 5000) { // 5 seconds to respawn
                            platform.isVisible = true;
                            platform.respawnStartTime = null;
                            console.log('☁️ Cloud respawned!');
                        }
                    }
                }
            });
            
            // Move player with moving platform
            if (player.onMovingPlatform && player.lastPlatform && player.lastPlatform.type === 'linear') {
                const platform = player.lastPlatform;
                
                // Verify player is still on the platform
                const collisionX = player.x + player.collisionOffsetX;
                const collisionY = player.y + player.collisionOffsetY;
                
                if (collisionX + player.collisionWidth > platform.x && collisionX < platform.x + platform.width &&
                    collisionY + player.collisionHeight >= platform.y - 8 && collisionY + player.collisionHeight <= platform.y + 8) {
                    
                    // Move player with platform using stored delta
                    if (platform.deltaX !== undefined && platform.deltaY !== undefined) {
                        player.x += platform.deltaX;
                        player.y += platform.deltaY;
                    }
                } else {
                    // Player is no longer on the platform
                    player.onMovingPlatform = false;
                }
                
                // Safety check: force player off platform if stuck for too long (5 seconds)
                if (player.onMovingPlatform && Date.now() - player.platformStartTime > 5000) {
                    console.log('Safety: Forcing player off stuck platform');
                    player.onMovingPlatform = false;
                    player.velY = -5; // Give player a small upward boost
                }
            }
            
            // ========================================
            // 🏗️ ENHANCED PLATFORM COLLISION & DOUBLE JUMP RESET
            // ========================================
            const tolerance = 5; // 🎯 Define collision tolerance
            let wasOnGround = player.onGround; // 📝 Remember previous ground state
            player.onGround = false;

            for (const platform of platforms) {
                if (platform.isVisible !== false) { // Skip invisible disappearing platforms and clouds
                    const collisionX = player.x + player.collisionOffsetX;
                    const collisionY = player.y + player.collisionOffsetY;
                    
                    const playerLeft = collisionX;
                    const playerRight = collisionX + player.collisionWidth;
                    const playerTop = collisionY;
                    const playerBottom = collisionY + player.collisionHeight;
                    
                    const platformLeft = platform.x;
                    const platformRight = platform.x + platform.width;
                    const platformTop = platform.y;
                    const platformBottom = platform.y + platform.height;
                    
                    // ✅ ENHANCED collision detection - more forgiving for moving players
                    const horizontalOverlap = playerRight > platformLeft + 2 && playerLeft < platformRight - 2;
                    const verticalCollision = playerBottom >= platformTop - tolerance && 
                                             playerBottom <= platformTop + tolerance * 2;
                    const isAbovePlatform = collisionY < platformBottom - 5;
                    const isFalling = player.velY >= -2; // More forgiving - allows small upward velocity
                    
                    // 🔽 DOWN JUMP CHECK - Skip collision if player just dropped through this platform
                    const justDroppedThrough = game.keys['downJumpPressed'] && player.lastPlatform === platform;
                    
                    // Reset down jump flag if player successfully dropped through a platform
                    if (game.keys['downJumpPressed'] && player.velY > 0 && player.y > (player.lastPlatform ? player.lastPlatform.y + 50 : 0)) {
                        game.keys['downJumpPressed'] = false;
                        console.log('🔽 Down jump flag reset - successfully dropped through platform');
                    }
                    
                    // 🌊 SWIMMING CHECK - Skip collision if player is swimming up in water
                    const isSwimmingUp = player.inWater && player.swimming && player.velY < 0;
                    
                    if (horizontalOverlap && verticalCollision && isAbovePlatform && isFalling && !justDroppedThrough && !isSwimmingUp) {
                        // 🎯 Player landed on platform - snap to exact position
                        player.y = platform.y - player.collisionHeight - player.collisionOffsetY;
                        player.velY = 0;
                        player.onGround = true;
                        
                        // 📍 Track last platform
                        player.lastPlatform = platform;
                        
                        // 🚀 Set moving platform state if this is a moving platform
                        if (platform.type === 'linear') {
                            player.onMovingPlatform = true;
                            player.platformStartTime = Date.now();
                            console.log('Player landed on moving platform');
                        } else {
                            player.onMovingPlatform = false;
                        }
                        
                        // ☁️ Start cloud disappearing timer when player steps on cloud
                        if (platform.type === 'cloud' && !platform.isDisappearing) {
                            platform.isDisappearing = true;
                            platform.cloudStartTime = Date.now();
                            console.log('☁️ Cloud disappearing timer started! Will disappear in 3 seconds, respawn in 8 seconds total.');
                        }
                        
                        break; // Exit loop once we find a platform we're standing on
                    }
                }
            }

            // 🧱 BARRIER COLLISION DETECTION - Prevent going too far left
            for (const platform of platforms) {
                if (platform.type === 'barrier') {
                    const collisionX = player.x + player.collisionOffsetX;
                    const collisionY = player.y + player.collisionOffsetY;
                    
                    const playerLeft = collisionX;
                    const playerRight = collisionX + player.collisionWidth;
                    const playerTop = collisionY;
                    const playerBottom = collisionY + player.collisionHeight;
                    
                    const barrierLeft = platform.x;
                    const barrierRight = platform.x + platform.width;
                    const barrierTop = platform.y;
                    const barrierBottom = platform.y + platform.height;
                    
                    // Check if player is colliding with barrier
                    if (playerRight > barrierLeft && playerLeft < barrierRight &&
                        playerBottom > barrierTop && playerTop < barrierBottom) {
                        
                        // Push player back to the right of the barrier
                        player.x = barrierRight - player.collisionOffsetX;
                        player.velX = Math.max(0, player.velX); // Stop leftward movement
                        console.log('🧱 Hit left barrier - pushed back!');
                    }
                }
            }
            
            // 🔋 SEPARATE DOUBLE JUMP RECHARGE LOGIC - More reliable
            // This runs AFTER all collision detection is complete
            // 🔋 DOUBLE JUMP RECHARGE LOGIC
            if (player.onGround) {
                // Just landed (wasn't on ground before, now is)
                if (!wasOnGround && !player.canDoubleJump) {
                    player.canDoubleJump = true;
                    console.log('🔋 Double jump recharged - just landed!');
                }
                // Still on ground and missing double jump (safety net)
                else if (!player.canDoubleJump) {
                    player.canDoubleJump = true;
                    console.log('🔋 Double jump recharged - safety recharge while on ground');
                }
            }
            
            // Move collectibles and enemies with their platforms
            platforms.forEach(platform => {
                if (platform.type === 'linear' && platform.deltaX !== undefined && platform.deltaY !== undefined) {
                    // Move enemies on this platform
                    enemies.forEach(enemy => {
                        if (enemy.x >= platform.x && enemy.x <= platform.x + platform.width &&
                            enemy.y >= platform.y - enemy.height - 5 && enemy.y <= platform.y + 5) {
                            enemy.x += platform.deltaX;
                            enemy.y += platform.deltaY;
                        }
                    });
                    
                    // Move collectibles on this platform
                    fish.forEach(fish => {
                        if (!fish.collected && fish.x >= platform.x && fish.x <= platform.x + platform.width &&
                            fish.y >= platform.y - 80 && fish.y <= platform.y + 20) {
                            fish.x += platform.deltaX;
                            fish.y += platform.deltaY;
                        }
                    });
                    
                    coins.forEach(coin => {
                        if (!coin.collected && coin.x >= platform.x && coin.x <= platform.x + platform.width &&
                            coin.y >= platform.y - 80 && coin.y <= platform.y + 20) {
                            coin.x += platform.deltaX;
                            coin.y += platform.deltaY;
                        }
                    });
                    
                    health.forEach(h => {
                        if (!h.collected && h.x >= platform.x && h.x <= platform.x + platform.width &&
                            h.y >= platform.y - 80 && h.y <= platform.y + 20) {
                            h.x += platform.deltaX;
                            h.y += platform.deltaY;
                        }
                    });
                    
                    treasures.forEach(treasure => {
                        if (!treasure.collected && treasure.x >= platform.x && treasure.x <= platform.x + platform.width &&
                            treasure.y >= platform.y - 80 && treasure.y <= platform.y + 20) {
                            treasure.x += platform.deltaX;
                            treasure.y += platform.deltaY;
                        }
                    });
                    
                    jetpacks.forEach(jetpack => {
                        if (!jetpack.collected && jetpack.x >= platform.x && jetpack.x <= platform.x + platform.width &&
                            jetpack.y >= platform.y - 80 && jetpack.y <= platform.y + 20) {
                            jetpack.x += platform.deltaX;
                            jetpack.y += platform.deltaY;
                        }
                    });
                    
                    mushrooms.forEach(mushroom => {
                        if (!mushroom.collected && mushroom.x >= platform.x && mushroom.x <= platform.x + platform.width &&
                            mushroom.y >= platform.y - 80 && mushroom.y <= platform.y + 20) {
                            mushroom.x += platform.deltaX;
                            mushroom.y += platform.deltaY;
                        }
                    });
                    
                    // Move laser powerups on this platform
                    if (laserPowerups) {
                        laserPowerups.forEach(laser => {
                            if (!laser.collected && laser.x >= platform.x && laser.x <= platform.x + platform.width &&
                                laser.y >= platform.y - 80 && laser.y <= platform.y + 20) {
                                laser.x += platform.deltaX;
                                laser.y += platform.deltaY;
                            }
                        });
                    }
                    
                    // Move keys on this platform
                    keys.forEach(key => {
                        if (!key.collected && key.x >= platform.x && key.x <= platform.x + platform.width &&
                            key.y >= platform.y - 80 && key.y <= platform.y + 20) {
                            key.x += platform.deltaX;
                            key.y += platform.deltaY;
                        }
                    });
                    
                    // Move breakable tiles (crates) on this platform
                    breakables.forEach(breakable => {
                        if (!breakable.broken && breakable.x >= platform.x && breakable.x <= platform.x + platform.width &&
                            breakable.y >= platform.y - 80 && breakable.y <= platform.y + 20) {
                            breakable.x += platform.deltaX;
                            breakable.y += platform.deltaY;
                        }
                    });
                }
            });
            
            // Player is not on ground - reset moving platform state
            if (!player.onGround && player.onMovingPlatform) {
                player.onMovingPlatform = false;
                console.log('Player left moving platform - no longer on ground');
            }
            
            // Screen boundaries - check if player has fallen off the bottom of the world
            // All platforms are now solid, so use all platforms for world bottom calculation
            const worldBottom = Math.max(...platforms.map(p => p.y)) + 500; // 500 pixels below the lowest platform - reasonable death boundary
            const worldTop = Math.min(...platforms.map(p => p.y)) - 1000; // 1000 pixels above the highest platform - reasonable death boundary
            if (player.y < worldTop) {
                console.log('Player went above world! Player Y:', player.y, 'World top:', worldTop);
                console.log('Player lives before death:', game.lives);
                game.lives--;
                if (game.lives <= 0) {
                    game.gameOver = true;
                } else {
                    // Reset player position to last platform they were on
                    player.velX = 0;
                    player.velY = 0;
                    player.canDoubleJump = true;
                    player.onGround = true; // Ensure they start on ground
                    
                    if (game.activeCheckpoint) {
                        // Respawn at the last activated checkpoint
                        player.x = game.activeCheckpoint.platform.x + (game.activeCheckpoint.platform.width / 2) - (player.collisionWidth / 2);
                        player.y = game.activeCheckpoint.platform.y - player.collisionHeight - player.collisionOffsetY;
                        console.log('Respawning at checkpoint');
                    } else {
                        // Simple respawn - just use the first platform
                        console.log('Simple respawn to first platform');
                        
                        // Reset checkpoints when player dies
                        game.activeCheckpoint = null;
                        if (game.checkpointProgress[game.level]) {
                            delete game.checkpointProgress[game.level];
                        }
                        console.log('Checkpoints reset due to death');
                        
                        if (platforms.length > 0) {
                            const firstPlatform = platforms[0];
                            player.x = firstPlatform.x + 50; // Simple positioning
                            player.y = firstPlatform.y - player.collisionHeight - 10;
                            console.log('Respawning at first platform:', firstPlatform.x, firstPlatform.y);
                        } else {
                            // Emergency fallback
                            player.x = 240;
                            player.y = 1170;
                            console.log('Emergency fallback respawn');
                        }
                    }
                    
                    // Simple safety check
                    if (platforms.length > 0) {
                        const firstPlatform = platforms[0];
                        // Ensure player is above the platform
                        if (player.y + player.collisionHeight > firstPlatform.y) {
                            player.y = firstPlatform.y - player.collisionHeight - 10;
                        }
                        console.log('Simple safety check completed');
                    }
                }
            }
            
            if (player.y > worldBottom) {
                console.log('Player fell off world! Player Y:', player.y, 'World bottom:', worldBottom);
                console.log('Player lives before death:', game.lives);
                game.lives--;
                if (game.lives <= 0) {
                    game.gameOver = true;
                } else {
                    // Reset player position to last platform they were on
                    player.velX = 0;
                    player.velY = 0;
                    player.canDoubleJump = true;
                    player.onGround = true; // Ensure they start on ground
                    
                    if (game.activeCheckpoint) {
                        // Respawn at the last activated checkpoint
                        player.x = game.activeCheckpoint.platform.x + (game.activeCheckpoint.platform.width / 2) - (player.collisionWidth / 2);
                        player.y = game.activeCheckpoint.platform.y - player.collisionHeight - player.collisionOffsetY;
                        console.log('Respawning at checkpoint');
                    } else {
                    // Simple respawn - just use the first platform
                    console.log('Simple respawn to first platform');
                    
                    // Reset checkpoints when player dies
                    game.activeCheckpoint = null;
                    if (game.checkpointProgress[game.level]) {
                        delete game.checkpointProgress[game.level];
                    }
                    console.log('Checkpoints reset due to death');
                    
                    if (platforms.length > 0) {
                        const firstPlatform = platforms[0];
                        player.x = firstPlatform.x + 50; // Simple positioning
                        player.y = firstPlatform.y - player.collisionHeight - 10;
                        console.log('Respawning at first platform:', firstPlatform.x, firstPlatform.y);
                    } else {
                        // Emergency fallback
                        player.x = 240;
                        player.y = 1170;
                        console.log('Emergency fallback respawn');
                    }
                }
                    
                    // Simple safety check
                    if (platforms.length > 0) {
                        const firstPlatform = platforms[0];
                        // Ensure player is above the platform
                        if (player.y + player.collisionHeight > firstPlatform.y) {
                            player.y = firstPlatform.y - player.collisionHeight - 10;
                        }
                        console.log('Simple safety check completed');
                    }
                }
            }
            
            // Update camera - position it closer to player and add Y positioning
            game.camera.x = player.x - game.canvasWidth / 2.5; // Changed from /3 to /2.5 to be closer
            if (game.camera.x < 0) game.camera.x = 0;
            
            // Add Y camera positioning to follow player vertically
            game.camera.y = player.y - game.canvasHeight / 2;
            // Removed ALL limits to allow camera to follow player anywhere
            
            // Debug camera movement (only log occasionally to avoid spam)
            if (Math.random() < 0.01) { // 1% chance to log
                console.log('📷 Camera following player - Player Y:', player.y, 'Camera Y:', game.camera.y, 'Screen Y:', player.y - game.camera.y);
                if (game.camera.y < 0) {
                    console.log('🚀 Camera is in negative Y territory - following player upward!');
                }
            }
            
            // 🤖 Update AI Bot (performance optimized)
            if (game.aiBot.isVisible) {
                updateAiBot();
            }
            
            // Fish collection
            fish.forEach((f, index) => {
                if (!f.collected && checkCollision(player, { x: f.x - 19, y: f.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    f.collected = true;
                    game.score += 100;
                    game.sessionStats.fishCollected++;
                    game.sessionStats.totalScore += 100;
                    game.sessionStats.currentSessionFish++;
                    game.sessionStats.currentSessionScore += 100;
                    
                    // Update highest fish if current session is higher
                    if (game.sessionStats.currentSessionFish > game.sessionStats.highestFish) {
                        game.sessionStats.highestFish = game.sessionStats.currentSessionFish;
                    }
                    saveStats();
                }
            });
            
            // Coin collection
            coins.forEach((c, index) => {
                if (!c.collected && checkCollision(player, { x: c.x - 14, y: c.y - 14, width: 29, height: 29 })) { // Scaled from 6, 12 (6*2.4=14.4, 12*2.4=28.8)
                    c.collected = true;
                    
                    // Apply wallet bonuses if connected
                    let coinMultiplier = 1;
                    let bonusCoins = 0;
                    if (otterWallet && otterWallet.isConnected) {
                        try {
                            const multipliers = otterWallet.getGameMultipliers();
                            coinMultiplier = multipliers.points;
                            
                            // Apply luck bonus for extra coins
                            if (multipliers.luck > 1.0 && Math.random() < 0.3) {
                                bonusCoins = Math.floor(multipliers.luck);
                                console.log(`🍀 Lucky! +${bonusCoins} bonus coins from wallet traits!`);
                            }
                        } catch (error) {
                            console.warn('⚠️ Error getting wallet coin multipliers:', error);
                        }
                    }
                    
                    game.coins += coinMultiplier + bonusCoins;
                    game.marketplace.coins += coinMultiplier + bonusCoins; // Add coins to marketplace
                    game.sessionStats.totalCoins += coinMultiplier + bonusCoins;
                    game.sessionStats.currentSessionCoins += coinMultiplier + bonusCoins;
                    
                    // Add score with XP and multiplier
                    addScoreWithXP(25 * coinMultiplier, 'Coin');
                    
                    // Update highest coins if current session is higher
                    if (game.sessionStats.currentSessionCoins > game.sessionStats.highestCoins) {
                        game.sessionStats.highestCoins = game.sessionStats.currentSessionCoins;
                    }
                    saveStats();
                    saveMarketplaceData(); // Save marketplace data when coins are collected
                    
                    // Check for coin-related achievements
                    if (game.sessionStats.totalCoins === 1) {
                        unlockAchievement('first_coin');
                    }
                    if (game.sessionStats.currentSessionCoins >= 10) {
                        unlockAchievement('ten_coins');
                    }
                    
                    // Check for score achievement
                    if (game.sessionStats.currentSessionScore >= 100) {
                        unlockAchievement('hundred_score');
                    }
                    
                    // Update collectibles counter
                    game.collectiblesCount.coinsCollected++;
                    updateCollectiblesCounter();
                    
                    // Check all achievements after coin collection
                    checkAllAchievements();
                }
            });
            
            // Health collection - more difficult to find health
            health.forEach((h, index) => {
                if (!h.collected && checkCollision(player, { x: h.x - 19, y: h.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    h.collected = true;
                    game.score += 25; // Reduced points from 50 to 25
                    game.sessionStats.healthCollected++;
                    game.sessionStats.healthPickups++;
                    game.sessionStats.totalScore += 25;
                    game.sessionStats.currentSessionHealth++;
                    game.sessionStats.currentSessionScore += 25;
                    
                    // Update highest health if current session is higher
                    if (game.sessionStats.currentSessionHealth > game.sessionStats.highestHealth) {
                        game.sessionStats.highestHealth = game.sessionStats.currentSessionHealth;
                    }
                    saveStats();
                    
                    // Heal player and 60% chance to get a life
                    healPlayer(25); // Heal 25 health points
                    if (Math.random() < 0.6) {
                        game.lives = Math.min(game.lives + 1, game.maxLives);
                        console.log('Health collected! +1 life');
                    } else {
                        console.log('Health collected! No life this time...');
                    }
                }
            });
            
            // Heart collection (extra lives)
            hearts.forEach((h, index) => {
                if (!h.collected && checkCollision(player, { x: h.x - 19, y: h.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    h.collected = true;
                    game.score += 100; // Heart gives 100 points
                    game.sessionStats.totalScore += 100;
                    game.sessionStats.currentSessionScore += 100;
                    saveStats();
                    
                    // Give player an extra life
                    game.lives = Math.min(game.lives + 1, game.maxLives);
                    addScreenShake(5);
                    console.log('❤️ Heart collected! +1 life. Total lives:', game.lives);
                    
                    // Create heart particles
                    for (let i = 0; i < 6; i++) {
                        game.particles.push({
                            x: h.x,
                            y: h.y,
                            velX: (Math.random() - 0.5) * 3,
                            velY: (Math.random() - 0.5) * 3,
                            life: 80,
                            decay: 1,
                            type: 'heart'
                        });
                    }
                }
            });
            
            // Armor collection
            armor.forEach((a, index) => {
                if (!a.collected && checkCollision(player, { x: a.x - 19, y: a.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    a.collected = true;
                    
                    let points = 50;
                    let armorAmount = 50;
                    let message = '🛡️ Armor collected! +50 armor points';
                    
                    // Different rewards for different armor types
                    if (a.isHidden) {
                        points = 100; // Hidden armor gives more points
                        armorAmount = 75; // Hidden armor gives more protection
                        if (a.hiddenType === 'underwater') {
                            message = '🛡️ Underwater armor collected! +75 armor points';
                        } else if (a.hiddenType === 'cloud') {
                            message = '🛡️ Cloud armor collected! +75 armor points';
                        } else {
                            message = '🛡️ Hidden armor collected! +75 armor points';
                        }
                    } else if (a.isBossArmor) {
                        points = 150; // Boss armor gives even more points
                        armorAmount = 100; // Boss armor gives maximum protection
                        message = '🛡️ Boss armor collected! +100 armor points';
                    }
                    
                    game.score += points;
                    game.sessionStats.totalScore += points;
                    game.sessionStats.currentSessionScore += points;
                    saveStats();
                    
                    // Add armor to player
                    addArmor(armorAmount);
                    console.log(message);
                    
                    // Special effects for hidden armor
                    if (a.isHidden) {
                        addScreenShake(3);
                        // Create sparkle particles
                        for (let i = 0; i < 8; i++) {
                            game.particles.push({
                                x: a.x,
                                y: a.y,
                                velX: (Math.random() - 0.5) * 4,
                                velY: (Math.random() - 0.5) * 4,
                                life: 60,
                                decay: 1,
                                type: 'sparkle'
                            });
                        }
                    }
                }
            });
            
            // Treasure collection
            treasures.forEach((t, index) => {
                if (!t.collected) {
                    // Check if player is near the treasure for interaction
                    const isNearTreasure = checkCollision(player, { x: t.x - 19, y: t.y - 19, width: 38, height: 38 });
                    
                    if (isNearTreasure) {
                        // Check if this is a golden chest that requires F key interaction
                        if (t.requiresKey && t.isGoldenChest) {
                            // Check if F key is pressed for golden chest interaction
                            if (game.keys['KeyF']) {
                                if (game.keyCount > 0) {
                                    // Player has a key, open the chest
                                    game.keyCount--;
                                    player.keys--;
                                    t.collected = true;
                                    game.score += t.value;
                                    game.sessionStats.treasuresCollected++;
                                    game.sessionStats.treasuresFound++;
                                    game.sessionStats.totalScore += t.value;
                                    game.sessionStats.currentSessionTreasures++;
                                    game.sessionStats.currentSessionScore += t.value;
                                    
                                    // Update highest treasures if current session is higher
                                    if (game.sessionStats.currentSessionTreasures > game.sessionStats.highestTreasures) {
                                        game.sessionStats.highestTreasures = game.sessionStats.currentSessionTreasures;
                                    }
                                    saveStats();
                                    
                                    // Golden chest rewards
                                    game.coins += 50; // Extra bonus coins for golden chests
                                    game.lives = Math.min(game.lives + 2, game.maxLives); // Bonus 2 lives for golden chest
                                    
                                    // Update collectibles counter
                                    game.collectiblesCount.chestsCollected++;
                                    updateCollectiblesCounter();
                                    
                                    addScreenShake(5);
                                    console.log('🔑 Golden chest opened with F key! +50 coins, +2 lives');
                                } else {
                                    // Player doesn't have a key
                                    console.log('🔑 Golden chest requires a key! Find a key first.');
                                    addScreenShake(2);
                                }
                            }
                            // Don't collect automatically - wait for F key
                        } else {
                            // Regular treasure collection (automatic)
                    t.collected = true;
                    game.sessionStats.treasuresCollected++;
                    game.sessionStats.treasuresFound++;
                    game.sessionStats.currentSessionTreasures++;
                    
                    // Add score with XP and multiplier
                    addScoreWithXP(t.value, 'Treasure');
                    
                    // Update highest treasures if current session is higher
                    if (game.sessionStats.currentSessionTreasures > game.sessionStats.highestTreasures) {
                        game.sessionStats.highestTreasures = game.sessionStats.currentSessionTreasures;
                    }
                    saveStats();
                    if (t.type === 'rareTreasure') {
                        game.coins += 25; // Extra bonus coins for rare treasures
                        game.lives = Math.min(game.lives + 1, game.maxLives); // Bonus life for rare treasure
                    } else {
                        game.coins += 10; // Regular bonus coins for normal treasures
                            }
                    
                    // Update collectibles counter
                    game.collectiblesCount.chestsCollected++;
                    updateCollectiblesCounter();
                        }
                    }
                }
            });
            
            // Jetpack collection
            jetpacks.forEach((j, index) => {
                if (!j.collected && checkCollision(player, { x: j.x - 19, y: j.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    j.collected = true;
                    game.score += 100;
                    game.sessionStats.totalScore += 100;
                    game.sessionStats.currentSessionScore += 100;
                    saveStats();
                    
                    // Give player jetpack ability
                                                                    player.hasJetpack = true;
                        updateAbilitiesDisplay();
                        addScreenShake(3);
                    console.log('Jetpack collected! Press Shift to activate!');
                }
            });
            
            // Mushroom collection
            mushrooms.forEach((m, index) => {
                if (!m.collected && checkCollision(player, { x: m.x - 19, y: m.y - 19, width: 38, height: 38 })) { // Scaled from 8, 16 (8*2.4=19.2, 16*2.4=38.4)
                    m.collected = true;
                    const mushroomValue = m.value || 1000; // Default to 1000 if value is missing
                    game.score += mushroomValue;
                    game.sessionStats.mushroomsCollected++;
                    game.sessionStats.mushroomsEaten++;
                    game.sessionStats.totalScore += mushroomValue;
                    game.sessionStats.currentSessionMushrooms++;
                    game.sessionStats.currentSessionScore += mushroomValue;
                    
                    // Update highest mushrooms if current session is higher
                    if (game.sessionStats.currentSessionMushrooms > game.sessionStats.highestMushrooms) {
                        game.sessionStats.highestMushrooms = game.sessionStats.currentSessionMushrooms;
                    }
                    saveStats();
                    
                    // Activate giant mode
                    player.isGiant = true;
                    player.giantTime = Date.now();
                    player.invulnerable = true;
                    
                    // Increase player size for giant mode
                    player.width = 96; // Scaled from 40 (40*2.4=96)
                    player.height = 140; // Scaled from 58 (58*2.4=139.2)
                    player.collisionWidth = 96;
                    player.collisionHeight = 140;
                    
                    // Adjust player position to keep feet on the same platform
                    player.y -= 40; // Move player up to compensate for larger collision box
                
                    // Force player back onto platform after size change
                    // Find the platform the player is currently on
                    let currentPlatform = null;
                    for (const platform of platforms) {
                        if (platform.isVisible !== false) {
                            const collisionX = player.x + player.collisionOffsetX;
                            const collisionY = player.y + player.collisionOffsetY;
                            
                            if (collisionX + player.collisionWidth > platform.x && 
                                collisionX < platform.x + platform.width &&
                                collisionY + player.collisionHeight >= platform.y - 10 &&
                                collisionY + player.collisionHeight <= platform.y + 10) {
                                currentPlatform = platform;
                                break;
                            }
                        }
                    }
                    
                    if (currentPlatform) {
                        // Calculate the correct position for the giant player on the platform
                        const newY = currentPlatform.y - player.collisionHeight - player.collisionOffsetY;
                        player.y = newY;
                        player.velY = 0; // Stop any falling velocity
                        player.onGround = true;
                        player.canDoubleJump = true; // Reset double jump
                        console.log('Repositioned giant player on platform:', {
                            platformY: currentPlatform.y,
                            playerY: player.y,
                            collisionHeight: player.collisionHeight,
                            collisionOffsetY: player.collisionOffsetY
                        });
                    } else {
                        // If no platform found, just ensure player is on ground
                                        player.onGround = true;
                                        player.canDoubleJump = true;
                        console.log('Giant mode activated! No platform repositioning needed.');
                    }
                    
                    addScreenShake(5);
                    console.log('🍄 Mushroom collected! Giant mode activated!');
                }
            });
            
            // Key collection
            keys.forEach((k, index) => {
                if (!k.collected && checkCollision(player, { x: k.x - 4, y: k.y - 12, width: 8, height: 24 })) { // Thinner collision box for keys
                    k.collected = true;
                    game.score += 200;
                    game.keyCount++;
                    player.keys++;
                    game.sessionStats.keysCollected++;
                    game.sessionStats.totalScore += 200;
                    game.sessionStats.currentSessionScore += 200;
                    saveStats();
                    
                    // Update collectibles counter
                    updateCollectiblesCounter();
                    
                    addScreenShake(3);
                    console.log('🔑 Key collected! Total keys:', game.keyCount);
                }
            });
            
            // 🔫 LASER COLLECTION CODE - ENHANCED COLLISION DETECTION
            function updateLaserCollection() {
                if (!laserPowerups || laserPowerups.length === 0) {
                    console.log('🔫 No laser powerups to check for collection');
                    return;
                }
                
                laserPowerups.forEach((l, index) => {
                if (!l.collected) {
                        // Enhanced collision box - larger pickup area
                        const laserBounds = {
                            x: l.x - 30,
                            y: l.y - 30,
                            width: 60,
                            height: 60
                        };
                        
                        const playerBounds = {
                            x: player.x,
                            y: player.y,
                            width: player.width,
                            height: player.height
                        };
                        
                        // Debug collision detection
                        const collision = checkCollision(playerBounds, laserBounds);
                        
                        if (collision) {
                        l.collected = true;
                            game.score += 200;
                            game.sessionStats.totalScore += 200;
                            game.sessionStats.currentSessionScore += 200;
                        saveStats();
                        
                        // Give player laser ability
                        player.hasLaser = true;
                        updateAbilitiesDisplay();
                        addScreenShake(5);
                            
                            console.log('🔫 Laser collected! Press Space to shoot!');
                            console.log('🔫 Player position:', player.x, player.y);
                            console.log('🔫 Laser position:', l.x, l.y);
                            
                            return; // Exit early since we found a collision
                    }
                }
            });
            }
            
            // Call the enhanced collection function
            updateLaserCollection();
            
            // 🔥 FIREBALL COLLECTION CODE
            function updateFireballCollection() {
                if (!fireballPowerups || fireballPowerups.length === 0) {
                    return;
                }
                
                fireballPowerups.forEach((f, index) => {
                    if (!f.collected) {
                        // Enhanced collision box - larger pickup area
                        const fireballBounds = {
                            x: f.x - 30,
                            y: f.y - 30,
                            width: 60,
                            height: 60
                        };
                        
                        const playerBounds = {
                            x: player.x,
                            y: player.y,
                            width: player.width,
                            height: player.height
                        };
                        
                        const collision = checkCollision(playerBounds, fireballBounds);
                        
                        if (collision) {
                            f.collected = true;
                            game.score += 300;
                            game.sessionStats.totalScore += 300;
                            game.sessionStats.currentSessionScore += 300;
                            saveStats();
                            
                            // Give player fireball ability
                                                                            player.hasFireball = true;
                        updateAbilitiesDisplay();
                        addScreenShake(5);
                            
                            console.log('🔥 Fireball collected! Right-click to shoot bouncing fireballs!');
                            console.log('🔥 Player hasFireball set to:', player.hasFireball);
                            console.log('🔥 Player position:', player.x, player.y);
                            console.log('🔥 Fireball position:', f.x, f.y);
                            
                            return; // Exit early since we found a collision
                        }
                    }
                });
            }
            
            // Call the fireball collection function
            updateFireballCollection();
            
            // Check if reached goal (only when player touches the flag!)
            if (game.goalX && game.goalY) {
                const playerRight = player.x + player.collisionWidth;
                const playerBottom = player.y + player.collisionHeight;
                
                // Goal flag triangular collision detection
                const flagCenterX = game.goalX + 180; // Center of platform
                const flagBaseY = game.goalY - 192; // Bottom of flag at platform level
                const flagTopY = game.goalY - 192 - 270; // Top of flag
                const flagWidth = 120; // Width of the flag
                
                // Define triangular flag bounds (triangle pointing right)
                const flagLeft = flagCenterX - flagWidth/2; // Left edge of flag
                const flagRight = flagCenterX + flagWidth/2; // Right edge of flag
                const flagTop = flagTopY; // Top point of flag
                const flagBottom = flagBaseY; // Bottom edge of flag
                
                // Check if player is within the rectangular bounds first (quick check)
                if (player.x < flagRight && playerRight > flagLeft && 
                    player.y < flagBottom && playerBottom > flagTop) {
                    
                    // More precise triangular collision detection
                    const playerCenterX = player.x + player.collisionWidth / 2;
                    const playerCenterY = player.y + player.collisionHeight / 2;
                    
                    // Check if player center is within the triangular flag area
                    const isInTriangle = checkTriangleCollision(
                        playerCenterX, playerCenterY,
                        flagLeft, flagBottom,  // Bottom left point
                        flagRight, flagBottom, // Bottom right point  
                        flagLeft, flagTop      // Top point (triangle pointing right)
                    );
                    
                    if (isInTriangle) {
                    
                    // Boss level check - prevent completion if boss is still alive
                    if (game.bossActive && game.currentBoss && game.currentBoss.health > 0) {
                        console.log('🚫 Cannot complete boss level - boss is still alive!');
                        // Don't set levelComplete = true, just return
                        return;
                    }
                    
                    game.levelComplete = true;
                    
                    // Calculate level completion bonus with XP system
                    const baseLevelBonus = 500;
                    const fishBonus = fish.filter(f => f.collected).length * 50;
                    const totalBaseBonus = baseLevelBonus + fishBonus;
                    
                    // Add score with XP and multiplier
                    addScoreWithXP(totalBaseBonus, 'Level Complete');
                    
                    // Add level completion XP bonus
                    const levelCompletionXP = player.rewards.levelCompletionBonus * game.level; // Higher levels = more XP
                    addXP(levelCompletionXP);
                    
                    console.log(`🎉 Level ${game.level} completed! +${levelCompletionXP} bonus XP`);
                game.sessionStats.currentSessionLevels++;
                
                // Update highest levels if current session is higher
                if (game.sessionStats.currentSessionLevels > game.sessionStats.highestLevels) {
                    game.sessionStats.highestLevels = game.sessionStats.currentSessionLevels;
                }
                
                // Update highest score if current session is higher
                if (game.sessionStats.currentSessionScore > game.sessionStats.highestScore) {
                    game.sessionStats.highestScore = game.sessionStats.currentSessionScore;
                }
                
                // Record level completion time
                const levelTime = Date.now() - game.sessionStats.levelStartTime;
                game.sessionStats.levelTimes.push({
                    level: game.level,
                    time: formatTime(levelTime)
                });
                game.sessionStats.levelsCompleted++;
                saveStats();
                
                // Check for level-related achievements
                if (game.sessionStats.levelsCompleted === 1) {
                    unlockAchievement('first_level');
                }
                if (game.sessionStats.levelsCompleted >= 5) {
                    unlockAchievement('five_levels');
                }
                
                // Check all achievements after level completion
                checkAllAchievements();
                
                // Reset secret chest state for next level
                game.secretChestsSpawned = false;
                game.secretChestConditions.coinsCollected = 0;
                game.secretChestConditions.treasuresCollected = 0;
                game.secretChestConditions.keysCollected = 0;
                
                document.getElementById('levelCompleteName').textContent = `${currentLevel.name} Complete!`;
                document.getElementById('levelComplete').style.display = 'block';
                    }
                }
            }
            
            // Update enemies
            enemies.forEach((enemy, enemyIndex) => {
                // Enemy type-specific AI
                if (enemy.type === 'eagle') {
                    // Simple Eagle AI: natural chase and attack
                    const distanceToPlayer = Math.abs(enemy.x - player.x);
                    const verticalDistance = Math.abs(enemy.y - player.y);
                    
                    // Check if player is in range for targeting (400px range)
                    if (distanceToPlayer < 400 && verticalDistance < 200 && !enemy.targetPlayer) {
                        enemy.targetPlayer = true;
                        enemy.chaseStartTime = Date.now();
                        console.log('🦅 Eagle spotted player! Starting chase');
                    }

                    if (enemy.targetPlayer) {
                        // Simple chase behavior
                        const playerDirection = player.x > enemy.x ? 1 : -1;
                        enemy.direction = playerDirection;
                        
                        // Move toward player
                        enemy.x += enemy.velX * playerDirection;
                        
                        // Follow player's height with some offset
                        const targetHeight = player.y - 80; // Stay above player
                        const heightDiff = targetHeight - enemy.y;
                        
                        if (Math.abs(heightDiff) > 10) {
                            if (heightDiff > 0) {
                                enemy.y += 3; // Fly down
                        } else {
                                enemy.y -= 3; // Fly up
                            }
                        }
                        
                        // Simple attack when close
                        if (distanceToPlayer < 200 && !enemy.isAttacking) {
                            enemy.isAttacking = true;
                            enemy.attackStartTime = Date.now();
                            console.log('🦅 Eagle attacking!');
                        }
                        
                        // Execute attack
                        if (enemy.isAttacking) {
                            const attackTime = Date.now() - enemy.attackStartTime;
                            if (attackTime < 1000) { // 1 second attack
                                // Dive toward player
                                const attackSpeed = 3; // Reduced from 5 to 3 for slower attack
                                if (player.y > enemy.y) {
                                    enemy.y += attackSpeed;
                                } else {
                                    enemy.y -= attackSpeed;
                                }
                            } else {
                                // Attack complete
                                enemy.isAttacking = false;
                                console.log('🦅 Eagle attack complete');
                            }
                        }
                        
                        // Return to patrol if player is too far or chase too long
                        const chaseTime = Date.now() - enemy.chaseStartTime;
                        if (distanceToPlayer > 500 || chaseTime > 8000) { // 8 seconds max chase
                            enemy.targetPlayer = false;
                            enemy.isAttacking = false;
                            enemy.isRetreating = true;
                            enemy.retreatStartTime = Date.now();
                            console.log('🦅 Eagle starting retreat to patrol');
                        }
                        
                    } else if (enemy.isRetreating) {
                        // Natural retreat behavior - fly back to original position
                        const retreatTime = Date.now() - enemy.retreatStartTime;
                        const retreatDuration = 4000; // 4 seconds to retreat
                        
                        if (retreatTime < retreatDuration) {
                            // Gradually move back to original spawn area
                            const retreatProgress = retreatTime / retreatDuration;
                            
                            // Move slowly back toward original position
                            const originalX = enemy.originalSpawnX || enemy.x;
                            const originalY = enemy.originalSpawnY || enemy.originalY || enemy.y;
                            
                            // Smooth movement back to original position
                            const xDiff = originalX - enemy.x;
                            const yDiff = originalY - enemy.y;
                            
                            enemy.x += xDiff * 0.02; // Gradual X movement
                            enemy.y += yDiff * 0.02; // Gradual Y movement
                            
                            // Set direction based on movement
                            if (xDiff > 0) {
                                enemy.direction = 1;
                            } else if (xDiff < 0) {
                                enemy.direction = -1;
                            }
                            
                            console.log('🦅 Eagle retreating - Progress:', (retreatProgress * 100).toFixed(0) + '%');
                        } else {
                            // Retreat complete - return to normal patrol
                            enemy.isRetreating = false;
                            enemy.retreatStartTime = undefined;
                            console.log('🦅 Eagle retreat complete - back to patrol');
                        }
                        
                    } else {
                        // Simple patrol behavior
                        enemy.x += enemy.velX * enemy.direction;
                        
                        // Gentle up and down movement
                        const time = Date.now() * 0.003;
                        enemy.y = (enemy.originalSpawnY || enemy.originalY || enemy.y) + Math.sin(time + (enemy.sineOffset || 0)) * 15;
                        
                        // Turn around at screen edges
                        if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                            enemy.direction *= -1;
                        }
                    }
                    
                } else if (enemy.type === 'shark') {
                    // Shark AI: underwater hunting with swooping attacks
                    const time = Date.now() * 0.003;
                    const distanceToPlayer = Math.abs(enemy.x - player.x);
                    const verticalDistance = Math.abs(enemy.y - player.y);
                    
                    // Define underwater swimming depths
                    const waterSurface = game.waterLevel;
                    const maxDepth = waterSurface + 400; // Maximum swimming depth
                    const minDepth = waterSurface + 50;  // Minimum swimming depth
                    const attackDepth = waterSurface + 100; // Depth during attack
                    const patrolDepth = waterSurface + 200; // Normal patrol depth
                    
                    // Check if player is in range for targeting (400px range underwater)
                    if (distanceToPlayer < 400 && verticalDistance < 200 && !enemy.targetPlayer && player.inWater) {
                        enemy.targetPlayer = true;
                        enemy.isAttacking = true;
                        enemy.followStartX = enemy.x;
                        enemy.followStartTime = Date.now();
                        enemy.totalFollowDistance = 0;
                        enemy.lastX = enemy.x;
                        console.log('🦈 Shark has detected player! Starting hunt from X:', enemy.x.toFixed(0));
                    }

                    if (enemy.targetPlayer) {
                        // Shark is targeting the player
                        const playerDirection = player.x > enemy.x ? 1 : -1;
                        enemy.direction = playerDirection;
                        
                        // Move toward player horizontally
                        const moveSpeed = Math.abs(enemy.velX) * 1.5; // Faster than eagle
                        const oldX = enemy.x;
                        enemy.x += moveSpeed * playerDirection;
                        
                        // Track cumulative distance traveled
                        if (enemy.lastX !== undefined) {
                            enemy.totalFollowDistance += Math.abs(enemy.x - enemy.lastX);
                        }
                        enemy.lastX = enemy.x;
                        
                        // Calculate how long shark has been following
                        const followTime = Date.now() - enemy.followStartTime;
                        
                        // Calculate target depth - follow player underwater
                        let targetDepth;
                        if (enemy.isDiving) {
                            // During attack, get closer to player
                            targetDepth = player.y + 20;
                        } else {
                            // Normal following - stay slightly below player
                            targetDepth = player.y + 50;
                        }
                        
                        // Clamp target depth to underwater bounds
                        targetDepth = Math.max(minDepth, Math.min(maxDepth, targetDepth));
                        
                        const depthDifference = targetDepth - enemy.y;
                        
                        // Adjust depth to follow player
                        const depthSpeed = enemy.isDiving ? 8 : 5;
                        if (Math.abs(depthDifference) > 5) {
                            if (depthDifference > 0) {
                                enemy.y += depthSpeed; // Swim down
                            } else {
                                enemy.y -= depthSpeed; // Swim up
                            }
                        }
                        
                        // Set stable original Y if not set
                        if (!enemy.originalYSet) {
                            enemy.originalY = Math.max(patrolDepth, enemy.y);
                            enemy.originalYSet = true;
                        }
                        
                        // Only attack if very close, not already attacking, not backing away, and not in cooldown
                        if (distanceToPlayer < 100 && !enemy.isDiving && !enemy.isBackingAway && 
                            !enemy.attackCooldown && Math.abs(enemy.y - player.y) < 80) {
                            enemy.isDiving = true;
                            enemy.diveStartY = enemy.y;
                            enemy.diveStartTime = Date.now();
                            enemy.attackCooldown = true; // Start cooldown
                            console.log('🦈 Shark attacking from depth:', enemy.y);
                        }
                        
                        // Attack cooldown timer (3 seconds)
                        if (enemy.attackCooldown && !enemy.isDiving && !enemy.isBackingAway) {
                            const timeSinceAttack = Date.now() - (enemy.diveStartTime || Date.now());
                            if (timeSinceAttack > 3000) {
                                enemy.attackCooldown = false;
                                console.log('🦈 Shark attack cooldown complete');
                            }
                        }
                        
                        // Prevent getting too close to player (minimum 50px distance)
                        if (distanceToPlayer < 50 && !enemy.isDiving && !enemy.isBackingAway) {
                            const backDirection = player.x > enemy.x ? -1 : 1;
                            enemy.x += enemy.velX * 0.8 * backDirection;
                            console.log('🦈 Shark maintaining distance from player');
                        }
                        
                        // Execute attack - underwater swoop
                        if (enemy.isDiving) {
                            const diveTime = Date.now() - enemy.diveStartTime;
                            const diveProgress = diveTime / 800; // 0.8 second attack
                            
                            if (diveProgress < 0.5) {
                                // First half: swim toward player
                                const diveAmount = diveProgress * 60; // Max 60px movement
                                const newY = enemy.diveStartY + diveAmount;
                                enemy.y = Math.min(newY, attackDepth);
                            } else if (diveProgress < 1.0) {
                                // Second half: swim back up
                                const pullUpProgress = (diveProgress - 0.5) / 0.5;
                                const pullUpY = attackDepth - (pullUpProgress * 40);
                                enemy.y = Math.max(pullUpY, patrolDepth);
                            } else {
                                // Attack complete - start backing away
                                enemy.isDiving = false;
                                enemy.isBackingAway = true;
                                enemy.backAwayStartTime = Date.now();
                                enemy.backAwayDirection = player.x > enemy.x ? -1 : 1; // Back away from player
                                console.log('🦈 Shark attack complete, backing away from player');
                            }
                        }
                        
                        // Back away behavior after attack
                        if (enemy.isBackingAway) {
                            const backAwayTime = Date.now() - enemy.backAwayStartTime;
                            const backAwayDuration = 1500; // 1.5 seconds to back away
                            
                            if (backAwayTime < backAwayDuration) {
                                // Move away from player
                                enemy.x += enemy.velX * 1.2 * enemy.backAwayDirection;
                                
                                // Swim back to patrol depth
                                const currentDepth = enemy.y;
                                const targetDepth = enemy.originalPatrolY || patrolDepth;
                                const depthDiff = targetDepth - currentDepth;
                                enemy.y += depthDiff * 0.05;
                                
                                console.log('🦈 Shark backing away - Progress:', (backAwayTime / backAwayDuration * 100).toFixed(0) + '%');
                            } else {
                                // Back away complete - return to normal hunting
                                enemy.isBackingAway = false;
                                enemy.backAwayStartTime = undefined;
                                enemy.backAwayDirection = undefined;
                                console.log('🦈 Shark back away complete, resuming hunt');
                            }
                        }
                        
                        // Retreat conditions
                        const shouldRetreat = (
                            distanceToPlayer > 250 ||                    // Player too far
                            enemy.totalFollowDistance > 300 ||           // Followed too far
                            followTime > 3000 ||                         // Followed too long (3 seconds)
                            Math.abs(enemy.x - enemy.followStartX) > 250 // Too far from starting position
                        );
                        
                        if (shouldRetreat) {
                            enemy.targetPlayer = false;
                            enemy.isAttacking = false;
                            enemy.isDiving = false;
                            enemy.originalYSet = false;
                            enemy.isRetreating = true;
                            enemy.retreatStartTime = Date.now();
                            
                            if (!enemy.originalPatrolY) {
                                enemy.originalPatrolY = enemy.originalY || patrolDepth;
                            }
                            
                            console.log('🦈 Shark retreating!');
                            
                            // Reset tracking variables
                            enemy.followStartX = undefined;
                            enemy.followStartTime = undefined;
                            enemy.totalFollowDistance = 0;
                            enemy.lastX = undefined;
                        }
                        
                    } else if (enemy.isRetreating) {
                        // Retreat behavior - slowly swim back to patrol area
                        const retreatTime = Date.now() - enemy.retreatStartTime;
                        const retreatDuration = 2000; // 2 seconds to retreat
                        
                        if (retreatTime < retreatDuration) {
                            const retreatProgress = retreatTime / retreatDuration;
                            
                            // Move slowly in the opposite direction of player
                            const retreatDirection = player.x > enemy.x ? -1 : 1;
                            enemy.x += enemy.velX * 0.6 * retreatDirection;
                            
                            // Gradually return to original patrol depth
                            const currentDepth = enemy.y;
                            const targetDepth = enemy.originalPatrolY || patrolDepth;
                            const depthDiff = targetDepth - currentDepth;
                            enemy.y += depthDiff * 0.03;
                            
                            console.log('🦈 Shark retreating - Progress:', (retreatProgress * 100).toFixed(0) + '%');
                        } else {
                            // Retreat complete - return to normal patrol
                            enemy.isRetreating = false;
                            enemy.retreatStartTime = undefined;
                            console.log('🦈 Shark retreat complete - returning to patrol');
                        }
                        
                        // Turn around at screen edges during retreat
                        if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                            enemy.direction *= -1;
                        }
                    } else {
                        // Normal patrol behavior - swim at patrol depth
                        const safePatrolY = Math.min(patrolDepth, enemy.originalY || patrolDepth);
                        enemy.x += enemy.velX * enemy.direction;
                        enemy.y = safePatrolY + Math.sin(time + enemy.sineOffset) * 30; // Larger oscillation underwater
                        
                        // Keep within underwater bounds
                        if (enemy.y < minDepth) {
                            enemy.y = minDepth;
                        }
                        if (enemy.y > maxDepth) {
                            enemy.y = maxDepth;
                        }
                        
                        // Turn around at screen edges
                        if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                            enemy.direction *= -1;
                        }
                    }
                    
                    // Final safety check - keep shark underwater
                    if (enemy.y < waterSurface + 30) {
                        enemy.y = waterSurface + 30;
                    }
                    
                    // Debug logging
                    if (enemy.targetPlayer && Date.now() % 500 < 50) {
                        console.log('🦈 Shark hunting - Distance:', distanceToPlayer.toFixed(0), 
                                   'FollowDist:', (enemy.totalFollowDistance || 0).toFixed(0),
                                   'Y:', enemy.y.toFixed(1));
                    }
                    
                } else if (enemy.type === 'charger') {
                    // Charger AI: patrol + charge attack
                    const distanceToPlayer = Math.abs(enemy.x - player.x);
                    const canSeePlayer = distanceToPlayer < 300 && Math.abs(enemy.y - player.y) < 100;
                    
                    if (canSeePlayer && !enemy.isCharging && Date.now() - enemy.lastChargeTime > enemy.chargeCooldown) {
                        // Start charge attack
                        enemy.isCharging = true;
                        enemy.chargeStartTime = Date.now();
                        enemy.chargeDirection = player.x > enemy.x ? 1 : -1;
                    }
                    
                    if (enemy.isCharging) {
                        const chargeProgress = (Date.now() - enemy.chargeStartTime) / enemy.chargeWindup;
                        if (chargeProgress < 1) {
                            // Windup phase - slow movement
                            enemy.x += enemy.velX * 0.3 * enemy.chargeDirection;
                        } else {
                            // Charge phase - fast movement
                            enemy.x += enemy.chargeSpeed * enemy.chargeDirection;
                            
                            // End charge if hit wall or went too far
                            if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                                enemy.isCharging = false;
                                enemy.lastChargeTime = Date.now();
                            }
                        }
                    } else {
                        // Normal patrol movement
                        enemy.x += enemy.velX * enemy.direction;
                        
                        // Turn around at platform edges with improved collision
                        let onPlatform = false;
                        for (const platform of platforms) {
                            if (platform.isVisible === false) continue;
                            
                            if (enemy.x >= platform.x && enemy.x <= platform.x + platform.width &&
                                enemy.y >= platform.y - enemy.height - 5 && enemy.y <= platform.y + 5) {
                                onPlatform = true;
                                
                                // Snap enemy to platform if they're slightly off
                                if (enemy.y > platform.y - enemy.height) {
                                    enemy.y = platform.y - enemy.height;
                                }
                                
                                if ((enemy.direction === 1 && enemy.x >= platform.x + platform.width - 48) ||
                                    (enemy.direction === -1 && enemy.x <= platform.x + 48)) {
                                    enemy.direction *= -1;
                                }
                                break;
                            }
                        }
                    }
                    
                } else if (enemy.type === 'goldfish') {
                    // Goldfish AI: swim underwater with natural movement
                    const time = Date.now() * 0.001;
                    
                    // Constant, reasonable speed - no level scaling
                    const goldfishSpeed = 0.8; // Fixed slow speed
                    const directionChangeChance = 0.003; // Low chance for direction changes
                    const verticalMovementIntensity = 0.3; // Gentle vertical movement
                    
                    // Horizontal swimming movement - constant speed
                    enemy.x += goldfishSpeed * enemy.direction;
                    
                    // Vertical swimming movement (sine wave pattern) - more intense in higher levels
                    enemy.y += Math.sin(time + enemy.x * 0.01) * verticalMovementIntensity;
                    
                    // Keep goldfish within water bounds
                    if (enemy.y < game.waterLevel + 50) {
                        enemy.y = game.waterLevel + 50;
                    }
                    if (enemy.y > game.waterLevel + 400) {
                        enemy.y = game.waterLevel + 400;
                    }
                    
                    // Turn around at screen edges
                    if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                        enemy.direction *= -1;
                    }
                    
                    // Random direction changes - more frequent in higher levels
                    if (Math.random() < directionChangeChance) {
                        enemy.direction *= -1;
                    }
                    
                } else if (enemy.type === 'gator') {
                    // Gator AI: sit on water surface and chase player when in range
                    const distanceToPlayer = Math.abs(enemy.x - player.x);
                    const playerInWater = player.inWater;
                    
                    // Check if player is in range and in water
                    if (distanceToPlayer < enemy.chaseRange && playerInWater && !enemy.isChasing) {
                        enemy.isChasing = true;
                        enemy.chaseStartTime = Date.now();
                        console.log('🐊 Gator spotted player! Starting chase from X:', enemy.x.toFixed(0));
                    }
                    
                    if (enemy.isChasing) {
                        // Chase the player
                        const playerDirection = player.x > enemy.x ? 1 : -1;
                        enemy.direction = playerDirection;
                        
                        // Move toward player at chase speed
                        enemy.x += enemy.chaseSpeed * playerDirection;
                        
                        // Keep gator on water surface
                        enemy.y = game.waterLevel - enemy.height + 20;
                        
                        // Check if chase should end
                        const chaseTime = Date.now() - enemy.chaseStartTime;
                        if (chaseTime > enemy.chaseDuration || distanceToPlayer > enemy.chaseRange * 1.5) {
                            enemy.isChasing = false;
                            enemy.chaseStartTime = 0; // Reset chase timer
                            console.log('🐊 Gator chase ended - returning to patrol at X:', enemy.x.toFixed(0), 'Original X:', enemy.originalX.toFixed(0));
                        }
                    } else {
                        // Normal patrol behavior on water surface
                        enemy.x += enemy.velX * enemy.patrolDirection;
                        enemy.y = game.waterLevel - enemy.height + 20; // Stay on water surface
                        
                        // Turn around at patrol boundaries
                        const patrolRange = 200; // How far from original position to patrol
                        if (Math.abs(enemy.x - enemy.originalX) > patrolRange) {
                            enemy.patrolDirection *= -1;
                            console.log('🐊 Gator patrol boundary reached - turning around at X:', enemy.x.toFixed(0));
                        }
                        
                        // Turn around at screen edges
                        if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                            enemy.patrolDirection *= -1;
                            console.log('🐊 Gator screen edge reached - turning around at X:', enemy.x.toFixed(0));
                        }
                    }
                } else if (enemy.type === 'wizgator') {
                    // Wizgator AI: sit on water/lava surface and chase player when in range
                    const distanceToPlayer = Math.abs(enemy.x - player.x);
                    const playerInWater = player.inWater;
                    const playerInLava = game.bossActive && player.y > game.waterLevel;
                    
                    // Check if player is in range and in water/lava
                    if (distanceToPlayer < enemy.chaseRange && (playerInWater || playerInLava) && !enemy.isChasing) {
                        enemy.isChasing = true;
                        enemy.chaseStartTime = Date.now();
                        console.log('🔮 Wizgator spotted player! Starting chase from X:', enemy.x.toFixed(0));
                    }
                    
                    if (enemy.isChasing) {
                        // Chase the player
                        const playerDirection = player.x > enemy.x ? 1 : -1;
                        enemy.direction = playerDirection;
                        
                        // Move toward player at chase speed
                        enemy.x += enemy.chaseSpeed * playerDirection;
                        
                        // Keep wizgator on water/lava surface
                        enemy.y = game.waterLevel - enemy.height + 20;
                        
                        // Check if chase should end
                        const chaseTime = Date.now() - enemy.chaseStartTime;
                        if (chaseTime > enemy.chaseDuration || distanceToPlayer > enemy.chaseRange * 1.5) {
                            enemy.isChasing = false;
                            enemy.chaseStartTime = 0; // Reset chase timer
                            console.log('🔮 Wizgator chase ended - returning to patrol at X:', enemy.x.toFixed(0), 'Original X:', enemy.originalX.toFixed(0));
                        }
                    } else {
                        // Normal patrol behavior on water/lava surface
                        enemy.x += enemy.velX * enemy.patrolDirection;
                        enemy.y = game.waterLevel - enemy.height + 20; // Stay on water/lava surface
                        
                        // Turn around at patrol boundaries
                        const patrolRange = 200; // How far from original position to patrol
                        if (Math.abs(enemy.x - enemy.originalX) > patrolRange) {
                            enemy.patrolDirection *= -1;
                            console.log('🔮 Wizgator patrol boundary reached - turning around at X:', enemy.x.toFixed(0));
                        }
                        
                        // Turn around at screen edges
                        if (enemy.x < game.camera.x - 100 || enemy.x > game.camera.x + game.canvasWidth + 100) {
                            enemy.patrolDirection *= -1;
                            console.log('🔮 Wizgator screen edge reached - turning around at X:', enemy.x.toFixed(0));
                        }
                    }
                    
                    // Debug wizgator shooting conditions
                    if (enemy.type === 'wizgator') {
                        console.log('🔮 WIZGATOR SHOOTING CHECK - CanShoot:', enemy.canShoot, 'TimeSinceLastShot:', Date.now() - enemy.lastShot, 'Cooldown:', enemy.shotCooldown, 'ShouldShoot:', enemy.canShoot && Date.now() - enemy.lastShot > enemy.shotCooldown);
                    }
                    
                    // Wizgator fireball shooting logic
                    if (enemy.type === 'wizgator' && enemy.canShoot && Date.now() - enemy.lastShot > enemy.shotCooldown) {
                        console.log('🔥 Wizgator firing fireball! Enemy:', enemy.x, enemy.y, 'Player:', player.x, player.y, 'CanShoot:', enemy.canShoot, 'TimeSinceLastShot:', Date.now() - enemy.lastShot, 'Cooldown:', enemy.shotCooldown);
                        
                        // Shoot fireball from mouth
                        const mouthX = enemy.x + (enemy.direction === 1 ? enemy.width - 10 : 10);
                        const mouthY = enemy.y + enemy.height / 2;
                        
                        // Calculate direction to player for accurate shooting
                        const dx = player.x - enemy.x;
                        const dy = player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const velX = (dx / distance) * 5; // Slightly slower than lasers
                        const velY = (dy / distance) * 5;
                        
                        lasers.push({
                            x: mouthX,
                            y: mouthY,
                            velX: velX,
                            velY: velY,
                            width: 32, // Increased from 20
                            height: 32, // Increased from 20
                            active: true,
                            color: '#FF6600', // Orange fireball
                            type: 'fireball'
                        });
                        
                        enemy.lastShot = Date.now();
                    }
                    
                } else {
                    // Basic enemy AI: patrol platforms with improved collision
                    enemy.x += enemy.velX * enemy.direction;
                    
                    // Improved AI: turn around at platform edges with better collision detection
                    let onPlatform = false;
                    let currentPlatform = null;
                    
                    for (const platform of platforms) {
                        if (platform.isVisible === false) continue; // Skip invisible platforms
                        
                        // Check if enemy is on this platform
                        if (enemy.x >= platform.x && enemy.x <= platform.x + platform.width &&
                            enemy.y >= platform.y - enemy.height - 5 && enemy.y <= platform.y + 5) {
                            onPlatform = true;
                            currentPlatform = platform;
                            
                            // Snap enemy to platform if they're slightly off
                            if (enemy.y > platform.y - enemy.height) {
                                enemy.y = platform.y - enemy.height;
                            }
                            
                            // Turn around at platform edges
                            if ((enemy.direction === 1 && enemy.x >= platform.x + platform.width - 48) ||
                                (enemy.direction === -1 && enemy.x <= platform.x + 48)) {
                                enemy.direction *= -1;
                            }
                            break;
                        }
                    }
                    
                    // If enemy is not on any platform, try to find the closest one and move towards it
                    if (!onPlatform) {
                        let closestPlatform = null;
                        let closestDistance = Infinity;
                        
                        for (const platform of platforms) {
                            if (platform.isVisible === false) continue;
                            
                            const distance = Math.abs(enemy.x - (platform.x + platform.width/2));
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestPlatform = platform;
                            }
                        }
                        
                        // Move towards the closest platform
                        if (closestPlatform && closestDistance < 200) {
                            if (enemy.x < closestPlatform.x + closestPlatform.width/2) {
                                enemy.direction = 1;
                            } else {
                                enemy.direction = -1;
                            }
                        }
                    }
                }
                
                // Shooting logic for level 5+ crabs
                if (enemy.canShoot && enemy.type === 'crab' && Date.now() - enemy.lastShot > enemy.shotCooldown) {
                    console.log('🔫 Shooter crab firing! Enemy:', enemy.x, enemy.y, 'Player:', player.x, player.y);
                    // Shoot from both claws
                    const leftClawX = enemy.x + (enemy.direction === 1 ? 29 : -10); // Scaled from 12, 4 (12*2.4=28.8, 4*2.4=9.6)
                    const rightClawX = enemy.x + (enemy.direction === 1 ? 38 : -19); // Scaled from 16, 8 (16*2.4=38.4, 8*2.4=19.2)
                    const clawY = enemy.y + 5; // Scaled from 2 (2*2.4=4.8, rounded to 5)
                    
                    // Left claw laser
                    lasers.push({
                        x: leftClawX,
                        y: clawY,
                        velX: enemy.direction * 7, // Scaled from 3 (3*2.4=7.2, rounded to 7)
                        velY: 0,
                        width: 19, // Scaled from 8 (8*2.4=19.2, rounded to 19)
                        height: 5, // Scaled from 2 (2*2.4=4.8, rounded to 5)
                        active: true
                    });
                    
                    // Right claw laser
                    lasers.push({
                        x: rightClawX,
                        y: clawY,
                        velX: enemy.direction * 7, // Scaled from 3 (3*2.4=7.2, rounded to 7)
                        velY: 0,
                        width: 19, // Scaled from 8 (8*2.4=19.2, rounded to 19)
                        height: 5, // Scaled from 2 (2*2.4=4.8, rounded to 5)
                        active: true
                    });
                    
                    enemy.lastShot = Date.now();
                }
                
                
                
                // Shooting logic for level 5+ goldfish
                if (enemy.canShoot && enemy.type === 'goldfish' && Date.now() - enemy.lastShot > enemy.shotCooldown) {
                    console.log('🔫 Shooting goldfish firing! Enemy:', enemy.x, enemy.y, 'Player:', player.x, player.y);
                    // Shoot from mouth
                    const mouthX = enemy.x + (enemy.direction === 1 ? enemy.width - 5 : 5);
                    const mouthY = enemy.y + enemy.height / 2;
                    
                    // Calculate direction to player for more accurate shooting
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const velX = (dx / distance) * 5;
                    const velY = (dy / distance) * 5;
                    
                    lasers.push({
                        x: mouthX,
                        y: mouthY,
                        velX: velX,
                        velY: velY,
                        width: 16, // Medium laser for goldfish
                        height: 6,
                        active: true,
                        color: '#FFD700' // Gold laser for goldfish
                    });
                    
                    enemy.lastShot = Date.now();
                }
                
                // Enemy collision with player - use player's collision box for more accurate detection
                const playerCollisionX = player.x + player.collisionOffsetX;
                const playerCollisionY = player.y + player.collisionOffsetY;
                
                // Check collision using enemy's collision box (smaller than sprite)
                const enemyCollisionX = enemy.x + (enemy.collisionOffsetX || 0);
                const enemyCollisionY = enemy.y + (enemy.collisionOffsetY || 0);
                const enemyCollisionWidth = enemy.collisionWidth || enemy.width;
                const enemyCollisionHeight = enemy.collisionHeight || enemy.height;
                
                if (playerCollisionX < enemyCollisionX + enemyCollisionWidth &&
                    playerCollisionX + player.collisionWidth > enemyCollisionX &&
                    playerCollisionY < enemyCollisionY + enemyCollisionHeight &&
                    playerCollisionY + player.collisionHeight > enemyCollisionY) {
                    
                    // MUCH MORE LENIENT conditions for "jump on head" - should work at all times
                    const isFalling = player.velY > 0;
                    const feetNearEnemyTop = playerCollisionY + player.collisionHeight >= enemyCollisionY - 10 && 
                                           playerCollisionY + player.collisionHeight <= enemyCollisionY + 10;
                    const isAboveEnemy = playerCollisionY < enemyCollisionY + enemyCollisionHeight * 0.5; // Much more lenient
                    const horizontalOverlap = Math.min(playerCollisionX + player.collisionWidth, enemyCollisionX + enemyCollisionWidth) - 
                                            Math.max(playerCollisionX, enemyCollisionX);
                    const isCenteredOnEnemy = horizontalOverlap > enemyCollisionWidth * 0.2; // Much more lenient centering
                    
                    if (isFalling && feetNearEnemyTop && isAboveEnemy && isCenteredOnEnemy) {
                        // Jump on head - bounce back up (ALWAYS works, even during invulnerability)
                        enemies.splice(enemyIndex, 1);
                        game.score += 200;
                        
                        // Track specific enemy types
                        switch (enemy.type) {
                            case 'crab':
                        game.sessionStats.crabsDefeated++;
                        game.sessionStats.currentSessionCrabs++;
                                break;
                            case 'eagle':
                                game.sessionStats.eaglesDefeated++;
                                break;
                            case 'gator':
                                game.sessionStats.gatorsDefeated++;
                                break;
                            case 'shark':
                                game.sessionStats.sharksDefeated++;
                                break;
                            default:
                                game.sessionStats.crabsDefeated++; // Default to crab for unknown types
                                game.sessionStats.currentSessionCrabs++;
                        }
                        
                        game.sessionStats.totalScore += 200;
                        game.sessionStats.currentSessionScore += 200;
                        
                        // Update highest crabs if current session is higher
                        if (game.sessionStats.currentSessionCrabs > game.sessionStats.highestCrabs) {
                            game.sessionStats.highestCrabs = game.sessionStats.currentSessionCrabs;
                        }
                        saveStats();
                        player.velY = -player.jumpPower * 0.4; // Slightly stronger bounce
                        addScreenShake(8);
                        addFreezeFrame(80);
                        game.particles.push(...createParticle(enemy.x + enemy.width/2, enemy.y + enemy.height, 'stomp'));
                        console.log('Enemy stomped! Bounce!'); // Debug message
                    } else {
                        // Any other collision = damage (only if not invulnerable)
                        if (!player.invulnerable) {
                            takeDamage(25); // Use new health system
                            player.x = enemy.x - 120; // Scaled from 50 (50*2.4=120)
                            player.velY = 0; // No bounce - just horizontal knockback
                        } else if (player.isGiant) {
                            // Mushroom power-up: knock over enemies by running into them
                            enemies.splice(enemyIndex, 1);
                            game.score += 200;
                            
                            // Track specific enemy types
                            switch (enemy.type) {
                                case 'crab':
                            game.sessionStats.crabsDefeated++;
                            game.sessionStats.currentSessionCrabs++;
                                    break;
                                case 'eagle':
                                    game.sessionStats.eaglesDefeated++;
                                    break;
                                case 'gator':
                                    game.sessionStats.gatorsDefeated++;
                                    break;
                                case 'shark':
                                    game.sessionStats.sharksDefeated++;
                                    break;
                                default:
                                    game.sessionStats.crabsDefeated++; // Default to crab for unknown types
                                    game.sessionStats.currentSessionCrabs++;
                            }
                            
                            game.sessionStats.totalScore += 200;
                            game.sessionStats.currentSessionScore += 200;
                            
                            // Update highest crabs if current session is higher
                            if (game.sessionStats.currentSessionCrabs > game.sessionStats.highestCrabs) {
                                game.sessionStats.highestCrabs = game.sessionStats.currentSessionCrabs;
                            }
                            saveStats();
                            console.log('Mushroom power-up! Enemy knocked over!');
                        }
                    }
                }
            });
            
            // Checkpoint collision and activation
            checkpoints.forEach((checkpoint, index) => {
                if (!checkpoint.activated && checkCollision(player, checkpoint)) {
                    checkpoint.activated = true;
                    game.activeCheckpoint = checkpoint;
                    
                    // Store checkpoint progress for this level
                    if (!game.checkpointProgress[game.level]) {
                        game.checkpointProgress[game.level] = [];
                    }
                    game.checkpointProgress[game.level].push(index);
                    
                    console.log('Checkpoint activated!');
                }
            });
            
            // Breakable tile collision
            breakables.forEach((tile, index) => {
                if (!tile.broken && checkCollision(player, tile)) {
                    // Check if player is falling (stomping)
                    if (player.velY > 0 && player.y < tile.y) {
                        tile.health--;
                        addScreenShake(5);
                        addFreezeFrame(50);
                        
                        // Create stomp particles
                        game.particles.push(...createParticle(tile.x + tile.width/2, tile.y + tile.height, 'stomp'));
                        
                        if (tile.health <= 0) {
                            tile.broken = true;
                            console.log('Breakable tile destroyed!');
                            
                            // Give reward based on tile type
                            if (tile.reward) {
                                switch (tile.reward) {
                                    case 'mushroom':
                                        // Create mushroom at tile location
                                        mushrooms.push({
                                            x: tile.x + tile.width/2,
                                            y: tile.y + tile.height,
                                            collected: false,
                                            type: 'mushroom',
                                            value: 1000 // 1000 points for mushroom
                                        });
                                        console.log('Mushroom reward from breakable tile!');
                                        break;
                                    case 'health':
                                        // Create health pickup at tile location
                                        health.push({
                                            x: tile.x + tile.width/2,
                                            y: tile.y + tile.height,
                                            collected: false,
                                            type: 'health'
                                        });
                                        console.log('Health reward from breakable tile!');
                                        break;

                                }
                                
                                // Create reward particles
                                game.particles.push(...createParticle(tile.x + tile.width/2, tile.y + tile.height, 'reward'));
                            }
                            
                            // Check if this reveals a secret room
                            secretRooms.forEach(room => {
                                if (!room.discovered && 
                                    Math.abs(tile.x - room.x) < 300 && 
                                    Math.abs(tile.y - room.y) < 200) {
                                    room.discovered = true;
                                    console.log('Secret room discovered!');
                                }
                            });
                        }
                    }
                }
            });
            
            // Update boss
            if (game.currentBoss && game.bossActive) {
                const boss = game.currentBoss;
                console.log('🔫 BOSS UPDATE - State:', boss.state, 'Health:', boss.health, '/', boss.maxHealth);
                boss.stateTimer += 16; // Assuming 60 FPS
                
                        // Debug boss health every 2 seconds
        if (boss.stateTimer % 2000 < 16) {
            const healthPercentage = (boss.health / boss.maxHealth * 100).toFixed(1);
            console.log('👑 Boss health:', boss.health, '/', boss.maxHealth, '(', healthPercentage + '%)', 'State:', boss.state, 'Timer:', boss.stateTimer);
        }
                
                // Boss AI
                const distanceToPlayer = Math.abs(boss.x - player.x);
                
                // State machine
                switch (boss.state) {

                        
                    
                        

                        
                            case 'shoot':
            // Shoot 8 lasers in 360 degrees every 2 seconds
            if (boss.stateTimer % 2000 < 16) {
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI * 2) / 8; // 8 directions
                    const speed = 6;
                    const laser = {
                        x: boss.x + boss.width / 2,
                        y: boss.y + boss.height / 2,
                        velX: Math.cos(angle) * speed,
                        velY: Math.sin(angle) * speed,
                        width: 30,
                        height: 6,
                        color: '#FF0000',
                        active: true,
                        angle: angle // 🎯 STORE THE ANGLE for proper rotation
                    };
                    bossLasers.push(laser);
                }
                console.log('🔫 8 lasers created in 360 degrees! Total:', bossLasers.length);
            }
                        

                        break;
                }
                
                // Physics
                boss.velY += 0.8; // Gravity
                boss.x += boss.velX;
                boss.y += boss.velY;
                
                // Ground collision
                boss.isGrounded = false;
                for (const platform of platforms) {
                    if (platform.type === 'disappearing' && !platform.isVisible) continue;
                    
                    if (boss.x < platform.x + platform.width && boss.x + boss.width > platform.x &&
                        boss.y + boss.height >= platform.y && boss.y < platform.y + platform.height) {
                        boss.y = platform.y - boss.height;
                        boss.velY = 0;
                        boss.isGrounded = true;
                        break;
                    }
                }
                
                // Spawn adds
                boss.addSpawnTimer += 16;
                if (boss.addSpawnTimer > boss.addSpawnCooldown) {
                    boss.adds.push({
                        x: boss.x + Math.random() * boss.width,
                        y: boss.y - 50,
                        width: 40,
                        height: 32,
                        velX: (Math.random() - 0.5) * 4,
                        velY: 0,
                        direction: Math.random() < 0.5 ? 1 : -1
                    });
                    boss.addSpawnTimer = 0;
                }
                
                // Update adds
                boss.adds.forEach((add, index) => {
                    add.x += add.velX;
                    add.velY += 0.8;
                    add.y += add.velY;
                    
                    // Ground collision for adds
                    for (const platform of platforms) {
                        if (platform.type === 'disappearing' && !platform.isVisible) continue;
                        
                        if (add.x < platform.x + platform.width && add.x + add.width > platform.x &&
                            add.y + add.height >= platform.y && add.y < platform.y + platform.height) {
                            add.y = platform.y - add.height;
                            add.velY = 0;
                            break;
                        }
                    }
                    
                    // Remove adds that fall off screen
                    if (add.y > game.camera.y + game.canvasHeight + 100) {
                        boss.adds.splice(index, 1);
                    }
                });
                
                // Boss collision with player
                const playerCollisionX = player.x + player.collisionOffsetX;
                const playerCollisionY = player.y + player.collisionOffsetY;
                
                if (playerCollisionX < boss.x + boss.width &&
                    playerCollisionX + player.collisionWidth > boss.x &&
                    playerCollisionY < boss.y + boss.height &&
                    playerCollisionY + player.collisionHeight > boss.y) {
                    
                    // Check if player is stomping boss
                    const isFalling = player.velY > 0;
                    const feetNearBossTop = playerCollisionY + player.collisionHeight >= boss.y - 10 && 
                                           playerCollisionY + player.collisionHeight <= boss.y + 10;
                    const isAboveBoss = playerCollisionY < boss.y + boss.height * 0.5;
                    
                    if (isFalling && feetNearBossTop && isAboveBoss) {
                        // Stomp boss
                        boss.health -= 20;
                        player.velY = -player.jumpPower * 0.6;
                        console.log('Boss stomped! Health:', boss.health);
                        
                        if (boss.health <= 0) {
                            // Don't set bossActive to false yet - keep lava until level changes
                            // game.bossActive = false; // REMOVED - keep lava active
                            game.currentBoss = null;
                            game.score += 1000;
                            game.sessionStats.bossesDefeated++;
                            game.sessionStats.currentSessionBosses++;
                            game.sessionStats.totalScore += 1000;
                            game.sessionStats.currentSessionScore += 1000;
                            saveStats();
                            console.log('Boss defeated by stomp! Lava remains until level change.');
                        }
                                            } else if (!player.damageInvulnerable) {
                            // Player takes damage
                            game.lives--;
                            if (game.lives <= 0) {
                                game.gameOver = true;
                            } else {
                                player.damageInvulnerable = true;
                                player.invulnerableTime = Date.now();
                            }
                    }
                }
                
                // Boss adds collision
                boss.adds.forEach((add, addIndex) => {
                    if (playerCollisionX < add.x + add.width &&
                        playerCollisionX + player.collisionWidth > add.x &&
                        playerCollisionY < add.y + add.height &&
                        playerCollisionY + player.collisionHeight > add.y) {
                        
                        // Check if stomping add
                        const isFalling = player.velY > 0;
                        const feetNearAddTop = playerCollisionY + player.collisionHeight >= add.y - 10 && 
                                               playerCollisionY + player.collisionHeight <= add.y + 10;
                        const isAboveAdd = playerCollisionY < add.y + add.height * 0.5;
                        
                        if (isFalling && feetNearAddTop && isAboveAdd) {
                            // Stomp add
                            boss.adds.splice(addIndex, 1);
                            player.velY = -player.jumpPower * 0.4;
                            game.score += 100;
                        } else if (!player.damageInvulnerable) {
                            // Player takes damage
                            takeDamage(25); // Use new health system
                        }
                    }
                });
            }
            
            // Update particles
            game.particles.forEach((particle, index) => {
                particle.x += particle.velX;
                particle.y += particle.velY;
                particle.velY += 0.3; // Gravity
                particle.life -= particle.decay;
                
                if (particle.life <= 0) {
                    game.particles.splice(index, 1);
                }
            });
            
            // Update screen shake
            if (game.screenShake > 0) {
                game.screenShake *= 0.9;
                if (game.screenShake < 0.1) game.screenShake = 0;
            }
            
            // Update freeze frame
            if (game.freezeFrame > 0) {
                game.freezeFrame -= 16; // Assuming 60 FPS
            }
            
            // Update lasers
            lasers.forEach((laser, laserIndex) => {
                laser.x += laser.velX;
                laser.y += laser.velY;
                
                // Remove lasers that go off screen
                if (laser.x < game.camera.x - 120 || laser.x > game.camera.x + canvas.width + 120) { // Scaled from 50 (50*2.4=120)
                    lasers.splice(laserIndex, 1);
                    return;
                }
                
                // Laser collision with player
                if (!player.damageInvulnerable && checkCollision(player, laser)) {
                    console.log('Laser hit player! No bounce applied...'); // Debug
                    takeDamage(25); // Use new health system
                    player.x -= 120; // Scaled from 50 (50*2.4=120)
                    player.velY = 0; // No bounce - just horizontal knockback
                    console.log('No bounce - velY set to 0'); // Debug
                    lasers.splice(laserIndex, 1);
                }
                
                // Laser collision with platforms
                for (const platform of platforms) {
                    if (checkCollision(laser, platform)) {
                        lasers.splice(laserIndex, 1);
                        break;
                    }
                }
            });
            
            // Update boss lasers
            bossLasers.forEach((laser, laserIndex) => {
                laser.x += laser.velX;
                laser.y += laser.velY;
                
                // Remove boss lasers that go off screen
                if (laser.x < game.camera.x - 200 || laser.x > game.camera.x + canvas.width + 200 ||
                    laser.y < game.camera.y - 200 || laser.y > game.camera.y + canvas.height + 200) {
                    bossLasers.splice(laserIndex, 1);
                    return;
                }
                
                // Boss laser collision with player
                if (!player.damageInvulnerable && checkCollision(player, laser)) {
                    console.log('🔫 Boss laser hit player!');
                    takeDamage(25); // Use new health system
                    player.x -= 120;
                    player.velY = 0;
                    bossLasers.splice(laserIndex, 1);
                }
                
                // Boss lasers pass through platforms (no collision detection)
                // This allows boss lasers to travel through the environment
            });
            
            // Check for new life every 10000 points
            const lifeThreshold = Math.floor(game.score / 10000);
            if (lifeThreshold > game.lastLifeScore) {
                game.lives = Math.min(game.lives + (lifeThreshold - game.lastLifeScore), game.maxLives);
                game.lastLifeScore = lifeThreshold;
            }
            
            // Update UI
            document.getElementById('score').textContent = game.score;
            document.getElementById('coins').textContent = game.coins;
            document.getElementById('lives').textContent = game.lives;
            document.getElementById('xp').textContent = player.xp;
            
            // Update XP bar
            const xpBarFill = document.getElementById('xpBarFill');
            const xpText = document.getElementById('xpText');
            if (xpBarFill && xpText) {
                // Calculate current level XP and XP needed for next level based on new system
                let currentLevelXP, xpForNextLevel;
                
                if (player.level === 1) {
                    currentLevelXP = player.xp;
                    xpForNextLevel = 1000;
                } else if (player.level === 2) {
                    currentLevelXP = player.xp - 1000;
                    xpForNextLevel = 1500;
                } else if (player.level === 3) {
                    currentLevelXP = player.xp - 2500;
                    xpForNextLevel = 2000;
                } else if (player.level === 4) {
                    currentLevelXP = player.xp - 4500;
                    xpForNextLevel = 2500;
                } else if (player.level === 5) {
                    currentLevelXP = player.xp - 7000;
                    xpForNextLevel = 3000;
                } else if (player.level === 6) {
                    currentLevelXP = player.xp - 10000;
                    xpForNextLevel = 3500;
                } else if (player.level === 7) {
                    currentLevelXP = player.xp - 13500;
                    xpForNextLevel = 4000;
                } else if (player.level === 8) {
                    currentLevelXP = player.xp - 17500;
                    xpForNextLevel = 4500;
                } else if (player.level === 9) {
                    currentLevelXP = player.xp - 22000;
                    xpForNextLevel = 5000;
                } else if (player.level === 10) {
                    currentLevelXP = player.xp - 27000;
                    xpForNextLevel = 5500;
                } else {
                    // Level 10+: 1000 XP per level
                    const level10Plus = player.level - 10;
                    const baseXP = 32500 + (level10Plus * 1000);
                    currentLevelXP = player.xp - baseXP;
                    xpForNextLevel = 1000;
                }
                
                const xpPercentage = (currentLevelXP / xpForNextLevel) * 100;
                
                xpBarFill.style.width = xpPercentage + '%';
                xpText.innerHTML = `Level ${player.level} <span id="xpProgress">(${currentLevelXP}/${xpForNextLevel} XP)</span>`;
            }
            
            // Update XP display
            document.getElementById('xp').textContent = player.xp;
            // Keys are now updated in updateCollectiblesCounter()
            
            // Update health bar
            updateHealthBar();
            
            // Update armor bar
            updateArmorBar();
            
            // Update collectibles counter (includes keys)
            updateCollectiblesCounter();
            
            // Update giant mode indicator
            const giantIndicator = document.getElementById('giantIndicator');
            if (giantIndicator) {
                if (player.isGiant) {
                    const remainingTime = Math.max(0, Math.ceil((player.giantDuration - (Date.now() - player.giantTime)) / 1000));
                    giantIndicator.textContent = `🍄 GIANT MODE: ${remainingTime}s`;
                    giantIndicator.style.display = 'block';
                } else {
                    giantIndicator.style.display = 'none';
                }
            }
        }
        
        // Render game
        function draw() {
            // Clear and draw background
            drawBackground();
            
            // Draw top boundary warning
            drawTopBoundary();
            
            // Water will be drawn as overlay at the end
            
            // Debug: Draw collision boxes if Shift key is held
            const showCollisionBoxes = game.keys['ShiftLeft'] || game.keys['ShiftRight'];
            
            // Draw platforms in correct order (bottom to top) so green grass is visible
            // Cloud platforms are drawn last to appear on top
            const regularPlatforms = platforms.filter(p => p.type !== 'cloud');
            const cloudPlatforms = platforms.filter(p => p.type === 'cloud');
            
            // Sort regular platforms by Y position (bottom first)
            const sortedRegularPlatforms = [...regularPlatforms].sort((a, b) => a.y - b.y);
            sortedRegularPlatforms.forEach(drawPlatform);
            
            // Draw cloud platforms last (on top)
            cloudPlatforms.forEach(drawPlatform);
            
            // Draw goal
            drawGoal();
            
            // Draw fish
            fish.forEach(f => {
                if (!f.collected) {
                    const x = f.x - game.camera.x;
                    const y = f.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawFish(x, y);
                    }
                }
            });
            
            // Draw coins
            coins.forEach(c => {
                if (!c.collected) {
                    const x = c.x - game.camera.x;
                    const y = c.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawCoin(x, y);
                    }
                }
            });
            
            // Draw health pickups
            health.forEach(h => {
                if (!h.collected) {
                    const x = h.x - game.camera.x;
                    const y = h.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawHealth(x, y);
                    }
                }
            });
            
            // Draw heart pickups (extra lives)
            hearts.forEach(h => {
                if (!h.collected) {
                    const x = h.x - game.camera.x;
                    const y = h.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawHeart(x, y);
                    }
                }
            });
            
            // Draw armor pickups
            armor.forEach(a => {
                if (!a.collected) {
                    const x = a.x - game.camera.x;
                    const y = a.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawArmor(x, y, a);
                    }
                }
            });
            
            // Draw jetpacks
            jetpacks.forEach(j => {
                if (!j.collected) {
                    const x = j.x - game.camera.x;
                    const y = j.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawJetpack(x, y);
                    }
                }
            });
            
            // Draw treasures
            treasures.forEach(t => {
                if (!t.collected) {
                    const x = t.x - game.camera.x;
                    const y = t.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        if (t.isSecret) {
                            // Draw secret chest with special effects
                            drawSecretChest(x, y, t);
                        } else if (t.type === 'rareTreasure') {
                            drawRareTreasure(x, y, t.requiresKey);
                        } else {
                            drawTreasure(x, y);
                        }
                        
                        // Draw treasure hit effect
                        if (t.hitEffect && Date.now() - t.hitTime < 1000) {
                            ctx.save();
                            const time = Date.now() * 0.01;
                            const glowIntensity = Math.sin(time * 5) * 0.3 + 0.7;
                            
                            // Treasure hit glow effect
                            ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 50, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Treasure hit text
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('TREASURE HIT!', x, y - 40);
                            ctx.restore();
                        }
                    }
                }
            });
            
            // Draw mushrooms
            mushrooms.forEach(m => {
                if (!m.collected) {
                    const x = m.x - game.camera.x;
                    const y = m.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawMushroom(x, y);
                    }
                }
            });
            
            // Draw keys
            keys.forEach(k => {
                if (!k.collected) {
                    const x = k.x - game.camera.x;
                    const y = k.y - game.camera.y;
                    if (x > -48 && x < game.canvasWidth + 48) { // Scaled from 20 (20*2.4=48)
                        drawKey(x, y);
                    }
                }
            });
            
            // 🔫 LASER DRAWING CODE - ENHANCED RENDERING
            function drawLasers() {
                if (!laserPowerups || laserPowerups.length === 0) {
                    console.log('🔫 No laser powerups to draw');
                    return;
                }
                
                console.log('🔫 Drawing laser powerups, count:', laserPowerups.filter(l => !l.collected).length);
                
                laserPowerups.forEach((l, index) => {
                    if (!l.collected) {
                        const screenX = l.x - game.camera.x;
                        const screenY = l.y - game.camera.y;
                        
                        // Wider visibility range
                        if (screenX > -100 && screenX < game.canvasWidth + 100 && 
                            screenY > -100 && screenY < game.canvasHeight + 100) {
                            
                            console.log('🔫 Drawing laser at screen position:', screenX, screenY);
                            drawLaser(screenX, screenY);
                            

                        }
                    }
                });
            }
            
            // Call the enhanced drawing function
            drawLasers();
            
            // 🔥 Draw fireball powerups
            if (fireballPowerups && fireballPowerups.length > 0) {
                fireballPowerups.forEach((f, index) => {
                    if (!f.collected) {
                        const screenX = f.x - game.camera.x;
                        const screenY = f.y - game.camera.y;
                        
                        // Wider visibility range
                        if (screenX > -100 && screenX < game.canvasWidth + 100 && 
                            screenY > -100 && screenY < game.canvasHeight + 100) {
                            
                            // Draw fireball powerup
                            ctx.save();
                            ctx.translate(screenX, screenY);
                            
                            const time = Date.now() * 0.01;
                            const pulseIntensity = Math.sin(time * 6) * 0.3 + 0.7;
                            
                            // 🔥 OUTER GLOW (animated) - Draw behind the asset
                            ctx.fillStyle = `rgba(255, 69, 0, ${0.6 * pulseIntensity})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, 35, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // 🌟 FIRE PARTICLES - Draw behind the asset
                            ctx.fillStyle = '#FFAA00';
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2 + time * 3;
                                const radius = 30 + Math.sin(time * 4 + i) * 5;
                                const particleX = Math.cos(angle) * radius;
                                const particleY = Math.sin(angle) * radius;
                                const particleSize = Math.random() * 3 + 1;
                                ctx.beginPath();
                                ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            // Draw fireball asset if available
                            if (gameAssets.fireball && gameAssets.fireball.complete) {
                                const fireballWidth = gameAssets.fireball.width * 0.6; // Scale down slightly
                                const fireballHeight = gameAssets.fireball.height * 0.6;
                                ctx.drawImage(gameAssets.fireball, -fireballWidth/2, -fireballHeight/2, fireballWidth, fireballHeight);
                            } else {
                                // Fallback to custom fireball drawing
                                // 🔥 FIREBALL POWERUP CORE
                                ctx.fillStyle = '#FF4500';
                                ctx.beginPath();
                                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // ⚡ INNER GLOW
                                ctx.fillStyle = '#FFFFFF';
                                ctx.beginPath();
                                ctx.arc(0, 0, 10, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            // 🔥 FLOATING EFFECT - Draw on top
                            const floatOffset = Math.sin(time * 2) * 3;
                            ctx.fillStyle = 'rgba(255, 69, 0, 0.3)';
                            ctx.beginPath();
                            ctx.arc(0, floatOffset + 5, 20, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // ⚡ SPARKLE EFFECT - Draw on top
                            ctx.fillStyle = '#FFFFFF';
                            for (let i = 0; i < 4; i++) {
                                const angle = (i * Math.PI / 2) + time * 2;
                                const sparkleX = Math.cos(angle) * 25;
                                const sparkleY = Math.sin(angle) * 25;
                                ctx.beginPath();
                                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            ctx.restore();
                        }
                    }
                });
            }
            
            // Draw enemies
            if (enemies.length > 0) {
                console.log('🎨 DRAW LOOP: Processing', enemies.length, 'enemies');
            }
            enemies.forEach(enemy => {
                if (enemy.type === 'wizgator') {
                    console.log('🎨 FOUND WIZGATOR IN DRAW LOOP! Position:', enemy.x, enemy.y);
                }
                // Draw based on enemy type
                if (enemy.type === 'eagle') {
                    drawEagle(enemy);
                } else if (enemy.type === 'charger') {
                    drawCharger(enemy);
                } else if (enemy.type === 'goldfish') {
                    drawGoldfish(enemy);
                } else if (enemy.type === 'gator') {
                    drawGator(enemy);
                } else if (enemy.type === 'wizgator') {
                    drawWizgator(enemy);
                } else if (enemy.type === 'shark') {
                    drawShark(enemy);
                } else {
                    drawCrab(enemy);
                }
                

            });
            
            // 🔫 Draw enemy lasers
            lasers.forEach(laser => {
                const laserScreenX = laser.x - game.camera.x;
                const laserScreenY = laser.y - game.camera.y;
                
                // Only draw if on screen
                if (laserScreenX > -50 && laserScreenX < game.canvasWidth + 50 && 
                    laserScreenY > -50 && laserScreenY < game.canvasHeight + 50) {
                    
                    ctx.save();
                    ctx.translate(laserScreenX + laser.width/2, laserScreenY + laser.height/2);
                    
                    // Calculate rotation from velocity
                    const rotation = Math.atan2(laser.velY, laser.velX);
                    ctx.rotate(rotation);
                    
                    // Laser glow effect
                    const glowColor = laser.color || '#FF0000';
                    ctx.fillStyle = glowColor.replace(')', ', 0.3)').replace('rgb', 'rgba');
                    ctx.fillRect(-laser.width/2 - 3, -laser.height/2 - 3, laser.width + 6, laser.height + 6);
                    
                    // Main laser beam
                    ctx.fillStyle = laser.color || '#FF0000';
                    ctx.fillRect(-laser.width/2, -laser.height/2, laser.width, laser.height);
                    
                                         // Laser core (brighter center)
                     ctx.fillStyle = laser.color === '#FFD700' ? '#FFFF00' : '#FFFFFF';
                     ctx.fillRect(-laser.width/2 + 2, -laser.height/2 + 1, laser.width - 4, laser.height - 2);
                     
                     // Laser tip glow
                     ctx.fillStyle = '#FFFFFF';
                     ctx.fillRect(laser.width/2 - 3, -laser.height/2, 6, laser.height);
                     
                     // Fireball effects
                     if (laser.type === 'fireball') {
                         // Fireball glow effect
                         const time = Date.now() * 0.01;
                         const glowIntensity = Math.sin(time) * 0.3 + 0.7;
                         
                         // Outer fire glow
                         ctx.fillStyle = `rgba(255, 102, 0, ${glowIntensity * 0.4})`;
                         ctx.beginPath();
                         ctx.arc(0, 0, laser.width + 12, 0, Math.PI * 2); // Increased from +8
                         ctx.fill();
                         
                         // Inner fire glow
                         ctx.fillStyle = `rgba(255, 165, 0, ${glowIntensity * 0.6})`;
                         ctx.beginPath();
                         ctx.arc(0, 0, laser.width + 8, 0, Math.PI * 2); // Increased from +4
                         ctx.fill();
                         
                         // Fireball core
                         ctx.fillStyle = '#FF6600';
                         ctx.beginPath();
                         ctx.arc(0, 0, laser.width/2, 0, Math.PI * 2);
                         ctx.fill();
                         
                         // Fireball center
                         ctx.fillStyle = '#FFFF00';
                         ctx.beginPath();
                         ctx.arc(0, 0, laser.width/3, 0, Math.PI * 2); // Increased from /4
                         ctx.fill();
                     }
                    
                    ctx.restore();
                }
            });
            
            // Draw checkpoints
            checkpoints.forEach(checkpoint => {
                drawCheckpoint(checkpoint);
            });
            
            // Draw breakable tiles
            breakables.forEach(tile => {
                drawBreakableTile(tile);
            });
            
            // Draw secret rooms
            secretRooms.forEach(room => {
                drawSecretRoom(room);
            });
            

            
            // Draw boss
            if (game.currentBoss && game.bossActive) {
                drawBoss(game.currentBoss);
            }
            
            // 🔥 FIXED BOSS LASER DRAWING SYSTEM
            bossLasers.forEach(laser => {
                const laserScreenX = laser.x - game.camera.x;
                const laserScreenY = laser.y - game.camera.y;
                
                ctx.save();
                ctx.translate(laserScreenX + laser.width/2, laserScreenY + laser.height/2); // Translate to center
                
                // 🎯 CORRECT ROTATION - Use stored angle or calculate from velocity
                let rotation = laser.angle || Math.atan2(laser.velY, laser.velX);
                ctx.rotate(rotation);
                
                // 🌟 LASER GLOW EFFECT (outer glow)
                ctx.fillStyle = `rgba(255, 0, 0, 0.3)`;
                ctx.fillRect(-laser.width/2 - 3, -laser.height/2 - 3, laser.width + 6, laser.height + 6);
                
                // 🔥 MAIN LASER BEAM (core)
                ctx.fillStyle = '#FF4444';
                ctx.fillRect(-laser.width/2, -laser.height/2, laser.width, laser.height);
                
                // ⚡ LASER CORE (bright center)
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(-laser.width/2 + 2, -laser.height/2 + 1, laser.width - 4, laser.height - 2);
                
                // ✨ LASER TIP GLOW (white hot tip)
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(laser.width/2 - 4, -laser.height/2, 6, laser.height);
                
                // 🌟 ENERGY PARTICLES (animated sparkles)
                ctx.fillStyle = '#FFAA00';
                for (let i = 0; i < 4; i++) {
                    const particleX = (Math.random() - 0.5) * laser.width;
                    const particleY = (Math.random() - 0.5) * laser.height;
                    const particleSize = Math.random() * 2 + 0.5;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 🔥 TRAILING ENERGY (behind the laser)
                ctx.fillStyle = `rgba(255, 100, 0, 0.6)`;
                for (let i = 0; i < 3; i++) {
                    const trailX = -laser.width/2 - (i * 4);
                    const trailWidth = laser.width * (0.8 - i * 0.2);
                    const trailHeight = laser.height * (0.6 - i * 0.1);
                    ctx.fillRect(trailX, -trailHeight/2, trailWidth, trailHeight);
                }
                
                ctx.restore();
            });
            
            // Apply screen shake
            if (game.screenShake > 0) {
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * game.screenShake,
                    (Math.random() - 0.5) * game.screenShake
                );
            }
            
            // Draw particles
            drawParticles();
            
            // Draw player
            const playerScreenX = player.x - game.camera.x;
            const playerScreenY = player.y - game.camera.y;
            drawOtter(playerScreenX, playerScreenY);
            
            // 🤖 Draw AI Bot (performance optimized)
            if (game.aiBot.isVisible) {
                drawAiBot();
            }
            
            // 🎯 Show crosshair on mouse when laser is active
            if (player.hasLaser && game.mouseX !== undefined && game.mouseY !== undefined) {
                ctx.save();
                ctx.strokeStyle = player.laserColors[player.currentLaserColor];
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.8;
                
                // Draw crosshair
                ctx.beginPath();
                ctx.moveTo(game.mouseX - 8, game.mouseY);
                ctx.lineTo(game.mouseX + 8, game.mouseY);
                ctx.moveTo(game.mouseX, game.mouseY - 8);
                ctx.lineTo(game.mouseX, game.mouseY + 8);
                ctx.stroke();
                
                // Draw small center dot
                ctx.fillStyle = player.laserColors[player.currentLaserColor];
                ctx.beginPath();
                ctx.arc(game.mouseX, game.mouseY, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
                         // 🔥 Show fireball crosshair when fireball is active
             if (player.hasFireball && game.mouseX !== undefined && game.mouseY !== undefined) {
                 ctx.save();
                 ctx.strokeStyle = player.fireballCooldown > 0 ? '#666666' : '#FF4500';
                 ctx.lineWidth = 2;
                 ctx.globalAlpha = player.fireballCooldown > 0 ? 0.3 : 0.8;
                 
                 // Draw fireball crosshair
                 ctx.beginPath();
                 ctx.moveTo(game.mouseX - 10, game.mouseY);
                 ctx.lineTo(game.mouseX + 10, game.mouseY);
                 ctx.moveTo(game.mouseX, game.mouseY - 10);
                 ctx.lineTo(game.mouseX, game.mouseY + 10);
                 ctx.stroke();
                 
                 // Draw fireball center dot
                 ctx.fillStyle = player.fireballCooldown > 0 ? '#666666' : '#FF4500';
                 ctx.beginPath();
                 ctx.arc(game.mouseX, game.mouseY, 3, 0, Math.PI * 2);
                 ctx.fill();
                 
                 // Removed on-screen 'FIREBALL' text indicator to avoid top-left label
                 
                 ctx.restore();
             }
            

            
            // 🔋 Draw charging indicator when laser is charging (only if laser charge ability is unlocked)
            if (player.hasLaser && player.isCharging && player.laserChargingLevel > 0) {
                ctx.save();
                
                // Calculate charge progress
                const currentTime = Date.now();
                const chargeDuration = currentTime - player.chargeStartTime;
                const chargeProgress = Math.min(1, chargeDuration / player.chargeTime);
                
                 // Calculate charge level
                 player.chargeLevel = Math.min(player.maxChargeLevel, Math.floor(chargeDuration / (player.chargeTime / player.maxChargeLevel)));
                 
                 // Flashing effect - faster when fully charged
                 const baseFlashSpeed = 0.005; // Base flash speed
                 const chargeSpeedMultiplier = 1 + (player.chargeLevel * 0.3); // Gets faster with charge level (adjusted for 5 levels)
                 const time = Date.now() * baseFlashSpeed * chargeSpeedMultiplier;
                 
                 // Flash intensity based on charge level
                 const flashIntensity = Math.sin(time * 20) * 0.5 + 0.5;
                 
                 // Apply flashing effect to the otter
                 ctx.globalAlpha = 0.3 + (flashIntensity * 0.7); // Flash between 30% and 100% opacity
                 
                 // Add glow effect around the otter
                 ctx.shadowColor = player.laserColors[player.currentLaserColor];
                 ctx.shadowBlur = 15 + (player.chargeLevel * 5); // Glow gets stronger with charge
                 
                 // Redraw the otter with flashing effect
                 drawOtter(playerScreenX, playerScreenY);
                 
                 // Reset shadow for other elements
                 ctx.shadowBlur = 0;
                 ctx.globalAlpha = 1.0;
                 
                                 // REMOVED: All text overlays for cleaner look
                
                ctx.restore();
            }
            
            // 🔫 Draw player lasers with enhanced visual effects
            playerLasers.forEach(laser => {
                const laserScreenX = laser.x - game.camera.x;
                const laserScreenY = laser.y - game.camera.y;
                
                ctx.save();
                // FIXED: Draw laser from its actual position, not centered
                ctx.translate(laserScreenX, laserScreenY);
                
                // Calculate rotation from velocity
                let rotation = Math.atan2(laser.velY, laser.velX);
                ctx.rotate(rotation);
                
                // Get charge level for enhanced effects
                const chargeLevel = laser.chargeLevel || 0;
                const time = Date.now() * 0.01;
                const pulseIntensity = Math.sin(time * 5) * 0.3 + 0.7;
                
                // REMOVED: Outer glow effects for cleaner look
                
                // 🔥 MAIN LASER BEAM (enhanced with charge effects)
                ctx.fillStyle = laser.color;
                ctx.fillRect(0, 0, laser.width, laser.height);
                
                // ⚡ LASER CORE (bright center, scales with charge)
                const coreWidth = Math.max(2, laser.width - (chargeLevel * 2));
                const coreHeight = Math.max(2, laser.height - (chargeLevel * 1));
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(2, 1, coreWidth, coreHeight);
                
                // ✨ LASER TIP GLOW (enhanced white hot tip)
                const tipGlowSize = 6 + (chargeLevel * 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(laser.width - 2, -1, tipGlowSize, laser.height + 2);
                
                // 🌟 ENERGY PARTICLES (more particles for higher charge)
                const particleCount = 3 + (chargeLevel * 2);
                ctx.fillStyle = laser.color;
                for (let i = 0; i < particleCount; i++) {
                    const particleX = Math.random() * laser.width;
                    const particleY = Math.random() * laser.height;
                    const particleSize = Math.random() * 2 + 0.5;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 🔥 TRAILING ENERGY (behind the laser, scales with charge)
                ctx.fillStyle = `${laser.color}60`; // 40% opacity
                for (let i = 0; i < 3 + chargeLevel; i++) {
                    const trailX = -(i * 4);
                    const trailWidth = laser.width * (0.8 - i * 0.1);
                    const trailHeight = laser.height * (0.6 - i * 0.1);
                    ctx.fillRect(trailX, 0, trailWidth, trailHeight);
                }
                
                // ⚡ CHARGE EFFECTS (special effects for charged lasers)
                if (chargeLevel > 0) {
                    // Lightning bolts around the laser
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.6 * pulseIntensity;
                    
                    for (let i = 0; i < chargeLevel; i++) {
                        const boltX = Math.random() * laser.width;
                        const boltY = Math.random() * laser.height;
                        ctx.beginPath();
                        ctx.moveTo(boltX, boltY);
                        ctx.lineTo(boltX + (Math.random() - 0.5) * 20, boltY + (Math.random() - 0.5) * 20);
                        ctx.stroke();
                    }
                    
                    // REMOVED: Energy rings for cleaner look
                    
                    // REMOVED: Explosion radius indicator and particles for cleaner look
                    

                }
                
                ctx.restore();
            });
            
            // 🔥 Draw player fireballs
            playerFireballs.forEach(fireball => {
                const fireballScreenX = fireball.x - game.camera.x;
                const fireballScreenY = fireball.y - game.camera.y;
                
                ctx.save();
                ctx.translate(fireballScreenX, fireballScreenY);
                
                // Calculate rotation from velocity
                let rotation = Math.atan2(fireball.velY, fireball.velX);
                ctx.rotate(rotation);
                
                const time = Date.now() * 0.01;
                const pulseIntensity = Math.sin(time * 8) * 0.3 + 0.7;
                
                // 🔥 FIREBALL CORE (bright orange center)
                ctx.fillStyle = '#FF4500';
                ctx.beginPath();
                ctx.arc(0, 0, fireball.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // ⚡ FIREBALL INNER GLOW (white hot center)
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(0, 0, fireball.width / 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 🔥 FIREBALL OUTER GLOW (animated orange glow)
                ctx.fillStyle = `rgba(255, 69, 0, ${0.6 * pulseIntensity})`;
                ctx.beginPath();
                ctx.arc(0, 0, fireball.width / 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // 🌟 FIRE PARTICLES (animated sparkles)
                ctx.fillStyle = '#FFAA00';
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + time * 2;
                    const radius = fireball.width / 2 + Math.sin(time * 3 + i) * 3;
                    const particleX = Math.cos(angle) * radius;
                    const particleY = Math.sin(angle) * radius;
                    const particleSize = Math.random() * 2 + 1;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 🔥 TRAILING FIRE (behind the fireball)
                ctx.fillStyle = 'rgba(255, 69, 0, 0.4)';
                for (let i = 0; i < 4; i++) {
                    const trailX = -(i * 6);
                    const trailRadius = (fireball.width / 2) * (0.8 - i * 0.15);
                    ctx.beginPath();
                    ctx.arc(trailX, 0, trailRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                

                
                ctx.restore();
            });
            
            // Restore screen shake
            if (game.screenShake > 0) {
                ctx.restore();
            }
            



            

            

            
            // Show giant mode activation effect
            if (game.giantModeActivated && Date.now() - game.giantModeTime < 2000) {
                ctx.save();
                const time = Date.now() * 0.01;
                const glowIntensity = Math.sin(time * 3) * 0.3 + 0.7;
                
                // Giant mode glow effect
                ctx.fillStyle = `rgba(255, 255, 0, ${glowIntensity * 0.3})`;
                ctx.beginPath();
                ctx.arc(playerScreenX + player.width/2, playerScreenY + player.height/2, 100, 0, Math.PI * 2);
                ctx.fill();
                
                // Giant mode text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GIANT MODE ACTIVATED!', playerScreenX + player.width/2, playerScreenY + player.height/2 - 120);
                ctx.restore();
            }
            
            // Show jetpack flames only when button is pressed
            if (player.jetpackActive && (game.keys['ShiftLeft'] || game.keys['ShiftRight'])) {
                ctx.save();
                const time = Date.now() * 0.01;
                const flameIntensity = Math.sin(time) * 0.3 + 0.7;
                
                // Scale flames based on giant mode
                const flameScale = player.isGiant ? 2.0 : 1.0;
                const flameWidth = 4 * flameScale; // Reduced from 10 to 4 (tail-sized)
                const flameHeight = 8 * flameScale; // Reduced from 20 to 8 (tail-sized)
                const innerFlameWidth = 2 * flameScale; // Reduced from 5 to 2
                const innerFlameHeight = 6 * flameScale; // Reduced from 15 to 6
                
                // Vertical flame dimensions (unchanged)
                const verticalFlameWidth = 10 * flameScale;
                const verticalFlameHeight = 20 * flameScale;
                const verticalInnerFlameWidth = 5 * flameScale;
                const verticalInnerFlameHeight = 15 * flameScale;
                
                if (player.inWater) {
                    // Water jetpack flames - horizontal from rear end
                    const flameX = playerScreenX + (player.direction === 1 ? -10 : player.width + 10);
                    const flameY = playerScreenY + player.height/2;
                    
                    // Jetpack flames (outer) - horizontal
                ctx.fillStyle = `rgba(255, 100, 0, ${flameIntensity})`;
                ctx.beginPath();
                    ctx.moveTo(flameX, flameY - flameWidth);
                    ctx.lineTo(flameX + (player.direction === 1 ? -flameHeight : flameHeight), flameY - flameWidth/2);
                    ctx.lineTo(flameX + (player.direction === 1 ? -flameHeight * 0.75 : flameHeight * 0.75), flameY);
                    ctx.lineTo(flameX + (player.direction === 1 ? -flameHeight : flameHeight), flameY + flameWidth/2);
                    ctx.lineTo(flameX, flameY + flameWidth);
                ctx.closePath();
                ctx.fill();
                
                    // Inner flame (brighter) - horizontal
                ctx.fillStyle = `rgba(255, 255, 0, ${flameIntensity * 0.8})`;
                ctx.beginPath();
                    ctx.moveTo(flameX, flameY - innerFlameWidth);
                    ctx.lineTo(flameX + (player.direction === 1 ? -innerFlameHeight : innerFlameHeight), flameY - innerFlameWidth/2);
                    ctx.lineTo(flameX + (player.direction === 1 ? -innerFlameHeight * 0.75 : innerFlameHeight * 0.75), flameY);
                    ctx.lineTo(flameX + (player.direction === 1 ? -innerFlameHeight : innerFlameHeight), flameY + innerFlameWidth/2);
                    ctx.lineTo(flameX, flameY + innerFlameWidth);
                ctx.closePath();
                ctx.fill();
                
                    // Additional flame particles for more dynamic effect - horizontal
                    ctx.fillStyle = `rgba(255, 200, 0, ${flameIntensity * 0.6})`;
                    for (let i = 0; i < 6; i++) {
                        const particleX = flameX + (player.direction === 1 ? -Math.random() * flameHeight : Math.random() * flameHeight);
                        const particleY = flameY + (Math.random() - 0.5) * flameWidth * 2;
                        const particleSize = Math.random() * 3 * flameScale + 1;
                ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                ctx.fill();
                    }
                } else {
                    // Land jetpack flames - vertical downward
                    // Calculate visual height for giant mode
                    const visualHeight = player.isGiant ? player.height * 1.5 : player.height;
                    
                    // Jetpack flames (outer)
                    ctx.fillStyle = `rgba(255, 100, 0, ${flameIntensity})`;
                    ctx.beginPath();
                    ctx.moveTo(playerScreenX + player.width/2 - verticalFlameWidth, playerScreenY + visualHeight);
                    ctx.lineTo(playerScreenX + player.width/2 - verticalFlameWidth/2, playerScreenY + visualHeight + verticalFlameHeight);
                    ctx.lineTo(playerScreenX + player.width/2, playerScreenY + visualHeight + verticalFlameHeight * 0.75);
                    ctx.lineTo(playerScreenX + player.width/2 + verticalFlameWidth/2, playerScreenY + visualHeight + verticalFlameHeight);
                    ctx.lineTo(playerScreenX + player.width/2 + verticalFlameWidth, playerScreenY + visualHeight);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner flame (brighter)
                    ctx.fillStyle = `rgba(255, 255, 0, ${flameIntensity * 0.8})`;
                ctx.beginPath();
                    ctx.moveTo(playerScreenX + player.width/2 - verticalInnerFlameWidth, playerScreenY + visualHeight);
                    ctx.lineTo(playerScreenX + player.width/2 - verticalInnerFlameWidth/2, playerScreenY + visualHeight + verticalInnerFlameHeight);
                    ctx.lineTo(playerScreenX + player.width/2, playerScreenY + visualHeight + verticalInnerFlameHeight * 0.75);
                    ctx.lineTo(playerScreenX + player.width/2 + verticalInnerFlameWidth/2, playerScreenY + visualHeight + verticalInnerFlameHeight);
                    ctx.lineTo(playerScreenX + player.width/2 + verticalInnerFlameWidth, playerScreenY + visualHeight);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Additional flame particles for more dynamic effect
                    ctx.fillStyle = `rgba(255, 200, 0, ${flameIntensity * 0.6})`;
                    for (let i = 0; i < 6; i++) {
                        const particleX = playerScreenX + player.width/2 + (Math.random() - 0.5) * verticalFlameWidth * 2;
                        const particleY = playerScreenY + visualHeight + Math.random() * verticalFlameHeight;
                        const particleSize = Math.random() * 3 * flameScale + 1;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }
            

            

            

            
            // Game over screen
            if (game.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px Orbitron, Arial Black, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER!', canvas.width/2, canvas.height/2 - 50);
                
                ctx.font = 'bold 24px Orbitron, Arial Black, sans-serif';
                ctx.fillText('Final Score: ' + game.score, canvas.width/2, canvas.height/2);
                ctx.fillText('Reached Level: ' + game.level, canvas.width/2, canvas.height/2 + 30);
                
                ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 50);
                
                if (game.keys['KeyR']) {
                    // Reset game
                    game.score = 0;
                    game.coins = 0;
                    game.lives = 3;
                    game.level = 1;
                    game.lastLifeScore = 0;
                    game.gameOver = false;
                    game.keyCount = 0; // Reset key count on game restart
                    
                    // Reset boss state
                    game.bossActive = false;
                    game.currentBoss = null;
                    
                    // Reset player state completely
                    player.x = 240;
                    player.y = 1200;
                    player.velX = 0;
                    player.velY = 0;
                    player.onGround = true;
                    player.canDoubleJump = true;
                    player.direction = 1;
                    player.health = player.maxHealth; // Reset health to full
                    player.armor = 0; // Reset armor to 0
                    player.invulnerable = false;
                    player.invulnerableTime = 0;
                    player.damageInvulnerable = false;
                    player.isGiant = false;
                    player.giantTime = 0;
                    player.canDash = false;
                    player.dashCooldown = 0;
                    player.dashDuration = 0;

                    player.lastPlatform = null;
                    player.onMovingPlatform = false;
                    
                    // Reset lava state
                    player.inLava = false;
                    player.lavaSinkTime = 0;
                    player.lavaDamageTime = 0;
                    player.lavaInvulnerable = false;
                    
                    loadLevel(1);
                    document.getElementById('level').textContent = 1;
                    document.getElementById('levelComplete').style.display = 'none';
                    console.log('Game restarted');
                }
            }
            
            // Draw water overlay as top layer (after everything else)
            drawWater();
        }
        
        function drawBoss(boss) {
            const x = boss.x - game.camera.x;
            const y = boss.y - game.camera.y;
            
            if (x > -200 && x < game.canvasWidth + 200) {
                if (gameAssets.useCustomAssets && gameAssets.kingcrab) {
                    // Draw custom kingcrab sprite for boss
                    ctx.save();
                    ctx.translate(x + boss.width/2, y + boss.height/2);
                    ctx.scale(boss.direction, 1);
                    ctx.drawImage(gameAssets.kingcrab, -boss.width/2, -boss.height/2, boss.width, boss.height);
                    
                    // State indicator on top of sprite
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(boss.state.toUpperCase(), 0, -boss.height/2 - 10);
                    
                    ctx.restore();
                } else {
                    // Draw default boss (fallback)
                    ctx.save();
                    ctx.translate(x + boss.width/2, y + boss.height/2);
                    ctx.scale(boss.direction, 1);
                    
                    // Boss body
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(-boss.width/2, -boss.height/2, boss.width, boss.height);
                    
                    // Boss shell
                    ctx.fillStyle = '#FF4444';
                    ctx.fillRect(-boss.width/2 + 10, -boss.height/2 + 10, boss.width - 20, boss.height - 20);
                    
                    // Boss eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-boss.width/4, -boss.height/3, 8, 0, Math.PI * 2);
                    ctx.arc(boss.width/4, -boss.height/3, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(-boss.width/4, -boss.height/3, 4, 0, Math.PI * 2);
                    ctx.arc(boss.width/4, -boss.height/3, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Boss claws
                    ctx.fillStyle = '#CC3333';
                    ctx.fillRect(-boss.width/2 - 15, -boss.height/2 + 20, 15, 20);
                    ctx.fillRect(boss.width/2, -boss.height/2 + 20, 15, 20);
                    
                    // State indicator
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(boss.state.toUpperCase(), 0, -boss.height/2 - 10);
                    
                    ctx.restore();
                }
                
                // Health bar
                const barWidth = 200;
                const barHeight = 20;
                const barX = x + (boss.width - barWidth) / 2;
                const barY = y - 30;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(barX, barY, (boss.health / boss.maxHealth) * barWidth, barHeight);
                
                // Draw adds
                boss.adds.forEach(add => {
                    const addX = add.x - game.camera.x;
                    const addY = add.y - game.camera.y;
                    
                    if (addX > -40 && addX < game.canvasWidth + 40) {
                        ctx.fillStyle = '#FF6666';
                        ctx.fillRect(addX, addY, add.width, add.height);
                    }
                });
            }
        }
        
        function drawBreakableTile(tile) {
            if (tile.broken) return;
            
            const x = tile.x - game.camera.x;
            const y = tile.y - game.camera.y;
            
            if (x > -50 && x < game.canvasWidth + 50) {
                ctx.save();
                
                // Determine which crate image to use based on health
                let crateImage = null;
                if (gameAssets.useCustomAssets) {
                    if (tile.health === 3) {
                        crateImage = gameAssets.crate; // Full health - intact crate
                    } else if (tile.health === 2) {
                        crateImage = gameAssets.crate1; // Damaged - first damage state
                    } else if (tile.health === 1) {
                        crateImage = gameAssets.crate2; // Heavily damaged - second damage state
                    }
                }
                
                if (crateImage && crateImage.complete) {
                    // Draw custom crate image
                    ctx.drawImage(crateImage, x, y, tile.width, tile.height);
                } else {
                    // Fallback to default drawn appearance
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x, y, tile.width, tile.height);
                
                    // Cracks based on damage level
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.beginPath();
                    
                    if (tile.health <= 2) {
                        // First crack
                ctx.moveTo(x + 10, y + 10);
                ctx.lineTo(x + 40, y + 30);
                    }
                    if (tile.health <= 1) {
                        // Second crack
                ctx.moveTo(x + 30, y + 15);
                ctx.lineTo(x + 15, y + 40);
                    }
                ctx.stroke();
                }
                
                // Health indicator
                for (let i = 0; i < tile.health; i++) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(x + 5 + i * 15, y - 10, 10, 5);
                }
                
                // Reward indicator (small icon above health bars)
                if (tile.reward) {
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    let rewardIcon = '?';
                    let rewardColor = '#FFD700';
                    
                    switch (tile.reward) {
                        case 'mushroom':
                            rewardIcon = '🍄';
                            rewardColor = '#FF00FF';
                            break;
                        case 'health':
                            rewardIcon = '❤️';
                            rewardColor = '#FF0000';
                            break;
                        case 'treasure':
                            rewardIcon = '💎';
                            rewardColor = '#FFD700';
                            break;
                    }
                    
                    ctx.fillStyle = rewardColor;
                    ctx.fillText(rewardIcon, x + tile.width/2, y - 20);
                }
                
                ctx.restore();
            }
        }
        
        function drawSecretRoom(room) {
            if (!room.discovered) return;
            
            const x = room.x - game.camera.x;
            const y = room.y - game.camera.y;
            
            if (x > -300 && x < game.canvasWidth + 300) {
                ctx.save();
                
                // Secret room background
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fillRect(x, y, room.width, room.height);
                
                // Glowing border
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(x, y, room.width, room.height);
                ctx.setLineDash([]);
                
                // Treasure indicator
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(room.contains === 'treasure' ? '💎' : '🍄', x + room.width/2, y + room.height/2);
                
                ctx.restore();
            }
        }
        
        function drawTopBoundary() {
            // Calculate world top boundary (1000 pixels above the highest platform)
            const worldTop = Math.min(...platforms.map(p => p.y)) - 1000;
            
            // Only draw if the boundary is visible on screen
            const boundaryScreenY = worldTop - game.camera.y;
            if (boundaryScreenY > -100 && boundaryScreenY < game.canvasHeight + 100) {
                ctx.save();
                
                // Create warning boundary effect
                const time = Date.now() * 0.005;
                const pulseIntensity = Math.sin(time) * 0.3 + 0.7;
                
                // Draw warning boundary line
                ctx.strokeStyle = `rgba(255, 0, 0, ${pulseIntensity * 0.8})`;
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 5]);
                ctx.lineDashOffset = time * 20; // Animated dash movement
                ctx.beginPath();
                ctx.moveTo(0, boundaryScreenY);
                ctx.lineTo(game.canvasWidth, boundaryScreenY);
                ctx.stroke();
                
                // Draw warning triangles
                ctx.fillStyle = `rgba(255, 0, 0, ${pulseIntensity * 0.6})`;
                for (let i = 0; i < game.canvasWidth; i += 40) {
                    ctx.beginPath();
                    ctx.moveTo(i, boundaryScreenY - 15);
                    ctx.lineTo(i + 10, boundaryScreenY);
                    ctx.lineTo(i - 10, boundaryScreenY);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Draw warning text
                ctx.fillStyle = `rgba(255, 0, 0, ${pulseIntensity * 0.9})`;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('WARNING: TOP BOUNDARY', game.canvasWidth / 2, boundaryScreenY - 25);
                
                ctx.restore();
            }
        }
        
        function drawParticles() {
            game.particles.forEach(particle => {
                const x = particle.x - game.camera.x;
                const y = particle.y - game.camera.y;
                
                if (x > -10 && x < game.canvasWidth + 10 && y > -10 && y < game.canvasHeight + 10) {
                    ctx.save();
                    ctx.globalAlpha = particle.life;
                    
                    if (particle.type === 'sparkle') {
                        // Sparkle effect for hidden armor
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add sparkle glow
                        ctx.fillStyle = `rgba(255, 255, 255, ${particle.life * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (particle.type === 'heart') {
                        // Heart particle effect for heart collection
                        ctx.fillStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.moveTo(x, y + 3);
                        ctx.bezierCurveTo(x - 4, y - 2, x - 4, y - 6, x, y - 6);
                        ctx.bezierCurveTo(x + 4, y - 6, x + 4, y - 2, x, y + 3);
                        ctx.fill();
                        
                        // Heart glow
                        ctx.strokeStyle = '#FF4444';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, y + 3);
                        ctx.bezierCurveTo(x - 4, y - 2, x - 4, y - 6, x, y - 6);
                        ctx.bezierCurveTo(x + 4, y - 6, x + 4, y - 2, x, y + 3);
                        ctx.stroke();
                    } else {
                        // Regular particles
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            });
        }
        
        const cutsceneTexts = [
            "Welcome to the Otter Kingdom, young adventurer!",
            "You are Ollie, a brave otter on a quest to save your homeland.",
            "The evil crabs have stolen the sacred mushrooms and scattered them across the land.",
            "You must journey through dangerous levels, defeat enemies, and collect treasures.",
            "Along the way, you'll discover secret rooms and unlock powerful abilities.",
            "Every 5 levels, you'll face a mighty boss - Captain Claws himself!",
            "Use your platforming skills, collect power-ups, and become the hero the otters need!",
            "Good luck, brave otter! The kingdom's fate rests in your paws!"
        ];
        
        function startGame() {
            // Give 50,000 coins for marketplace testing
            if (!game.sessionStats) {
                game.sessionStats = {
                    // Current Game Session Stats
                    totalScore: 0,
                    levelsCompleted: 0,
                    totalCoins: 0,
                    crabsDefeated: 0,
                    eaglesDefeated: 0,
                    gatorsDefeated: 0,
                    sharksDefeated: 0,
                    bossesDefeated: 0,
                    fishCollected: 0,
                    healthCollected: 0,
                    treasuresCollected: 0,
                    mushroomsCollected: 0,
                    keysCollected: 0,
                    treasuresFound: 0,
                    healthPickups: 0,
                    mushroomsEaten: 0,
                    jetpacksUsed: 0,
                    lasersUsed: 0,
                    fireballsShot: 0,
                    fireballsHit: 0,
                    underwaterTime: 0,
                    jetpackTime: 0,
                    laserTime: 0,
                    damageTaken: 0,
                    jumpsMade: 0,
                    perfectLevels: 0,
                    speedRunLevels: 0,
                    noDamageLevels: 0,
                    noJumpLevels: 0,
                    noPowerupLevels: 0,
                    
                    // All-Time Stats (Persistent)
                    allTimeScore: 0,
                    allTimeLevels: 0,
                    allTimeCoins: 0,
                    allTimeEnemies: 0,
                    allTimeBosses: 0,
                    allTimeFish: 0,
                    allTimeHealth: 0,
                    allTimeTreasures: 0,
                    allTimeMushrooms: 0,
                    allTimeJetpacks: 0,
                    allTimeLasers: 0,
                    allTimeFireballs: 0,
                    allTimeUnderwater: 0,
                    allTimeJetpackTime: 0,
                    allTimeLaserTime: 0,
                    allTimeDamage: 0,
                    allTimeJumps: 0,
                    allTimePerfectLevels: 0,
                    allTimeSpeedRuns: 0,
                    allTimeNoDamage: 0,
                    allTimeNoJumps: 0,
                    allTimeNoPowerups: 0,
                    allTimeKeys: 0,
                    
                    // Session Records
                    levelTimes: [],
                    levelStartTime: Date.now(),
                    highestScore: 0,
                    highestLevels: 0,
                    highestCoins: 0,
                    highestCrabs: 0,
                    highestBosses: 0,
                    highestFish: 0,
                    highestHealth: 0,
                    highestTreasures: 0,
                    highestMushrooms: 0,
                    currentSessionScore: 0,
                    currentSessionLevels: 0,
                    currentSessionCoins: 0,
                    currentSessionCrabs: 0,
                    currentSessionBosses: 0,
                    currentSessionFish: 0,
                    currentSessionHealth: 0,
                    currentSessionTreasures: 0,
                    currentSessionMushrooms: 0
                };
            }
            
            // Start with 0 coins (fresh start)
            game.sessionStats.totalCoins = 0;
            game.sessionStats.currentSessionCoins = 0;
            game.coins = 0;
            game.marketplace.coins = 0; // Set marketplace coins to 0
            console.log('🆕 Starting fresh with 0 coins');
            saveStats(); // Save to localStorage
            saveMarketplaceData(); // Save marketplace data
            updateLeaderboard(); // Update the leaderboard display
            updateMarketplace(); // Update marketplace display
            checkAllAchievements(); // Check for achievements
            
            // Initialize collectibles counter
            game.collectiblesCount.coinsCollected = 0;
            
            // Reset secret chest state for new level
            game.secretChestsSpawned = false;
            game.secretChestConditions.coinsCollected = 0;
            game.secretChestConditions.treasuresCollected = 0;
            game.secretChestConditions.keysCollected = 0;
            game.collectiblesCount.chestsCollected = 0;
            game.collectiblesCount.goldenChestsCollected = 0;
            updateCollectiblesCounter();
            
            // Load player progress (XP, level, etc.)
            loadPlayerProgress();
            
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('cutscenePanel').style.display = 'flex';
            game.cutsceneActive = true;
            game.cutsceneIndex = 0;
            displayCutsceneText();
        }
        
        function displayCutsceneText() {
            if (game.cutsceneIndex < cutsceneTexts.length) {
                const text = cutsceneTexts[game.cutsceneIndex];
                const textElement = document.getElementById('cutsceneText');
                
                // Clear any existing text and intervals
                textElement.textContent = '';
                if (game.typewriterInterval) {
                    clearInterval(game.typewriterInterval);
                }
                
                console.log('Displaying cutscene text:', text); // Debug log
                
                // Option 1: Character by character typing (current)
                let charIndex = 0;
                game.typewriterInterval = setInterval(() => {
                    if (charIndex < text.length) {
                        textElement.textContent += text[charIndex];
                        charIndex++;
                    } else {
                        clearInterval(game.typewriterInterval);
                        game.typewriterInterval = null;
                        setTimeout(() => {
                            game.cutsceneIndex++;
                            if (game.cutsceneIndex < cutsceneTexts.length) {
                                displayCutsceneText();
                            } else {
                                endCutscene();
                            }
                        }, 2000);
                    }
                }, 50);
                
                // Option 2: Word by word typing (uncomment to use instead)
                /*
                const words = text.split(' ');
                let wordIndex = 0;
                game.typewriterInterval = setInterval(() => {
                    if (wordIndex < words.length) {
                        textElement.textContent += (wordIndex > 0 ? ' ' : '') + words[wordIndex];
                        wordIndex++;
                    } else {
                        clearInterval(game.typewriterInterval);
                        game.typewriterInterval = null;
                        setTimeout(() => {
                            game.cutsceneIndex++;
                            if (game.cutsceneIndex < cutsceneTexts.length) {
                                displayCutsceneText();
                            } else {
                                endCutscene();
                            }
                        }, 2000);
                    }
                }, 200);
                */
            }
        }
        
        function endCutscene() {
            document.getElementById('cutscenePanel').style.display = 'none';
            game.cutsceneActive = false;
            game.storyMode = true;
            game.gameState = 'playing';
            
            // Load the current level and update UI
            loadLevel(game.level);
            document.getElementById('level').textContent = game.level;
            
            // Show pause button and settings button, hide title screen buttons
            document.getElementById('pauseBtn').style.display = 'inline-block';
            document.getElementById('settingsBtn').style.display = 'inline-block';
            document.getElementById('profileBtn').style.display = 'none';
            document.getElementById('marketplaceBtn').style.display = 'none';
            document.getElementById('startGameBtn').style.display = 'none';
            
            // Enable abilities for the player
            // Dash removed - no longer needed
            
            console.log('Story mode activated! Abilities unlocked! Level loaded:', game.level);
        }
        
        function skipCutscene() {
            if (game.typewriterInterval) {
                clearInterval(game.typewriterInterval);
                game.typewriterInterval = null;
            }
            endCutscene();
        }
        
        function returnToStart() {
            // Reset game state but preserve current level
            game.score = 0;
            game.lives = 3;
            // Don't reset game.level - preserve current level
            game.coins = 0;
            game.gameOver = false;
            game.levelComplete = false;
            game.levelTransition = false;
            game.lastLifeScore = 0;
            game.camera = { x: 0, y: 0 };
            // Reset checkpoint progress for current level only
            if (game.checkpointProgress[game.level]) {
                delete game.checkpointProgress[game.level];
            }
            game.activeCheckpoint = null;
            game.currentBoss = null;
            game.bossActive = false;
            game.secrets = [];
            game.secretRooms = [];
            game.particles = [];
            game.screenShake = 0;
            game.freezeFrame = 0;
            game.storyMode = false;
            game.cutsceneActive = false;
            game.cutsceneIndex = 0;
            game.gameState = 'menu';
            if (game.typewriterInterval) {
                clearInterval(game.typewriterInterval);
                game.typewriterInterval = null;
            }
            
            // Reset player state
            player.x = 240;
            player.y = 1200;
            player.velX = 0;
            player.velY = 0;
            player.onGround = true;
            player.canDoubleJump = true;
            player.direction = 1;
            player.invulnerable = false;
            player.invulnerableTime = 0;
            player.giant = false;
            player.giantTime = 0;

            // Reset jetpack
            player.hasJetpack = false;
            player.jetpackActive = false;
            player.jetpackTime = 0;
            player.lastPlatform = null;
            
            // Hide all panels
            document.getElementById('leaderboardPanel').style.display = 'none';
            document.getElementById('instructionsPanel').style.display = 'none';

            document.getElementById('cutscenePanel').style.display = 'none';
            
            // Show title screen
            document.getElementById('titleScreen').style.display = 'flex';
            
            // Hide pause button and settings button, show title screen buttons
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('settingsBtn').style.display = 'none';
            document.getElementById('profileBtn').style.display = 'inline-block';
            document.getElementById('marketplaceBtn').style.display = 'inline-block';
            document.getElementById('startGameBtn').style.display = 'inline-block';
            
            // Reset UI displays
            document.getElementById('score').textContent = '0';
            document.getElementById('coins').textContent = '0';
            document.getElementById('level').textContent = game.level; // Show current level, not 1
            document.getElementById('lives').textContent = '3';
            document.getElementById('giantIndicator').style.display = 'none';
            
            // Reset XP display with proper span structure
            const xpText = document.getElementById('xpText');
            const xpBarFill = document.getElementById('xpBarFill');
            if (xpText) {
                xpText.innerHTML = `Level 1 <span id="xpProgress">(0/1000 XP)</span>`;
            }
            if (xpBarFill) {
                xpBarFill.style.width = '0%';
            }
            
            // Regenerate level
            generateLevel();
            
            console.log('Returned to start screen');
        }
        
        // Health Bar Functions
        function updateHealthBar() {
            const healthBarFill = document.getElementById('healthBarFill');
            const healthText = document.getElementById('healthText');
            
            if (healthBarFill && healthText) {
                const healthPercentage = (player.health / player.maxHealth) * 100;
                healthBarFill.style.width = healthPercentage + '%';
                healthText.textContent = `Health: ${Math.round(healthPercentage)}%`;
                
                // Update health bar color based on health level
                healthBarFill.classList.remove('medium', 'low');
                if (healthPercentage <= 30) {
                    healthBarFill.classList.add('low');
                } else if (healthPercentage <= 60) {
                    healthBarFill.classList.add('medium');
                }
            }
        }
        
        function takeDamage(damageAmount = 25) {
            if (player.invulnerable || player.damageInvulnerable) {
                return; // Player is invulnerable
            }
            
            // Apply wallet defense bonuses if connected
            if (otterWallet && otterWallet.isConnected) {
                try {
                    const multipliers = otterWallet.getGameMultipliers();
                    if (multipliers.defense < 1.0) {
                        const damageReduction = damageAmount * (1 - multipliers.defense);
                        damageAmount = Math.max(1, damageAmount - damageReduction);
                        console.log(`🛡️ Wallet defense reduced damage by ${Math.round((1 - multipliers.defense) * 100)}%! Damage: ${damageAmount + damageReduction} → ${damageAmount}`);
                    }
                } catch (error) {
                    console.warn('⚠️ Error getting wallet defense multipliers:', error);
                }
            }
            
            // Apply armor boost if player has the ability
            if (player.hasArmorBoost && player.armorLevel > 0) {
                const armorBoostPercent = player.armorLevel * 25; // 25%, 50%, or 75%
                const damageReduction = damageAmount * (armorBoostPercent / 100);
                damageAmount = Math.max(1, damageAmount - damageReduction); // Minimum 1 damage
                console.log(`🛡️ Armor boost reduced damage by ${armorBoostPercent}%! Damage: ${damageAmount + damageReduction} → ${damageAmount}`);
            }
            
            // Armor absorbs damage first
            if (player.armor > 0) {
                const armorAbsorbed = Math.min(player.armor, damageAmount);
                player.armor -= armorAbsorbed;
                damageAmount -= armorAbsorbed;
                updateArmorBar();
                console.log('🛡️ Armor absorbed', armorAbsorbed, 'damage! Armor remaining:', player.armor);
            }
            
            // Remaining damage goes to health
            if (damageAmount > 0) {
                player.health = Math.max(0, player.health - damageAmount);
                game.sessionStats.damageTaken += damageAmount;
                updateHealthBar();
                console.log('💔 Player took', damageAmount, 'damage to health! Health remaining:', player.health);
            }
            
            // Activate damage invulnerability
            player.damageInvulnerable = true;
            player.invulnerableTime = Date.now();
            
            // If health reaches 0, lose a life and reset health
            if (player.health <= 0) {
                game.lives--;
                player.health = player.maxHealth; // Reset health to full
                updateHealthBar();
                
                // Update lives display
                const livesElement = document.getElementById('lives');
                if (livesElement) {
                    livesElement.textContent = game.lives;
                }
                
                console.log('💔 Player took damage! Health: 0, Lives remaining:', game.lives);
                
                if (game.lives <= 0) {
                    console.log('💔 GAME OVER! No lives remaining.');
                    game.gameOver = true;
                }
            }
        }
        
        function healPlayer(healAmount = 25) {
            player.health = Math.min(player.maxHealth, player.health + healAmount);
            updateHealthBar();
            console.log('❤️ Player healed! Health:', player.health);
        }
        
        // Armor Bar Functions
        function updateArmorBar() {
            const armorBarFill = document.getElementById('armorBarFill');
            const armorText = document.getElementById('armorText');
            
            if (armorBarFill && armorText) {
                const armorPercentage = (player.armor / player.maxArmor) * 100;
                armorBarFill.style.width = armorPercentage + '%';
                armorText.textContent = `Armor: ${Math.round(armorPercentage)}%`;
            }
        }
        
        function addArmor(armorAmount = 25) {
            player.armor = Math.min(player.maxArmor, player.armor + armorAmount);
            updateArmorBar();
            console.log('🛡️ Armor added! Armor:', player.armor);
        }
        
                // Abilities Display Functions
        function updateAbilitiesDisplay() {
            const laserAbility = document.getElementById('laserAbility');
            const fireballAbility = document.getElementById('fireballAbility');
            const jetpackAbility = document.getElementById('jetpackAbility');
            
            if (laserAbility) {
                if (player.hasLaser) {
                    laserAbility.classList.remove('inactive');
                    laserAbility.classList.add('active');
                } else {
                    laserAbility.classList.remove('active');
                    laserAbility.classList.add('inactive');
                }
            }
            
            if (fireballAbility) {
                if (player.hasFireball) {
                    fireballAbility.classList.remove('inactive');
                    fireballAbility.classList.add('active');
                } else {
                    fireballAbility.classList.remove('active');
                    fireballAbility.classList.add('inactive');
                }
            }
            
            if (jetpackAbility) {
                if (player.hasJetpack) {
                    jetpackAbility.classList.remove('inactive');
                    jetpackAbility.classList.add('active');
                } else {
                    jetpackAbility.classList.remove('active');
                    jetpackAbility.classList.add('inactive');
                }
            }
        }
        
        function removeArmor(armorAmount = 25) {
            player.armor = Math.max(0, player.armor - armorAmount);
            updateArmorBar();
            console.log('🛡️ Armor damaged! Armor remaining:', player.armor);
        }
        
        // Game loop
        function gameLoop() {
            game.frameCount = (game.frameCount || 0) + 1;
            update();
            updateTimeStats();
            
            // Check achievements every 60 frames (1 second at 60fps) for real-time tracking
            if (game.frameCount % 60 === 0) {
                checkAllAchievements();
                checkSecretChestConditions(); // Check for secret chest conditions
                updateAbilitiesDisplay(); // Update abilities display
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function updateTimeStats() {
            const currentTime = Date.now();
            const deltaTime = 16; // Approximate frame time
            
            // Track underwater time
            if (player.inWater) {
                game.sessionStats.underwaterTime += deltaTime;
            }
            
            // Track jetpack time
            if (player.jetpackActive) {
                game.sessionStats.jetpackTime += deltaTime;
            }
            
            // Track laser time (when laser is being used)
            if (player.hasLaser && (player.isCharging || player.laserCooldown > 0)) {
                game.sessionStats.laserTime += deltaTime;
            }
        }
        
        // Asset management functions
        function toggleAssetPanel() {
            const panel = document.getElementById('assetPanel');
            const isVisible = panel.style.display === 'block';
            
            panel.style.display = isVisible ? 'none' : 'block';
        }
        
        function toggleInstructions() {
            const panel = document.getElementById('instructionsPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }
        

        
        // Get current skin image based on equipped skin
        function getCurrentSkinImage() {
            const currentSkin = marketplaceItems.skins.find(skin => skin.id === game.marketplace.currentSkin);
            if (currentSkin && currentSkin.image) {
                return currentSkin.image;
            }
            return 'public/oggg.png'; // Default skin
        }
        
        // Get current swimming asset based on equipped skin
        function getCurrentSwimmingAsset() {
            const currentSkin = marketplaceItems.skins.find(skin => skin.id === game.marketplace.currentSkin);
            if (!currentSkin) {
                return gameAssets.swimmingOtter; // Default swimming otter
            }
            
            switch (currentSkin.id) {
                case 'red_plumber':
                    return gameAssets.redPlumberSwimming || gameAssets.swimmingOtter;
                case 'green_plumber':
                    return gameAssets.greenPlumberSwimming || gameAssets.swimmingOtter;
                case 'yellow_plumber':
                    return gameAssets.yellowPlumberSwimming || gameAssets.swimmingOtter;
                case 'purple_plumber':
                    return gameAssets.purplePlumberSwimming || gameAssets.swimmingOtter;
                case 'snow_plumber':
                    return gameAssets.snowPlumberSwimming || gameAssets.swimmingOtter;
                default:
                    return gameAssets.swimmingOtter; // Default swimming otter
            }
        }
        
        function toggleMarketplace() {
            console.log('🛒 Marketplace button clicked!');
            const panel = document.getElementById('marketplacePanel');
            console.log('Panel found:', panel);
            const isVisible = panel.style.display === 'block';
            console.log('Is visible:', isVisible);
            
            if (!isVisible) {
                console.log('Updating marketplace...');
                updateMarketplace();
            }
            
            panel.style.display = isVisible ? 'none' : 'block';
            console.log('Panel display set to:', panel.style.display);
        }
        
        function updateMarketplace() {
            console.log('🛒 Updating marketplace...');
            console.log('Marketplace coins:', game.marketplace.coins);
            
            // Update coins display
            const coinsElement = document.getElementById('marketplaceCoins');
            console.log('Coins element found:', coinsElement);
            if (coinsElement) {
                coinsElement.textContent = game.marketplace.coins;
            }
            
            // Update hats grid
            updateHatsGrid();
            
            // Update skins grid
            updateSkinsGrid();
            
            // Update abilities grid
            updateAbilitiesGrid();
        }
        
        function updateHatsGrid() {
            console.log('🦉 Updating hats grid...');
            const grid = document.getElementById('hatsGrid');
            console.log('Hats grid element found:', grid);
            if (!grid) {
                console.error('Hats grid element not found!');
                return;
            }
            
            if (!marketplaceItems || !marketplaceItems.hats) {
                console.error('Marketplace items not defined!');
                return;
            }
            
            grid.innerHTML = '';
            console.log('Marketplace hats:', marketplaceItems.hats);
            
            marketplaceItems.hats.forEach(hat => {
                const hatElement = document.createElement('div');
                hatElement.className = `marketplace-item ${hat.owned ? 'owned' : 'unowned'}`;
                hatElement.style.cssText = `
                    background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(26,26,46,0.6));
                    border: 2px solid ${hat.owned ? 'rgba(76,175,80,0.6)' : 'rgba(255,215,0,0.4)'};
                    border-radius: 20px;
                    padding: 25px;
                    text-align: center;
                    cursor: pointer;
                    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                    position: relative;
                    overflow: hidden;
                    backdrop-filter: blur(10px);
                    ${hat.equipped ? 'box-shadow: 0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3);' : 'box-shadow: 0 4px 15px rgba(0,0,0,0.2);'}
                `;
                
                // Add hover effects
                hatElement.addEventListener('mouseenter', () => {
                    hatElement.style.transform = 'translateY(-8px) scale(1.02)';
                    hatElement.style.boxShadow = hat.equipped ? 
                        '0 0 40px rgba(76,175,80,0.8), 0 12px 35px rgba(0,0,0,0.4)' : 
                        '0 8px 25px rgba(0,0,0,0.4), 0 0 20px rgba(255,215,0,0.3)';
                });
                
                hatElement.addEventListener('mouseleave', () => {
                    hatElement.style.transform = 'translateY(0) scale(1)';
                    hatElement.style.boxShadow = hat.equipped ? 
                        '0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3)' : 
                        '0 4px 15px rgba(0,0,0,0.2)';
                });
                
                // Add dark overlay for unowned items
                if (!hat.owned) {
                    const darkOverlay = document.createElement('div');
                    darkOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.6);
                        pointer-events: none;
                        z-index: 1;
                        border-radius: 18px;
                    `;
                    hatElement.appendChild(darkOverlay);
                }
                
                const contentDiv = document.createElement('div');
                contentDiv.style.cssText = `
                    position: relative;
                    z-index: 2;
                `;
                
                contentDiv.innerHTML = `
                    <div style="margin-bottom: 20px; text-align: center; position: relative;">
                        <div style="width: 80px; height: 80px; margin: 0 auto; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border-radius: 15px; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255,255,255,0.1);">
                            <img src="${hat.image}" alt="${hat.name}" style="width: 60px; height: 60px; object-fit: contain; filter: ${hat.owned ? 'none' : 'brightness(0.3) grayscale(0.5)'}; border-radius: 8px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display: none; font-size: 40px; filter: ${hat.owned ? 'none' : 'brightness(0.3)'};">🦉</div>
                    </div>
                        ${hat.equipped ? '<div style="position: absolute; top: -5px; right: -5px; background: #4CAF50; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">✓</div>' : ''}
                    </div>
                    <div style="font-size: 18px; margin-bottom: 10px; filter: ${hat.owned ? 'none' : 'brightness(0.4)'}; color: ${hat.owned ? '#FFD700' : '#999'}; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">${hat.name}</div>
                    <div style="font-size: 13px; color: ${hat.owned ? '#00FFFF' : '#666'}; margin-bottom: 20px; line-height: 1.4; opacity: 0.9;">${hat.description}</div>
                    <div style="font-size: 16px; color: ${hat.owned ? '#4CAF50' : '#FFD700'}; margin-bottom: 20px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                        ${hat.owned ? '✓ OWNED' : `${hat.price} 🪙`}
                    </div>
                    ${hat.owned ? 
                        `<button onclick="equipHat('${hat.id}')" style="background: ${hat.equipped ? 'linear-gradient(135deg, #4CAF50, #45a049)' : 'linear-gradient(135deg, #2196F3, #1976D2)'}; color: white; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            ${hat.equipped ? '✓ EQUIPPED' : 'EQUIP'}
                        </button>` :
                        `<button onclick="buyHat('${hat.id}')" style="background: ${game.marketplace.coins >= hat.price ? 'linear-gradient(135deg, #FFD700, #FFA500)' : 'linear-gradient(135deg, #666666, #444444)'}; color: ${game.marketplace.coins >= hat.price ? '#000' : '#999'}; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            ${game.marketplace.coins >= hat.price ? '🛒 BUY' : '❌ NOT ENOUGH COINS'}
                        </button>`
                    }
                `;
                
                hatElement.appendChild(contentDiv);
                grid.appendChild(hatElement);
            });
        }
        
        function updateSkinsGrid() {
            console.log('🦦 Updating skins grid...');
            const grid = document.getElementById('skinsGrid');
            console.log('Skins grid element found:', grid);
            if (!grid) {
                console.error('Skins grid element not found!');
                return;
            }
            
            if (!marketplaceItems || !marketplaceItems.skins) {
                console.error('Marketplace items not defined!');
                return;
            }
            
            grid.innerHTML = '';
            console.log('Marketplace skins:', marketplaceItems.skins);
            
            marketplaceItems.skins.forEach(skin => {
                const skinElement = document.createElement('div');
                skinElement.className = `marketplace-item ${skin.owned ? 'owned' : 'unowned'}`;
                skinElement.style.cssText = `
                    background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(26,26,46,0.6));
                    border: 2px solid ${skin.owned ? 'rgba(76,175,80,0.6)' : 'rgba(255,215,0,0.4)'};
                    border-radius: 20px;
                    padding: 25px;
                    text-align: center;
                    cursor: pointer;
                    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                    position: relative;
                    overflow: hidden;
                    backdrop-filter: blur(10px);
                    ${skin.equipped ? 'box-shadow: 0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3);' : 'box-shadow: 0 4px 15px rgba(0,0,0,0.2);'}
                `;
                
                // Add hover effects
                skinElement.addEventListener('mouseenter', () => {
                    skinElement.style.transform = 'translateY(-8px) scale(1.02)';
                    skinElement.style.boxShadow = skin.equipped ? 
                        '0 0 40px rgba(76,175,80,0.8), 0 12px 35px rgba(0,0,0,0.4)' : 
                        '0 8px 25px rgba(0,0,0,0.4), 0 0 20px rgba(255,215,0,0.3)';
                });
                
                skinElement.addEventListener('mouseleave', () => {
                    skinElement.style.transform = 'translateY(0) scale(1)';
                    skinElement.style.boxShadow = skin.equipped ? 
                        '0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3)' : 
                        '0 4px 15px rgba(0,0,0,0.2)';
                });
                
                // Add dark overlay for unowned items
                if (!skin.owned) {
                    const darkOverlay = document.createElement('div');
                    darkOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.6);
                        pointer-events: none;
                        z-index: 1;
                        border-radius: 18px;
                    `;
                    skinElement.appendChild(darkOverlay);
                }
                
                const contentDiv = document.createElement('div');
                contentDiv.style.cssText = `
                    position: relative;
                    z-index: 2;
                `;
                
                contentDiv.innerHTML = `
                    <div style="margin-bottom: 20px; text-align: center; position: relative;">
                        <div style="width: 80px; height: 80px; margin: 0 auto; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border-radius: 15px; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255,255,255,0.1);">
                            <img src="${skin.image}" alt="${skin.name}" style="width: 60px; height: 60px; object-fit: contain; filter: ${skin.owned ? 'none' : 'brightness(0.3) grayscale(0.5)'}; border-radius: 8px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display: none; font-size: 40px; filter: ${skin.owned ? 'none' : 'brightness(0.3)'};">🦦</div>
                    </div>
                        ${skin.equipped ? '<div style="position: absolute; top: -5px; right: -5px; background: #4CAF50; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">✓</div>' : ''}
                    </div>
                    <div style="font-size: 18px; margin-bottom: 10px; filter: ${skin.owned ? 'none' : 'brightness(0.4)'}; color: ${skin.owned ? '#FFD700' : '#999'}; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">${skin.name}</div>
                    <div style="font-size: 13px; color: ${skin.owned ? '#00FFFF' : '#666'}; margin-bottom: 20px; line-height: 1.4; opacity: 0.9;">${skin.description}</div>
                    <div style="font-size: 16px; color: ${skin.owned ? '#4CAF50' : '#FFD700'}; margin-bottom: 20px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                        ${skin.owned ? '✓ OWNED' : (skin.unlockType === 'achievement' ? '🔒 ACHIEVEMENT' : `${skin.price} 🪙`)}
                    </div>
                    ${skin.owned ? 
                        `<button onclick="equipSkin('${skin.id}')" style="background: ${skin.equipped ? 'linear-gradient(135deg, #4CAF50, #45a049)' : 'linear-gradient(135deg, #2196F3, #1976D2)'}; color: white; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            ${skin.equipped ? '✓ EQUIPPED' : 'EQUIP'}
                        </button>` :
                        (skin.unlockType === 'achievement' ? 
                            `<button style="background: linear-gradient(135deg, #666666, #444444); color: #999; border: none; padding: 12px 20px; border-radius: 12px; cursor: not-allowed; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                                🔒 LOCKED
                            </button>` :
                            `<button onclick="buySkin('${skin.id}')" style="background: ${game.marketplace.coins >= skin.price ? 'linear-gradient(135deg, #FFD700, #FFA500)' : 'linear-gradient(135deg, #666666, #444444)'}; color: ${game.marketplace.coins >= skin.price ? '#000' : '#999'}; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                                ${game.marketplace.coins >= skin.price ? '🛒 BUY' : '❌ NOT ENOUGH COINS'}
                            </button>`
                        )
                    }
                `;
                
                skinElement.appendChild(contentDiv);
                grid.appendChild(skinElement);
            });
        }
        
        function updateAbilitiesGrid() {
            console.log('⚡ Updating abilities grid...');
            const grid = document.getElementById('abilitiesGrid');
            console.log('Abilities grid element found:', grid);
            if (!grid) {
                console.error('Abilities grid element not found!');
                return;
            }
            
            if (!marketplaceItems || !marketplaceItems.abilities) {
                console.error('Marketplace abilities not defined!');
                return;
            }
            
            grid.innerHTML = '';
            console.log('Marketplace abilities:', marketplaceItems.abilities);
            
            marketplaceItems.abilities.forEach(ability => {
                const abilityElement = document.createElement('div');
                abilityElement.className = `marketplace-item ${ability.owned ? 'owned' : 'unowned'}`;
                abilityElement.style.cssText = `
                    background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(26,26,46,0.6));
                    border: 2px solid ${ability.owned ? 'rgba(76,175,80,0.6)' : 'rgba(255,107,53,0.4)'};
                    border-radius: 20px;
                    padding: 25px;
                    text-align: center;
                    cursor: pointer;
                    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                    position: relative;
                    overflow: hidden;
                    backdrop-filter: blur(10px);
                    ${ability.equipped ? 'box-shadow: 0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3);' : 'box-shadow: 0 4px 15px rgba(0,0,0,0.2);'}
                `;
                
                // Add hover effects
                abilityElement.addEventListener('mouseenter', () => {
                    abilityElement.style.transform = 'translateY(-8px) scale(1.02)';
                    abilityElement.style.boxShadow = ability.equipped ? 
                        '0 0 40px rgba(76,175,80,0.8), 0 12px 35px rgba(0,0,0,0.4)' : 
                        '0 8px 25px rgba(0,0,0,0.4), 0 0 20px rgba(255,107,53,0.3)';
                });
                
                abilityElement.addEventListener('mouseleave', () => {
                    abilityElement.style.transform = 'translateY(0) scale(1)';
                    abilityElement.style.boxShadow = ability.equipped ? 
                        '0 0 30px rgba(76,175,80,0.6), 0 8px 25px rgba(0,0,0,0.3)' : 
                        '0 4px 15px rgba(0,0,0,0.2)';
                });
                
                // Add dark overlay for unowned items
                if (!ability.owned) {
                    const darkOverlay = document.createElement('div');
                    darkOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.6);
                        pointer-events: none;
                        z-index: 1;
                        border-radius: 18px;
                    `;
                    abilityElement.appendChild(darkOverlay);
                }
                
                const contentDiv = document.createElement('div');
                contentDiv.style.cssText = `
                    position: relative;
                    z-index: 2;
                `;
                
                contentDiv.innerHTML = `
                    <div style="margin-bottom: 20px; text-align: center; position: relative;">
                        <div style="width: 80px; height: 80px; margin: 0 auto; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border-radius: 15px; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255,255,255,0.1);">
                            <img src="${ability.image}" alt="${ability.name}" style="width: 60px; height: 60px; object-fit: contain; filter: ${ability.owned ? 'none' : 'brightness(0.3) grayscale(0.5)'}; border-radius: 8px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display: none; font-size: 40px; filter: ${ability.owned ? 'none' : 'brightness(0.3)'};">⚡</div>
                    </div>
                        ${ability.equipped ? '<div style="position: absolute; top: -5px; right: -5px; background: #4CAF50; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">✓</div>' : ''}
                    </div>
                    <div style="font-size: 18px; margin-bottom: 10px; filter: ${ability.owned ? 'none' : 'brightness(0.4)'}; color: ${ability.owned ? '#FFD700' : '#999'}; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">${ability.name}</div>
                    <div style="font-size: 13px; color: ${ability.owned ? '#00FFFF' : '#666'}; margin-bottom: 20px; line-height: 1.4; opacity: 0.9;">
                        ${ability.id === 'armor' && player.hasArmorBoost ? 
                            `Level ${player.armorLevel} (+${player.armorLevel * 25}% armor)` : 
                            ability.description}
                    </div>
                    <div style="font-size: 16px; color: ${ability.owned ? '#4CAF50' : '#FFD700'}; margin-bottom: 20px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                        ${ability.owned ? '✓ OWNED' : `${ability.price} 🪙`}
                    </div>
                    ${ability.owned ? 
                        `<button onclick="equipAbility('${ability.id}')" style="background: ${ability.equipped ? 'linear-gradient(135deg, #4CAF50, #45a049)' : 'linear-gradient(135deg, #FF6B35, #F7931E)'}; color: white; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            ${ability.equipped ? '✓ EQUIPPED' : 'EQUIP'}
                        </button>` :
                        `<button onclick="buyAbility('${ability.id}')" style="background: ${game.marketplace.coins >= ability.price ? 'linear-gradient(135deg, #FFD700, #FFA500)' : 'linear-gradient(135deg, #666666, #444444)'}; color: ${game.marketplace.coins >= ability.price ? '#000' : '#999'}; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            ${game.marketplace.coins >= ability.price ? '🛒 BUY' : '❌ NOT ENOUGH COINS'}
                        </button>`
                    }
                `;
                
                abilityElement.appendChild(contentDiv);
                grid.appendChild(abilityElement);
            });
        }
        
        function switchMarketplaceTab(tab) {
            const hatsTab = document.getElementById('hatsTab');
            const skinsTab = document.getElementById('skinsTab');
            const abilitiesTab = document.getElementById('abilitiesTab');
            const hatsBtn = document.getElementById('hatsTabBtn');
            const skinsBtn = document.getElementById('skinsTabBtn');
            const abilitiesBtn = document.getElementById('abilitiesTabBtn');
            
            // Hide all tabs
            hatsTab.style.display = 'none';
            skinsTab.style.display = 'none';
            abilitiesTab.style.display = 'none';
            
            // Remove active class from all buttons and reset styles
            [hatsBtn, skinsBtn, abilitiesBtn].forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.3), rgba(0,0,0,0.1))';
                btn.style.color = '#999';
                btn.style.border = '2px solid rgba(255,255,255,0.1)';
            });
            
            if (tab === 'hats') {
                hatsTab.style.display = 'block';
                hatsBtn.classList.add('active');
                hatsBtn.style.background = 'linear-gradient(135deg, rgba(76,175,80,0.2), rgba(76,175,80,0.1))';
                hatsBtn.style.color = '#4CAF50';
                hatsBtn.style.border = '2px solid rgba(76,175,80,0.4)';
            } else if (tab === 'skins') {
                skinsTab.style.display = 'block';
                skinsBtn.classList.add('active');
                skinsBtn.style.background = 'linear-gradient(135deg, rgba(33,150,243,0.2), rgba(33,150,243,0.1))';
                skinsBtn.style.color = '#2196F3';
                skinsBtn.style.border = '2px solid rgba(33,150,243,0.4)';
            } else if (tab === 'abilities') {
                abilitiesTab.style.display = 'block';
                abilitiesBtn.classList.add('active');
                abilitiesBtn.style.background = 'linear-gradient(135deg, rgba(255,107,53,0.2), rgba(255,107,53,0.1))';
                abilitiesBtn.style.color = '#FF6B35';
                abilitiesBtn.style.border = '2px solid rgba(255,107,53,0.4)';
            }
        }
        
        function buyHat(hatId) {
            const hat = marketplaceItems.hats.find(h => h.id === hatId);
            if (hat && game.marketplace.coins >= hat.price) {
                game.marketplace.coins -= hat.price;
                hat.owned = true;
                game.marketplace.ownedHats.push(hatId);
                updateMarketplace();
                saveMarketplaceData();
                
                // Check for marketplace achievements
                unlockAchievement('marketplace_shopper');
                
                // Check for hat collector achievement
                if (game.marketplace.ownedHats.length >= 4) { // 3 hats + 'none'
                    unlockAchievement('hat_collector');
                }
            }
        }
        
        function buySkin(skinId) {
            const skin = marketplaceItems.skins.find(s => s.id === skinId);
            if (skin && game.marketplace.coins >= skin.price) {
                game.marketplace.coins -= skin.price;
                skin.owned = true;
                game.marketplace.ownedSkins.push(skinId);
                updateMarketplace();
                saveMarketplaceData();
                
                // Check for marketplace achievements
                unlockAchievement('marketplace_shopper');
                
                // Check for skin collector achievement
                if (game.marketplace.ownedSkins.length >= 4) { // 3 skins + 'default'
                    unlockAchievement('skin_collector');
                }
            }
        }
        
        function equipHat(hatId) {
            // Unequip current hat
            marketplaceItems.hats.forEach(hat => hat.equipped = false);
            
            // Equip new hat
            const hat = marketplaceItems.hats.find(h => h.id === hatId);
            if (hat) {
                hat.equipped = true;
                game.marketplace.currentHat = hatId;
                game.aiBot.currentHat = hatId;
            }
            
            updateMarketplace();
            saveMarketplaceData();
        }
        
        function equipSkin(skinId) {
            // Unequip current skin
            marketplaceItems.skins.forEach(skin => skin.equipped = false);
            
            // Equip new skin
            const skin = marketplaceItems.skins.find(s => s.id === skinId);
            if (skin) {
                skin.equipped = true;
                game.marketplace.currentSkin = skinId;
            }
            
            updateMarketplace();
            saveMarketplaceData();
        }
        
        function buyAbility(abilityId) {
            const ability = marketplaceItems.abilities.find(a => a.id === abilityId);
            if (ability && game.marketplace.coins >= ability.price) {
                game.marketplace.coins -= ability.price;
                ability.owned = true;
                game.marketplace.ownedAbilities.push(abilityId);
                updateMarketplace();
                saveMarketplaceData();
                
                // Check for marketplace achievements
                unlockAchievement('marketplace_shopper');
            }
        }
        
        function equipAbility(abilityId) {
            const ability = marketplaceItems.abilities.find(a => a.id === abilityId);
            if (ability && ability.owned) {
                // Toggle ability (can equip multiple abilities)
                if (ability.equipped) {
                    ability.equipped = false;
                    game.marketplace.currentAbilities = game.marketplace.currentAbilities.filter(id => id !== abilityId);
                } else {
                    ability.equipped = true;
                    game.marketplace.currentAbilities.push(abilityId);
                }
                
                updateMarketplace();
                saveMarketplaceData();
            }
        }
        
        function saveMarketplaceData() {
            localStorage.setItem('otterBrosMarketplace', JSON.stringify({
                coins: game.marketplace.coins,
                ownedHats: game.marketplace.ownedHats,
                ownedSkins: game.marketplace.ownedSkins,
                ownedAbilities: game.marketplace.ownedAbilities,
                currentHat: game.marketplace.currentHat,
                currentSkin: game.marketplace.currentSkin,
                currentAbilities: game.marketplace.currentAbilities
            }));
        }
        
        function loadMarketplaceData() {
            console.log('🛒 Starting fresh marketplace - no saved data loaded');
            
            // Reset marketplace to fresh state
            game.marketplace.coins = 0;
            game.marketplace.ownedHats = [];
            game.marketplace.ownedSkins = [];
            game.marketplace.ownedAbilities = [];
            game.marketplace.currentHat = null;
            game.marketplace.currentSkin = null;
            game.marketplace.currentAbilities = [];
            
            // Reset all marketplace items but keep defaults
                marketplaceItems.hats.forEach(hat => {
                if (hat.id === 'none') {
                    hat.owned = true;
                    hat.equipped = true;
                } else {
                    hat.owned = false;
                    hat.equipped = false;
                }
                });
                
                marketplaceItems.skins.forEach(skin => {
                if (skin.id === 'default') {
                    skin.owned = true;
                    skin.equipped = true;
                } else {
                    skin.owned = false;
                    skin.equipped = false;
                }
                });
                
                marketplaceItems.abilities.forEach(ability => {
                ability.owned = false;
                ability.equipped = false;
                });
            
            console.log('🆕 Fresh marketplace initialized');
        }
        
        function toggleProfile() {
            console.log('👤 Profile button clicked!');
            const panel = document.getElementById('profilePanel');
            const isVisible = panel.style.display === 'block';
            
            if (!isVisible) {
                updateProfileDisplay();
                updateProfile();
            }
            
            panel.style.display = isVisible ? 'none' : 'block';
        }
        
        function updateProfile() {
            console.log('👤 Updating profile...');
            
            // Update profile display (handles header updates)
            updateProfileDisplay();
            
            // Update main stats
            document.getElementById('profileTotalScore').textContent = game.sessionStats.totalScore || 0;
            document.getElementById('profileLevelsCompleted').textContent = game.sessionStats.levelsCompleted || 0;
            document.getElementById('profileTotalCoins').textContent = game.sessionStats.totalCoins || 0;
            document.getElementById('profileEnemiesDefeated').textContent = game.sessionStats.crabsDefeated || 0;
            document.getElementById('profileBossesDefeated').textContent = game.sessionStats.bossesDefeated || 0;
            
            // Update detailed stats
            document.getElementById('profileGamesPlayed').textContent = game.profile.gamesPlayed || 0;
            document.getElementById('profilePlayTime').textContent = formatPlayTime(game.profile.playTime || 0);
            document.getElementById('profileBestScore').textContent = game.profile.bestScore || 0;
            document.getElementById('profileCurrentLevel').textContent = game.level || 1;
            document.getElementById('profileTreasuresFound').textContent = game.sessionStats.treasuresFound || 0;
            document.getElementById('profileKeysCollected').textContent = game.sessionStats.keysCollected || 0;
            document.getElementById('profileHealthPickups').textContent = game.sessionStats.healthPickups || 0;
            document.getElementById('profileMushroomsEaten').textContent = game.sessionStats.mushroomsEaten || 0;
            document.getElementById('profileLaserLevel').textContent = player.laserChargingLevel || 1;
            document.getElementById('profileMaxCharge').textContent = player.maxChargeLevel || 5;
            
            // Update enemy defeat breakdown
            document.getElementById('profileCrabsDefeated').textContent = game.sessionStats.crabsDefeated || 0;
            document.getElementById('profileEaglesDefeated').textContent = game.sessionStats.eaglesDefeated || 0;
            document.getElementById('profileGatorsDefeated').textContent = game.sessionStats.gatorsDefeated || 0;
            document.getElementById('profileSharksDefeated').textContent = game.sessionStats.sharksDefeated || 0;
            
            // Update recent achievements
            updateRecentAchievements();
            
            // Update customization
            updateProfileCustomization();
            
            // Update achievements list
            updateAchievementsList();
            
            // Update wallet profile if wallet tab is active
            const walletTab = document.getElementById('walletTab');
            if (walletTab && walletTab.style.display !== 'none') {
                updateWalletProfile();
            }
        }
        
        function updateWalletProfile() {
            console.log('🔗 Updating wallet profile...');
            
            if (!otterWallet) {
                console.log('⚠️ No wallet available for profile update');
                return;
            }
            
            console.log('📊 Current wallet state:', {
                isConnected: otterWallet.isConnected,
                account: otterWallet.account,
                userNFTs: otterWallet.userNFTs.length,
                stakedNFTs: otterWallet.stakedNFTs.length
            });
            
            // Update wallet connection status
            const connectedStatus = document.getElementById('walletConnectedStatus');
            const disconnectedStatus = document.getElementById('walletDisconnectedStatus');
            const walletAddressDisplay = document.getElementById('walletAddressDisplay');
            
            if (otterWallet.isConnected) {
                connectedStatus.style.display = 'block';
                disconnectedStatus.style.display = 'none';
                if (otterWallet.account) {
                    walletAddressDisplay.textContent = `${otterWallet.account.slice(0, 6)}...${otterWallet.account.slice(-4)}`;
                }
            } else {
                connectedStatus.style.display = 'none';
                disconnectedStatus.style.display = 'block';
            }
            
            // Update NFT collection stats
            const totalNFTs = otterWallet.userNFTs.length;
            const stakedNFTs = otterWallet.stakedNFTs.length;
            const legendaryNFTs = otterWallet.userNFTs.filter(nft => nft.rarity === 'legendary').length;
            const epicNFTs = otterWallet.userNFTs.filter(nft => nft.rarity === 'epic').length;
            
            document.getElementById('profileTotalNFTs').textContent = totalNFTs;
            document.getElementById('profileStakedNFTs').textContent = stakedNFTs;
            document.getElementById('profileLegendaryNFTs').textContent = legendaryNFTs;
            document.getElementById('profileEpicNFTs').textContent = epicNFTs;
            
            // Update staking rewards
            let totalEarned = otterWallet.fishCoins;
            let avgMultiplier = 1.0;
            let stakingTime = 0;
            
            if (stakedNFTs > 0) {
                const totalMultiplier = otterWallet.stakedNFTs.reduce((sum, nft) => sum + nft.multiplier, 0);
                avgMultiplier = totalMultiplier / stakedNFTs;
                
                // Calculate total staking time
                otterWallet.stakedNFTs.forEach(nft => {
                    const stakingTime = Date.now() - otterWallet.stakingStartTimes[nft.tokenId];
                    totalEarned += Math.floor(stakingTime / (1000 * 60 * 60) * nft.multiplier * 10 / 24);
                });
                
                // Get average staking time
                const stakingTimes = Object.values(otterWallet.stakingStartTimes);
                if (stakingTimes.length > 0) {
                    const avgStakingTime = stakingTimes.reduce((sum, time) => sum + (Date.now() - time), 0) / stakingTimes.length;
                    stakingTime = Math.floor(avgStakingTime / (1000 * 60 * 60));
                }
            }
            
            document.getElementById('profileFishEarned').textContent = Math.floor(totalEarned);
            document.getElementById('profileStakingRate').textContent = `${Math.round(avgMultiplier * 10)}/day`;
            document.getElementById('profileAvgMultiplier').textContent = `${avgMultiplier.toFixed(1)}x`;
            document.getElementById('profileStakingTime').textContent = `${stakingTime}h`;
            
            // Update game multipliers
            const multipliers = otterWallet.getGameMultipliers();
            document.getElementById('profileSpeedMultiplier').textContent = `${multipliers.speed.toFixed(1)}x`;
            document.getElementById('profilePointsMultiplier').textContent = `${multipliers.points.toFixed(1)}x`;
            document.getElementById('profileDamageMultiplier').textContent = `${multipliers.damage.toFixed(1)}x`;
            document.getElementById('profileDefenseMultiplier').textContent = `${multipliers.defense.toFixed(1)}x`;
            document.getElementById('profileLuckMultiplier').textContent = `${multipliers.luck.toFixed(1)}x`;
            
            // Update active traits
            updateActiveTraitsDisplay();
            
            // Update NFT gallery
            updateNFTGallery();
        }
        
        function updateActiveTraitsDisplay() {
            const container = document.getElementById('profileActiveTraits');
            container.innerHTML = '';
            
            if (!otterWallet || !otterWallet.isConnected) {
                const noTraitsDiv = document.createElement('div');
                noTraitsDiv.style.cssText = 'text-align: center; padding: 20px; color: #888; font-style: italic;';
                noTraitsDiv.textContent = 'Connect wallet to see active traits';
                container.appendChild(noTraitsDiv);
                return;
            }
            
            const activeTraits = otterWallet.getActiveTraits();
            
            if (activeTraits.length === 0) {
                const noTraitsDiv = document.createElement('div');
                noTraitsDiv.style.cssText = 'text-align: center; padding: 20px; color: #888; font-style: italic;';
                noTraitsDiv.textContent = 'No active traits found';
                container.appendChild(noTraitsDiv);
                return;
            }
            
            activeTraits.forEach(trait => {
                const traitDiv = document.createElement('div');
                traitDiv.style.cssText = 'background: linear-gradient(135deg, rgba(255,107,53,0.15), rgba(255,107,53,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,107,53,0.3); text-align: center;';
                
                const perk = otterWallet.gamePerks[trait];
                const multiplier = otterWallet.traitMultipliers[trait] || 1.0;
                
                traitDiv.innerHTML = `
                    <div style="font-size: 18px; margin-bottom: 8px;">${getTraitIcon(trait)}</div>
                    <div style="font-size: 14px; font-weight: bold; color: #FF6B35; margin-bottom: 5px;">${trait}</div>
                    <div style="font-size: 12px; color: #00FFFF; margin-bottom: 5px;">${multiplier.toFixed(1)}x Multiplier</div>
                    ${perk ? `<div style="font-size: 11px; color: #FFD700; opacity: 0.8;">${perk.description}</div>` : ''}
                `;
                
                container.appendChild(traitDiv);
            });
        }
        
        function updateNFTGallery() {
            const container = document.getElementById('profileNFTGallery');
            container.innerHTML = '';
            
            if (!otterWallet || !otterWallet.isConnected) {
                const noNFTsDiv = document.createElement('div');
                noNFTsDiv.style.cssText = 'text-align: center; padding: 20px; color: #888; font-style: italic;';
                noNFTsDiv.textContent = 'Connect wallet to see your NFTs';
                container.appendChild(noNFTsDiv);
                return;
            }
            
            if (otterWallet.userNFTs.length === 0) {
                const noNFTsDiv = document.createElement('div');
                noNFTsDiv.style.cssText = 'text-align: center; padding: 20px; color: #888; font-style: italic;';
                noNFTsDiv.textContent = 'No NFTs found in wallet';
                container.appendChild(noNFTsDiv);
                return;
            }
            
            otterWallet.userNFTs.forEach(nft => {
                const nftCard = document.createElement('div');
                nftCard.style.cssText = 'background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,215,0,0.3); text-align: center; position: relative;';
                
                const isStaked = otterWallet.stakedNFTs.some(staked => staked.tokenId === nft.tokenId);
                const rarityColor = getRarityColor(nft.rarity);
                
                nftCard.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 8px;">🦦</div>
                    <div style="font-size: 14px; font-weight: bold; color: #FFD700; margin-bottom: 5px;">${nft.name}</div>
                    <div style="font-size: 12px; color: ${rarityColor}; margin-bottom: 5px; text-transform: capitalize;">${nft.rarity}</div>
                    <div style="font-size: 11px; color: #00FFFF; margin-bottom: 8px;">${nft.multiplier.toFixed(1)}x Multiplier</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 8px;">${nft.traits.join(', ')}</div>
                    ${isStaked ? '<div style="position: absolute; top: 5px; right: 5px; background: #4CAF50; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px;">⭐ Staked</div>' : ''}
                `;
                
                container.appendChild(nftCard);
            });
        }
        
        function getTraitIcon(trait) {
            const icons = {
                'Plumber-v5': '👑',
                'Plumber-v3': '⚡',
                'Plumber-v4': '🏃',
                'Plumber-v2': '🍀',
                'Plumber': '🛠️',
                'Overalls V3': '🏗️',
                'Overalls V2': '🔨',
                'Pirate Hat': '🏴‍☠️',
                'Crown': '👑',
                'Wizard Hat': '🧙‍♂️',
                'Golden Fur': '✨',
                'Laser Eyes': '👁️',
                'Diamond Teeth': '💎',
                'Sunglasses': '😎',
                'Rainbow Fur': '🌈',
                'Baseball Cap': '🧢',
                'Beanie': '🎩'
            };
            return icons[trait] || '🎮';
        }
        
        function getRarityColor(rarity) {
            const colors = {
                'legendary': '#FFD700',
                'epic': '#FF6B35',
                'rare': '#00FFFF',
                'common': '#888'
            };
            return colors[rarity] || '#888';
        }
        
        function connectWalletFromProfile() {
            console.log('🔗 Connecting wallet from profile...');
            if (otterWallet) {
                otterWallet.connect().then(() => {
                    console.log('✅ Wallet connected from profile');
                    updateWalletProfile();
                }).catch(error => {
                    console.error('❌ Failed to connect wallet from profile:', error);
                });
            } else {
                console.error('❌ OtterWallet not initialized');
            }
        }

        function disconnectWalletFromProfile() {
            console.log('🔌 Disconnecting wallet from profile...');
            if (otterWallet) {
                otterWallet.disconnect();
                updateWalletProfile();
                console.log('✅ Wallet disconnected from profile');
            } else {
                console.error('❌ OtterWallet not initialized');
            }
        }

        function refreshMetadata() {
            console.log('🌐 Refreshing metadata...');
            if (otterWallet && otterWallet.isConnected) {
                console.log('👤 Current wallet address:', otterWallet.account);
                console.log('📊 Current NFTs:', otterWallet.userNFTs.length);
                
                // Force reload NFTs with fresh metadata
                otterWallet.loadUserNFTsWithMetadata(otterWallet.userNFTs.length).then(() => {
                    updateWalletProfile();
                    console.log('✅ Metadata refreshed');
                    console.log('📊 Updated NFTs:', otterWallet.userNFTs.length);
                }).catch(error => {
                    console.error('❌ Failed to refresh metadata:', error);
                });
            } else {
                console.log('⚠️ Wallet not connected, cannot refresh metadata');
            }
        }

        function checkNFTs() {
            console.log('🔍 Checking NFTs...');
            if (otterWallet && otterWallet.isConnected) {
                console.log('👤 Current wallet address:', otterWallet.account);
                console.log('📊 Current NFTs:', otterWallet.userNFTs.length);
                
                // Show detailed NFT information
                console.log('🦦 NFT Details:');
                otterWallet.userNFTs.forEach((nft, index) => {
                    console.log(`  ${index + 1}. Token #${nft.tokenId}: ${nft.name}`);
                    console.log(`     Traits: ${nft.traits.join(', ')}`);
                    console.log(`     Rarity: ${nft.rarity}`);
                    console.log(`     Multiplier: ${nft.multiplier}x`);
                });
                
                // Update the profile display
                updateWalletProfile();
                console.log('✅ NFT check completed');
            } else {
                console.log('⚠️ Wallet not connected, cannot check NFTs');
            }
        }

        function scanAllOtterfulOtters() {
            console.log('🔍 Scanning all 2222 Otterful Otters...');
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('⚠️ Wallet not connected');
                return;
            }
            
            // This will trigger a full scan of all 2222 tokens
            otterWallet.loadNFTs().then(() => {
                console.log('✅ Full scan completed');
                console.log(`📊 Found ${otterWallet.userNFTs.length} NFTs`);
                updateWalletProfile();
            }).catch(error => {
                console.error('❌ Full scan failed:', error);
            });
        }
        
        function refreshWalletData() {
            console.log('🔄 Refreshing wallet data...');
            console.log('🔍 otterWallet exists:', !!otterWallet);
            console.log('🔍 otterWallet.isConnected:', otterWallet?.isConnected);
            
            if (otterWallet && otterWallet.isConnected) {
                console.log('👤 Current wallet address:', otterWallet.account);
                console.log('🔗 Current network:', window.ethereum.chainId);
                
                otterWallet.loadNFTs().then(() => {
                    updateWalletProfile();
                    console.log('✅ Wallet data refreshed');
                    console.log('📊 Total NFTs loaded:', otterWallet.userNFTs.length);
                }).catch(error => {
                    console.error('❌ Failed to refresh wallet data:', error);
                });
            } else {
                console.log('⚠️ Wallet not connected, cannot refresh');
                if (!otterWallet) {
                    console.error('❌ OtterWallet not initialized');
                } else if (!otterWallet.isConnected) {
                    console.log('💡 Try connecting your wallet first');
                }
            }
        }
        
        function testContractConnection() {
            console.log('🧪 Testing contract connection...');
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('⚠️ Wallet not connected');
                return;
            }
            
            console.log('🔗 Testing basic wallet connection...');
            console.log('👤 Account:', otterWallet.account);
            console.log('🔗 Provider:', otterWallet.provider);
            console.log('📋 Contract:', otterWallet.contractAddress);
            
            // Test network first
            window.ethereum.request({method: 'eth_chainId'}).then(chainId => {
                console.log('🌐 Current chain ID:', chainId);
                console.log('🎯 Expected chain ID:', otterWallet.apeChainId);
                console.log('✅ Network match:', chainId === otterWallet.apeChainId);
                
                // Test basic contract calls
                return otterWallet.getTokenBalance();
            }).then(balance => {
                console.log('✅ Balance test passed:', balance);
                
                if (balance > 0) {
                    console.log('🎉 You have NFTs! Loading them...');
                    return otterWallet.loadUserNFTsWithMetadata(balance);
                } else {
                    console.log('⚠️ No NFTs found in wallet');
                    return Promise.resolve();
                }
            }).then(() => {
                console.log('✅ NFT loading test completed');
                console.log('📊 User NFTs:', otterWallet.userNFTs);
            }).catch(error => {
                console.error('❌ Contract test failed:', error);
                console.log('🔍 Error details:', error.message);
                console.log('🔍 Error code:', error.code);
            });
        }

        function testMetadataFetching() {
            console.log('🌐 Testing metadata fetching...');
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('⚠️ Wallet not connected');
                return;
            }
            
            // Test metadata fetching for a specific token
            const testTokenId = 1; // Test with token ID 1
            console.log(`🧪 Testing metadata for token #${testTokenId}...`);
            
            otterWallet.getTokenMetadata(testTokenId).then(metadata => {
                console.log('✅ Metadata test result:', metadata);
                if (metadata && metadata.attributes) {
                    console.log('🎨 Attributes found:', metadata.attributes.length);
                    metadata.attributes.forEach(attr => {
                        console.log(`  - ${attr.trait_type}: ${attr.value}`);
                    });
                } else {
                    console.log('⚠️ No attributes found in metadata');
                }
            }).catch(error => {
                console.error('❌ Metadata test failed:', error);
            });
        }
        
        function updateRecentAchievements() {
            const container = document.getElementById('profileRecentAchievements');
            container.innerHTML = '';
            
            game.profile.recentAchievements.slice(-3).forEach(achievement => {
                const div = document.createElement('div');
                div.style.cssText = 'margin-bottom: 8px; padding: 8px; background: rgba(255,215,0,0.1); border-radius: 8px; border-left: 3px solid #FFD700;';
                div.textContent = achievement;
                container.appendChild(div);
            });
        }
        
        function updateProfileCustomization() {
            // Update currently equipped items
            updateCurrentlyEquipped();
            
            // Update inventory
            updateInventoryDisplay();
            
            // Update quick equip dropdowns
            updateQuickEquipDropdowns();
        }
        
        function updateCurrentlyEquipped() {
            // Update current skin
            const currentSkin = marketplaceItems.skins.find(skin => skin.id === game.marketplace.currentSkin);
            if (currentSkin) {
                document.getElementById('profileSkinName').textContent = currentSkin.name;
                document.getElementById('profileSkinDescription').textContent = currentSkin.description;
                // Update skin image based on current skin
                const skinImage = document.getElementById('profileSkinImage');
                if (currentSkin.id === 'default') {
                    skinImage.src = 'public/oggg.png';
                } else {
                    skinImage.src = currentSkin.image || 'public/oggg.png';
                }
            }
            
            // Update current hat
            const currentHat = marketplaceItems.hats.find(hat => hat.id === game.marketplace.currentHat);
            if (currentHat) {
                document.getElementById('profileHatName').textContent = currentHat.name;
                document.getElementById('profileHatDescription').textContent = currentHat.description;
                // Update hat image
                const hatImage = document.getElementById('profileHatImage');
                if (currentHat.id === 'none') {
                    hatImage.innerHTML = '';
                    hatImage.style.background = 'rgba(0,0,0,0.1)';
                    hatImage.style.backgroundImage = 'url(public/owl.png)';
                    hatImage.style.backgroundSize = 'contain';
                    hatImage.style.backgroundPosition = 'center';
                    hatImage.style.backgroundRepeat = 'no-repeat';
                } else {
                    hatImage.innerHTML = '';
                    hatImage.style.background = 'rgba(0,0,0,0.1)';
                    hatImage.style.backgroundImage = `url(${currentHat.image})`;
                    hatImage.style.backgroundSize = 'contain';
                    hatImage.style.backgroundPosition = 'center';
                    hatImage.style.backgroundRepeat = 'no-repeat';
                }
            }
            
            // Update current abilities
            const abilitiesContainer = document.getElementById('profileCurrentAbilities');
            if (abilitiesContainer) {
                abilitiesContainer.innerHTML = '';
                
                if (game.marketplace.currentAbilities.length === 0) {
                    abilitiesContainer.innerHTML = '<div style="text-align: center; color: #888; font-style: italic; padding: 20px;">No abilities equipped</div>';
                } else {
                    game.marketplace.currentAbilities.forEach(abilityId => {
                        const ability = marketplaceItems.abilities.find(a => a.id === abilityId);
                        if (ability) {
                            const abilityDiv = document.createElement('div');
                            abilityDiv.style.cssText = `
                                background: rgba(76,175,80,0.2);
                                border: 2px solid #4CAF50;
                                border-radius: 15px;
                                padding: 15px;
                                text-align: center;
                                margin-bottom: 10px;
                            `;
                            
                            let abilityLevel = '';
                            if (abilityId === 'armor' && player.hasArmorBoost) {
                                abilityLevel = `Level ${player.armorLevel} (+${player.armorLevel * 25}% armor)`;
                            } else if (abilityId === 'laser' && player.hasLaser) {
                                abilityLevel = `Level ${player.laserChargingLevel}`;
                            }
                            
                            abilityDiv.innerHTML = `
                                <img src="${ability.image}" alt="${ability.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; margin-bottom: 8px; background: rgba(0,0,0,0.1);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div style="display: none; font-size: 24px; margin: 8px 0;">⚡</div>
                                <div style="font-size: 12px; font-weight: bold; color: #4CAF50; margin-bottom: 3px;">${ability.name}</div>
                                <div style="font-size: 10px; color: #00FFFF; margin-bottom: 6px;">${ability.description}</div>
                                ${abilityLevel ? `<div style="font-size: 9px; color: #FFD700; margin-bottom: 6px;">${abilityLevel}</div>` : ''}
                                <div style="font-size: 9px; color: #4CAF50; font-weight: bold;">✓ EQUIPPED</div>
                            `;
                            
                            abilitiesContainer.appendChild(abilityDiv);
                        }
                    });
                }
            }
        }
        
        function updateInventoryDisplay() {
            // Update skins inventory
            const skinsContainer = document.getElementById('profileSkinsInventory');
            skinsContainer.innerHTML = '';
            
            marketplaceItems.skins.forEach(skin => {
                const skinDiv = document.createElement('div');
                
                if (skin.owned) {
                    // Owned skin styling
                    skinDiv.style.cssText = `
                        background: ${skin.equipped ? 'rgba(76,175,80,0.2)' : 'rgba(100,100,100,0.1)'};
                        border: 2px solid ${skin.equipped ? '#4CAF50' : '#666666'};
                        border-radius: 15px;
                        padding: 15px;
                        text-align: center;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    `;
                    
                    skinDiv.onclick = () => quickEquipSkin(skin.id);
                    
                    skinDiv.innerHTML = `
                        <img src="${skin.image}" alt="${skin.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; margin-bottom: 8px; background: rgba(0,0,0,0.1);">
                        <div style="font-size: 12px; font-weight: bold; color: ${skin.equipped ? '#4CAF50' : '#FFFFFF'}; margin-bottom: 3px;">${skin.name}</div>
                        <div style="font-size: 10px; color: #00FFFF; margin-bottom: 6px;">${skin.description}</div>
                        ${skin.equipped ? '<div style="font-size: 9px; color: #4CAF50; font-weight: bold;">✓ EQUIPPED</div>' : '<div style="font-size: 9px; color: #FFD700;">Click to equip</div>'}
                    `;
                } else {
                    // Locked skin styling
                    skinDiv.style.cssText = `
                        background: rgba(0,0,0,0.3);
                        border: 2px solid #666666;
                        border-radius: 15px;
                        padding: 15px;
                        text-align: center;
                        transition: all 0.3s ease;
                        position: relative;
                        opacity: 0.6;
                    `;
                    
                    // Add dark overlay for locked skins
                    const darkOverlay = document.createElement('div');
                    darkOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.5);
                        border-radius: 13px;
                        pointer-events: none;
                        z-index: 1;
                    `;
                    skinDiv.appendChild(darkOverlay);
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.style.cssText = `
                        position: relative;
                        z-index: 2;
                    `;
                    
                    let unlockText = '';
                    if (skin.unlockType === 'achievement') {
                        unlockText = '🔒 ACHIEVEMENT';
                    } else if (skin.unlockType === 'purchase') {
                        unlockText = `${skin.price} 🪙`;
                    }
                    
                    contentDiv.innerHTML = `
                        <img src="${skin.image}" alt="${skin.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; margin-bottom: 8px; background: rgba(0,0,0,0.1); filter: brightness(0.4) grayscale(0.3);">
                        <div style="font-size: 12px; font-weight: bold; color: #666666; margin-bottom: 3px;">${skin.name}</div>
                        <div style="font-size: 10px; color: #888888; margin-bottom: 6px;">${skin.description}</div>
                        <div style="font-size: 9px; color: #FFD700; margin-bottom: 8px;">${unlockText}</div>
                        <div style="font-size: 9px; color: #FF4444; font-weight: bold;">🔒 LOCKED</div>
                        ${skin.unlockType === 'purchase' ? 
                            `<button onclick="event.stopPropagation(); openMarketplaceForSkin('${skin.id}')" style="background: #666666; color: white; border: none; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 9px; min-width: 50px; margin-top: 8px;">
                                BUY
                            </button>` : 
                            `<div style="font-size: 9px; color: #888888; margin-top: 8px;">Complete achievement to unlock</div>`
                        }
                    `;
                    
                    skinDiv.appendChild(contentDiv);
                }
                
                skinsContainer.appendChild(skinDiv);
            });
            
            // Update hats inventory
            const hatsContainer = document.getElementById('profileHatsInventory');
            hatsContainer.innerHTML = '';
            
            marketplaceItems.hats.forEach(hat => {
                if (hat.owned) {
                    const hatDiv = document.createElement('div');
                    hatDiv.style.cssText = `
                        background: ${hat.equipped ? 'rgba(76,175,80,0.2)' : 'rgba(100,100,100,0.1)'};
                        border: 2px solid ${hat.equipped ? '#4CAF50' : '#666666'};
                        border-radius: 15px;
                        padding: 15px;
                        text-align: center;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    `;
                    
                    hatDiv.onclick = () => quickEquipHat(hat.id);
                    
                    const hatImage = hat.id === 'none' ? `<img src="public/owl.png" alt="${hat.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; background: rgba(0,0,0,0.1);">` : `<img src="${hat.image}" alt="${hat.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; background: rgba(0,0,0,0.1);">`;
                    
                    hatDiv.innerHTML = `
                        <div style="width: 32px; height: 32px; margin: 0 auto 8px; display: flex; align-items: center; justify-content: center;">${hatImage}</div>
                        <div style="font-size: 12px; font-weight: bold; color: ${hat.equipped ? '#4CAF50' : '#FFFFFF'}; margin-bottom: 3px;">${hat.name}</div>
                        <div style="font-size: 10px; color: #00FFFF; margin-bottom: 6px;">${hat.description}</div>
                        ${hat.equipped ? '<div style="font-size: 9px; color: #4CAF50; font-weight: bold;">✓ EQUIPPED</div>' : '<div style="font-size: 9px; color: #FFD700;">Click to equip</div>'}
                    `;
                    
                    hatsContainer.appendChild(hatDiv);
                }
            });
            
            // Update abilities inventory
            const abilitiesContainer = document.getElementById('profileAbilitiesInventory');
            if (abilitiesContainer) {
                abilitiesContainer.innerHTML = '';
                
                marketplaceItems.abilities.forEach(ability => {
                    const abilityDiv = document.createElement('div');
                    
                    if (ability.owned) {
                        // Owned ability styling
                        abilityDiv.style.cssText = `
                            background: ${ability.equipped ? 'rgba(76,175,80,0.2)' : 'rgba(100,100,100,0.1)'};
                            border: 2px solid ${ability.equipped ? '#4CAF50' : '#FF6B35'};
                            border-radius: 15px;
                            padding: 15px;
                            text-align: center;
                            transition: all 0.3s ease;
                        `;
                        
                        // Get current ability status
                        let abilityStatus = '';
                        let abilityLevel = '';
                        
                        if (ability.id === 'armor' && player.hasArmorBoost) {
                            abilityLevel = `Level ${player.armorLevel} (+${player.armorLevel * 25}% armor)`;
                        } else if (ability.id === 'laser' && player.hasLaser) {
                            abilityLevel = `Level ${player.laserChargingLevel}`;
                        }
                        
                        if (ability.equipped) {
                            abilityStatus = `<div style="font-size: 9px; color: #4CAF50; font-weight: bold; margin-bottom: 8px;">✓ EQUIPPED</div>`;
                        } else {
                            abilityStatus = `<div style="font-size: 9px; color: #FFD700; margin-bottom: 8px;">Click to equip</div>`;
                        }
                        
                        abilityDiv.innerHTML = `
                            <img src="${ability.image}" alt="${ability.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; margin-bottom: 8px; background: rgba(0,0,0,0.1);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display: none; font-size: 24px; margin: 8px 0;">⚡</div>
                            <div style="font-size: 12px; font-weight: bold; color: ${ability.equipped ? '#4CAF50' : '#FFFFFF'}; margin-bottom: 3px;">${ability.name}</div>
                            <div style="font-size: 10px; color: #00FFFF; margin-bottom: 6px;">${ability.description}</div>
                            ${abilityLevel ? `<div style="font-size: 9px; color: #FFD700; margin-bottom: 6px;">${abilityLevel}</div>` : ''}
                            ${abilityStatus}
                            <div style="display: flex; gap: 8px; justify-content: center;">
                                <button onclick="event.stopPropagation(); quickEquipAbility('${ability.id}')" style="background: ${ability.equipped ? '#4CAF50' : '#FF6B35'}; color: white; border: none; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 9px; min-width: 50px;">
                                    ${ability.equipped ? 'EQUIPPED' : 'EQUIP'}
                                </button>
                                <button onclick="event.stopPropagation(); toggleAbility('${ability.id}')" style="background: ${ability.equipped ? '#FF4444' : '#666666'}; color: white; border: none; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 9px; min-width: 50px;">
                                    ${ability.equipped ? 'DISABLE' : 'ENABLE'}
                                </button>
                            </div>
                        `;
                    } else {
                        // Locked ability styling
                        abilityDiv.style.cssText = `
                            background: rgba(0,0,0,0.3);
                            border: 2px solid #666666;
                            border-radius: 15px;
                            padding: 15px;
                            text-align: center;
                            transition: all 0.3s ease;
                            position: relative;
                            opacity: 0.6;
                        `;
                        
                        // Add dark overlay for locked abilities
                        const darkOverlay = document.createElement('div');
                        darkOverlay.style.cssText = `
                            position: absolute;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(0,0,0,0.5);
                            border-radius: 13px;
                            pointer-events: none;
                            z-index: 1;
                        `;
                        abilityDiv.appendChild(darkOverlay);
                        
                        const contentDiv = document.createElement('div');
                        contentDiv.style.cssText = `
                            position: relative;
                            z-index: 2;
                        `;
                        
                        contentDiv.innerHTML = `
                            <img src="${ability.image}" alt="${ability.name}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: contain; margin-bottom: 8px; background: rgba(0,0,0,0.1); filter: brightness(0.4) grayscale(0.3);" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div style="display: none; font-size: 24px; margin: 8px 0; filter: brightness(0.4);">⚡</div>
                            <div style="font-size: 12px; font-weight: bold; color: #666666; margin-bottom: 3px;">${ability.name}</div>
                            <div style="font-size: 10px; color: #888888; margin-bottom: 6px;">${ability.description}</div>
                            <div style="font-size: 9px; color: #FFD700; margin-bottom: 8px;">${ability.price} 🪙</div>
                            <div style="font-size: 9px; color: #FF4444; font-weight: bold;">🔒 LOCKED</div>
                            <button onclick="event.stopPropagation(); openMarketplaceForAbility('${ability.id}')" style="background: #666666; color: white; border: none; padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 9px; min-width: 50px; margin-top: 8px;">
                                BUY
                            </button>
                        `;
                        
                        abilityDiv.appendChild(contentDiv);
                    }
                    
                    abilitiesContainer.appendChild(abilityDiv);
                });
            }
        }
        
        function updateQuickEquipDropdowns() {
            // Update skin dropdown
            const skinSelect = document.getElementById('quickEquipSkin');
            skinSelect.innerHTML = '<option value="">Select a skin...</option>';
            
            marketplaceItems.skins.forEach(skin => {
                if (skin.owned) {
                    const option = document.createElement('option');
                    option.value = skin.id;
                    option.textContent = skin.name;
                    if (skin.equipped) {
                        option.textContent += ' (Equipped)';
                    }
                    skinSelect.appendChild(option);
                }
            });
            
            // Update hat dropdown
            const hatSelect = document.getElementById('quickEquipHat');
            hatSelect.innerHTML = '<option value="">Select a hat...</option>';
            
            marketplaceItems.hats.forEach(hat => {
                if (hat.owned) {
                    const option = document.createElement('option');
                    option.value = hat.id;
                    option.textContent = hat.name;
                    if (hat.equipped) {
                        option.textContent += ' (Equipped)';
                    }
                    hatSelect.appendChild(option);
                }
            });
        }
        
        function quickEquipSkin(skinId) {
            if (!skinId) return;
            
            const skin = marketplaceItems.skins.find(s => s.id === skinId);
            if (skin && skin.owned) {
                // Unequip current skin
                marketplaceItems.skins.forEach(s => s.equipped = false);
                
                // Equip new skin
                skin.equipped = true;
                game.marketplace.currentSkin = skinId;
                
                // Save and update
                saveMarketplaceData();
                updateProfileCustomization();
                updateMarketplace();
                
                console.log(`🦦 Equipped skin: ${skin.name}`);
            }
        }
        
        function quickEquipHat(hatId) {
            if (!hatId) return;
            
            const hat = marketplaceItems.hats.find(h => h.id === hatId);
            if (hat && hat.owned) {
                // Unequip current hat
                marketplaceItems.hats.forEach(h => h.equipped = false);
                
                // Equip new hat
                hat.equipped = true;
                game.marketplace.currentHat = hatId;
                
                // Save and update
                saveMarketplaceData();
                updateProfileCustomization();
                updateMarketplace();
                
                console.log(`🦉 Equipped hat: ${hat.name}`);
            }
        }
        
        function quickEquipAbility(abilityId) {
            if (!abilityId) return;
            
            const ability = marketplaceItems.abilities.find(a => a.id === abilityId);
            if (ability && ability.owned) {
                // Toggle ability (can equip multiple abilities)
                if (ability.equipped) {
                    ability.equipped = false;
                    game.marketplace.currentAbilities = game.marketplace.currentAbilities.filter(id => id !== abilityId);
                } else {
                    ability.equipped = true;
                    game.marketplace.currentAbilities.push(abilityId);
                }
                
                // Save and update
                saveMarketplaceData();
                updateProfileCustomization();
                updateMarketplace();
                
                console.log(`⚡ ${ability.equipped ? 'Equipped' : 'Unequipped'} ability: ${ability.name}`);
            }
        }
        
        function toggleAbility(abilityId) {
            if (!abilityId) return;
            
            const ability = marketplaceItems.abilities.find(a => a.id === abilityId);
            if (!ability || !ability.owned) return;
            
            if (ability.equipped) {
                // Disable the ability
                ability.equipped = false;
                game.marketplace.currentAbilities = game.marketplace.currentAbilities.filter(id => id !== abilityId);
                
                // Reset player ability status
                if (abilityId === 'jetpack') {
                    player.hasJetpack = false;
                } else if (abilityId === 'laser') {
                    player.hasLaser = false;
                } else if (abilityId === 'fireball') {
                    player.hasFireball = false;
                } else if (abilityId === 'armor') {
                    player.hasArmorBoost = false;
                    player.armorLevel = 0;
                }
                
                console.log(`⚡ Disabled ability: ${ability.name}`);
            } else {
                // Enable the ability
                ability.equipped = true;
                if (!game.marketplace.currentAbilities.includes(abilityId)) {
                    game.marketplace.currentAbilities.push(abilityId);
                }
                
                // Set player ability status
                if (abilityId === 'jetpack') {
                    player.hasJetpack = true;
                } else if (abilityId === 'laser') {
                    player.hasLaser = true;
                } else if (abilityId === 'fireball') {
                    player.hasFireball = true;
                } else if (abilityId === 'armor') {
                    player.hasArmorBoost = true;
                    player.armorLevel = 1; // Start at level 1
                }
                
                console.log(`⚡ Enabled ability: ${ability.name}`);
            }
            
            // Save marketplace data
            saveMarketplaceData();
            
            // Update display
            updateProfileCustomization();
            updateMarketplace();
        }
        
        function openMarketplaceForAbility(abilityId) {
            // Close profile panel
            document.getElementById('profilePanel').style.display = 'none';
            
            // Open marketplace panel
            document.getElementById('marketplacePanel').style.display = 'block';
            
            // Switch to abilities tab
            switchMarketplaceTab('abilities');
            
            console.log(`🛒 Opening marketplace for ability: ${abilityId}`);
        }
        
        function openMarketplaceForSkin(skinId) {
            // Close profile panel
            document.getElementById('profilePanel').style.display = 'none';
            
            // Open marketplace panel
            document.getElementById('marketplacePanel').style.display = 'block';
            
            // Switch to skins tab
            switchMarketplaceTab('skins');
            
            console.log(`🛒 Opening marketplace for skin: ${skinId}`);
        }
        
        function updateAchievementsList() {
            const container = document.getElementById('profileAchievementsList');
            container.innerHTML = '';
            
            achievements.forEach(achievement => {
                const div = document.createElement('div');
                const isUnlocked = achievement.unlocked;
                const xpReward = achievement.xpReward || 0;
                
                div.style.cssText = `
                    background: ${isUnlocked ? 'linear-gradient(135deg, rgba(76,175,80,0.15), rgba(76,175,80,0.05))' : 'linear-gradient(135deg, rgba(100,100,100,0.15), rgba(100,100,100,0.05))'};
                    border: 2px solid ${isUnlocked ? '#4CAF50' : '#666666'};
                    border-radius: 15px;
                    padding: 20px;
                    text-align: center;
                    opacity: ${isUnlocked ? '1' : '0.7'};
                    transition: transform 0.2s, box-shadow 0.2s;
                    cursor: pointer;
                    position: relative;
                    overflow: hidden;
                `;
                
                // Add hover effects
                div.onmouseover = function() {
                    this.style.transform = 'scale(1.05)';
                    this.style.boxShadow = `0 8px 25px ${isUnlocked ? 'rgba(76,175,80,0.3)' : 'rgba(100,100,100,0.3)'}`;
                };
                div.onmouseout = function() {
                    this.style.transform = 'scale(1)';
                    this.style.boxShadow = 'none';
                };
                
                div.innerHTML = `
                    <div style="font-size: 36px; margin-bottom: 12px; filter: ${isUnlocked ? 'drop-shadow(0 0 8px rgba(76,175,80,0.5))' : 'grayscale(100%)'};">
                        ${achievement.icon}
                    </div>
                    <div style="font-size: 16px; font-weight: bold; color: ${isUnlocked ? '#4CAF50' : '#999999'}; margin-bottom: 8px; text-shadow: ${isUnlocked ? '0 0 8px rgba(76,175,80,0.5)' : 'none'};">
                        ${achievement.name}
                    </div>
                    <div style="font-size: 12px; color: #00FFFF; margin-bottom: 10px; line-height: 1.4;">
                        ${achievement.description}
                    </div>
                    ${isUnlocked ? 
                        `<div style="font-size: 11px; color: #4CAF50; margin-top: 8px; font-weight: bold; text-shadow: 0 0 5px rgba(76,175,80,0.5);">
                            ✓ UNLOCKED • +${xpReward} XP
                        </div>` : 
                        `<div style="font-size: 11px; color: #666; margin-top: 8px; font-style: italic;">
                            🔒 LOCKED • +${xpReward} XP
                        </div>`
                    }
                    ${achievement.hidden ? '<div style="position: absolute; top: 10px; right: 10px; font-size: 12px; color: #FFD700;">🔍</div>' : ''}
                `;
                
                container.appendChild(div);
            });
        }
        
        function switchProfileTab(tab) {
            const statsTab = document.getElementById('statsTab');
            const achievementsTab = document.getElementById('achievementsTab');
            const customizationTab = document.getElementById('customizationTab');
            const walletTab = document.getElementById('walletTab');
            const statsBtn = document.getElementById('statsTabBtn');
            const achievementsBtn = document.getElementById('achievementsTabBtn');
            const customizationBtn = document.getElementById('customizationTabBtn');
            const walletBtn = document.getElementById('walletTabBtn');
            
            // Hide all tabs
            statsTab.style.display = 'none';
            achievementsTab.style.display = 'none';
            customizationTab.style.display = 'none';
            walletTab.style.display = 'none';
            
            // Remove active class from all buttons
            statsBtn.classList.remove('active');
            achievementsBtn.classList.remove('active');
            customizationBtn.classList.remove('active');
            walletBtn.classList.remove('active');
            
            // Show selected tab and activate button
            if (tab === 'stats') {
                statsTab.style.display = 'block';
                statsBtn.classList.add('active');
            } else if (tab === 'achievements') {
                achievementsTab.style.display = 'block';
                achievementsBtn.classList.add('active');
            } else if (tab === 'customization') {
                customizationTab.style.display = 'block';
                customizationBtn.classList.add('active');
            } else if (tab === 'wallet') {
                walletTab.style.display = 'block';
                walletBtn.classList.add('active');
                updateWalletProfile(); // Update wallet data when tab is opened
            }
        }
        
        function unlockAchievement(achievementId) {
            const achievement = achievements.find(a => a.id === achievementId);
            if (achievement && !achievement.unlocked) {
                achievement.unlocked = true;
                
                // Initialize arrays if they don't exist
                if (!game.profile.achievements) {
                    game.profile.achievements = [];
                }
                if (!game.profile.recentAchievements) {
                    game.profile.recentAchievements = [];
                }
                
                game.profile.achievements.push(achievementId);
                game.profile.recentAchievements.push(`🏆 ${achievement.name} - ${achievement.description}`);
                
                // Keep only last 10 recent achievements
                if (game.profile.recentAchievements.length > 10) {
                    game.profile.recentAchievements = game.profile.recentAchievements.slice(-10);
                }
                
                // Award XP for achievement completion
                if (achievement.xpReward) {
                    addXP(achievement.xpReward);
                    showXPRewardNotification(achievement.xpReward, achievement.name);
                }
                
                console.log(`🏆 Achievement unlocked: ${achievement.name} (+${achievement.xpReward || 0} XP)`);
                saveProfileData();
                
                // Check for skin unlocks based on this achievement
                checkSkinUnlocks(achievementId);
            }
        }
        
        function showXPRewardNotification(xpAmount, achievementName) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute;
                top: 80px;
                left: 20px;
                background: linear-gradient(135deg, #00FFFF, #0080FF);
                color: white;
                padding: 8px 15px;
                border-radius: 8px;
                font-size: 12px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 4px 15px rgba(0,255,255,0.4);
                animation: achievementSlideIn 0.5s ease-out;
                max-width: 200px;
                font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 14px; margin-bottom: 2px;">⭐ ${achievementName}</div>
                <div style="font-size: 10px; opacity: 0.9;">+${xpAmount} XP</div>
            `;
            
            // Position relative to the score/coins area
            const scoreElement = document.getElementById('score');
            if (scoreElement && scoreElement.parentElement) {
                scoreElement.parentElement.style.position = 'relative';
                scoreElement.parentElement.appendChild(notification);
            } else {
            document.body.appendChild(notification);
            }
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'achievementSlideOut 0.5s ease-in';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                    }, 500);
                }
            }, 2500);
        }
        
        function checkSkinUnlocks(achievementId) {
            marketplaceItems.skins.forEach(skin => {
                if (skin.unlockType === 'achievement' && skin.achievementId === achievementId && !skin.owned) {
                    skin.owned = true;
                    game.marketplace.ownedSkins.push(skin.id);
                    saveMarketplaceData();
                    
                    // Show skin unlock notification
                    showSkinUnlockNotification(skin);
                    
                    console.log(`🎨 Skin unlocked: ${skin.name} via achievement ${achievementId}`);
                }
            });
        }
        
        function showSkinUnlockNotification(skin) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FF6B35, #FFD700);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 8px 25px rgba(255,107,53,0.4);
                animation: levelUpPulse 3s ease-in-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">🎨</div>
                <div>SKIN UNLOCKED!</div>
                <div style="font-size: 16px; margin-top: 5px;">${skin.name}</div>
                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">${skin.description}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        function checkAllAchievements() {
            // Basic achievements
            if (!achievements.find(a => a.id === 'first_game').unlocked) {
                unlockAchievement('first_game');
            }
            
            // Coin achievements
            const totalCoins = game.sessionStats.totalCoins;
            if (totalCoins >= 1 && !achievements.find(a => a.id === 'first_coin').unlocked) {
                unlockAchievement('first_coin');
            }
            if (totalCoins >= 10 && !achievements.find(a => a.id === 'ten_coins').unlocked) {
                unlockAchievement('ten_coins');
            }
            if (totalCoins >= 50 && !achievements.find(a => a.id === 'fifty_coins').unlocked) {
                unlockAchievement('fifty_coins');
            }
            if (totalCoins >= 100 && !achievements.find(a => a.id === 'hundred_coins').unlocked) {
                unlockAchievement('hundred_coins');
            }
            if (totalCoins >= 200 && !achievements.find(a => a.id === 'two_hundred_coins').unlocked) {
                unlockAchievement('two_hundred_coins');
            }
            
            // Level achievements
            const levelsCompleted = game.sessionStats.levelsCompleted;
            if (levelsCompleted >= 1 && !achievements.find(a => a.id === 'first_level').unlocked) {
                unlockAchievement('first_level');
            }
            if (levelsCompleted >= 5 && !achievements.find(a => a.id === 'five_levels').unlocked) {
                unlockAchievement('five_levels');
            }
            if (levelsCompleted >= 10 && !achievements.find(a => a.id === 'ten_levels').unlocked) {
                unlockAchievement('ten_levels');
            }
            if (levelsCompleted >= 20 && !achievements.find(a => a.id === 'twenty_levels').unlocked) {
                unlockAchievement('twenty_levels');
            }
            if (levelsCompleted >= 50 && !achievements.find(a => a.id === 'fifty_levels').unlocked) {
                unlockAchievement('fifty_levels');
            }
            if (levelsCompleted >= 100 && !achievements.find(a => a.id === 'hundred_levels').unlocked) {
                unlockAchievement('hundred_levels');
            }
            
            // Score achievements
            const currentScore = game.score;
            if (currentScore >= 100 && !achievements.find(a => a.id === 'hundred_score').unlocked) {
                unlockAchievement('hundred_score');
            }
            if (currentScore >= 1000 && !achievements.find(a => a.id === 'thousand_score').unlocked) {
                unlockAchievement('thousand_score');
            }
            if (currentScore >= 10000 && !achievements.find(a => a.id === 'ten_thousand_score').unlocked) {
                unlockAchievement('ten_thousand_score');
            }
            if (currentScore >= 100000 && !achievements.find(a => a.id === 'hundred_thousand_score').unlocked) {
                unlockAchievement('hundred_thousand_score');
            }
            if (currentScore >= 1000000 && !achievements.find(a => a.id === 'million_score').unlocked) {
                unlockAchievement('million_score');
            }
            
            // Enemy achievements
            const enemiesDefeated = game.sessionStats.crabsDefeated + game.sessionStats.eaglesDefeated + game.sessionStats.gatorsDefeated + game.sessionStats.sharksDefeated;
            if (enemiesDefeated >= 1 && !achievements.find(a => a.id === 'first_enemy').unlocked) {
                unlockAchievement('first_enemy');
            }
            if (enemiesDefeated >= 20 && !achievements.find(a => a.id === 'twenty_enemies').unlocked) {
                unlockAchievement('twenty_enemies');
            }
            if (enemiesDefeated >= 50 && !achievements.find(a => a.id === 'fifty_enemies').unlocked) {
                unlockAchievement('fifty_enemies');
            }
            if (enemiesDefeated >= 100 && !achievements.find(a => a.id === 'hundred_enemies').unlocked) {
                unlockAchievement('hundred_enemies');
            }
            if (enemiesDefeated >= 1000 && !achievements.find(a => a.id === 'thousand_enemies').unlocked) {
                unlockAchievement('thousand_enemies');
            }
            
            // Boss achievements
            const bossesDefeated = game.sessionStats.bossesDefeated;
            if (bossesDefeated >= 1 && !achievements.find(a => a.id === 'boss_defeater').unlocked) {
                unlockAchievement('boss_defeater');
            }
            if (bossesDefeated >= 5 && !achievements.find(a => a.id === 'five_bosses').unlocked) {
                unlockAchievement('five_bosses');
            }
            if (bossesDefeated >= 10 && !achievements.find(a => a.id === 'ten_bosses').unlocked) {
                unlockAchievement('ten_bosses');
            }
            if (bossesDefeated >= 20 && !achievements.find(a => a.id === 'twenty_bosses').unlocked) {
                unlockAchievement('twenty_bosses');
            }
            if (bossesDefeated >= 50 && !achievements.find(a => a.id === 'fifty_bosses').unlocked) {
                unlockAchievement('fifty_bosses');
            }
            
            // Collection achievements
            const totalItems = game.sessionStats.fishCollected + game.sessionStats.healthCollected + game.sessionStats.treasuresCollected + game.sessionStats.mushroomsCollected;
            if (totalItems >= 100 && !achievements.find(a => a.id === 'collector').unlocked) {
                unlockAchievement('collector');
            }
            if (totalItems >= 500 && !achievements.find(a => a.id === 'master_collector').unlocked) {
                unlockAchievement('master_collector');
            }
            if (totalItems >= 1000 && !achievements.find(a => a.id === 'collector_god').unlocked) {
                unlockAchievement('collector_god');
            }
            
            // Marketplace achievements
            const ownedHats = marketplaceItems.hats.filter(hat => hat.owned).length;
            const ownedSkins = marketplaceItems.skins.filter(skin => skin.owned).length;
            
            if (ownedHats >= 3 && !achievements.find(a => a.id === 'hat_collector').unlocked) {
                unlockAchievement('hat_collector');
            }
            if (ownedHats >= marketplaceItems.hats.length && !achievements.find(a => a.id === 'all_hats').unlocked) {
                unlockAchievement('all_hats');
            }
            if (ownedSkins >= 3 && !achievements.find(a => a.id === 'skin_collector').unlocked) {
                unlockAchievement('skin_collector');
            }
            if (ownedSkins >= marketplaceItems.skins.length && !achievements.find(a => a.id === 'all_skins').unlocked) {
                unlockAchievement('all_skins');
            }
            
            // Hidden achievements (random checks)
            checkHiddenAchievements();
            
            // Time-based achievements
            checkTimeBasedAchievements();
            
            // New gameplay achievements
            checkNewGameplayAchievements();
        }
        
        function checkNewGameplayAchievements() {
            // Fireball achievements
            if (game.sessionStats.fireballsHit >= 10 && !achievements.find(a => a.id === 'fireball_master').unlocked) {
                unlockAchievement('fireball_master');
            }
            
            // All-time stats achievements
            if (game.sessionStats.allTimeUnderwater >= 600000 && !achievements.find(a => a.id === 'underwater_explorer_master').unlocked) { // 10 minutes
                unlockAchievement('underwater_explorer_master');
            }
            
            if (game.sessionStats.allTimeJetpackTime >= 300000 && !achievements.find(a => a.id === 'jetpack_explorer').unlocked) { // 5 minutes
                unlockAchievement('jetpack_explorer');
            }
            
            if (game.sessionStats.allTimeLasers >= 25 && !achievements.find(a => a.id === 'laser_expert').unlocked) {
                unlockAchievement('laser_expert');
            }
            
            if (game.sessionStats.allTimeTreasures >= 50 && !achievements.find(a => a.id === 'treasure_hunter').unlocked) {
                unlockAchievement('treasure_hunter');
            }
            
            if (game.sessionStats.allTimeHealth >= 100 && !achievements.find(a => a.id === 'health_master').unlocked) {
                unlockAchievement('health_master');
            }
            
            if (game.sessionStats.allTimeMushrooms >= 50 && !achievements.find(a => a.id === 'mushroom_master').unlocked) {
                unlockAchievement('mushroom_master');
            }
            
            if (game.sessionStats.allTimeKeys >= 25 && !achievements.find(a => a.id === 'key_collector').unlocked) {
                unlockAchievement('key_collector');
            }
            
            if (game.sessionStats.allTimeFish >= 100 && !achievements.find(a => a.id === 'fish_collector').unlocked) {
                unlockAchievement('fish_collector');
            }
            
            if (game.sessionStats.allTimeJumps >= 500 && !achievements.find(a => a.id === 'jump_master').unlocked) {
                unlockAchievement('jump_master');
            }
            
            // Total enemies defeated (for skin unlock)
            const totalEnemiesDefeated = game.sessionStats.allTimeEnemies;
            if (totalEnemiesDefeated >= 50 && !achievements.find(a => a.id === 'defeat_50_enemies').unlocked) {
                unlockAchievement('defeat_50_enemies');
            }
            
            // Total coins collected (for skin unlock)
            if (game.sessionStats.allTimeCoins >= 100 && !achievements.find(a => a.id === 'collect_100_coins').unlocked) {
                unlockAchievement('collect_100_coins');
            }
            
            // Total levels completed (for skin unlock)
            if (game.sessionStats.allTimeLevels >= 10 && !achievements.find(a => a.id === 'complete_10_levels').unlocked) {
                unlockAchievement('complete_10_levels');
            }
            
            // Total bosses defeated (for skin unlock)
            if (game.sessionStats.allTimeBosses >= 5 && !achievements.find(a => a.id === 'defeat_5_bosses').unlocked) {
                unlockAchievement('defeat_5_bosses');
            }
            
            // Player level (for skin unlock)
            if (player.level >= 20 && !achievements.find(a => a.id === 'reach_level_20').unlocked) {
                unlockAchievement('reach_level_20');
            }
        }
        
        function checkHiddenAchievements() {
            // Lucky 777
            if (game.score === 777 && !achievements.find(a => a.id === 'lucky_777').unlocked) {
                unlockAchievement('lucky_777');
            }
            
            // Unlucky 13
            const totalItems = game.sessionStats.fishCollected + game.sessionStats.healthCollected + game.sessionStats.treasuresCollected + game.sessionStats.mushroomsCollected;
            if (totalItems === 13 && !achievements.find(a => a.id === 'collector_13').unlocked) {
                unlockAchievement('collector_13');
            }
            
            // Devil Hunter 666
            const enemiesDefeated = game.sessionStats.crabsDefeated + game.sessionStats.eaglesDefeated + game.sessionStats.gatorsDefeated + game.sessionStats.sharksDefeated;
            if (enemiesDefeated === 666 && !achievements.find(a => a.id === 'enemy_666').unlocked) {
                unlockAchievement('enemy_666');
            }
            
            // Answer to Everything 42
            if (game.sessionStats.totalCoins === 42 && !achievements.find(a => a.id === 'coin_42').unlocked) {
                unlockAchievement('coin_42');
            }
            
            // Nice Level 69
            if (game.level === 69 && !achievements.find(a => a.id === 'level_69').unlocked) {
                unlockAchievement('level_69');
            }
            
            // Random Master (5 hidden achievements)
            const hiddenAchievements = achievements.filter(a => a.hidden && a.unlocked);
            if (hiddenAchievements.length >= 5 && !achievements.find(a => a.id === 'random_master').unlocked) {
                unlockAchievement('random_master');
            }
        }
        
        function checkTimeBasedAchievements() {
            const now = new Date();
            const hour = now.getHours();
            const month = now.getMonth() + 1;
            const day = now.getDay(); // 0 = Sunday, 6 = Saturday
            
            // Midnight Gamer
            if (hour === 0 && !achievements.find(a => a.id === 'midnight_gamer').unlocked) {
                unlockAchievement('midnight_gamer');
            }
            
            // Early Bird
            if (hour === 6 && !achievements.find(a => a.id === 'early_bird').unlocked) {
                unlockAchievement('early_bird');
            }
            
            // Weekend Warrior
            if ((day === 0 || day === 6) && !achievements.find(a => a.id === 'weekend_warrior').unlocked) {
                unlockAchievement('weekend_warrior');
            }
            
            // Seasonal achievements
            if (month === 12 && !achievements.find(a => a.id === 'christmas_player').unlocked) {
                unlockAchievement('christmas_player');
            }
            if (month === 10 && !achievements.find(a => a.id === 'halloween_player').unlocked) {
                unlockAchievement('halloween_player');
            }
            if (month >= 6 && month <= 8 && !achievements.find(a => a.id === 'summer_player').unlocked) {
                unlockAchievement('summer_player');
            }
            if (month >= 3 && month <= 5 && !achievements.find(a => a.id === 'spring_player').unlocked) {
                unlockAchievement('spring_player');
            }
        }
        
        function saveProfileData() {
            localStorage.setItem('otterBrosProfile', JSON.stringify({
                playerName: game.profile.playerName,
                profilePicture: game.profile.profilePicture,
                level: game.profile.level,
                experience: game.profile.experience,
                achievements: game.profile.achievements,
                recentAchievements: game.profile.recentAchievements,
                playTime: game.profile.playTime,
                gamesPlayed: game.profile.gamesPlayed,
                bestScore: game.profile.bestScore,
                favoriteLevel: game.profile.favoriteLevel
            }));
        }
        
        function loadProfileData() {
            console.log('👤 Starting fresh profile - no saved data loaded');
            
            // Reset profile to fresh state
            game.profile = {
                gamesPlayed: 0,
                playTime: 0,
                bestScore: 0,
                achievements: [],
                recentAchievements: [],
                playerName: 'Otter Player',
                profilePicture: null
            };
            
            // Reset all achievements to locked
                achievements.forEach(achievement => {
                achievement.unlocked = false;
            });
            
            // Ensure real-time achievement tracking is enabled
            game.achievementTrackingEnabled = true;
            
            // Update profile display
            updateProfileDisplay();
        }
        
        // Profile editing functions
        function editProfilePicture() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const profileImage = document.getElementById('profileOtterImage');
                        profileImage.src = e.target.result;
                        game.profile.profilePicture = e.target.result;
                        saveProfileData();
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }
        
        function editPlayerName() {
            const currentName = game.profile.playerName || 'Otter Player';
            const newName = prompt('Enter your new player name:', currentName);
            
            if (newName && newName.trim() !== '') {
                game.profile.playerName = newName.trim();
                updateProfileDisplay();
                saveProfileData();
            }
        }
        
        function updateProfileDisplay() {
            // Update profile picture
            const profileImage = document.getElementById('profileOtterImage');
            if (game.profile.profilePicture) {
                profileImage.src = game.profile.profilePicture;
            }
            
            // Update player name
            const playerName = document.getElementById('profilePlayerName');
            playerName.textContent = game.profile.playerName || 'Otter Player';
            
            // Update coins
            const profileCoins = document.getElementById('profileCoins');
            profileCoins.textContent = game.marketplace.coins || 0;
        }
        
        function formatPlayTime(minutes) {
            if (minutes < 60) {
                return `${minutes} min`;
            } else {
                const hours = Math.floor(minutes / 60);
                const remainingMinutes = minutes % 60;
                return `${hours}h ${remainingMinutes}m`;
            }
        }
        
        // Home Screen Particle Effects
        function initHomeScreenParticles() {
            const particleContainer = document.getElementById('particleContainer');
            if (!particleContainer) return;
            
            const particles = [];
            const particleCount = 20;
            
            // Create particles
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.style.cssText = `
                    position: absolute;
                    width: 4px;
                    height: 4px;
                    background: radial-gradient(circle, #FFD700, transparent);
                    border-radius: 50%;
                    pointer-events: none;
                    animation: particleFloat ${5 + Math.random() * 5}s linear infinite;
                    animation-delay: ${Math.random() * 5}s;
                    opacity: ${0.3 + Math.random() * 0.4};
                `;
                
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                
                particleContainer.appendChild(particle);
                particles.push(particle);
            }
            
            // Add particle animation CSS
            if (!document.querySelector('#particleAnimationCSS')) {
                const style = document.createElement('style');
                style.id = 'particleAnimationCSS';
                style.textContent = `
                    @keyframes particleFloat {
                        0% {
                            transform: translateY(100vh) translateX(0px) rotate(0deg);
                            opacity: 0;
                        }
                        10% {
                            opacity: 1;
                        }
                        90% {
                            opacity: 1;
                        }
                        100% {
                            transform: translateY(-100px) translateX(${Math.random() * 200 - 100}px) rotate(360deg);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Enhanced button click effects
        function addButtonClickEffect(button) {
            const ripple = document.createElement('div');
            ripple.style.cssText = `
                position: absolute;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.6);
                transform: scale(0);
                animation: ripple 0.6s linear;
                pointer-events: none;
            `;
            
            const rect = button.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            const x = event.clientX - rect.left - size / 2;
            const y = event.clientY - rect.top - size / 2;
            
            ripple.style.width = ripple.style.height = size + 'px';
            ripple.style.left = x + 'px';
            ripple.style.top = y + 'px';
            
            button.appendChild(ripple);
            
            setTimeout(() => {
                ripple.remove();
            }, 600);
        }
        
        // Add ripple animation CSS
        if (!document.querySelector('#rippleAnimationCSS')) {
            const style = document.createElement('style');
            style.id = 'rippleAnimationCSS';
            style.textContent = `
                @keyframes ripple {
                    to {
                        transform: scale(4);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Dynamic background effect
        function addDynamicBackground() {
            const titleScreen = document.getElementById('titleScreen');
            if (!titleScreen) return;
            
            // Create gradient overlay
            const gradientOverlay = document.createElement('div');
            gradientOverlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(45deg, 
                    rgba(255,215,0,0.1) 0%, 
                    rgba(0,255,255,0.1) 25%, 
                    rgba(255,215,0,0.1) 50%, 
                    rgba(0,255,255,0.1) 75%, 
                    rgba(255,215,0,0.1) 100%);
                background-size: 400% 400%;
                animation: gradientShift 8s ease-in-out infinite;
                pointer-events: none;
                z-index: 1;
            `;
            
            titleScreen.appendChild(gradientOverlay);
            
            // Add gradient animation CSS
            if (!document.querySelector('#gradientAnimationCSS')) {
                const style = document.createElement('style');
                style.id = 'gradientAnimationCSS';
                style.textContent = `
                    @keyframes gradientShift {
                        0%, 100% { background-position: 0% 50%; }
                        50% { background-position: 100% 50%; }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        

        
        function toggleLeaderboard() {
            const panel = document.getElementById('leaderboardPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                updateLeaderboard();
            } else {
                panel.style.display = 'none';
            }
        }
        
        function saveStats() {
            // Update all-time stats with current session stats
            if (game.sessionStats) {
                game.sessionStats.allTimeScore += game.sessionStats.totalScore;
                game.sessionStats.allTimeLevels += game.sessionStats.levelsCompleted;
                game.sessionStats.allTimeCoins += game.sessionStats.totalCoins;
                game.sessionStats.allTimeEnemies += (game.sessionStats.crabsDefeated + game.sessionStats.eaglesDefeated + game.sessionStats.gatorsDefeated + game.sessionStats.sharksDefeated);
                game.sessionStats.allTimeBosses += game.sessionStats.bossesDefeated;
                game.sessionStats.allTimeFish += game.sessionStats.fishCollected;
                game.sessionStats.allTimeHealth += game.sessionStats.healthCollected;
                game.sessionStats.allTimeTreasures += game.sessionStats.treasuresCollected;
                game.sessionStats.allTimeMushrooms += game.sessionStats.mushroomsCollected;
                game.sessionStats.allTimeJetpacks += game.sessionStats.jetpacksUsed;
                game.sessionStats.allTimeLasers += game.sessionStats.lasersUsed;
                game.sessionStats.allTimeFireballs += game.sessionStats.fireballsShot;
                game.sessionStats.allTimeUnderwater += game.sessionStats.underwaterTime;
                game.sessionStats.allTimeJetpackTime += game.sessionStats.jetpackTime;
                game.sessionStats.allTimeLaserTime += game.sessionStats.laserTime;
                game.sessionStats.allTimeDamage += game.sessionStats.damageTaken;
                game.sessionStats.allTimeJumps += game.sessionStats.jumpsMade;
                game.sessionStats.allTimePerfectLevels += game.sessionStats.perfectLevels;
                game.sessionStats.allTimeSpeedRuns += game.sessionStats.speedRunLevels;
                game.sessionStats.allTimeNoDamage += game.sessionStats.noDamageLevels;
                game.sessionStats.allTimeNoJumps += game.sessionStats.noJumpLevels;
                game.sessionStats.allTimeNoPowerups += game.sessionStats.noPowerupLevels;
                game.sessionStats.allTimeKeys += game.sessionStats.keysCollected;
            }
            
            localStorage.setItem('otterBrosStats', JSON.stringify(game.sessionStats));
        }
        
        function loadStats() {
            // Start fresh - don't load any saved stats
            game.sessionStats = {
                totalScore: 0,
                levelsCompleted: 0,
                totalCoins: 0,
                crabsDefeated: 0,
                eaglesDefeated: 0,
                gatorsDefeated: 0,
                sharksDefeated: 0,
                bossesDefeated: 0,
                treasuresFound: 0,
                keysCollected: 0,
                healthPickups: 0,
                mushroomsEaten: 0,
                currentSessionScore: 0,
                levelStartTime: Date.now(),
                // Additional properties needed by updateLeaderboard
                fishCollected: 0,
                healthCollected: 0,
                treasuresCollected: 0,
                mushroomsCollected: 0,
                levelTimes: [],
                highestScore: 0,
                highestLevels: 0,
                highestCoins: 0,
                highestCrabs: 0,
                highestFish: 0,
                highestHealth: 0,
                highestTreasures: 0,
                highestMushrooms: 0,
                currentSessionLevels: 0,
                currentSessionCoins: 0,
                currentSessionCrabs: 0,
                currentSessionBosses: 0,
                currentSessionFish: 0,
                currentSessionHealth: 0,
                currentSessionTreasures: 0,
                currentSessionMushrooms: 0
            };
            console.log('🆕 Starting fresh - no saved stats loaded');
        }
        
        function resetStats() {
            if (confirm('Are you sure you want to reset all saved stats? This cannot be undone.')) {
                localStorage.removeItem('otterBrosStats');
                game.sessionStats = {
                    // Cumulative stats (total across all sessions)
                    totalScore: 0,
                    levelsCompleted: 0,
                    totalCoins: 0,
                    crabsDefeated: 0,
                    fishCollected: 0,
                    healthCollected: 0,
                    treasuresCollected: 0,
                    mushroomsCollected: 0,
                    levelTimes: [],
                    levelStartTime: Date.now(),
                    // Highest scores (best single session)
                    highestScore: 0,
                    highestLevels: 0,
                    highestCoins: 0,
                    highestCrabs: 0,
                    highestFish: 0,
                    highestHealth: 0,
                    highestTreasures: 0,
                    highestMushrooms: 0,
                    // Current session tracking
                    currentSessionScore: 0,
                    currentSessionLevels: 0,
                    currentSessionCoins: 0,
                    currentSessionCrabs: 0,
                    currentSessionFish: 0,
                    currentSessionHealth: 0,
                    currentSessionTreasures: 0,
                    currentSessionMushrooms: 0
                };
                updateLeaderboard();
            }
        }
        
        function updateLeaderboard() {
            // Update all-time stats
            document.getElementById('totalScore').textContent = game.sessionStats.totalScore;
            document.getElementById('totalLevels').textContent = game.sessionStats.levelsCompleted;
            document.getElementById('totalCoins').textContent = game.sessionStats.totalCoins;
            document.getElementById('totalCrabs').textContent = game.sessionStats.crabsDefeated;
            document.getElementById('totalBosses').textContent = game.sessionStats.bossesDefeated;
            document.getElementById('totalFish').textContent = game.sessionStats.fishCollected;
            document.getElementById('totalHealth').textContent = game.sessionStats.healthCollected;
            document.getElementById('totalTreasures').textContent = game.sessionStats.treasuresCollected;
            document.getElementById('totalMushrooms').textContent = game.sessionStats.mushroomsCollected;
            
            // Update highest scores
            document.getElementById('highestScore').textContent = game.sessionStats.highestScore;
            document.getElementById('highestLevels').textContent = game.sessionStats.highestLevels;
            document.getElementById('highestCoins').textContent = game.sessionStats.highestCoins;
            document.getElementById('highestCrabs').textContent = game.sessionStats.highestCrabs;
            document.getElementById('highestFish').textContent = game.sessionStats.highestFish;
            document.getElementById('highestHealth').textContent = game.sessionStats.highestHealth;
            document.getElementById('highestTreasures').textContent = game.sessionStats.highestTreasures;
            document.getElementById('highestMushrooms').textContent = game.sessionStats.highestMushrooms;
            
            // Update current session stats
            document.getElementById('sessionScore').textContent = game.sessionStats.currentSessionScore;
            document.getElementById('sessionLevels').textContent = game.sessionStats.currentSessionLevels;
            document.getElementById('sessionCoins').textContent = game.sessionStats.currentSessionCoins;
            document.getElementById('sessionCrabs').textContent = game.sessionStats.currentSessionCrabs;
            document.getElementById('sessionBosses').textContent = game.sessionStats.currentSessionBosses;
            document.getElementById('sessionFish').textContent = game.sessionStats.currentSessionFish;
            document.getElementById('sessionHealth').textContent = game.sessionStats.currentSessionHealth;
            document.getElementById('sessionTreasures').textContent = game.sessionStats.currentSessionTreasures;
            document.getElementById('sessionMushrooms').textContent = game.sessionStats.currentSessionMushrooms;
            
            // Load global leaderboard
            loadGlobalLeaderboard();
            
            // Update recent achievements
            updateRecentAchievements();
            
            // Update level times
            const levelTimesDiv = document.getElementById('levelTimes');
            if (game.sessionStats.levelTimes.length === 0) {
                levelTimesDiv.innerHTML = '<div style="text-align: center; color: #888; font-style: italic;">No levels completed yet</div>';
            } else {
                levelTimesDiv.innerHTML = game.sessionStats.levelTimes.map(time => 
                    `<div style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid rgba(255,215,0,0.3);">
                        <span>Level ${time.level}</span>
                        <span style="color: #00FFFF;">${time.time}</span>
                    </div>`
                ).join('');
            }
        }
        
        function updateRecentAchievements() {
            const container = document.getElementById('recentAchievements');
            container.innerHTML = '';
            
            // Get unlocked achievements
            const unlockedAchievements = achievements.filter(achievement => achievement.unlocked);
            
            if (unlockedAchievements.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 20px; color: #888; font-style: italic; background: rgba(100,100,100,0.1); border-radius: 15px;">
                        <div style="font-size: 48px; margin-bottom: 10px;">🏆</div>
                        <div style="font-size: 16px; color: #00FFFF;">No achievements unlocked yet</div>
                        <div style="font-size: 12px; margin-top: 5px;">Keep playing to earn badges!</div>
                    </div>
                `;
                return;
            }
            
            // Show the 4 most recent achievements
            const recentAchievements = unlockedAchievements.slice(-4);
            
            recentAchievements.forEach(achievement => {
                const achievementDiv = document.createElement('div');
                achievementDiv.style.cssText = `
                    background: rgba(76,175,80,0.1);
                    border: 2px solid #4CAF50;
                    border-radius: 15px;
                    padding: 15px;
                    text-align: center;
                    transition: all 0.3s ease;
                `;
                
                achievementDiv.innerHTML = `
                    <div style="font-size: 32px; margin-bottom: 10px;">${achievement.icon}</div>
                    <div style="font-size: 14px; font-weight: bold; color: #4CAF50; margin-bottom: 5px;">${achievement.name}</div>
                    <div style="font-size: 11px; color: #00FFFF; line-height: 1.3;">${achievement.description}</div>
                    <div style="font-size: 10px; color: #4CAF50; margin-top: 8px; font-weight: bold;">✓ UNLOCKED</div>
                `;
                
                container.appendChild(achievementDiv);
            });
            
            // If there are more than 4 achievements, show a count
            if (unlockedAchievements.length > 4) {
                const moreDiv = document.createElement('div');
                moreDiv.style.cssText = `
                    grid-column: 1 / -1;
                    text-align: center;
                    padding: 10px;
                    background: rgba(255,215,0,0.1);
                    border: 2px solid #FFD700;
                    border-radius: 15px;
                    color: #FFD700;
                    font-weight: bold;
                `;
                moreDiv.textContent = `+${unlockedAchievements.length - 4} more achievements unlocked!`;
                container.appendChild(moreDiv);
            }
        }
        
        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        function clearAsset(type) {
            // Clear the specific asset
            gameAssets[type] = null;
            
            // Clear cached pattern for background
            if (type === 'background') {
                gameAssets.backgroundPattern = null;
            }
            
            // Clear the preview
            const preview = document.getElementById(type + 'Preview');
            if (preview) {
                preview.innerHTML = '<span style="color: #FFD700;">No asset loaded</span>';
            }
            
            // Clear the file input
            const input = document.getElementById(type + 'Sprite');
            if (input) {
                input.value = '';
            }
            
            // Check if any assets are still loaded
            const hasAnyAssets = Object.keys(gameAssets).some(key => 
                key !== 'useCustomAssets' && gameAssets[key] !== null
            );
            
            if (!hasAnyAssets) {
                gameAssets.useCustomAssets = false;
            }
        }
        
        function loadAsset(type, input) {
            const file = input.files[0];
            if (!file) return;
            
            // Clear the previous asset and preview first
            if (gameAssets[type]) {
                gameAssets[type] = null;
            }
            // Clear cached pattern for background
            if (type === 'background') {
                gameAssets.backgroundPattern = null;
            }
            const preview = document.getElementById(type + 'Preview');
            if (preview) {
                preview.innerHTML = '<span>Loading...</span>';
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Ensure the old image is completely replaced
                    gameAssets[type] = img;
                    gameAssets.useCustomAssets = true;
                    
                    // For background images, create the pattern immediately to avoid performance issues
                    if (type === 'background') {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0);
                        gameAssets.backgroundPattern = tempCtx.createPattern(tempCanvas, 'repeat');
                    }
                    
                    updateAssetPreview(type, img);
                };
                img.onerror = function() {
                    // Handle loading errors
                    if (preview) {
                        preview.innerHTML = '<span style="color: red;">Error loading image</span>';
                    }
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                if (preview) {
                    preview.innerHTML = '<span style="color: red;">Error reading file</span>';
                }
            };
            reader.readAsDataURL(file);
        }
        
        function updateAssetPreview(type, img) {
            const preview = document.getElementById(type + 'Preview');
            if (preview) {
                // Completely clear the preview first
                preview.innerHTML = '';
                
                // Create new preview image
                const previewImg = document.createElement('img');
                previewImg.style.maxWidth = '100px';
                previewImg.style.maxHeight = '100px';
                previewImg.style.border = '2px solid #FFD700';
                previewImg.style.borderRadius = '5px';
                previewImg.style.margin = '5px';
                
                // Set the source after creating the element to ensure proper loading
                previewImg.onload = function() {
                    // Image loaded successfully
                };
                previewImg.onerror = function() {
                    preview.innerHTML = '<span style="color: red;">Preview failed to load</span>';
                };
                previewImg.src = img.src;
                preview.appendChild(previewImg);
            }
        }
        
        function resetToDefault() {
            // Clear all assets
            gameAssets.player = null;
            gameAssets.enemy = null;
            gameAssets.coin = null;
            gameAssets.health = null;
            gameAssets.heart = null;
            gameAssets.treasure = null;
            gameAssets.rareTreasure = null;
            gameAssets.mushroom = null;
            gameAssets.fish = null;
            gameAssets.background = null;
            gameAssets.backgroundPattern = null; // Clear cached pattern
            gameAssets.platform = null;
                                        gameAssets.crate = null;
            gameAssets.crate1 = null;
            gameAssets.crate2 = null;
            gameAssets.key = null;
            gameAssets.wizgator = null;
            gameAssets.shark = null;
            gameAssets.shark1 = null;
            gameAssets.useCustomAssets = false;
            
            // Clear all previews
            const previews = document.querySelectorAll('.preview');
            previews.forEach(preview => {
                preview.innerHTML = '<span style="color: #FFD700;">No asset loaded</span>';
            });
            
            // Clear file inputs
            const inputs = document.querySelectorAll('input[type="file"]');
            inputs.forEach(input => {
                input.value = '';
                // Trigger change event to ensure UI updates
                input.dispatchEvent(new Event('change'));
            });
        }
        
        function exportAssetConfig() {
            const config = {
                useCustomAssets: gameAssets.useCustomAssets,
                assets: {}
            };
            
            // Convert images to base64 for export
            Object.keys(gameAssets).forEach(key => {
                if (key !== 'useCustomAssets' && gameAssets[key]) {
                    const canvas = document.createElement('canvas');
                    canvas.width = gameAssets[key].width;
                    canvas.height = gameAssets[key].height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(gameAssets[key], 0, 0);
                    config.assets[key] = canvas.toDataURL();
                }
            });
            
            const dataStr = JSON.stringify(config, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'game-assets-config.json';
            link.click();
            
            URL.revokeObjectURL(url);
        }
        
        function importAssetConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const config = JSON.parse(e.target.result);
                        gameAssets.useCustomAssets = config.useCustomAssets;
                        
                        Object.keys(config.assets).forEach(key => {
                            const img = new Image();
                            img.onload = function() {
                                gameAssets[key] = img;
                                updateAssetPreview(key, img);
                            };
                            img.src = config.assets[key];
                        });
                    } catch (error) {
                        alert('Error loading asset configuration: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // 🔫 DEBUGGING HELPER - Add this to check laser status
        function debugLasers() {
            console.log('🔫 === LASER DEBUG INFO ===');
            console.log('🔫 Laser powerups array exists:', typeof laserPowerups !== 'undefined');
            console.log('🔫 Laser powerups count:', laserPowerups ? laserPowerups.length : 'N/A');
            
            if (laserPowerups && laserPowerups.length > 0) {
                laserPowerups.forEach((l, i) => {
                    console.log(`🔫 Laser powerup ${i}:`, {
                        x: l.x,
                        y: l.y,
                        collected: l.collected,
                        screenX: l.x - (game.camera ? game.camera.x : 0),
                        screenY: l.y - (game.camera ? game.camera.y : 0)
                    });
                });
            }
            
            console.log('🔫 Player position:', player ? {x: player.x, y: player.y} : 'N/A');
            console.log('🔫 Camera position:', game.camera ? {x: game.camera.x, y: game.camera.y} : 'N/A');
            console.log('🔫 ========================');
        }
        
        // 🔫 INITIALIZATION CHECK - Add this to your level generation
        function initializeLevelWithLasers(platforms, levelNum) {
            console.log('🔫 Initializing level', levelNum, 'with laser powerups');
            
            // Make sure laserPowerups array exists globally
            if (typeof laserPowerups === 'undefined') {
                console.error('🔫 ERROR: laserPowerups array is not defined globally!');
                window.laserPowerups = []; // Create it if missing
            }
            
            // Generate laser powerups for this level
            const newLaserPowerups = generateRandomLasers(platforms, levelNum);
            
            // Replace existing laser powerups
            laserPowerups.length = 0; // Clear existing
            laserPowerups.push(...newLaserPowerups); // Add new ones
            
            console.log('🔫 Level initialized with', laserPowerups.length, 'laser powerups');
            
            return laserPowerups;
        }
        
        // Start the game with error handling
        try {
            console.log('🎮 Starting game...');
            gameLoop();
            console.log('🎮 Game loop started successfully');
            
            // Initialize health bar
            setTimeout(() => {
                updateHealthBar();
                console.log('❤️ Health bar initialized');
            }, 100);
            
            // Initialize armor bar
            setTimeout(() => {
                updateArmorBar();
                console.log('🛡️ Armor bar initialized');
            }, 150);
        } catch (error) {
            console.error('❌ Error starting game:', error);
            alert('Game failed to start: ' + error.message);
        }
        
        // Debug lasers on startup
        setTimeout(() => {
            try {
                debugLasers();
            } catch (error) {
                console.error('❌ Error in debugLasers:', error);
            }
        }, 1000);
        
        // 🌍 Global Leaderboard System
        let globalLeaderboardData = {
            scores: [],
            coins: [],
            levels: [],
            bosses: []
        };
        let currentLeaderboardTab = 'score';
        let leaderboardUpdateInterval = null;
        
        // Mock global leaderboard data (in a real app, this would come from a server)
        function generateMockLeaderboardData() {
            const mockPlayers = [
                'OtterMaster', 'RiverRunner', 'SwimChamp', 'AquaHero', 'WaterWizard',
                'StreamSurfer', 'CreekKing', 'PondPrince', 'LakeLegend', 'OceanOtter',
                'WaveWarrior', 'TideTamer', 'SplashStar', 'DiveDynamo', 'FloatFighter'
            ];
            
            return {
                scores: mockPlayers.map((name, index) => ({
                    name: name,
                    score: Math.floor(Math.random() * 50000) + 10000,
                    rank: index + 1,
                    timestamp: Date.now() - Math.random() * 86400000 // Random time in last 24 hours
                })).sort((a, b) => b.score - a.score).map((player, index) => ({...player, rank: index + 1})),
                
                coins: mockPlayers.map((name, index) => ({
                    name: name,
                    coins: Math.floor(Math.random() * 2000) + 500,
                    rank: index + 1,
                    timestamp: Date.now() - Math.random() * 86400000
                })).sort((a, b) => b.coins - a.coins).map((player, index) => ({...player, rank: index + 1})),
                
                levels: mockPlayers.map((name, index) => ({
                    name: name,
                    levels: Math.floor(Math.random() * 50) + 10,
                    rank: index + 1,
                    timestamp: Date.now() - Math.random() * 86400000
                })).sort((a, b) => b.levels - a.levels).map((player, index) => ({...player, rank: index + 1})),
                
                bosses: mockPlayers.map((name, index) => ({
                    name: name,
                    bosses: Math.floor(Math.random() * 20) + 5,
                    rank: index + 1,
                    timestamp: Date.now() - Math.random() * 86400000
                })).sort((a, b) => b.bosses - a.bosses).map((player, index) => ({...player, rank: index + 1}))
            };
        }
        
        function loadGlobalLeaderboard() {
            console.log('🌍 Loading global leaderboard...');
            
            // Simulate API call delay
            setTimeout(() => {
                globalLeaderboardData = generateMockLeaderboardData();
                updateGlobalLeaderboardDisplay();
                updateLeaderboardStatus();
                
                // Start real-time updates
                if (!leaderboardUpdateInterval) {
                    leaderboardUpdateInterval = setInterval(() => {
                        updateGlobalLeaderboardData();
                    }, 30000); // Update every 30 seconds
                }
            }, 500);
        }
        
        function refreshGlobalLeaderboard() {
            console.log('🔄 Refreshing global leaderboard...');
            const refreshBtn = document.getElementById('refreshLeaderboardBtn');
            refreshBtn.textContent = '⏳ Loading...';
            refreshBtn.disabled = true;
            
            // Simulate refresh delay
            setTimeout(() => {
                globalLeaderboardData = generateMockLeaderboardData();
                updateGlobalLeaderboardDisplay();
                updateLeaderboardStatus();
                
                refreshBtn.textContent = '🔄 Refresh';
                refreshBtn.disabled = false;
            }, 1000);
        }
        
        function updateGlobalLeaderboardData() {
            // Simulate real-time updates by randomly updating some scores
            const updateChance = 0.3; // 30% chance to update each player
            
            globalLeaderboardData.scores.forEach(player => {
                if (Math.random() < updateChance) {
                    player.score += Math.floor(Math.random() * 1000);
                    player.timestamp = Date.now();
                }
            });
            
            globalLeaderboardData.coins.forEach(player => {
                if (Math.random() < updateChance) {
                    player.coins += Math.floor(Math.random() * 50);
                    player.timestamp = Date.now();
                }
            });
            
            globalLeaderboardData.levels.forEach(player => {
                if (Math.random() < updateChance) {
                    player.levels += Math.floor(Math.random() * 2);
                    player.timestamp = Date.now();
                }
            });
            
            globalLeaderboardData.bosses.forEach(player => {
                if (Math.random() < updateChance) {
                    player.bosses += Math.floor(Math.random() * 1);
                    player.timestamp = Date.now();
                }
            });
            
            // Re-sort and re-rank
            globalLeaderboardData.scores.sort((a, b) => b.score - a.score).forEach((player, index) => player.rank = index + 1);
            globalLeaderboardData.coins.sort((a, b) => b.coins - a.coins).forEach((player, index) => player.rank = index + 1);
            globalLeaderboardData.levels.sort((a, b) => b.levels - a.levels).forEach((player, index) => player.rank = index + 1);
            globalLeaderboardData.bosses.sort((a, b) => b.bosses - a.bosses).forEach((player, index) => player.rank = index + 1);
            
            updateGlobalLeaderboardDisplay();
            updateLeaderboardStatus();
        }
        
        function updateGlobalLeaderboardDisplay() {
            const content = document.getElementById('globalLeaderboardContent');
            const data = globalLeaderboardData[currentLeaderboardTab];
            
            if (!data || data.length === 0) {
                content.innerHTML = '<div style="text-align: center; color: #FFD700; font-size: 18px; margin: 20px 0;">No data available</div>';
                return;
            }
            
            let html = '<div style="max-height: 300px; overflow-y: auto;">';
            
            data.slice(0, 10).forEach((player, index) => {
                const isCurrentPlayer = player.name === (game.profile.playerName || 'Otter Player');
                const rankColor = index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#FFD700';
                const bgColor = isCurrentPlayer ? 'rgba(255,215,0,0.2)' : 'rgba(0,0,0,0.3)';
                const borderColor = isCurrentPlayer ? '#FFD700' : 'transparent';
                
                html += `
                    <div style="display: flex; align-items: center; padding: 10px; margin: 5px 0; background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 10px; ${isCurrentPlayer ? 'box-shadow: 0 0 10px rgba(255,215,0,0.5);' : ''}">
                        <div style="width: 40px; text-align: center; font-weight: bold; color: ${rankColor}; font-size: 18px;">
                            ${player.rank === 1 ? '🥇' : player.rank === 2 ? '🥈' : player.rank === 3 ? '🥉' : `#${player.rank}`}
                        </div>
                        <div style="flex: 1; margin-left: 15px;">
                            <div style="font-weight: bold; color: ${isCurrentPlayer ? '#FFD700' : '#FFFFFF'}; font-size: 16px;">
                                ${player.name} ${isCurrentPlayer ? '(You)' : ''}
                            </div>
                            <div style="font-size: 12px; color: #00FFFF;">
                                ${currentLeaderboardTab === 'score' ? `${player.score.toLocaleString()} points` : 
                                  currentLeaderboardTab === 'coins' ? `${player.coins.toLocaleString()} coins` : 
                                  `${player.levels} levels`}
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #666;">
                            ${formatTimeAgo(player.timestamp)}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            content.innerHTML = html;
        }
        
        function switchLeaderboardTab(tab) {
            currentLeaderboardTab = tab;
            
            // Update tab button styles
            document.getElementById('scoreTabBtn').style.background = tab === 'score' ? '#FFD700' : 'rgba(255,215,0,0.3)';
            document.getElementById('scoreTabBtn').style.color = tab === 'score' ? 'black' : '#FFD700';
            document.getElementById('coinsTabBtn').style.background = tab === 'coins' ? '#FFD700' : 'rgba(255,215,0,0.3)';
            document.getElementById('coinsTabBtn').style.color = tab === 'coins' ? 'black' : '#FFD700';
            document.getElementById('levelsTabBtn').style.background = tab === 'levels' ? '#FFD700' : 'rgba(255,215,0,0.3)';
            document.getElementById('levelsTabBtn').style.color = tab === 'levels' ? 'black' : '#FFD700';
            document.getElementById('bossesTabBtn').style.background = tab === 'bosses' ? '#FFD700' : 'rgba(255,215,0,0.3)';
            document.getElementById('bossesTabBtn').style.color = tab === 'bosses' ? 'black' : '#FFD700';
            
            updateGlobalLeaderboardDisplay();
        }
        
        function updateLeaderboardStatus() {
            const status = document.getElementById('leaderboardStatus');
            const now = new Date();
            status.textContent = `Last updated: ${now.toLocaleTimeString()}`;
        }
        
        function formatTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (minutes < 1) return 'Just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return `${days}d ago`;
        }
        
        // Submit player score to global leaderboard (simulated)
        function submitToGlobalLeaderboard() {
            const playerName = game.profile.playerName || 'Otter Player';
            const playerScore = game.sessionStats.totalScore;
            const playerCoins = game.sessionStats.totalCoins;
            const playerLevels = game.sessionStats.levelsCompleted;
            
            console.log('🌍 Submitting to global leaderboard:', {
                name: playerName,
                score: playerScore,
                coins: playerCoins,
                levels: playerLevels
            });
            
            // In a real implementation, this would send data to a server
            // For now, we'll just log it and update the mock data
            setTimeout(() => {
                // Simulate score submission
                console.log('✅ Score submitted successfully!');
            }, 1000);
        }
        
        // Pause Menu Functions
        
        // Toggle pause menu
        function togglePauseMenu() {
            const pauseMenu = document.getElementById('pauseMenu');
            if (pauseMenu.style.display === 'none' || pauseMenu.style.display === '') {
                pauseMenu.style.display = 'block';
                game.gameState = 'paused';
                updatePauseMenuStats();
                populatePauseCustomization();
                setupPauseEventListeners();
                // Hide pause button and settings button when menu is open
                document.getElementById('pauseBtn').style.display = 'none';
                document.getElementById('settingsBtn').style.display = 'none';
            } else {
                pauseMenu.style.display = 'none';
                game.gameState = 'playing';
                // Show pause button and settings button when menu is closed
                if (game.gameState === 'playing') {
                    document.getElementById('pauseBtn').style.display = 'inline-block';
                    document.getElementById('settingsBtn').style.display = 'inline-block';
                }
            }
        }
        
        // Switch pause menu tabs
        function switchPauseTab(tab) {
            const instructionsTab = document.getElementById('pauseInstructionsTab');
            const settingsTab = document.getElementById('pauseSettingsTab');
            const customizationTab = document.getElementById('pauseCustomizationTab');
            const actionsTab = document.getElementById('pauseActionsTab');
            
            const instructionsBtn = document.getElementById('pauseInstructionsTabBtn');
            const settingsBtn = document.getElementById('pauseSettingsTabBtn');
            const customizationBtn = document.getElementById('pauseCustomizationTabBtn');
            const actionsBtn = document.getElementById('pauseActionsTabBtn');
            
            // Hide all tabs
            instructionsTab.style.display = 'none';
            settingsTab.style.display = 'none';
            customizationTab.style.display = 'none';
            actionsTab.style.display = 'none';
            
            // Remove active class from all buttons and reset styles
            [instructionsBtn, settingsBtn, customizationBtn, actionsBtn].forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.3), rgba(0,0,0,0.1))';
                btn.style.color = '#999';
                btn.style.border = '2px solid rgba(255,255,255,0.1)';
            });
            
            if (tab === 'instructions') {
                instructionsTab.style.display = 'block';
                instructionsBtn.classList.add('active');
                instructionsBtn.style.background = 'linear-gradient(135deg, rgba(76,175,80,0.2), rgba(76,175,80,0.1))';
                instructionsBtn.style.color = '#4CAF50';
                instructionsBtn.style.border = '2px solid rgba(76,175,80,0.4)';
            } else if (tab === 'settings') {
                settingsTab.style.display = 'block';
                settingsBtn.classList.add('active');
                settingsBtn.style.background = 'linear-gradient(135deg, rgba(33,150,243,0.2), rgba(33,150,243,0.1))';
                settingsBtn.style.color = '#2196F3';
                settingsBtn.style.border = '2px solid rgba(33,150,243,0.4)';
            } else if (tab === 'customization') {
                customizationTab.style.display = 'block';
                customizationBtn.classList.add('active');
                customizationBtn.style.background = 'linear-gradient(135deg, rgba(255,107,53,0.2), rgba(255,107,53,0.1))';
                customizationBtn.style.color = '#FF6B35';
                customizationBtn.style.border = '2px solid rgba(255,107,53,0.4)';
            } else if (tab === 'actions') {
                actionsTab.style.display = 'block';
                actionsBtn.classList.add('active');
                actionsBtn.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,215,0,0.1))';
                actionsBtn.style.color = '#FFD700';
                actionsBtn.style.border = '2px solid rgba(255,215,0,0.4)';
            }
        }
        
        // Update pause menu statistics
        function updatePauseMenuStats() {
            document.getElementById('pauseScore').textContent = game.score;
            document.getElementById('pauseCoins').textContent = game.coins;
            document.getElementById('pauseHealth').textContent = player.health;
            document.getElementById('pauseLevel').textContent = player.level;
        }
        
        // Populate pause menu customization options
        function populatePauseCustomization() {
            // Populate otter skins
            const otterSkinsContainer = document.getElementById('pauseOtterSkins');
            otterSkinsContainer.innerHTML = '';
            
            if (marketplaceItems && marketplaceItems.skins) {
                marketplaceItems.skins.forEach(skin => {
                    if (skin.owned) {
                        const skinElement = document.createElement('div');
                        skinElement.style.cssText = `
                            background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(26,26,46,0.6));
                            border: 2px solid ${skin.equipped ? 'rgba(76,175,80,0.6)' : 'rgba(255,215,0,0.4)'};
                            border-radius: 10px;
                            padding: 10px;
                            text-align: center;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            ${skin.equipped ? 'box-shadow: 0 0 15px rgba(76,175,80,0.6);' : ''}
                        `;
                        
                        skinElement.innerHTML = `
                            <img src="${skin.image}" alt="${skin.name}" style="width: 40px; height: 40px; object-fit: contain; border-radius: 5px;">
                            <div style="font-size: 10px; color: #FFD700; margin-top: 5px;">${skin.name}</div>
                            ${skin.equipped ? '<div style="color: #4CAF50; font-size: 8px;">✓</div>' : ''}
                        `;
                        
                        skinElement.onclick = () => equipSkin(skin.id);
                        otterSkinsContainer.appendChild(skinElement);
                    }
                });
            }
            
            // Populate owl hats
            const owlHatsContainer = document.getElementById('pauseOwlHats');
            owlHatsContainer.innerHTML = '';
            
            if (marketplaceItems && marketplaceItems.hats) {
                marketplaceItems.hats.forEach(hat => {
                    if (hat.owned) {
                        const hatElement = document.createElement('div');
                        hatElement.style.cssText = `
                            background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(26,26,46,0.6));
                            border: 2px solid ${hat.equipped ? 'rgba(76,175,80,0.6)' : 'rgba(255,215,0,0.4)'};
                            border-radius: 10px;
                            padding: 10px;
                            text-align: center;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            ${hat.equipped ? 'box-shadow: 0 0 15px rgba(76,175,80,0.6);' : ''}
                        `;
                        
                        hatElement.innerHTML = `
                            <img src="${hat.image}" alt="${hat.name}" style="width: 40px; height: 40px; object-fit: contain; border-radius: 5px;">
                            <div style="font-size: 10px; color: #FFD700; margin-top: 5px;">${hat.name}</div>
                            ${hat.equipped ? '<div style="color: #4CAF50; font-size: 8px;">✓</div>' : ''}
                        `;
                        
                        hatElement.onclick = () => equipHat(hat.id);
                        owlHatsContainer.appendChild(hatElement);
                    }
                });
            }
        }
        
        // Setup pause menu event listeners
        function setupPauseEventListeners() {
            // AI Owl Bot toggle
            const aiOwlToggle = document.getElementById('aiOwlToggle');
            const aiOwlStatus = document.getElementById('aiOwlStatus');
            
            aiOwlToggle.checked = aiOwlBotEnabled;
            aiOwlStatus.textContent = aiOwlBotEnabled ? 'ON' : 'OFF';
            aiOwlStatus.style.color = aiOwlBotEnabled ? '#4CAF50' : '#FF4444';
            
            aiOwlToggle.addEventListener('change', function() {
                aiOwlBotEnabled = this.checked;
                aiOwlStatus.textContent = aiOwlBotEnabled ? 'ON' : 'OFF';
                aiOwlStatus.style.color = aiOwlBotEnabled ? '#4CAF50' : '#FF4444';
                console.log('🤖 AI Owl Bot:', aiOwlBotEnabled ? 'Enabled' : 'Disabled');
            });
            
            // Settings sliders
            const sliders = [
                { id: 'screenShakeSlider', label: 'Screen Shake' },
                { id: 'particleEffectsSlider', label: 'Particle Effects' },
                { id: 'masterVolumeSlider', label: 'Master Volume' },
                { id: 'sfxVolumeSlider', label: 'SFX Volume' }
            ];
            
            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                if (element) {
                    const display = element.nextElementSibling;
                    if (display) {
                        element.addEventListener('input', function() {
                            display.textContent = this.value + '%';
                        });
                    }
                }
            });
        }
        
        // Pause menu action functions
        function resumeGame() {
            togglePauseMenu();
            game.gameState = 'playing';
        }
        
        function restartLevel() {
            if (confirm('Are you sure you want to restart the current level? All progress will be lost.')) {
                togglePauseMenu();
                // Reset current level without going back to title screen
                game.score = 0;
                game.coins = 0;
                game.lives = 3;
                game.gameOver = false;
                game.levelComplete = false;
                game.levelTransition = false;
                game.lastLifeScore = 0;
                game.camera = { x: 0, y: 0 };
                
                // Reset checkpoint progress for current level only
                if (game.checkpointProgress[game.level]) {
                    delete game.checkpointProgress[game.level];
                }
                game.activeCheckpoint = null;
                game.currentBoss = null;
                game.bossActive = false;
                game.secrets = [];
                game.secretRooms = [];
                game.particles = [];
                game.screenShake = 0;
                game.freezeFrame = 0;
                
                // Reset player state
                player.x = 240;
                player.y = 1200;
                player.velX = 0;
                player.velY = 0;
                player.onGround = true;
                player.canDoubleJump = true;
                player.direction = 1;
                player.invulnerable = false;
                player.invulnerableTime = 0;
                player.giant = false;
                player.giantTime = 0;
                player.health = player.maxHealth;
                player.armor = 0;

                // Reset jetpack
                player.hasJetpack = false;
                player.jetpackActive = false;
                player.jetpackTime = 0;
                player.lastPlatform = null;
                
                // Reset laser system for each level (but preserve laser charging level)
                player.hasLaser = false;
                player.laserActive = false;
                player.laserTime = 0;
                player.laserCooldown = 0;
                player.currentLaserColor = 0;
                player.isCharging = false;
                player.chargeStartTime = 0;
                player.chargeLevel = 0;
                
                // Reset fireball system for each level
                player.hasFireball = false;
                player.fireballCooldown = 0;
                
                // Check for equipped abilities from marketplace
                if (game.marketplace.currentAbilities && game.marketplace.currentAbilities.length > 0) {
                    game.marketplace.currentAbilities.forEach(abilityId => {
                        if (abilityId === 'jetpack') {
                            player.hasJetpack = true;
                        } else if (abilityId === 'laser') {
                            player.hasLaser = true;
                        } else if (abilityId === 'fireball') {
                            player.hasFireball = true;
                        } else if (abilityId === 'armor') {
                            player.hasArmorBoost = true;
                            player.armorLevel = 1;
                        }
                    });
                }
                
                playerLasers = [];
                bossLasers = [];
                playerFireballs = [];
                
                // Reset key count for each level
                game.keyCount = 0;
                player.keys = 0;
                
                // Regenerate level
                generateLevel(game.level);
                
                // Reset UI displays
                document.getElementById('score').textContent = '0';
                document.getElementById('coins').textContent = '0';
                document.getElementById('lives').textContent = '3';
                document.getElementById('giantIndicator').style.display = 'none';
                
                // Reset collectibles counter for new level
                game.collectiblesCount.coinsCollected = 0;
                game.collectiblesCount.chestsCollected = 0;
                game.collectiblesCount.goldenChestsCollected = 0;
                updateCollectiblesCounter();
                
                game.gameState = 'playing';
                console.log('Level restarted successfully');
            }
        }
        
        function returnToHome() {
            if (confirm('Are you sure you want to return to the main menu? All unsaved progress will be lost.')) {
                togglePauseMenu();
                returnToStart();
            }
        }
        
        function saveAndQuit() {
            savePlayerProgress();
            saveMarketplaceData();
            alert('Progress saved! Returning to main menu.');
            togglePauseMenu();
            returnToStartScreen();
            // Show title screen buttons
            document.getElementById('profileBtn').style.display = 'inline-block';
            document.getElementById('marketplaceBtn').style.display = 'inline-block';
            document.getElementById('startGameBtn').style.display = 'inline-block';
            document.getElementById('settingsBtn').style.display = 'none';
        }
        
        // Add keyboard event listener for pause menu
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && game.gameState === 'playing') {
                e.preventDefault();
                togglePauseMenu();
            }
        });

        // Asset Importer Functions
        let importedAssets = {
            otter: null,
            owl: null,
            enemies: [],
            backgrounds: [],
            platforms: [],
            collectibles: []
        };

        function importOtterCharacter() {
            const input = document.getElementById('otterCharacterInput');
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        importedAssets.otter = {
                            src: e.target.result,
                            name: file.name,
                            width: img.width,
                            height: img.height
                        };
                        showAssetImportNotification('Otter character imported successfully!', 'success');
                        console.log('🦦 Otter character imported:', file.name);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                showAssetImportNotification('Please select a file first!', 'error');
            }
        }

        function importOwlCompanion() {
            const input = document.getElementById('owlCompanionInput');
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        importedAssets.owl = {
                            src: e.target.result,
                            name: file.name,
                            width: img.width,
                            height: img.height
                        };
                        showAssetImportNotification('Owl companion imported successfully!', 'success');
                        console.log('🦉 Owl companion imported:', file.name);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                showAssetImportNotification('Please select a file first!', 'error');
            }
        }

        function importEnemySprites() {
            const input = document.getElementById('enemySpritesInput');
            const files = input.files;
            if (files.length > 0) {
                importedAssets.enemies = [];
                let loadedCount = 0;
                
                Array.from(files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            importedAssets.enemies.push({
                                src: e.target.result,
                                name: file.name,
                                width: img.width,
                                height: img.height,
                                type: `enemy_${index}`
                            });
                            loadedCount++;
                            
                            if (loadedCount === files.length) {
                                showAssetImportNotification(`${files.length} enemy sprites imported successfully!`, 'success');
                                console.log('👹 Enemy sprites imported:', files.length, 'files');
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                showAssetImportNotification('Please select files first!', 'error');
            }
        }

        function importBackgrounds() {
            const input = document.getElementById('backgroundInput');
            const files = input.files;
            if (files.length > 0) {
                importedAssets.backgrounds = [];
                let loadedCount = 0;
                
                Array.from(files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            importedAssets.backgrounds.push({
                                src: e.target.result,
                                name: file.name,
                                width: img.width,
                                height: img.height,
                                type: `background_${index}`
                            });
                            loadedCount++;
                            
                            if (loadedCount === files.length) {
                                showAssetImportNotification(`${files.length} background images imported successfully!`, 'success');
                                console.log('🌅 Background images imported:', files.length, 'files');
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                showAssetImportNotification('Please select files first!', 'error');
            }
        }

        function importPlatforms() {
            const input = document.getElementById('platformInput');
            const files = input.files;
            if (files.length > 0) {
                importedAssets.platforms = [];
                let loadedCount = 0;
                
                Array.from(files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            importedAssets.platforms.push({
                                src: e.target.result,
                                name: file.name,
                                width: img.width,
                                height: img.height,
                                type: `platform_${index}`
                            });
                            loadedCount++;
                            
                            if (loadedCount === files.length) {
                                showAssetImportNotification(`${files.length} platform textures imported successfully!`, 'success');
                                console.log('🏗️ Platform textures imported:', files.length, 'files');
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                showAssetImportNotification('Please select files first!', 'error');
            }
        }

        function importCollectibles() {
            const input = document.getElementById('collectiblesInput');
            const files = input.files;
            if (files.length > 0) {
                importedAssets.collectibles = [];
                let loadedCount = 0;
                
                Array.from(files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            importedAssets.collectibles.push({
                                src: e.target.result,
                                name: file.name,
                                width: img.width,
                                height: img.height,
                                type: `collectible_${index}`
                            });
                            loadedCount++;
                            
                            if (loadedCount === files.length) {
                                showAssetImportNotification(`${files.length} collectibles imported successfully!`, 'success');
                                console.log('🪙 Collectibles imported:', files.length, 'files');
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                showAssetImportNotification('Please select files first!', 'error');
            }
        }

        function previewImportedAssets() {
            const previewArea = document.getElementById('assetPreviewArea');
            const previewGrid = document.getElementById('assetPreviewGrid');
            
            if (previewArea.style.display === 'none') {
                previewArea.style.display = 'block';
                previewGrid.innerHTML = '';
                
                // Add all imported assets to preview
                const allAssets = [
                    ...(importedAssets.otter ? [importedAssets.otter] : []),
                    ...(importedAssets.owl ? [importedAssets.owl] : []),
                    ...importedAssets.enemies,
                    ...importedAssets.backgrounds,
                    ...importedAssets.platforms,
                    ...importedAssets.collectibles
                ];
                
                if (allAssets.length === 0) {
                    previewGrid.innerHTML = '<div style="text-align: center; color: #FFD700; grid-column: 1 / -1;">No assets imported yet</div>';
                    return;
                }
                
                allAssets.forEach(asset => {
                    const assetElement = document.createElement('div');
                    assetElement.style.cssText = `
                        background: rgba(255,215,0,0.1);
                        border: 2px solid rgba(255,215,0,0.3);
                        border-radius: 10px;
                        padding: 10px;
                        text-align: center;
                        transition: all 0.3s ease;
                    `;
                    
                    assetElement.innerHTML = `
                        <img src="${asset.src}" alt="${asset.name}" style="width: 60px; height: 60px; object-fit: contain; border-radius: 5px; margin-bottom: 5px;">
                        <div style="font-size: 10px; color: #FFD700; word-break: break-word;">${asset.name}</div>
                        <div style="font-size: 8px; color: #00FFFF;">${asset.width}x${asset.height}</div>
                    `;
                    
                    previewGrid.appendChild(assetElement);
                });
            } else {
                previewArea.style.display = 'none';
            }
        }

        function exportAssetPack() {
            const assetPack = {
                version: '1.0',
                timestamp: Date.now(),
                assets: importedAssets
            };
            
            const dataStr = JSON.stringify(assetPack, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `otter-bros-asset-pack-${Date.now()}.json`;
            link.click();
            
            showAssetImportNotification('Asset pack exported successfully!', 'success');
            console.log('📦 Asset pack exported');
        }

        function resetToDefaults() {
            if (confirm('Are you sure you want to reset all imported assets to defaults?')) {
                importedAssets = {
                    otter: null,
                    owl: null,
                    enemies: [],
                    backgrounds: [],
                    platforms: [],
                    collectibles: []
                };
                
                // Clear file inputs
                document.getElementById('otterCharacterInput').value = '';
                document.getElementById('owlCompanionInput').value = '';
                document.getElementById('enemySpritesInput').value = '';
                document.getElementById('backgroundInput').value = '';
                document.getElementById('platformInput').value = '';
                document.getElementById('collectiblesInput').value = '';
                
                // Hide preview area
                document.getElementById('assetPreviewArea').style.display = 'none';
                
                showAssetImportNotification('Assets reset to defaults!', 'success');
                console.log('🔄 Assets reset to defaults');
            }
        }

        function clearAllAssets() {
            if (confirm('Are you sure you want to clear all imported assets? This cannot be undone.')) {
                importedAssets = {
                    otter: null,
                    owl: null,
                    enemies: [],
                    backgrounds: [],
                    platforms: [],
                    collectibles: []
                };
                
                // Clear file inputs
                document.getElementById('otterCharacterInput').value = '';
                document.getElementById('owlCompanionInput').value = '';
                document.getElementById('enemySpritesInput').value = '';
                document.getElementById('backgroundInput').value = '';
                document.getElementById('platformInput').value = '';
                document.getElementById('collectiblesInput').value = '';
                
                // Hide preview area
                document.getElementById('assetPreviewArea').style.display = 'none';
                
                showAssetImportNotification('All assets cleared!', 'success');
                console.log('🗑️ All assets cleared');
            }
        }

        function showAssetImportNotification(message, type) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? 'linear-gradient(135deg, #4CAF50, #45a049)' : 'linear-gradient(135deg, #FF4444, #CC0000)'};
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                animation: slideIn 0.3s ease-out;
            `;
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Secret chest spawning system
        function checkSecretChestConditions() {
            // Check if conditions are met for secret chests
            const coinsCollected = game.collectiblesCount.coinsCollected;
            const treasuresCollected = game.sessionStats.treasuresCollected;
            const keysCollected = game.sessionStats.keysCollected;
            
            // Update tracking
            game.secretChestConditions.coinsCollected = coinsCollected;
            game.secretChestConditions.treasuresCollected = treasuresCollected;
            game.secretChestConditions.keysCollected = keysCollected;
            
            // Check if all conditions are met and chests haven't been spawned yet
            if (coinsCollected >= 100 && treasuresCollected >= 11 && keysCollected >= 1 && !game.secretChestsSpawned) {
                spawnSecretChests();
                showAIOwlBotMessage("🦉 *whispers* Hoot hoot! I sense something special at the beginning of this level... maybe you should go back and check? *winks*");
            }
        }

        function spawnSecretChests() {
            console.log('🎁 SECRET CHESTS SPAWNING!');
            game.secretChestsSpawned = true;
            
            // Find the spawn point (beginning of level)
            const spawnX = 100; // Player spawn position
            const spawnY = 1000; // Ground level
            
            // Create 20 chests equally spaced
            const chestSpacing = 60; // Space between chests
            const totalWidth = 19 * chestSpacing; // 20 chests = 19 spaces
            const startX = spawnX - totalWidth / 2; // Center the chests around spawn
            
            for (let i = 0; i < 20; i++) {
                const chestX = startX + (i * chestSpacing);
                const chestY = spawnY - 50; // Slightly above ground
                
                const secretChest = {
                    x: chestX,
                    y: chestY,
                    width: 40,
                    height: 40,
                    collected: false,
                    type: 'chest',
                    isSecret: true,
                    value: 25, // Each chest gives 25 coins (regular chest value)
                    glowIntensity: 0,
                    glowSpeed: 0.05,
                    glowDirection: 1
                };
                
                treasures.push(secretChest);
            }
            
            // Show special notification
            showSecretChestNotification();
        }

        function showSecretChestNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FFD700, #FFA500);
                color: white;
                padding: 20px 30px;
                border-radius: 15px;
                font-size: 18px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 10px 30px rgba(255,215,0,0.6);
                animation: secretChestPulse 2s ease-in-out;
                font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 10px;">📦</div>
                <div>SECRET CHESTS DISCOVERED!</div>
                <div style="font-size: 14px; margin-top: 8px; opacity: 0.9;">20 Regular Chests have appeared!</div>
                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">Check the beginning of the level!</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 4000);
        }

        function showAIOwlBotMessage(message) {
            if (!aiOwlBotEnabled) return;
            
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 120px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, rgba(0,255,255,0.9), rgba(0,255,255,0.8));
                color: #000;
                padding: 12px 20px;
                border-radius: 20px;
                font-size: 14px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 5px 20px rgba(0,255,255,0.4);
                animation: owlMessageSlideIn 0.5s ease-out;
                max-width: 400px;
                font-family: 'SuperMario', 'Orbitron', 'Arial Black', sans-serif;
                border: 2px solid #00FFFF;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 16px; margin-bottom: 5px;">🦉 AI Owl Bot</div>
                <div style="font-size: 12px;">${message}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'owlMessageSlideOut 0.5s ease-in';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 500);
                }
            }, 6000);
        }

        // Add CSS animations for notifications
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
            @keyframes achievementSlideIn {
                from { transform: translateY(-20px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }
            @keyframes achievementSlideOut {
                from { transform: translateY(0); opacity: 1; }
                to { transform: translateY(-20px); opacity: 0; }
            }
            @keyframes secretChestPulse {
                0% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 10px 30px rgba(255,215,0,0.6); }
                50% { transform: translate(-50%, -50%) scale(1.1); box-shadow: 0 15px 40px rgba(255,215,0,0.8); }
                100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 10px 30px rgba(255,215,0,0.6); }
            }
            @keyframes owlMessageSlideIn {
                from { transform: translateX(-50%) translateY(50px); opacity: 0; }
                to { transform: translateX(-50%) translateY(0); opacity: 1; }
            }
            @keyframes owlMessageSlideOut {
                from { transform: translateX(-50%) translateY(0); opacity: 1; }
                to { transform: translateX(-50%) translateY(50px); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        function testMetadataFetching() {
            console.log('🌐 Testing metadata fetching for your wallet...');
            console.log('👤 Your wallet address:', '0x16E315e37cDEda413D22a6899FFF67A4B001D91B');
            
            if (!otterWallet || !otterWallet.isConnected) {
                console.log('⚠️ Wallet not connected');
                return;
            }
            
            // Test your specific wallet
            const testAddress = '0x16E315e37cDEda413D22a6899FFF67A4B001D91B';
            const contractAddress = '0x4e5913922b7ddf916c8d27d1016827f799687e66';
            
            console.log('🔍 Testing balance for your address...');
            const data = '0x70a08231' + testAddress.slice(2).padStart(64, '0');
            
            window.ethereum.request({
                method: 'eth_call',
                params: [{
                    to: contractAddress,
                    data: data
                }, 'latest']
            }).then(result => {
                const balance = parseInt(result, 16);
                console.log('💰 Your balance:', balance);
                
                if (balance > 0) {
                    console.log('🎉 Found NFTs! Now checking token 0...');
                    // Check token 0 specifically
                    const ownerData = '0x6352211e' + '0'.padStart(64, '0');
                    return window.ethereum.request({
                        method: 'eth_call',
                        params: [{
                            to: contractAddress,
                            data: ownerData
                        }, 'latest']
                    });
                } else {
                    console.log('⚠️ No NFTs found');
                }
            }).then(result => {
                if (result) {
                    const owner = '0x' + result.slice(26);
                    console.log('👤 Token 0 owner:', owner);
                    console.log('✅ Matches your wallet:', owner.toLowerCase() === testAddress.toLowerCase());
                }
            }).catch(error => {
                console.error('❌ Error testing metadata:', error);
            });
        }

    </script>
</body>
</html>


